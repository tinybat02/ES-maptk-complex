define(["@grafana/ui","react"], function(__WEBPACK_EXTERNAL_MODULE__grafana_ui__, __WEBPACK_EXTERNAL_MODULE_react__) { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./module.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/attr-accept/dist/es/index.js":
/*!****************************************************!*\
  !*** ../node_modules/attr-accept/dist/es/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (file, acceptedFiles) {
  if (file && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(',');
    var fileName = file.name || '';
    var mimeType = (file.type || '').toLowerCase();
    var baseMimeType = mimeType.replace(/\/.*$/, '');
    return acceptedFilesArray.some(function (type) {
      var validType = type.trim().toLowerCase();

      if (validType.charAt(0) === '.') {
        return fileName.toLowerCase().endsWith(validType);
      } else if (validType.endsWith('/*')) {
        // This is something like a image/* mime type
        return baseMimeType === validType.replace(/\/.*$/, '');
      }

      return mimeType === validType;
    });
  }

  return true;
};

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/dist/cjs.js!../node_modules/maptalks/dist/maptalks.css":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js??ref--8-1!../node_modules/postcss-loader/src??ref--8-2!../node_modules/sass-loader/dist/cjs.js!../node_modules/maptalks/dist/maptalks.css ***!
  \****************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
var ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/getUrl.js */ "../node_modules/css-loader/dist/runtime/getUrl.js");
var ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(/*! ./images/control/kedu.png */ "../node_modules/maptalks/dist/images/control/kedu.png");
var ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(/*! ./images/control/3.png */ "../node_modules/maptalks/dist/images/control/3.png");
var ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(/*! ./images/control/ico-dot.png */ "../node_modules/maptalks/dist/images/control/ico-dot.png");
var ___CSS_LOADER_URL_IMPORT_3___ = __webpack_require__(/*! ./images/control/5.png */ "../node_modules/maptalks/dist/images/control/5.png");
var ___CSS_LOADER_URL_IMPORT_4___ = __webpack_require__(/*! ./images/control/5_1.png */ "../node_modules/maptalks/dist/images/control/5_1.png");
var ___CSS_LOADER_URL_IMPORT_5___ = __webpack_require__(/*! ./images/control/infownd-close.png */ "../node_modules/maptalks/dist/images/control/infownd-close.png");
var ___CSS_LOADER_URL_IMPORT_6___ = __webpack_require__(/*! ./images/control/infownd-close-hover.png */ "../node_modules/maptalks/dist/images/control/infownd-close-hover.png");
var ___CSS_LOADER_URL_IMPORT_7___ = __webpack_require__(/*! ./images/control/close-2.png */ "../node_modules/maptalks/dist/images/control/close-2.png");
var ___CSS_LOADER_URL_IMPORT_8___ = __webpack_require__(/*! ./images/control/layer.png */ "../node_modules/maptalks/dist/images/control/layer.png");
exports = ___CSS_LOADER_API_IMPORT___(true);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_6___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_6___);
var ___CSS_LOADER_URL_REPLACEMENT_7___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_7___);
var ___CSS_LOADER_URL_REPLACEMENT_8___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_8___);
// Module
exports.push([module.i, ".maptalks-zoom {\n  text-align: center; }\n\n.maptalks-zoom .maptalks-zoom-zoomlevel {\n  display: block;\n  width: 29px;\n  height: 29px;\n  background: #172029;\n  color: #fff;\n  line-height: 29px;\n  font-size: 12px;\n  transform: scale(0.8);\n  -ms-transform: scale(0.8);\n  transform-origin: bottom left;\n  -ms-transform-origin: bottom left; }\n\n.maptalks-zoom-slider {\n  margin-top: 6px; }\n\n.maptalks-zoom-slider a.maptalks-zoom-zoomin, .maptalks-zoom-slider a.maptalks-zoom-zoomout {\n  display: block;\n  font-size: 16px;\n  width: 21px;\n  height: 21px;\n  border: 1px solid #363539;\n  background: #172029;\n  color: #fff;\n  line-height: 19px;\n  text-decoration: none; }\n\n.maptalks-zoom-slider-box {\n  width: 21px;\n  height: 124px;\n  background: #34495e;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") repeat-y;\n  border: 1px solid #35383b;\n  position: relative; }\n\n.maptalks-zoom-slider-box .maptalks-zoom-slider-ruler {\n  width: 5px;\n  height: 112px;\n  background: #372e2b;\n  border-radius: 2px;\n  -moz-border-radius: 2px;\n  -webkit-border-radius: 2px;\n  margin: 4px auto;\n  position: relative; }\n\n.maptalks-zoom-slider-box .maptalks-zoom-slider-ruler .maptalks-zoom-slider-reading {\n  width: 5px;\n  height: 50%;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  background: #1bbc9b;\n  border-radius: 2px;\n  -moz-border-radius: 2px;\n  -webkit-border-radius: 2px; }\n\n.maptalks-zoom-slider-box .maptalks-zoom-slider-dot {\n  width: 15px;\n  height: 15px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n  position: absolute;\n  top: 50%;\n  left: 3px;\n  cursor: pointer; }\n\n.maptalks-toolbar-vertical {\n  margin: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-horizonal ul, .maptalks-toolbar-vertical ul {\n  margin: 0;\n  padding: 0; }\n\n.maptalks-toolbar-vertical ul li + li {\n  border-top: 1px solid #425568; }\n\n.maptalks-toolbar-vertical li {\n  text-align: center;\n  list-style: none;\n  line-height: 28px;\n  color: #fff;\n  background: #34495e;\n  min-width: 10px;\n  min-height: 28px;\n  position: relative;\n  padding: 0 10px; }\n\n.maptalks-toolbar-vertical li:hover {\n  background: #1bbc9b; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu {\n  padding: 0;\n  position: absolute;\n  top: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu li {\n  list-style: none;\n  min-width: 95px;\n  background: #223140;\n  height: 27px; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu li a {\n  color: #fff;\n  display: block;\n  line-height: 27px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") no-repeat 14px 10px;\n  text-indent: 33px;\n  text-decoration: none;\n  font-size: 12px; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu em.maptalks-ico {\n  display: block;\n  width: 5px;\n  height: 6px;\n  position: absolute;\n  top: 12px;\n  right: -4px; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu li.maptalks-on, .maptalks-toolbar-vertical li .maptalks-dropMenu li:hover {\n  background: #0e595e; }\n\n.maptalks-toolbar-horizonal {\n  margin: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-horizonal li {\n  text-align: left;\n  line-height: 28px;\n  color: #fff;\n  padding: 0 10px;\n  list-style: none;\n  min-width: 28px;\n  min-height: 28px;\n  float: left;\n  background: #34495e;\n  position: relative; }\n\n.maptalks-toolbar-horizonal ul li + li {\n  border-left: 1px solid #425568; }\n\n.maptalks-toolbar-horizonal li:hover {\n  background: #1bbc9b; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu {\n  display: block;\n  position: absolute;\n  left: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu li {\n  list-style: none;\n  min-width: 95px;\n  background: #223140;\n  height: 27px; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu li + li {\n  border-left: none;\n  border-top: 1px solid #425568; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu li a {\n  color: #fff;\n  display: block;\n  line-height: 27px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") no-repeat 5px 10px;\n  text-indent: 20px;\n  text-decoration: none;\n  font-size: 12px; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu em.maptalks-ico {\n  display: block;\n  width: 5px;\n  height: 6px;\n  position: absolute;\n  top: -4px;\n  left: 12px; }\n\n.maptalks-toolbar-horizonal .maptalks-dropMenu li:hover {\n  background: #0e595e; }\n\n.maptalks-menu {\n  background: #fff;\n  padding: 1px;\n  width: 172px;\n  border: 1px solid #b4b3b3; }\n\n.maptalks-menu em.maptalks-ico {\n  display: block;\n  width: 17px;\n  height: 10px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") no-repeat;\n  position: absolute;\n  top: -10px;\n  left: 8px; }\n\n.maptalks-menu .maptalks-menu-items {\n  color: #5a5756;\n  margin: 0;\n  padding: 0;\n  font-size: 12px; }\n\n.maptalks-menu .maptalks-menu-items li {\n  list-style: none;\n  height: 30px;\n  line-height: 30px;\n  text-indent: 16px; }\n\n.maptalks-menu .maptalks-menu-items li:hover {\n  background: #007fbe;\n  color: #fff;\n  cursor: pointer; }\n\n.maptalks-menu .maptalks-menu-items li.maptalks-menu-splitter {\n  list-style: none;\n  height: 2px;\n  background: #ddd; }\n\n.maptalks-msgBox {\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  border-radius: 3px; }\n\n.maptalks-msgBox em.maptalks-ico {\n  display: block;\n  width: 17px;\n  height: 10px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ") no-repeat;\n  position: absolute;\n  left: 50%;\n  margin-left: -5px;\n  bottom: -10px; }\n\n.maptalks-msgBox h2 {\n  display: block;\n  height: 30px;\n  line-height: 30px;\n  font-weight: 700;\n  font-size: 14px;\n  padding: 0 10px;\n  margin: 0; }\n\n.maptalks-msgBox a.maptalks-close {\n  display: block;\n  width: 13px;\n  height: 13px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ") no-repeat;\n  position: absolute;\n  top: 8px;\n  right: 10px; }\n\n.maptalks-msgBox a.maptalks-close:hover {\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ") no-repeat; }\n\n.maptalks-msgBox .maptalks-msgContent {\n  font-size: 12px;\n  padding: 10px;\n  min-width: 200px; }\n\n.maptalks-panel {\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  border-radius: 3px; }\n\n.maptalks-panel .maptalks-panel-content {\n  padding: 10px;\n  min-width: 200px;\n  min-height: 60px; }\n\n.maptalks-panel a.maptalks-close {\n  display: block;\n  width: 6px;\n  height: 7px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_7___ + ") no-repeat;\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n\n.maptalks-panel a.maptalks-close:hover {\n  opacity: .5; }\n\n.maptalks-attribution {\n  display: inline-block;\n  opacity: 1;\n  background: #fff;\n  background-color: rgba(255, 255, 255, 0.7);\n  padding: 0;\n  font-size: 13px;\n  font-family: microsoft yahei,Helvetica Neue,Helvetica,sans-serif; }\n\n.maptalks-attribution a {\n  text-decoration: none;\n  color: #0078a8; }\n\n.maptalks-attribution a:hover {\n  text-decoration: underline; }\n\n.maptalks-overview {\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  width: 100%;\n  height: 100%; }\n\n.maptalks-overview-button {\n  cursor: pointer;\n  background: #fff;\n  width: 18px;\n  height: 18px;\n  position: absolute;\n  bottom: 1px;\n  right: 1px;\n  font: 16px sans-serif;\n  text-align: center;\n  line-height: 16px;\n  border: 1px solid #b4b3b3;\n  color: #363539; }\n\n.maptalks-layer-switcher ul {\n  list-style: none; }\n\n.maptalks-layer-switcher .panel > ul {\n  padding-left: 1em; }\n\n.maptalks-layer-switcher .group > ul {\n  padding-left: 10px; }\n\n.maptalks-layer-switcher .group + .group {\n  padding-top: 1em; }\n\n.maptalks-layer-switcher label {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  display: inline-block;\n  font-size: 14px;\n  white-space: nowrap;\n  color: #bbb; }\n\n.maptalks-layer-switcher .group > label {\n  font-weight: 700;\n  color: #ddd;\n  width: 100%; }\n\n.maptalks-layer-switcher .layer label {\n  padding-top: 5px;\n  width: 92%; }\n\n.maptalks-layer-switcher input {\n  margin: 0 5px;\n  position: relative;\n  top: -2px; }\n\n.maptalks-layer-switcher input[disabled=disabled] {\n  cursor: not-allowed; }\n\n.maptalks-layer-switcher input[disabled=disabled] + label {\n  color: #666; }\n\n.maptalks-layer-switcher .panel, .maptalks-layer-switcher button {\n  border-radius: 4px; }\n\n.maptalks-layer-switcher button {\n  width: 28px;\n  height: 28px;\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_8___ + ") no-repeat 4px 4px;\n  background-color: #172029;\n  border: none; }\n\n.maptalks-layer-switcher.shown button {\n  display: none; }\n\n.maptalks-layer-switcher .panel {\n  background-color: #172029;\n  display: none;\n  overflow-y: auto;\n  overflow-x: hidden;\n  min-width: 120px;\n  max-width: 400px;\n  max-height: 500px; }\n\n.maptalks-layer-switcher li {\n  white-space: nowrap; }\n\n.maptalks-layer-switcher li.group {\n  margin-right: 1em; }\n\n.maptalks-layer-switcher.shown .panel {\n  display: block; }\n\n.maptalks-layer-switcher ::-webkit-scrollbar {\n  width: 6px; }\n\n.maptalks-layer-switcher ::-webkit-scrollbar-track {\n  background-color: #1f1f1f; }\n\n.maptalks-layer-switcher ::-webkit-scrollbar-thumb {\n  border-radius: 5px;\n  background-color: #777; }\n\n.maptalks-tooltip {\n  display: block;\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  padding: 0 4px;\n  height: 24px;\n  line-height: 24px;\n  font-size: 14px;\n  white-space: nowrap; }\n", "",{"version":3,"sources":["maptalks.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB,EAAE;;AAEtB;EACE,cAAc;EACd,WAAW;EACX,YAAY;EACZ,mBAAmB;EACnB,WAAW;EACX,iBAAiB;EACjB,eAAe;EACf,qBAAqB;EACrB,yBAAyB;EACzB,6BAA6B;EAC7B,iCAAiC,EAAE;;AAErC;EACE,eAAe,EAAE;;AAEnB;EACE,cAAc;EACd,eAAe;EACf,WAAW;EACX,YAAY;EACZ,yBAAyB;EACzB,mBAAmB;EACnB,WAAW;EACX,iBAAiB;EACjB,qBAAqB,EAAE;;AAEzB;EACE,WAAW;EACX,aAAa;EACb,mBAAmB;EACnB,4DAAiD;EACjD,yBAAyB;EACzB,kBAAkB,EAAE;;AAEtB;EACE,UAAU;EACV,aAAa;EACb,mBAAmB;EACnB,kBAAkB;EAClB,uBAAuB;EACvB,0BAA0B;EAC1B,gBAAgB;EAChB,kBAAkB,EAAE;;AAEtB;EACE,UAAU;EACV,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,mBAAmB;EACnB,kBAAkB;EAClB,uBAAuB;EACvB,0BAA0B,EAAE;;AAE9B;EACE,WAAW;EACX,YAAY;EACZ,6DAA+C;EAC/C,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,eAAe,EAAE;;AAEnB;EACE,SAAS;EACT,iBAAiB,EAAE;;AAErB;EACE,SAAS;EACT,UAAU,EAAE;;AAEd;EACE,6BAA6B,EAAE;;AAEjC;EACE,kBAAkB;EAClB,gBAAgB;EAChB,iBAAiB;EACjB,WAAW;EACX,mBAAmB;EACnB,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB,eAAe,EAAE;;AAEnB;EACE,mBAAmB,EAAE;;AAEvB;EACE,UAAU;EACV,kBAAkB;EAClB,MAAM;EACN,iBAAiB,EAAE;;AAErB;EACE,gBAAgB;EAChB,eAAe;EACf,mBAAmB;EACnB,YAAY,EAAE;;AAEhB;EACE,WAAW;EACX,cAAc;EACd,iBAAiB;EACjB,uEAA+D;EAC/D,iBAAiB;EACjB,qBAAqB;EACrB,eAAe,EAAE;;AAEnB;EACE,cAAc;EACd,UAAU;EACV,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,WAAW,EAAE;;AAEf;EACE,mBAAmB,EAAE;;AAEvB;EACE,SAAS;EACT,iBAAiB,EAAE;;AAErB;EACE,gBAAgB;EAChB,iBAAiB;EACjB,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,WAAW;EACX,mBAAmB;EACnB,kBAAkB,EAAE;;AAEtB;EACE,8BAA8B,EAAE;;AAElC;EACE,mBAAmB,EAAE;;AAEvB;EACE,cAAc;EACd,kBAAkB;EAClB,OAAO;EACP,iBAAiB,EAAE;;AAErB;EACE,gBAAgB;EAChB,eAAe;EACf,mBAAmB;EACnB,YAAY,EAAE;;AAEhB;EACE,iBAAiB;EACjB,6BAA6B,EAAE;;AAEjC;EACE,WAAW;EACX,cAAc;EACd,iBAAiB;EACjB,sEAA8D;EAC9D,iBAAiB;EACjB,qBAAqB;EACrB,eAAe,EAAE;;AAEnB;EACE,cAAc;EACd,UAAU;EACV,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,UAAU,EAAE;;AAEd;EACE,mBAAmB,EAAE;;AAEvB;EACE,gBAAgB;EAChB,YAAY;EACZ,YAAY;EACZ,yBAAyB,EAAE;;AAE7B;EACE,cAAc;EACd,WAAW;EACX,YAAY;EACZ,6DAA+C;EAC/C,kBAAkB;EAClB,UAAU;EACV,SAAS,EAAE;;AAEb;EACE,cAAc;EACd,SAAS;EACT,UAAU;EACV,eAAe,EAAE;;AAEnB;EACE,gBAAgB;EAChB,YAAY;EACZ,iBAAiB;EACjB,iBAAiB,EAAE;;AAErB;EACE,mBAAmB;EACnB,WAAW;EACX,eAAe,EAAE;;AAEnB;EACE,gBAAgB;EAChB,WAAW;EACX,gBAAgB,EAAE;;AAEpB;EACE,gBAAgB;EAChB,yBAAyB;EACzB,kBAAkB,EAAE;;AAEtB;EACE,cAAc;EACd,WAAW;EACX,YAAY;EACZ,6DAAiD;EACjD,kBAAkB;EAClB,SAAS;EACT,iBAAiB;EACjB,aAAa,EAAE;;AAEjB;EACE,cAAc;EACd,YAAY;EACZ,iBAAiB;EACjB,gBAAgB;EAChB,eAAe;EACf,eAAe;EACf,SAAS,EAAE;;AAEb;EACE,cAAc;EACd,WAAW;EACX,YAAY;EACZ,6DAA2D;EAC3D,kBAAkB;EAClB,QAAQ;EACR,WAAW,EAAE;;AAEf;EACE,6DAAiE,EAAE;;AAErE;EACE,eAAe;EACf,aAAa;EACb,gBAAgB,EAAE;;AAEpB;EACE,gBAAgB;EAChB,yBAAyB;EACzB,kBAAkB,EAAE;;AAEtB;EACE,aAAa;EACb,gBAAgB;EAChB,gBAAgB,EAAE;;AAEpB;EACE,cAAc;EACd,UAAU;EACV,WAAW;EACX,6DAAqD;EACrD,kBAAkB;EAClB,SAAS;EACT,WAAW,EAAE;;AAEf;EACE,WAAW,EAAE;;AAEf;EACE,qBAAqB;EACrB,UAAU;EACV,gBAAgB;EAChB,0CAA0C;EAC1C,UAAU;EACV,eAAe;EACf,gEAAgE,EAAE;;AAEpE;EACE,qBAAqB;EACrB,cAAc,EAAE;;AAElB;EACE,0BAA0B,EAAE;;AAE9B;EACE,gBAAgB;EAChB,yBAAyB;EACzB,WAAW;EACX,YAAY,EAAE;;AAEhB;EACE,eAAe;EACf,gBAAgB;EAChB,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,WAAW;EACX,UAAU;EACV,qBAAqB;EACrB,kBAAkB;EAClB,iBAAiB;EACjB,yBAAyB;EACzB,cAAc,EAAE;;AAElB;EACE,gBAAgB,EAAE;;AAEpB;EACE,iBAAiB,EAAE;;AAErB;EACE,kBAAkB,EAAE;;AAEtB;EACE,gBAAgB,EAAE;;AAEpB;EACE,uBAAuB;EACvB,gBAAgB;EAChB,qBAAqB;EACrB,eAAe;EACf,mBAAmB;EACnB,WAAW,EAAE;;AAEf;EACE,gBAAgB;EAChB,WAAW;EACX,WAAW,EAAE;;AAEf;EACE,gBAAgB;EAChB,UAAU,EAAE;;AAEd;EACE,aAAa;EACb,kBAAkB;EAClB,SAAS,EAAE;;AAEb;EACE,mBAAmB,EAAE;;AAEvB;EACE,WAAW,EAAE;;AAEf;EACE,kBAAkB,EAAE;;AAEtB;EACE,WAAW;EACX,YAAY;EACZ,qEAA2D;EAC3D,yBAAyB;EACzB,YAAY,EAAE;;AAEhB;EACE,aAAa,EAAE;;AAEjB;EACE,yBAAyB;EACzB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,gBAAgB;EAChB,gBAAgB;EAChB,iBAAiB,EAAE;;AAErB;EACE,mBAAmB,EAAE;;AAEvB;EACE,iBAAiB,EAAE;;AAErB;EACE,cAAc,EAAE;;AAElB;EACE,UAAU,EAAE;;AAEd;EACE,yBAAyB,EAAE;;AAE7B;EACE,kBAAkB;EAClB,sBAAsB,EAAE;;AAE1B;EACE,cAAc;EACd,gBAAgB;EAChB,yBAAyB;EACzB,cAAc;EACd,YAAY;EACZ,iBAAiB;EACjB,eAAe;EACf,mBAAmB,EAAE","file":"maptalks.css","sourcesContent":[".maptalks-zoom {\n  text-align: center; }\n\n.maptalks-zoom .maptalks-zoom-zoomlevel {\n  display: block;\n  width: 29px;\n  height: 29px;\n  background: #172029;\n  color: #fff;\n  line-height: 29px;\n  font-size: 12px;\n  transform: scale(0.8);\n  -ms-transform: scale(0.8);\n  transform-origin: bottom left;\n  -ms-transform-origin: bottom left; }\n\n.maptalks-zoom-slider {\n  margin-top: 6px; }\n\n.maptalks-zoom-slider a.maptalks-zoom-zoomin, .maptalks-zoom-slider a.maptalks-zoom-zoomout {\n  display: block;\n  font-size: 16px;\n  width: 21px;\n  height: 21px;\n  border: 1px solid #363539;\n  background: #172029;\n  color: #fff;\n  line-height: 19px;\n  text-decoration: none; }\n\n.maptalks-zoom-slider-box {\n  width: 21px;\n  height: 124px;\n  background: #34495e;\n  background: url(images/control/kedu.png) repeat-y;\n  border: 1px solid #35383b;\n  position: relative; }\n\n.maptalks-zoom-slider-box .maptalks-zoom-slider-ruler {\n  width: 5px;\n  height: 112px;\n  background: #372e2b;\n  border-radius: 2px;\n  -moz-border-radius: 2px;\n  -webkit-border-radius: 2px;\n  margin: 4px auto;\n  position: relative; }\n\n.maptalks-zoom-slider-box .maptalks-zoom-slider-ruler .maptalks-zoom-slider-reading {\n  width: 5px;\n  height: 50%;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  background: #1bbc9b;\n  border-radius: 2px;\n  -moz-border-radius: 2px;\n  -webkit-border-radius: 2px; }\n\n.maptalks-zoom-slider-box .maptalks-zoom-slider-dot {\n  width: 15px;\n  height: 15px;\n  background: url(images/control/3.png) no-repeat;\n  position: absolute;\n  top: 50%;\n  left: 3px;\n  cursor: pointer; }\n\n.maptalks-toolbar-vertical {\n  margin: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-horizonal ul, .maptalks-toolbar-vertical ul {\n  margin: 0;\n  padding: 0; }\n\n.maptalks-toolbar-vertical ul li + li {\n  border-top: 1px solid #425568; }\n\n.maptalks-toolbar-vertical li {\n  text-align: center;\n  list-style: none;\n  line-height: 28px;\n  color: #fff;\n  background: #34495e;\n  min-width: 10px;\n  min-height: 28px;\n  position: relative;\n  padding: 0 10px; }\n\n.maptalks-toolbar-vertical li:hover {\n  background: #1bbc9b; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu {\n  padding: 0;\n  position: absolute;\n  top: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu li {\n  list-style: none;\n  min-width: 95px;\n  background: #223140;\n  height: 27px; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu li a {\n  color: #fff;\n  display: block;\n  line-height: 27px;\n  background: url(images/control/ico-dot.png) no-repeat 14px 10px;\n  text-indent: 33px;\n  text-decoration: none;\n  font-size: 12px; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu em.maptalks-ico {\n  display: block;\n  width: 5px;\n  height: 6px;\n  position: absolute;\n  top: 12px;\n  right: -4px; }\n\n.maptalks-toolbar-vertical li .maptalks-dropMenu li.maptalks-on, .maptalks-toolbar-vertical li .maptalks-dropMenu li:hover {\n  background: #0e595e; }\n\n.maptalks-toolbar-horizonal {\n  margin: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-horizonal li {\n  text-align: left;\n  line-height: 28px;\n  color: #fff;\n  padding: 0 10px;\n  list-style: none;\n  min-width: 28px;\n  min-height: 28px;\n  float: left;\n  background: #34495e;\n  position: relative; }\n\n.maptalks-toolbar-horizonal ul li + li {\n  border-left: 1px solid #425568; }\n\n.maptalks-toolbar-horizonal li:hover {\n  background: #1bbc9b; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu {\n  display: block;\n  position: absolute;\n  left: 0;\n  overflow: visible; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu li {\n  list-style: none;\n  min-width: 95px;\n  background: #223140;\n  height: 27px; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu li + li {\n  border-left: none;\n  border-top: 1px solid #425568; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu li a {\n  color: #fff;\n  display: block;\n  line-height: 27px;\n  background: url(images/control/ico-dot.png) no-repeat 5px 10px;\n  text-indent: 20px;\n  text-decoration: none;\n  font-size: 12px; }\n\n.maptalks-toolbar-horizonal li .maptalks-dropMenu em.maptalks-ico {\n  display: block;\n  width: 5px;\n  height: 6px;\n  position: absolute;\n  top: -4px;\n  left: 12px; }\n\n.maptalks-toolbar-horizonal .maptalks-dropMenu li:hover {\n  background: #0e595e; }\n\n.maptalks-menu {\n  background: #fff;\n  padding: 1px;\n  width: 172px;\n  border: 1px solid #b4b3b3; }\n\n.maptalks-menu em.maptalks-ico {\n  display: block;\n  width: 17px;\n  height: 10px;\n  background: url(images/control/5.png) no-repeat;\n  position: absolute;\n  top: -10px;\n  left: 8px; }\n\n.maptalks-menu .maptalks-menu-items {\n  color: #5a5756;\n  margin: 0;\n  padding: 0;\n  font-size: 12px; }\n\n.maptalks-menu .maptalks-menu-items li {\n  list-style: none;\n  height: 30px;\n  line-height: 30px;\n  text-indent: 16px; }\n\n.maptalks-menu .maptalks-menu-items li:hover {\n  background: #007fbe;\n  color: #fff;\n  cursor: pointer; }\n\n.maptalks-menu .maptalks-menu-items li.maptalks-menu-splitter {\n  list-style: none;\n  height: 2px;\n  background: #ddd; }\n\n.maptalks-msgBox {\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  border-radius: 3px; }\n\n.maptalks-msgBox em.maptalks-ico {\n  display: block;\n  width: 17px;\n  height: 10px;\n  background: url(images/control/5_1.png) no-repeat;\n  position: absolute;\n  left: 50%;\n  margin-left: -5px;\n  bottom: -10px; }\n\n.maptalks-msgBox h2 {\n  display: block;\n  height: 30px;\n  line-height: 30px;\n  font-weight: 700;\n  font-size: 14px;\n  padding: 0 10px;\n  margin: 0; }\n\n.maptalks-msgBox a.maptalks-close {\n  display: block;\n  width: 13px;\n  height: 13px;\n  background: url(images/control/infownd-close.png) no-repeat;\n  position: absolute;\n  top: 8px;\n  right: 10px; }\n\n.maptalks-msgBox a.maptalks-close:hover {\n  background: url(images/control/infownd-close-hover.png) no-repeat; }\n\n.maptalks-msgBox .maptalks-msgContent {\n  font-size: 12px;\n  padding: 10px;\n  min-width: 200px; }\n\n.maptalks-panel {\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  border-radius: 3px; }\n\n.maptalks-panel .maptalks-panel-content {\n  padding: 10px;\n  min-width: 200px;\n  min-height: 60px; }\n\n.maptalks-panel a.maptalks-close {\n  display: block;\n  width: 6px;\n  height: 7px;\n  background: url(images/control/close-2.png) no-repeat;\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n\n.maptalks-panel a.maptalks-close:hover {\n  opacity: .5; }\n\n.maptalks-attribution {\n  display: inline-block;\n  opacity: 1;\n  background: #fff;\n  background-color: rgba(255, 255, 255, 0.7);\n  padding: 0;\n  font-size: 13px;\n  font-family: microsoft yahei,Helvetica Neue,Helvetica,sans-serif; }\n\n.maptalks-attribution a {\n  text-decoration: none;\n  color: #0078a8; }\n\n.maptalks-attribution a:hover {\n  text-decoration: underline; }\n\n.maptalks-overview {\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  width: 100%;\n  height: 100%; }\n\n.maptalks-overview-button {\n  cursor: pointer;\n  background: #fff;\n  width: 18px;\n  height: 18px;\n  position: absolute;\n  bottom: 1px;\n  right: 1px;\n  font: 16px sans-serif;\n  text-align: center;\n  line-height: 16px;\n  border: 1px solid #b4b3b3;\n  color: #363539; }\n\n.maptalks-layer-switcher ul {\n  list-style: none; }\n\n.maptalks-layer-switcher .panel > ul {\n  padding-left: 1em; }\n\n.maptalks-layer-switcher .group > ul {\n  padding-left: 10px; }\n\n.maptalks-layer-switcher .group + .group {\n  padding-top: 1em; }\n\n.maptalks-layer-switcher label {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  display: inline-block;\n  font-size: 14px;\n  white-space: nowrap;\n  color: #bbb; }\n\n.maptalks-layer-switcher .group > label {\n  font-weight: 700;\n  color: #ddd;\n  width: 100%; }\n\n.maptalks-layer-switcher .layer label {\n  padding-top: 5px;\n  width: 92%; }\n\n.maptalks-layer-switcher input {\n  margin: 0 5px;\n  position: relative;\n  top: -2px; }\n\n.maptalks-layer-switcher input[disabled=disabled] {\n  cursor: not-allowed; }\n\n.maptalks-layer-switcher input[disabled=disabled] + label {\n  color: #666; }\n\n.maptalks-layer-switcher .panel, .maptalks-layer-switcher button {\n  border-radius: 4px; }\n\n.maptalks-layer-switcher button {\n  width: 28px;\n  height: 28px;\n  background: url(images/control/layer.png) no-repeat 4px 4px;\n  background-color: #172029;\n  border: none; }\n\n.maptalks-layer-switcher.shown button {\n  display: none; }\n\n.maptalks-layer-switcher .panel {\n  background-color: #172029;\n  display: none;\n  overflow-y: auto;\n  overflow-x: hidden;\n  min-width: 120px;\n  max-width: 400px;\n  max-height: 500px; }\n\n.maptalks-layer-switcher li {\n  white-space: nowrap; }\n\n.maptalks-layer-switcher li.group {\n  margin-right: 1em; }\n\n.maptalks-layer-switcher.shown .panel {\n  display: block; }\n\n.maptalks-layer-switcher ::-webkit-scrollbar {\n  width: 6px; }\n\n.maptalks-layer-switcher ::-webkit-scrollbar-track {\n  background-color: #1f1f1f; }\n\n.maptalks-layer-switcher ::-webkit-scrollbar-thumb {\n  border-radius: 5px;\n  background-color: #777; }\n\n.maptalks-tooltip {\n  display: block;\n  background: #fff;\n  border: 1px solid #b4b3b3;\n  padding: 0 4px;\n  height: 24px;\n  line-height: 24px;\n  font-size: 14px;\n  white-space: nowrap; }\n"]}]);
// Exports
module.exports = exports;


/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/dist/cjs.js!./style/main.css":
/*!**************************************************************************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js??ref--8-1!../node_modules/postcss-loader/src??ref--8-2!../node_modules/sass-loader/dist/cjs.js!./style/main.css ***!
  \**************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(true);
// Module
exports.push([module.i, ".pane {\n  background: #34495e;\n  line-height: 28px;\n  color: #fff;\n  z-index: 10;\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  padding: 0px 10px 0px 10px;\n  border-radius: 3px; }\n\n.pane:hover {\n  cursor: pointer; }\n", "",{"version":3,"sources":["main.css"],"names":[],"mappings":"AAAA;EACE,mBAAmB;EACnB,iBAAiB;EACjB,WAAW;EACX,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,WAAW;EACX,0BAA0B;EAC1B,kBAAkB,EAAE;;AAEtB;EACE,eAAe,EAAE","file":"main.css","sourcesContent":[".pane {\n  background: #34495e;\n  line-height: 28px;\n  color: #fff;\n  z-index: 10;\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  padding: 0px 10px 0px 10px;\n  border-radius: 3px; }\n\n.pane:hover {\n  cursor: pointer; }\n"]}]);
// Exports
module.exports = exports;


/***/ }),

/***/ "../node_modules/css-loader/dist/runtime/api.js":
/*!******************************************************!*\
  !*** ../node_modules/css-loader/dist/runtime/api.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "../node_modules/css-loader/dist/runtime/getUrl.js":
/*!*********************************************************!*\
  !*** ../node_modules/css-loader/dist/runtime/getUrl.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = url && url.__esModule ? url.default : url;

  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  }

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), "\"");
  }

  return url;
};

/***/ }),

/***/ "../node_modules/file-selector/dist/es5/file-selector.js":
/*!***************************************************************!*\
  !*** ../node_modules/file-selector/dist/es5/file-selector.js ***!
  \***************************************************************/
/*! exports provided: fromEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEvent", function() { return fromEvent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../node_modules/file-selector/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./file */ "../node_modules/file-selector/dist/es5/file.js");


var FILES_TO_IGNORE = [
    // Thumbnail cache files for macOS and Windows
    '.DS_Store',
    'Thumbs.db' // Windows
];
/**
 * Convert a DragEvent's DataTrasfer object to a list of File objects
 * NOTE: If some of the items are folders,
 * everything will be flattened and placed in the same list but the paths will be kept as a {path} property.
 * @param evt
 */
function fromEvent(evt) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            return [2 /*return*/, isDragEvt(evt) && evt.dataTransfer
                    ? getDataTransferFiles(evt.dataTransfer, evt.type)
                    : getInputFiles(evt)];
        });
    });
}
function isDragEvt(value) {
    return !!value.dataTransfer;
}
function getInputFiles(evt) {
    var files = isInput(evt.target)
        ? evt.target.files
            ? fromList(evt.target.files)
            : []
        : [];
    return files.map(function (file) { return Object(_file__WEBPACK_IMPORTED_MODULE_1__["toFileWithPath"])(file); });
}
function isInput(value) {
    return value !== null;
}
function getDataTransferFiles(dt, type) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var items, files;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!dt.items) return [3 /*break*/, 2];
                    items = fromList(dt.items)
                        .filter(function (item) { return item.kind === 'file'; });
                    // According to https://html.spec.whatwg.org/multipage/dnd.html#dndevents,
                    // only 'dragstart' and 'drop' has access to the data (source node)
                    if (type !== 'drop') {
                        return [2 /*return*/, items];
                    }
                    return [4 /*yield*/, Promise.all(items.map(toFilePromises))];
                case 1:
                    files = _a.sent();
                    return [2 /*return*/, noIgnoredFiles(flatten(files))];
                case 2: return [2 /*return*/, noIgnoredFiles(fromList(dt.files)
                        .map(function (file) { return Object(_file__WEBPACK_IMPORTED_MODULE_1__["toFileWithPath"])(file); }))];
            }
        });
    });
}
function noIgnoredFiles(files) {
    return files.filter(function (file) { return FILES_TO_IGNORE.indexOf(file.name) === -1; });
}
// IE11 does not support Array.from()
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Browser_compatibility
// https://developer.mozilla.org/en-US/docs/Web/API/FileList
// https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItemList
function fromList(items) {
    var files = [];
    // tslint:disable: prefer-for-of
    for (var i = 0; i < items.length; i++) {
        var file = items[i];
        files.push(file);
    }
    return files;
}
// https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItem
function toFilePromises(item) {
    if (typeof item.webkitGetAsEntry !== 'function') {
        return fromDataTransferItem(item);
    }
    var entry = item.webkitGetAsEntry();
    // Safari supports dropping an image node from a different window and can be retrieved using
    // the DataTransferItem.getAsFile() API
    // NOTE: FileSystemEntry.file() throws if trying to get the file
    if (entry && entry.isDirectory) {
        return fromDirEntry(entry);
    }
    return fromDataTransferItem(item);
}
function flatten(items) {
    return items.reduce(function (acc, files) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spread"])(acc, (Array.isArray(files) ? flatten(files) : [files])); }, []);
}
function fromDataTransferItem(item) {
    var file = item.getAsFile();
    if (!file) {
        return Promise.reject(item + " is not a File");
    }
    var fwp = Object(_file__WEBPACK_IMPORTED_MODULE_1__["toFileWithPath"])(file);
    return Promise.resolve(fwp);
}
// https://developer.mozilla.org/en-US/docs/Web/API/FileSystemEntry
function fromEntry(entry) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            return [2 /*return*/, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
        });
    });
}
// https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryEntry
function fromDirEntry(entry) {
    var reader = entry.createReader();
    return new Promise(function (resolve, reject) {
        var entries = [];
        function readEntries() {
            var _this = this;
            // https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryEntry/createReader
            // https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryReader/readEntries
            reader.readEntries(function (batch) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                var files, err_1, items;
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!!batch.length) return [3 /*break*/, 5];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, Promise.all(entries)];
                        case 2:
                            files = _a.sent();
                            resolve(files);
                            return [3 /*break*/, 4];
                        case 3:
                            err_1 = _a.sent();
                            reject(err_1);
                            return [3 /*break*/, 4];
                        case 4: return [3 /*break*/, 6];
                        case 5:
                            items = Promise.all(batch.map(fromEntry));
                            entries.push(items);
                            // Continue reading
                            readEntries();
                            _a.label = 6;
                        case 6: return [2 /*return*/];
                    }
                });
            }); }, function (err) {
                reject(err);
            });
        }
        readEntries();
    });
}
// https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileEntry
function fromFileEntry(entry) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    entry.file(function (file) {
                        var fwp = Object(_file__WEBPACK_IMPORTED_MODULE_1__["toFileWithPath"])(file, entry.fullPath);
                        resolve(fwp);
                    }, function (err) {
                        reject(err);
                    });
                })];
        });
    });
}
//# sourceMappingURL=file-selector.js.map

/***/ }),

/***/ "../node_modules/file-selector/dist/es5/file.js":
/*!******************************************************!*\
  !*** ../node_modules/file-selector/dist/es5/file.js ***!
  \******************************************************/
/*! exports provided: COMMON_MIME_TYPES, toFileWithPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMMON_MIME_TYPES", function() { return COMMON_MIME_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFileWithPath", function() { return toFileWithPath; });
var COMMON_MIME_TYPES = new Map([
    ['avi', 'video/avi'],
    ['gif', 'image/gif'],
    ['ico', 'image/x-icon'],
    ['jpeg', 'image/jpeg'],
    ['jpg', 'image/jpeg'],
    ['mkv', 'video/x-matroska'],
    ['mov', 'video/quicktime'],
    ['mp4', 'video/mp4'],
    ['pdf', 'application/pdf'],
    ['png', 'image/png'],
    ['zip', 'application/zip'],
    ['doc', 'application/msword'],
    ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']
]);
function toFileWithPath(file, path) {
    var f = withMimeType(file);
    if (typeof f.path !== 'string') { // on electron, path is already set to the absolute path
        var webkitRelativePath = file.webkitRelativePath;
        Object.defineProperty(f, 'path', {
            value: typeof path === 'string'
                ? path
                // If <input webkitdirectory> is set,
                // the File will have a {webkitRelativePath} property
                // https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/webkitdirectory
                : typeof webkitRelativePath === 'string' && webkitRelativePath.length > 0
                    ? webkitRelativePath
                    : file.name,
            writable: false,
            configurable: false,
            enumerable: true
        });
    }
    return f;
}
function withMimeType(file) {
    var name = file.name;
    var hasExtension = name && name.lastIndexOf('.') !== -1;
    if (hasExtension && !file.type) {
        var ext = name.split('.')
            .pop().toLowerCase();
        var type = COMMON_MIME_TYPES.get(ext);
        if (type) {
            Object.defineProperty(file, 'type', {
                value: type,
                writable: false,
                configurable: false,
                enumerable: true
            });
        }
    }
    return file;
}
//# sourceMappingURL=file.js.map

/***/ }),

/***/ "../node_modules/file-selector/dist/es5/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/file-selector/dist/es5/index.js ***!
  \*******************************************************/
/*! exports provided: fromEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _file_selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./file-selector */ "../node_modules/file-selector/dist/es5/file-selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromEvent", function() { return _file_selector__WEBPACK_IMPORTED_MODULE_0__["fromEvent"]; });


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/file-selector/node_modules/tslib/tslib.es6.js":
/*!*********************************************************************!*\
  !*** ../node_modules/file-selector/node_modules/tslib/tslib.es6.js ***!
  \*********************************************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "../node_modules/maptalks.three/dist/maptalks.three.es.js":
/*!****************************************************************!*\
  !*** ../node_modules/maptalks.three/dist/maptalks.three.es.js ***!
  \****************************************************************/
/*! exports provided: ThreeLayer, ThreeRenderer, BaseObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThreeLayer", function() { return ThreeLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThreeRenderer", function() { return ThreeRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseObject", function() { return BaseObject$$1; });
/* harmony import */ var maptalks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! maptalks */ "../node_modules/maptalks/dist/maptalks.es.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "../node_modules/three/build/three.module.js");
/*!
 * maptalks.three v0.12.3
 * LICENSE : MIT
 * (c) 2016-2020 maptalks.org
 */
var IS_NODE = typeof exports === 'object' && typeof module !== 'undefined';
    var maptalks = maptalks;
    if (IS_NODE) {
        maptalks = maptalks || __webpack_require__(/*! maptalks */ "../node_modules/maptalks/dist/maptalks.es.js");
    }
    var workerLoaded;
    function define(_, chunk) {
    if (!workerLoaded) {
        if(maptalks&&maptalks.registerWorkerAdapter){
            maptalks.registerWorkerAdapter('maptalks.three', chunk);
            workerLoaded = true;
        }else{
          console.warn('maptalks.registerWorkerAdapter is not defined,If you need to use ThreeVectorTileLayer,you can npm i maptalks@next,more https://github.com/maptalks/maptalks.js/tree/next');
        }
    } else {
        var exports = IS_NODE ? module.exports : maptalks;
        chunk(exports, maptalks);
    }
}




function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

define(['exports'], function (exports) {
    var earcut_1 = earcut;
    var default_1 = earcut;

    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length,
          outerLen = hasHoles ? holeIndices[0] * dim : data.length,
          outerNode = linkedList(data, 0, outerLen, dim, true),
          triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }

      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    } // create a circular doubly linked list from polygon points in the specified winding order


    function linkedList(data, start, end, dim, clockwise) {
      var i, last;

      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      }

      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }

      return last;
    } // eliminate colinear or duplicate points


    function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p = start,
          again;

      do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);

      return end;
    } // main ear slicing loop which triangulates a polygon (given as a linked list)


    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return; // interlink polygon nodes in z-order

      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear,
          prev,
          next; // iterate through ears, slicing them one by one

      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          // cut off the triangle
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear); // skipping the next vertex leads to less sliver triangles

          ear = next.next;
          stop = next.next;
          continue;
        }

        ear = next; // if we looped through the whole remaining polygon and can't find any more ears

        if (ear === stop) {
          // try filtering points and slicing again
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }

          break;
        }
      }
    } // check whether a polygon node forms a valid ear with adjacent nodes


    function isEar(ear) {
      var a = ear.prev,
          b = ear,
          c = ear.next;
      if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
      // now make sure we don't have other points inside the potential ear

      var p = ear.next.next;

      while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }

      return true;
    }

    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev,
          b = ear,
          c = ear.next;
      if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
      // triangle bbox; min & max are calculated like this for speed

      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
          minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
          maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
          maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

      var minZ = zOrder(minTX, minTY, minX, minY, invSize),
          maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
      var p = ear.prevZ,
          n = ear.nextZ; // look for points inside the triangle in both directions

      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      } // look for remaining points in decreasing z-order


      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      } // look for remaining points in increasing z-order


      while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }

      return true;
    } // go through all polygon nodes and cure small local self-intersections


    function cureLocalIntersections(start, triangles, dim) {
      var p = start;

      do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim); // remove two nodes involved

          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }

        p = p.next;
      } while (p !== start);

      return filterPoints(p);
    } // try splitting polygon into two and triangulate them independently


    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      // look for a valid diagonal that divides the polygon into two
      var a = start;

      do {
        var b = a.next.next;

        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            // split the polygon in two by the diagonal
            var c = splitPolygon(a, b); // filter colinear points around the cuts

            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next); // run earcut on each half

            earcutLinked(a, triangles, dim, minX, minY, invSize);
            earcutLinked(c, triangles, dim, minX, minY, invSize);
            return;
          }

          b = b.next;
        }

        a = a.next;
      } while (a !== start);
    } // link every hole into the outer loop, producing a single-ring polygon without holes


    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [],
          i,
          len,
          start,
          end,
          list;

      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }

      queue.sort(compareX); // process holes from left to right

      for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }

      return outerNode;
    }

    function compareX(a, b) {
      return a.x - b.x;
    } // find a bridge between vertices that connects hole with an outer ring and and link it


    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);

      if (outerNode) {
        var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
      }
    } // David Eberly's algorithm for finding a bridge between hole and outer polygon


    function findHoleBridge(hole, outerNode) {
      var p = outerNode,
          hx = hole.x,
          hy = hole.y,
          qx = -Infinity,
          m; // find a segment intersected by a ray from the hole's leftmost point to the left;
      // segment's endpoint with lesser x will be potential connection point

      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

          if (x <= hx && x > qx) {
            qx = x;

            if (x === hx) {
              if (hy === p.y) return p;
              if (hy === p.next.y) return p.next;
            }

            m = p.x < p.next.x ? p : p.next;
          }
        }

        p = p.next;
      } while (p !== outerNode);

      if (!m) return null;
      if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
      // look for points inside the triangle of hole point, segment intersection and endpoint;
      // if there are no points found, we have a valid connection;
      // otherwise choose the point of the minimum angle with the ray as connection point

      var stop = m,
          mx = m.x,
          my = m.y,
          tanMin = Infinity,
          tan;
      p = m;

      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }

        p = p.next;
      } while (p !== stop);

      return m;
    } // whether sector in vertex m contains sector in vertex p in the same coordinates


    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    } // interlink polygon nodes in z-order


    function indexCurve(start, minX, minY, invSize) {
      var p = start;

      do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);

      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    } // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


    function sortLinked(list) {
      var i,
          p,
          q,
          e,
          tail,
          numMerges,
          pSize,
          qSize,
          inSize = 1;

      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
          numMerges++;
          q = p;
          pSize = 0;

          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }

          qSize = inSize;

          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }

            if (tail) tail.nextZ = e;else list = e;
            e.prevZ = tail;
            tail = e;
          }

          p = q;
        }

        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);

      return list;
    } // z-order of a point given coords and inverse of the longer side of data bbox


    function zOrder(x, y, minX, minY, invSize) {
      // coords are transformed into non-negative 15-bit integer range
      x = 32767 * (x - minX) * invSize;
      y = 32767 * (y - minY) * invSize;
      x = (x | x << 8) & 0x00FF00FF;
      x = (x | x << 4) & 0x0F0F0F0F;
      x = (x | x << 2) & 0x33333333;
      x = (x | x << 1) & 0x55555555;
      y = (y | y << 8) & 0x00FF00FF;
      y = (y | y << 4) & 0x0F0F0F0F;
      y = (y | y << 2) & 0x33333333;
      y = (y | y << 1) & 0x55555555;
      return x | y << 1;
    } // find the leftmost node of a polygon ring


    function getLeftmost(start) {
      var p = start,
          leftmost = start;

      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
      } while (p !== start);

      return leftmost;
    } // check if a point lies within a convex triangle


    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    } // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
      locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
      area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
    } // signed area of a triangle


    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    } // check if two points are equal


    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    } // check if two segments intersect


    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true; // general case

      if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

      if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

      if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

      if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

      return false;
    } // for collinear points p, q, r, check if point q lies on segment pr


    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }

    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    } // check if a polygon diagonal intersects any polygon segments


    function intersectsPolygon(a, b) {
      var p = a;

      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
      } while (p !== a);

      return false;
    } // check if a polygon diagonal is locally inside the polygon


    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    } // check if the middle point of a polygon diagonal is inside the polygon


    function middleInside(a, b) {
      var p = a,
          inside = false,
          px = (a.x + b.x) / 2,
          py = (a.y + b.y) / 2;

      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
      } while (p !== a);

      return inside;
    } // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring


    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y),
          b2 = new Node(b.i, b.x, b.y),
          an = a.next,
          bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    } // create a node and optionally link it with previous one (in a circular doubly linked list)


    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);

      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }

      return p;
    }

    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }

    function Node(i, x, y) {
      // vertex index in coordinates array
      this.i = i; // vertex coordinates

      this.x = x;
      this.y = y; // previous and next vertex nodes in a polygon ring

      this.prev = null;
      this.next = null; // z-order curve value

      this.z = null; // previous and next nodes in z-order

      this.prevZ = null;
      this.nextZ = null; // indicates whether this is a steiner point

      this.steiner = false;
    } // return a percentage difference between the polygon area and its triangulation area;
    // used to verify correctness of triangulation


    earcut.deviation = function (data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));

      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }

      var trianglesArea = 0;

      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
      }

      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };

    function signedArea(data, start, end, dim) {
      var sum = 0;

      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }

      return sum;
    } // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts


    earcut.flatten = function (data) {
      var dim = data[0][0].length,
          result = {
        vertices: [],
        holes: [],
        dimensions: dim
      },
          holeIndex = 0;

      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }

        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }

      return result;
    };
    earcut_1.default = default_1;

    /*
     (c) 2017, Vladimir Agafonkin
     Simplify.js, a high-performance JS polyline simplification library
     mourner.github.io/simplify-js
    */
    // to suit your point format, run search/replace for '.x' and '.y';
    // for 3D version, see 3d branch (configurability would draw significant performance overhead)
    // square distance between 2 points
    function getSqDist(p1, p2) {
      var dx = p1[0] - p2[0],
          dy = p1[1] - p2[1];
      return dx * dx + dy * dy;
    } // square distance from a point to a segment


    function getSqSegDist(p, p1, p2) {
      var x = p1[0],
          y = p1[1],
          dx = p2[0] - x,
          dy = p2[1] - y;

      if (dx !== 0 || dy !== 0) {
        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
          x = p2[0];
          y = p2[1];
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }

      dx = p[0] - x;
      dy = p[1] - y;
      return dx * dx + dy * dy;
    } // rest of the code doesn't care about point format
    // basic distance-based simplification


    function simplifyRadialDist(points, sqTolerance) {
      var prevPoint = points[0],
          newPoints = [prevPoint],
          point;

      for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
          newPoints.push(point);
          prevPoint = point;
        }
      }

      if (prevPoint !== point) newPoints.push(point);
      return newPoints;
    }

    function simplifyDPStep(points, first, last, sqTolerance, simplified) {
      var maxSqDist = sqTolerance,
          index;

      for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
    } // simplification using Ramer-Douglas-Peucker algorithm


    function simplifyDouglasPeucker(points, sqTolerance) {
      var last = points.length - 1;
      var simplified = [points[0]];
      simplifyDPStep(points, 0, last, sqTolerance, simplified);
      simplified.push(points[last]);
      return simplified;
    } // both algorithms combined for awesome performance


    function simplify(points, tolerance, highestQuality) {
      if (points.length <= 2) return points;
      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
      points = simplifyDouglasPeucker(points, sqTolerance);
      return points;
    }

    function dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    function v2Dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    function normalize(out, v) {
      var x = v[0];
      var y = v[1];
      var z = v[2];
      var d = Math.sqrt(x * x + y * y + z * z);
      out[0] = x / d;
      out[1] = y / d;
      out[2] = z / d;
      return out;
    }
    function v2Normalize(out, v) {
      var x = v[0];
      var y = v[1];
      var d = Math.sqrt(x * x + y * y);
      out[0] = x / d;
      out[1] = y / d;
      return out;
    }
    function scale(out, v, s) {
      out[0] = v[0] * s;
      out[1] = v[1] * s;
      out[2] = v[2] * s;
      return out;
    }
    function scaleAndAdd(out, v1, v2, s) {
      out[0] = v1[0] + v2[0] * s;
      out[1] = v1[1] + v2[1] * s;
      out[2] = v1[2] + v2[2] * s;
      return out;
    }
    function v2Add(out, v1, v2) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    function v3Sub(out, v1, v2) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      out[2] = v1[2] - v2[2];
      return out;
    }
    function v3Normalize(out, v) {
      var x = v[0];
      var y = v[1];
      var z = v[2];
      var d = Math.sqrt(x * x + y * y + z * z);
      out[0] = x / d;
      out[1] = y / d;
      out[2] = z / d;
      return out;
    }
    function v3Cross(out, v1, v2) {
      var ax = v1[0],
          ay = v1[1],
          az = v1[2],
          bx = v2[0],
          by = v2[1],
          bz = v2[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
    }
    var rel = []; // start and end must be normalized

    function slerp(out, start, end, t) {
      // https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/
      var cosT = dot(start, end);
      var theta = Math.acos(cosT) * t;
      scaleAndAdd(rel, end, start, -cosT);
      normalize(rel, rel); // start and rel Orthonormal basis

      scale(out, start, Math.cos(theta));
      scaleAndAdd(out, out, rel, Math.sin(theta));
      return out;
    }
    function area$1(points, start, end) {
      // Signed polygon area
      var n = end - start;

      if (n < 3) {
        return 0;
      }

      var area = 0;

      for (var i = (end - 1) * 2, j = start * 2; j < end * 2;) {
        var x0 = points[i];
        var y0 = points[i + 1];
        var x1 = points[j];
        var y1 = points[j + 1];
        i = j;
        j += 2;
        area += x0 * y1 - x1 * y0;
      }

      return area;
    }

    // TODO fitRect x, y are negative?
    function triangulate(vertices, holes, dimensions) {
      if (dimensions === void 0) {
        dimensions = 2;
      }

      return earcut_1(vertices, holes, dimensions);
    }
    var v1 = [];
    var v2 = [];
    var v = [];

    function innerOffsetPolygon(vertices, out, start, end, outStart, offset, miterLimit, close) {
      var checkMiterLimit = miterLimit != null;
      var outOff = outStart;
      var indicesMap = null;

      if (checkMiterLimit) {
        indicesMap = new Uint32Array(end - start);
      }

      for (var i = start; i < end; i++) {
        var nextIdx = i === end - 1 ? start : i + 1;
        var prevIdx = i === start ? end - 1 : i - 1;
        var x1 = vertices[prevIdx * 2];
        var y1 = vertices[prevIdx * 2 + 1];
        var x2 = vertices[i * 2];
        var y2 = vertices[i * 2 + 1];
        var x3 = vertices[nextIdx * 2];
        var y3 = vertices[nextIdx * 2 + 1];
        v1[0] = x2 - x1;
        v1[1] = y2 - y1;
        v2[0] = x3 - x2;
        v2[1] = y3 - y2;
        v2Normalize(v1, v1);
        v2Normalize(v2, v2);
        checkMiterLimit && (indicesMap[i] = outOff);

        if (!close && i === start) {
          v[0] = v2[1];
          v[1] = -v2[0];
          v2Normalize(v, v);
          out[outOff * 2] = x2 + v[0] * offset;
          out[outOff * 2 + 1] = y2 + v[1] * offset;
          outOff++;
        } else if (!close && i === end - 1) {
          v[0] = v1[1];
          v[1] = -v1[0];
          v2Normalize(v, v);
          out[outOff * 2] = x2 + v[0] * offset;
          out[outOff * 2 + 1] = y2 + v[1] * offset;
          outOff++;
        } else {
          // PENDING Why using sub will lost the direction info.
          v2Add(v, v2, v1);
          var tmp = v[1];
          v[1] = -v[0];
          v[0] = tmp;
          v2Normalize(v, v);
          var cosA = v2Dot(v, v2);
          var sinA = Math.sqrt(1 - cosA * cosA); // PENDING

          var miter = offset * Math.min(10, 1 / sinA);
          var isCovex = offset * cosA < 0;

          if (checkMiterLimit && 1 / sinA > miterLimit && isCovex) {
            var mx = x2 + v[0] * offset;
            var my = y2 + v[1] * offset;
            var halfA = Math.acos(sinA) / 2;
            var dist = Math.tan(halfA) * Math.abs(offset);
            out[outOff * 2] = mx + v[1] * dist;
            out[outOff * 2 + 1] = my - v[0] * dist;
            outOff++;
            out[outOff * 2] = mx - v[1] * dist;
            out[outOff * 2 + 1] = my + v[0] * dist;
            outOff++;
          } else {
            out[outOff * 2] = x2 + v[0] * miter;
            out[outOff * 2 + 1] = y2 + v[1] * miter;
            outOff++;
          }
        }
      }

      return indicesMap;
    }

    function offsetPolygon(vertices, holes, offset, miterLimit, close) {
      var offsetVertices = miterLimit != null ? [] : new Float32Array(vertices.length);
      var exteriorSize = holes && holes.length ? holes[0] : vertices.length / 2;
      innerOffsetPolygon(vertices, offsetVertices, 0, exteriorSize, 0, offset, miterLimit, close, false);

      if (holes) {
        for (var i = 0; i < holes.length; i++) {
          var start = holes[i];
          var end = holes[i + 1] || vertices.length / 2;
          innerOffsetPolygon(vertices, offsetVertices, start, end, miterLimit != null ? offsetVertices.length / 2 : start, offset, miterLimit, close);
        }
      }

      return offsetVertices;
    }

    function reversePoints(points, stride, start, end) {
      for (var i = 0; i < Math.floor((end - start) / 2); i++) {
        for (var j = 0; j < stride; j++) {
          var a = (i + start) * stride + j;
          var b = (end - i - 1) * stride + j;
          var tmp = points[a];
          points[a] = points[b];
          points[b] = tmp;
        }
      }

      return points;
    }

    function convertToClockwise(vertices, holes) {
      var polygonVertexCount = vertices.length / 2;
      var start = 0;
      var end = holes && holes.length ? holes[0] : polygonVertexCount;

      if (area$1(vertices, start, end) > 0) {
        reversePoints(vertices, 2, start, end);
      }

      for (var h = 1; h < (holes ? holes.length : 0) + 1; h++) {
        start = holes[h - 1];
        end = holes[h] || polygonVertexCount;

        if (area$1(vertices, start, end) < 0) {
          reversePoints(vertices, 2, start, end);
        }
      }
    }

    function normalizeOpts(opts) {
      opts.depth = opts.depth || 1;
      opts.bevelSize = opts.bevelSize || 0;
      opts.bevelSegments = opts.bevelSegments == null ? 2 : opts.bevelSegments;
      opts.smoothSide = opts.smoothSide || false;
      opts.smoothBevel = opts.smoothBevel || false;
      opts.simplify = opts.simplify || 0; // Normalize bevel options.

      if (typeof opts.depth === 'number') {
        opts.bevelSize = Math.min(!(opts.bevelSegments > 0) ? 0 : opts.bevelSize, opts.depth / 2);
      }

      if (!(opts.bevelSize > 0)) {
        opts.bevelSegments = 0;
      }

      opts.bevelSegments = Math.round(opts.bevelSegments);
      var boundingRect = opts.boundingRect;
      opts.translate = opts.translate || [0, 0];
      opts.scale = opts.scale || [1, 1];

      if (opts.fitRect) {
        var targetX = opts.fitRect.x == null ? boundingRect.x || 0 : opts.fitRect.x;
        var targetY = opts.fitRect.y == null ? boundingRect.y || 0 : opts.fitRect.y;
        var targetWidth = opts.fitRect.width;
        var targetHeight = opts.fitRect.height;

        if (targetWidth == null) {
          if (targetHeight != null) {
            targetWidth = targetHeight / boundingRect.height * boundingRect.width;
          } else {
            targetWidth = boundingRect.width;
            targetHeight = boundingRect.height;
          }
        } else if (targetHeight == null) {
          targetHeight = targetWidth / boundingRect.width * boundingRect.height;
        }

        opts.scale = [targetWidth / boundingRect.width, targetHeight / boundingRect.height];
        opts.translate = [(targetX - boundingRect.x) * opts.scale[0], (targetY - boundingRect.y) * opts.scale[1]];
      }
    }

    function generateNormal(indices, position) {
      function v3Set(p, a, b, c) {
        p[0] = a;
        p[1] = b;
        p[2] = c;
      }

      var p1 = [];
      var p2 = [];
      var p3 = [];
      var v21 = [];
      var v32 = [];
      var n = [];
      var len = indices.length;
      var normals = new Float32Array(position.length);

      for (var f = 0; f < len;) {
        var i1 = indices[f++] * 3;
        var i2 = indices[f++] * 3;
        var i3 = indices[f++] * 3;
        v3Set(p1, position[i1], position[i1 + 1], position[i1 + 2]);
        v3Set(p2, position[i2], position[i2 + 1], position[i2 + 2]);
        v3Set(p3, position[i3], position[i3 + 1], position[i3 + 2]);
        v3Sub(v21, p1, p2);
        v3Sub(v32, p2, p3);
        v3Cross(n, v21, v32); // Already be weighted by the triangle area

        for (var _i = 0; _i < 3; _i++) {
          normals[i1 + _i] = normals[i1 + _i] + n[_i];
          normals[i2 + _i] = normals[i2 + _i] + n[_i];
          normals[i3 + _i] = normals[i3 + _i] + n[_i];
        }
      }

      for (var i = 0; i < normals.length;) {
        v3Set(n, normals[i], normals[i + 1], normals[i + 2]);
        v3Normalize(n, n);
        normals[i++] = n[0];
        normals[i++] = n[1];
        normals[i++] = n[2];
      }

      return normals;
    } // 0,0----1,0
    // 0,1----1,1


    var quadToTriangle = [[0, 0], [1, 0], [1, 1], [0, 0], [1, 1], [0, 1]]; // Add side vertices and indices. Include bevel.

    function addExtrudeSide(out, _ref, start, end, cursors, opts) {
      var vertices = _ref.vertices,
          topVertices = _ref.topVertices,
          depth = _ref.depth,
          rect = _ref.rect;
      var ringVertexCount = end - start;
      var splitSide = opts.smoothSide ? 1 : 2;
      var splitRingVertexCount = ringVertexCount * splitSide;
      var splitBevel = opts.smoothBevel ? 1 : 2;
      var bevelSize = Math.min(depth / 2, opts.bevelSize);
      var bevelSegments = opts.bevelSegments;
      var vertexOffset = cursors.vertex;
      var size = Math.max(rect.width, rect.height, depth); // Side vertices

      if (bevelSize > 0) {
        var v0 = [0, 0, 1];
        var _v = [];
        var _v2 = [0, 0, -1];
        var _v3 = [];
        var ringCount = 0;
        var vLen = new Float32Array(ringVertexCount);

        for (var k = 0; k < 2; k++) {
          var z = k === 0 ? depth - bevelSize : bevelSize;

          for (var s = 0; s <= bevelSegments * splitBevel; s++) {
            var uLen = 0;
            var prevX = void 0;
            var prevY = void 0;

            for (var i = 0; i < ringVertexCount; i++) {
              for (var j = 0; j < splitSide; j++) {
                // TODO Cache and optimize
                var idx = ((i + j) % ringVertexCount + start) * 2;
                _v[0] = vertices[idx] - topVertices[idx];
                _v[1] = vertices[idx + 1] - topVertices[idx + 1];
                _v[2] = 0;
                var l = Math.sqrt(_v[0] * _v[0] + _v[1] * _v[1]);
                _v[0] /= l;
                _v[1] /= l;
                var t = (Math.floor(s / splitBevel) + s % splitBevel) / bevelSegments;
                k === 0 ? slerp(_v3, v0, _v, t) : slerp(_v3, _v, _v2, t);
                var t2 = k === 0 ? t : 1 - t;
                var a = bevelSize * Math.sin(t2 * Math.PI / 2);
                var b = l * Math.cos(t2 * Math.PI / 2); // ellipse radius

                var r = bevelSize * l / Math.sqrt(a * a + b * b);
                var x = _v3[0] * r + topVertices[idx];
                var y = _v3[1] * r + topVertices[idx + 1];
                var zz = _v3[2] * r + z;
                out.position[cursors.vertex * 3] = x;
                out.position[cursors.vertex * 3 + 1] = y;
                out.position[cursors.vertex * 3 + 2] = zz; // TODO Cache and optimize

                if (i > 0 || j > 0) {
                  uLen += Math.sqrt((prevX - x) * (prevX - x) + (prevY - y) * (prevY - y));
                }

                if (s > 0 || k > 0) {
                  var tmp = (cursors.vertex - splitRingVertexCount) * 3;
                  var prevX2 = out.position[tmp];
                  var prevY2 = out.position[tmp + 1];
                  var prevZ2 = out.position[tmp + 2];
                  vLen[i] += Math.sqrt((prevX2 - x) * (prevX2 - x) + (prevY2 - y) * (prevY2 - y) + (prevZ2 - zz) * (prevZ2 - zz));
                }

                out.uv[cursors.vertex * 2] = uLen / size;
                out.uv[cursors.vertex * 2 + 1] = vLen[i] / size;
                prevX = x;
                prevY = y;
                cursors.vertex++;
              }

              if (splitBevel > 1 && s % splitBevel || splitBevel === 1 && s >= 1) {
                for (var f = 0; f < 6; f++) {
                  var m = (quadToTriangle[f][0] + i * splitSide) % splitRingVertexCount;
                  var n = quadToTriangle[f][1] + ringCount;
                  out.indices[cursors.index++] = (n - 1) * splitRingVertexCount + m + vertexOffset;
                }
              }
            }

            ringCount++;
          }
        }
      } else {
        for (var _k = 0; _k < 2; _k++) {
          var _z = _k === 0 ? depth - bevelSize : bevelSize;

          var _uLen = 0;

          var _prevX = void 0;

          var _prevY = void 0;

          for (var _i2 = 0; _i2 < ringVertexCount; _i2++) {
            for (var _m = 0; _m < splitSide; _m++) {
              var _idx = ((_i2 + _m) % ringVertexCount + start) * 2;

              var _x = vertices[_idx];
              var _y = vertices[_idx + 1];
              out.position[cursors.vertex * 3] = _x;
              out.position[cursors.vertex * 3 + 1] = _y;
              out.position[cursors.vertex * 3 + 2] = _z;

              if (_i2 > 0 || _m > 0) {
                _uLen += Math.sqrt((_prevX - _x) * (_prevX - _x) + (_prevY - _y) * (_prevY - _y));
              }

              out.uv[cursors.vertex * 2] = _uLen / size;
              out.uv[cursors.vertex * 2 + 1] = _z / size;
              _prevX = _x;
              _prevY = _y;
              cursors.vertex++;
            }
          }
        }
      } // Connect the side


      var sideStartRingN = bevelSize > 0 ? bevelSegments * splitBevel + 1 : 1;

      for (var _i3 = 0; _i3 < ringVertexCount; _i3++) {
        for (var _f = 0; _f < 6; _f++) {
          var _m2 = (quadToTriangle[_f][0] + _i3 * splitSide) % splitRingVertexCount;

          var _n = quadToTriangle[_f][1] + sideStartRingN;

          out.indices[cursors.index++] = (_n - 1) * splitRingVertexCount + _m2 + vertexOffset;
        }
      }
    }

    function addTopAndBottom(_ref2, out, cursors, opts) {
      var indices = _ref2.indices,
          vertices = _ref2.vertices,
          topVertices = _ref2.topVertices,
          rect = _ref2.rect,
          depth = _ref2.depth;

      if (vertices.length <= 4) {
        return;
      }

      var vertexOffset = cursors.vertex; // Top indices

      var indicesLen = indices.length;

      for (var i = 0; i < indicesLen; i++) {
        out.indices[cursors.index++] = vertexOffset + indices[i];
      }

      var size = Math.max(rect.width, rect.height); // Top and bottom vertices

      for (var k = 0; k < (opts.excludeBottom ? 1 : 2); k++) {
        for (var _i4 = 0; _i4 < topVertices.length; _i4 += 2) {
          var x = topVertices[_i4];
          var y = topVertices[_i4 + 1];
          out.position[cursors.vertex * 3] = x;
          out.position[cursors.vertex * 3 + 1] = y;
          out.position[cursors.vertex * 3 + 2] = (1 - k) * depth;
          out.uv[cursors.vertex * 2] = (x - rect.x) / size;
          out.uv[cursors.vertex * 2 + 1] = (y - rect.y) / size;
          cursors.vertex++;
        }
      } // Bottom indices


      if (!opts.excludeBottom) {
        var vertexCount = vertices.length / 2;

        for (var _i5 = 0; _i5 < indicesLen; _i5 += 3) {
          for (var _k2 = 0; _k2 < 3; _k2++) {
            out.indices[cursors.index++] = vertexOffset + vertexCount + indices[_i5 + 2 - _k2];
          }
        }
      }
    }

    function innerExtrudeTriangulatedPolygon(preparedData, opts) {
      var indexCount = 0;
      var vertexCount = 0;

      for (var p = 0; p < preparedData.length; p++) {
        var _preparedData$p = preparedData[p],
            indices = _preparedData$p.indices,
            vertices = _preparedData$p.vertices,
            holes = _preparedData$p.holes,
            depth = _preparedData$p.depth;
        var polygonVertexCount = vertices.length / 2;
        var bevelSize = Math.min(depth / 2, opts.bevelSize);
        var bevelSegments = !(bevelSize > 0) ? 0 : opts.bevelSegments;
        indexCount += indices.length * (opts.excludeBottom ? 1 : 2);
        vertexCount += polygonVertexCount * (opts.excludeBottom ? 1 : 2);
        var ringCount = 2 + bevelSegments * 2;
        var start = 0;
        var end = 0;

        for (var h = 0; h < (holes ? holes.length : 0) + 1; h++) {
          if (h === 0) {
            end = holes && holes.length ? holes[0] : polygonVertexCount;
          } else {
            start = holes[h - 1];
            end = holes[h] || polygonVertexCount;
          }

          indexCount += (end - start) * 6 * (ringCount - 1);
          var sideRingVertexCount = (end - start) * (opts.smoothSide ? 1 : 2);
          vertexCount += sideRingVertexCount * ringCount // Double the bevel vertex number if not smooth
          + (!opts.smoothBevel ? bevelSegments * sideRingVertexCount * 2 : 0);
        }
      }

      var data = {
        position: new Float32Array(vertexCount * 3),
        indices: new (vertexCount > 0xffff ? Uint32Array : Uint16Array)(indexCount),
        uv: new Float32Array(vertexCount * 2)
      };
      var cursors = {
        vertex: 0,
        index: 0
      };

      for (var d = 0; d < preparedData.length; d++) {
        addTopAndBottom(preparedData[d], data, cursors, opts);
      }

      for (var _d = 0; _d < preparedData.length; _d++) {
        var _preparedData$_d = preparedData[_d],
            _holes = _preparedData$_d.holes,
            _vertices = _preparedData$_d.vertices;
        var topVertexCount = _vertices.length / 2;
        var _start = 0;

        var _end = _holes && _holes.length ? _holes[0] : topVertexCount; // Add exterior


        addExtrudeSide(data, preparedData[_d], _start, _end, cursors, opts); // Add holes

        if (_holes) {
          for (var _h = 0; _h < _holes.length; _h++) {
            _start = _holes[_h];
            _end = _holes[_h + 1] || topVertexCount;
            addExtrudeSide(data, preparedData[_d], _start, _end, cursors, opts);
          }
        }
      } // Wrap uv


      for (var i = 0; i < data.uv.length; i++) {
        var val = data.uv[i];

        if (val > 0 && Math.round(val) === val) {
          data.uv[i] = 1;
        } else {
          data.uv[i] = val % 1;
        }
      }

      data.normal = generateNormal(data.indices, data.position); // PENDING

      data.boundingRect = preparedData[0] && preparedData[0].rect;
      return data;
    }

    function removeClosePointsOfPolygon(polygon, epsilon) {
      var newPolygon = [];

      for (var k = 0; k < polygon.length; k++) {
        var points = polygon[k];
        var newPoints = [];
        var len = points.length;
        var x1 = points[len - 1][0];
        var y1 = points[len - 1][1];
        var dist = 0;

        for (var i = 0; i < len; i++) {
          var x2 = points[i][0];
          var y2 = points[i][1];
          var dx = x2 - x1;
          var dy = y2 - y1;
          dist += Math.sqrt(dx * dx + dy * dy);

          if (dist > epsilon) {
            newPoints.push(points[i]);
            dist = 0;
          }

          x1 = x2;
          y1 = y2;
        }

        if (newPoints.length >= 3) {
          newPolygon.push(newPoints);
        }
      }

      return newPolygon.length > 0 ? newPolygon : null;
    }

    function simplifyPolygon(polygon, tolerance) {
      var newPolygon = [];

      for (var k = 0; k < polygon.length; k++) {
        var points = polygon[k];
        points = simplify(points, tolerance, true);

        if (points.length >= 3) {
          newPolygon.push(points);
        }
      }

      return newPolygon.length > 0 ? newPolygon : null;
    }
    /**
     *
     * @param {Array} polygons Polygons array that match GeoJSON MultiPolygon geometry.
     * @param {Object} [opts]
     * @param {number|Function} [opts.depth]
     * @param {number} [opts.bevelSize = 0]
     * @param {number} [opts.bevelSegments = 2]
     * @param {number} [opts.simplify = 0]
     * @param {boolean} [opts.smoothSide = false]
     * @param {boolean} [opts.smoothBevel = false]
     * @param {boolean} [opts.excludeBottom = false]
     * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
     * @param {Array} [opts.translate]
     * @param {Array} [opts.scale]
     *
     * @return {Object} {indices, position, uv, normal, boundingRect}
     */


    function extrudePolygon(polygons, opts) {
      opts = Object.assign({}, opts);
      var min = [Infinity, Infinity];
      var max = [-Infinity, -Infinity];

      for (var i = 0; i < polygons.length; i++) {
        updateBoundingRect(polygons[i][0], min, max);
      }

      opts.boundingRect = opts.boundingRect || {
        x: min[0],
        y: min[1],
        width: max[0] - min[0],
        height: max[1] - min[1]
      };
      normalizeOpts(opts);
      var preparedData = [];
      var translate = opts.translate || [0, 0];
      var scale$$1 = opts.scale || [1, 1];
      var boundingRect = opts.boundingRect;
      var transformdRect = {
        x: boundingRect.x * scale$$1[0] + translate[0],
        y: boundingRect.y * scale$$1[1] + translate[1],
        width: boundingRect.width * scale$$1[0],
        height: boundingRect.height * scale$$1[1]
      };
      var epsilon = Math.min(boundingRect.width, boundingRect.height) / 1e5;

      for (var _i9 = 0; _i9 < polygons.length; _i9++) {
        var newPolygon = removeClosePointsOfPolygon(polygons[_i9], epsilon);

        if (!newPolygon) {
          continue;
        }

        var simplifyTolerance = opts.simplify / Math.max(scale$$1[0], scale$$1[1]);

        if (simplifyTolerance > 0) {
          newPolygon = simplifyPolygon(newPolygon, simplifyTolerance);
        }

        if (!newPolygon) {
          continue;
        }

        var _earcut$flatten = earcut_1.flatten(newPolygon),
            vertices = _earcut$flatten.vertices,
            holes = _earcut$flatten.holes,
            dimensions = _earcut$flatten.dimensions;

        for (var k = 0; k < vertices.length;) {
          vertices[k] = vertices[k++] * scale$$1[0] + translate[0];
          vertices[k] = vertices[k++] * scale$$1[1] + translate[1];
        }

        convertToClockwise(vertices, holes);

        if (dimensions !== 2) {
          throw new Error('Only 2D polygon points are supported');
        }

        var topVertices = opts.bevelSize > 0 ? offsetPolygon(vertices, holes, opts.bevelSize, null, true) : vertices;
        var indices = triangulate(topVertices, holes, dimensions);
        preparedData.push({
          indices: indices,
          vertices: vertices,
          topVertices: topVertices,
          holes: holes,
          rect: transformdRect,
          depth: typeof opts.depth === 'function' ? opts.depth(_i9) : opts.depth
        });
      }

      return innerExtrudeTriangulatedPolygon(preparedData, opts);
    }

    function updateBoundingRect(points, min, max) {
      for (var i = 0; i < points.length; i++) {
        min[0] = Math.min(points[i][0], min[0]);
        min[1] = Math.min(points[i][1], min[1]);
        max[0] = Math.max(points[i][0], max[0]);
        max[1] = Math.max(points[i][1], max[1]);
      }
    }

    var initialize = function initialize() {};
    var onmessage = function onmessage(message, postResponse) {
      var data = message.data;
      var type = data.type,
          datas = data.datas;

      if (type === 'Polygon') {
        generateData(datas);
        var result = generateExtrudePolygons(datas);
        postResponse(null, result, [result.position, result.normal, result.uv, result.indices]);
      }
    };

    function generateData(list) {
      var len = list.length;

      for (var i = 0; i < len; i++) {
        var data = list[i].data;

        for (var j = 0, len1 = data.length; j < len1; j++) {
          var d = data[j];

          for (var m = 0, len2 = d.length; m < len2; m++) {
            //ring
            list[i].data[j][m] = arrayBufferToArray(d[m]);
          }
        }
      }
    }

    function arrayBufferToArray(buffer) {
      var ps = new Float32Array(buffer);
      var vs = [];

      for (var i = 0, len = ps.length; i < len; i += 2) {
        var x = ps[i],
            y = ps[i + 1];
        vs.push([x, y]);
      }

      return vs;
    }

    function generateExtrudePolygons(datas) {
      var len = datas.length;
      var geometriesAttributes = [],
          geometries = [],
          faceMap = [];
      var faceIndex = 0,
          psIndex = 0,
          normalIndex = 0,
          uvIndex = 0;

      for (var i = 0; i < len; i++) {
        var buffGeom = extrudePolygons(datas[i]);
        var _position = buffGeom.position,
            _normal = buffGeom.normal,
            _uv = buffGeom.uv,
            _indices = buffGeom.indices;
        geometries.push(buffGeom);
        var faceLen = _indices.length / 3;
        faceMap[i] = [faceIndex + 1, faceIndex + faceLen];
        faceIndex += faceLen;
        var psCount = _position.length / 3,
            //  colorCount = buffGeom.attributes.color.count,
        normalCount = _normal.length / 3,
            uvCount = _uv.length / 2;
        geometriesAttributes[i] = {
          position: {
            count: psCount,
            start: psIndex,
            end: psIndex + psCount * 3
          },
          normal: {
            count: normalCount,
            start: normalIndex,
            end: normalIndex + normalCount * 3
          },
          // color: {
          //     count: colorCount,
          //     start: colorIndex,
          //     end: colorIndex + colorCount * 3,
          // },
          uv: {
            count: uvCount,
            start: uvIndex,
            end: uvIndex + uvCount * 2
          },
          hide: false
        };
        psIndex += psCount * 3;
        normalIndex += normalCount * 3; // colorIndex += colorCount * 3;

        uvIndex += uvCount * 2;
      }

      var geometry = mergeBufferGeometries(geometries);
      var position = geometry.position,
          normal = geometry.normal,
          uv = geometry.uv,
          indices = geometry.indices;
      return {
        position: position.buffer,
        normal: normal.buffer,
        uv: uv.buffer,
        indices: indices.buffer,
        faceMap: faceMap,
        geometriesAttributes: geometriesAttributes
      };
    }

    function extrudePolygons(d) {
      var data = d.data,
          height = d.height;

      var _extrudePolygon = extrudePolygon( // polygons same with coordinates of MultiPolygon type geometry in GeoJSON
      // See http://wiki.geojson.org/GeoJSON_draft_version_6#MultiPolygon
      data, // Options of extrude
      {
        // Can be a constant value, or a function.
        // Default to be 1.
        depth: height
      }),
          position = _extrudePolygon.position,
          normal = _extrudePolygon.normal,
          uv = _extrudePolygon.uv,
          indices = _extrudePolygon.indices;

      return {
        position: position,
        normal: normal,
        uv: uv,
        indices: indices
      };
    }

    function mergeBufferAttributes(attributes, arrayLength) {
      var array = new Float32Array(arrayLength);
      var offset = 0;

      for (var i = 0; i < attributes.length; ++i) {
        array.set(attributes[i], offset);
        offset += attributes[i].length;
      }

      return array;
    }

    function mergeBufferGeometries(geometries) {
      var attributes = {},
          attributesLen = {};

      for (var i = 0; i < geometries.length; ++i) {
        var geometry = geometries[i];

        for (var name in geometry) {
          if (attributes[name] === undefined) {
            attributes[name] = [];
            attributesLen[name] = 0;
          }

          attributes[name].push(geometry[name]);
          attributesLen[name] += geometry[name].length;
        }
      } // merge attributes


      var mergedGeometry = {};
      var indexOffset = 0;
      var mergedIndex = [];

      for (var _name in attributes) {
        if (_name === 'indices') {
          var indices = attributes[_name];

          for (var _i = 0, len = indices.length; _i < len; _i++) {
            var index = indices[_i];

            for (var j = 0, len1 = index.length; j < len1; j++) {
              mergedIndex.push(index[j] + indexOffset);
            }

            indexOffset += attributes['position'][_i].length / 3;
          }
        } else {
          var mergedAttribute = mergeBufferAttributes(attributes[_name], attributesLen[_name]);
          if (!mergedAttribute) return null;
          mergedGeometry[_name] = mergedAttribute;
        }
      }

      mergedGeometry['indices'] = new Uint32Array(mergedIndex);
      return mergedGeometry;
    }

    exports.initialize = initialize;
    exports.onmessage = onmessage;

    Object.defineProperty(exports, '__esModule', { value: true });

});

var ToolTip = /*#__PURE__*/function (_maptalks$ui$ToolTip) {
  _inheritsLoose(ToolTip, _maptalks$ui$ToolTip);

  function ToolTip() {
    return _maptalks$ui$ToolTip.apply(this, arguments) || this;
  }

  var _proto = ToolTip.prototype;

  /**
  * Adds the UI Component to a BaseObject
  * @param {BaseObject} owner - BaseObject to add.
  * @returns {UIComponent} this
  * @fires UIComponent#add
  */
  _proto.addTo = function addTo(owner) {
    if (owner instanceof BaseObject$$1) {
      owner.on('mousemove', this.onMouseMove, this);
      owner.on('mouseout', this.onMouseOut, this);
      this._owner = owner; // first time

      this._switchEvents('on');

      if (this.onAdd) {
        this.onAdd();
      }
      /**
       * add event.
       *
       * @event ui.UIComponent#add
       * @type {Object}
       * @property {String} type - add
       * @property {ui.UIComponent} target - UIComponent
       */


      this.fire('add');
      return this;
    } else {
      throw new Error('Invalid BaseObject the tooltip is added to.');
    }
  };

  return ToolTip;
}(maptalks__WEBPACK_IMPORTED_MODULE_0__["ui"].ToolTip);

/**
 * three api adapt
 */

var REVISION$1 = parseInt(three__WEBPACK_IMPORTED_MODULE_1__["REVISION"]);
/**
 *
 * @param {THREE.BufferGeometry} bufferGeomertry
 * @param {String} key
 * @param {*} value
 */

function addAttribute(bufferGeomertry, key, value) {
  if (REVISION$1 > 109) {
    bufferGeomertry.setAttribute(key, value);
  } else {
    bufferGeomertry.addAttribute(key, value);
  }

  return bufferGeomertry;
}
function setRaycasterLinePrecision(raycaster, linePrecision) {
  if (REVISION$1 > 113) {
    raycaster.params.Line.threshold = linePrecision;
  } else {
    raycaster.linePrecision = linePrecision;
  }
}

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */

var LineSegmentsGeometry = function LineSegmentsGeometry() {
  three__WEBPACK_IMPORTED_MODULE_1__["InstancedBufferGeometry"].call(this);
  this.type = 'LineSegmentsGeometry'; // var plane = new THREE.BufferGeometry();

  var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
  var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
  var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
  this.setIndex(index);
  addAttribute(this, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](positions, 3));
  addAttribute(this, 'uv', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](uvs, 2)); // this.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  // this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
};

LineSegmentsGeometry.prototype = Object.assign(Object.create(three__WEBPACK_IMPORTED_MODULE_1__["InstancedBufferGeometry"].prototype), {
  constructor: LineSegmentsGeometry,
  isLineSegmentsGeometry: true,
  applyMatrix: function applyMatrix(matrix) {
    var start = this.attributes.instanceStart;
    var end = this.attributes.instanceEnd;

    if (start !== undefined) {
      matrix.applyToBufferAttribute(start);
      matrix.applyToBufferAttribute(end);
      start.data.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  },
  setPositions: function setPositions(array) {
    var lineSegments;

    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if (Array.isArray(array)) {
      lineSegments = new Float32Array(array);
    }

    var instanceBuffer = new three__WEBPACK_IMPORTED_MODULE_1__["InstancedInterleavedBuffer"](lineSegments, 6, 1); // xyz, xyz

    addAttribute(this, 'instanceStart', new three__WEBPACK_IMPORTED_MODULE_1__["InterleavedBufferAttribute"](instanceBuffer, 3, 0));
    addAttribute(this, 'instanceEnd', new three__WEBPACK_IMPORTED_MODULE_1__["InterleavedBufferAttribute"](instanceBuffer, 3, 3)); // this.addAttribute('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz
    // this.addAttribute('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz
    //

    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  },
  setColors: function setColors(array) {
    var colors;

    if (array instanceof Float32Array) {
      colors = array;
    } else if (Array.isArray(array)) {
      colors = new Float32Array(array);
    }

    var instanceColorBuffer = new three__WEBPACK_IMPORTED_MODULE_1__["InstancedInterleavedBuffer"](colors, 6, 1); // rgb, rgb

    addAttribute(this, 'instanceColorStart', new three__WEBPACK_IMPORTED_MODULE_1__["InterleavedBufferAttribute"](instanceColorBuffer, 3, 0));
    addAttribute(this, 'instanceColorEnd', new three__WEBPACK_IMPORTED_MODULE_1__["InterleavedBufferAttribute"](instanceColorBuffer, 3, 3)); // this.addAttribute('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb
    // this.addAttribute('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb

    return this;
  },
  fromWireframeGeometry: function fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  },
  fromEdgesGeometry: function fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  },
  fromMesh: function fromMesh(mesh) {
    this.fromWireframeGeometry(new three__WEBPACK_IMPORTED_MODULE_1__["WireframeGeometry"](mesh.geometry)); // set colors, maybe

    return this;
  },
  fromLineSegements: function fromLineSegements(lineSegments) {
    var geometry = lineSegments.geometry;

    if (geometry.isGeometry) {
      this.setPositions(geometry.vertices);
    } else if (geometry.isBufferGeometry) {
      this.setPositions(geometry.position.array); // assumes non-indexed
    } // set colors, maybe


    return this;
  },
  computeBoundingBox: function () {
    var box = new three__WEBPACK_IMPORTED_MODULE_1__["Box3"]();
    return function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_1__["Box3"]();
      }

      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;

      if (start !== undefined && end !== undefined) {
        this.boundingBox.setFromBufferAttribute(start);
        box.setFromBufferAttribute(end);
        this.boundingBox.union(box);
      }
    };
  }(),
  computeBoundingSphere: function () {
    var vector = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    return function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_1__["Sphere"]();
      }

      if (this.boundingBox === null) {
        this.computeBoundingBox();
      }

      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;

      if (start !== undefined && end !== undefined) {
        var center = this.boundingSphere.center;
        this.boundingBox.getCenter(center);
        var maxRadiusSq = 0;

        for (var i = 0, il = start.count; i < il; i++) {
          vector.fromBufferAttribute(start, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
          vector.fromBufferAttribute(end, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);
        }
      }
    };
  }(),
  toJSON: function toJSON() {// todo
  },
  // clone: function () {
  //     // todo
  // },
  // eslint-disable-next-line no-unused-vars
  copy: function copy(source) {
    // todo
    return this;
  }
});

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  linewidth: <float>,
 *  dashed: <boolean>,
 *  dashScale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *  resolution: <Vector2>, // to be set by renderer
 * }
 */
var UniformsLib$1 = {},
    ShaderLib = {};
UniformsLib$1.line = {
  linewidth: {
    value: 1
  },
  resolution: {
    value: new three__WEBPACK_IMPORTED_MODULE_1__["Vector2"](1, 1)
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  } // todo FIX - maybe change to totalSize

};
ShaderLib['line'] = {
  uniforms: three__WEBPACK_IMPORTED_MODULE_1__["UniformsUtils"].merge([three__WEBPACK_IMPORTED_MODULE_1__["UniformsLib"].common, three__WEBPACK_IMPORTED_MODULE_1__["UniformsLib"].fog, UniformsLib$1.line]),
  vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
  fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"
};

var LineMaterial = function LineMaterial(parameters) {
  three__WEBPACK_IMPORTED_MODULE_1__["ShaderMaterial"].call(this, {
    type: 'LineMaterial',
    uniforms: three__WEBPACK_IMPORTED_MODULE_1__["UniformsUtils"].clone(ShaderLib['line'].uniforms),
    vertexShader: ShaderLib['line'].vertexShader,
    fragmentShader: ShaderLib['line'].fragmentShader
  });
  this.dashed = false;
  Object.defineProperties(this, {
    color: {
      enumerable: true,
      get: function get() {
        return this.uniforms.diffuse.value;
      },
      set: function set(value) {
        this.uniforms.diffuse.value = value;
      }
    },
    linewidth: {
      enumerable: true,
      get: function get() {
        return this.uniforms.linewidth.value;
      },
      set: function set(value) {
        this.uniforms.linewidth.value = value;
      }
    },
    dashScale: {
      enumerable: true,
      get: function get() {
        return this.uniforms.dashScale.value;
      },
      set: function set(value) {
        this.uniforms.dashScale.value = value;
      }
    },
    dashSize: {
      enumerable: true,
      get: function get() {
        return this.uniforms.dashSize.value;
      },
      set: function set(value) {
        this.uniforms.dashSize.value = value;
      }
    },
    gapSize: {
      enumerable: true,
      get: function get() {
        return this.uniforms.gapSize.value;
      },
      set: function set(value) {
        this.uniforms.gapSize.value = value;
      }
    },
    resolution: {
      enumerable: true,
      get: function get() {
        return this.uniforms.resolution.value;
      },
      set: function set(value) {
        this.uniforms.resolution.value.copy(value);
      }
    }
  });
  this.setValues(parameters);
};

LineMaterial.prototype = Object.create(three__WEBPACK_IMPORTED_MODULE_1__["ShaderMaterial"].prototype);
LineMaterial.prototype.constructor = LineMaterial;
LineMaterial.prototype.isLineMaterial = true;

LineMaterial.prototype.copy = function (source) {
  three__WEBPACK_IMPORTED_MODULE_1__["ShaderMaterial"].prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.resolution = source.resolution; // todo

  return this;
};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */

var LineSegments2 = function LineSegments2(geometry, material) {
  three__WEBPACK_IMPORTED_MODULE_1__["Mesh"].call(this);
  this.type = 'LineSegments2';
  this.geometry = geometry !== undefined ? geometry : new LineSegmentsGeometry();
  this.material = material !== undefined ? material : new LineMaterial({
    color: Math.random() * 0xffffff
  });
};

LineSegments2.prototype = Object.assign(Object.create(three__WEBPACK_IMPORTED_MODULE_1__["Mesh"].prototype), {
  constructor: LineSegments2,
  isLineSegments2: true,
  computeLineDistances: function () {
    // for backwards-compatability, but could be a method of LineSegmentsGeometry...
    var start = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    var end = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    return function computeLineDistances() {
      var geometry = this.geometry;
      var instanceStart = geometry.attributes.instanceStart;
      var instanceEnd = geometry.attributes.instanceEnd;
      var lineDistances = new Float32Array(2 * instanceStart.data.count);

      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {
        start.fromBufferAttribute(instanceStart, i);
        end.fromBufferAttribute(instanceEnd, i);
        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);
      }

      var instanceDistanceBuffer = new three__WEBPACK_IMPORTED_MODULE_1__["InstancedInterleavedBuffer"](lineDistances, 2, 1); // d0, d1

      addAttribute(geometry, 'instanceDistanceStart', new three__WEBPACK_IMPORTED_MODULE_1__["InterleavedBufferAttribute"](instanceDistanceBuffer, 1, 0));
      addAttribute(geometry, 'instanceDistanceEnd', new three__WEBPACK_IMPORTED_MODULE_1__["InterleavedBufferAttribute"](instanceDistanceBuffer, 1, 1)); // geometry.addAttribute('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0
      // geometry.addAttribute('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1

      return this;
    };
  }(),
  // eslint-disable-next-line no-unused-vars
  copy: function copy(source) {
    // todo
    return this;
  }
});

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */

var LineGeometry = function LineGeometry() {
  LineSegmentsGeometry.call(this);
  this.type = 'LineGeometry';
};

LineGeometry.prototype = Object.assign(Object.create(LineSegmentsGeometry.prototype), {
  constructor: LineGeometry,
  isLineGeometry: true,
  // setPositions: function (array) {
  //     // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format
  //     var length = array.length - 3;
  //     var points = new Float32Array(2 * length);
  //     for (var i = 0; i < length; i += 3) {
  //         points[2 * i] = array[i];
  //         points[2 * i + 1] = array[i + 1];
  //         points[2 * i + 2] = array[i + 2];
  //         points[2 * i + 3] = array[i + 3];
  //         points[2 * i + 4] = array[i + 4];
  //         points[2 * i + 5] = array[i + 5];
  //     }
  //     LineSegmentsGeometry.prototype.setPositions.call(this, points);
  //     return this;
  // },
  // setColors: function (array) {
  //     // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format
  //     var length = array.length - 3;
  //     var colors = new Float32Array(2 * length);
  //     for (var i = 0; i < length; i += 3) {
  //         colors[2 * i] = array[i];
  //         colors[2 * i + 1] = array[i + 1];
  //         colors[2 * i + 2] = array[i + 2];
  //         colors[2 * i + 3] = array[i + 3];
  //         colors[2 * i + 4] = array[i + 4];
  //         colors[2 * i + 5] = array[i + 5];
  //     }
  //     LineSegmentsGeometry.prototype.setColors.call(this, colors);
  //     return this;
  // },
  fromLine: function fromLine(line) {
    var geometry = line.geometry;

    if (geometry.isGeometry) {
      this.setPositions(geometry.vertices);
    } else if (geometry.isBufferGeometry) {
      this.setPositions(geometry.position.array); // assumes non-indexed
    } // set colors, maybe


    return this;
  },
  // eslint-disable-next-line no-unused-vars
  copy: function copy(source) {
    // todo
    return this;
  }
});

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */

var Line2 = function Line2(geometry, material) {
  LineSegments2.call(this);
  this.type = 'Line2';
  this.geometry = geometry !== undefined ? geometry : new LineGeometry();
  this.material = material !== undefined ? material : new LineMaterial({
    color: Math.random() * 0xffffff
  });
};

Line2.prototype = Object.assign(Object.create(LineSegments2.prototype), {
  constructor: Line2,
  isLine2: true,
  // eslint-disable-next-line no-unused-vars
  copy: function copy(source) {
    // todo
    return this;
  }
});

var OPTIONS = {
  interactive: true,
  altitude: 0,
  minZoom: 0,
  maxZoom: 30,
  asynchronous: false
};
/**
 * a Class for Eventable
 */

var Base = function Base() {};
/**
 * EVENTS=[
 *  'add',
 *  'remove',
    'mousemove',
    'click',
    'mousedown',
    'mouseup',
    'dblclick',
    'contextmenu',
    'touchstart',
    'touchmove',
    'touchend',
    'mouseover',
    'mouseout',
    'idchange',
    'propertieschange',
    'show',
    'hide',
    'symbolchange'
     empty
];
 * This is the base class for all 3D objects
 *
 *
 * Its function and maptalks.geometry are as similar as possible
 *
 * maptalks.Eventable(Base) return a Class  https://github.com/maptalks/maptalks.js/blob/master/src/core/Eventable.js
 *
 */


var BaseObject$$1 = /*#__PURE__*/function (_maptalks$Eventable) {
  _inheritsLoose(BaseObject$$1, _maptalks$Eventable);

  function BaseObject$$1(id) {
    var _this;

    _this = _maptalks$Eventable.call(this) || this;
    _this.isBaseObject = true;
    _this.isAdd = false;
    _this.object3d = null;
    _this.options = {};
    _this.toolTip = null;
    _this.infoWindow = null;
    _this._mouseover = false;
    _this._showPlayer = null;
    _this._visible = true;
    _this._zoomVisible = true;
    _this._vt = null;
    _this.picked = false;
    _this.pickObject3d = null;

    if (id === undefined) {
      id = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].GUID();
    }

    _this.id = id;
    return _this;
  }

  var _proto = BaseObject$$1.prototype;

  _proto.addTo = function addTo(layer) {
    if (layer instanceof ThreeLayer) {
      layer.addMesh(this);
    } else {
      console.error('layer only support maptalks.ThreeLayer');
    }

    return this;
  };

  _proto.remove = function remove() {
    var layer = this.getLayer();

    if (layer) {
      layer.removeMesh(this);
    }

    return this;
  };

  _proto.getObject3d = function getObject3d() {
    return this.object3d;
  };

  _proto.getId = function getId() {
    return this.id;
  };

  _proto.setId = function setId(id) {
    var oldId = this.getId();
    this.id = id;

    this._fire('idchange', {
      'old': oldId,
      'new': id,
      'target': this
    });

    return this;
  };

  _proto.getType = function getType() {
    return this.constructor.name;
  };

  _proto.getOptions = function getOptions() {
    return this.options;
  };

  _proto.getProperties = function getProperties() {
    return (this.options || {}).properties;
  };

  _proto.setProperties = function setProperties(property) {
    var old = Object.assign({}, this.getProperties());
    this.options.properties = property;

    this._fire('propertieschange', {
      'old': old,
      'new': property,
      'target': this
    });

    return this;
  };

  _proto.getLayer = function getLayer() {
    return this.options.layer;
  } // eslint-disable-next-line consistent-return
  ;

  _proto.getMap = function getMap() {
    var layer = this.getLayer();

    if (layer) {
      return layer.getMap();
    }
  } // eslint-disable-next-line consistent-return
  ;

  _proto.getCenter = function getCenter() {
    var options = this.getOptions();
    var coordinate = options.coordinate,
        lineString = options.lineString,
        polygon = options.polygon;

    if (coordinate) {
      return coordinate;
    } else {
      var geometry = polygon || lineString;

      if (geometry && geometry.getCenter) {
        return geometry.getCenter();
      }
    }
  };

  _proto.getAltitude = function getAltitude() {
    return this.getOptions().altitude;
  }
  /**
   * Different objects need to implement their own methods
   * @param {*} altitude
   */
  ;

  _proto.setAltitude = function setAltitude(altitude) {
    if (maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isNumber(altitude)) {
      var z = this.getLayer().distanceToVector3(altitude, altitude).x;
      this.getObject3d().position.z = z;
      this.options.altitude = altitude;

      if (this.pickObject3d) {
        this.pickObject3d.position.z = z;
      } //fix merged mesh


      if (this._baseObjects && Array.isArray(this._baseObjects)) {
        for (var i = 0, len = this._baseObjects.length; i < len; i++) {
          if (this._baseObjects[i]) {
            this._baseObjects[i].getObject3d().position.z = z;
          }
        }
      }
    }

    return this;
  };

  _proto.show = function show() {
    //  in zoom range
    if (this._zoomVisible) {
      this.getObject3d().visible = true;

      this._fire('show');
    }

    this._visible = true;
    return this;
  };

  _proto.hide = function hide() {
    this.getObject3d().visible = false;

    this._fire('hide');

    this._visible = false;
    return this;
  };

  _proto.isVisible = function isVisible() {
    return !!this.getObject3d().visible;
  }
  /**
   *  Different objects need to implement their own methods
   */
  ;

  _proto.getSymbol = function getSymbol() {
    return this.getObject3d().material;
  }
  /**
   *  Different objects need to implement their own methods
   * @param {*} material
   */
  ;

  _proto.setSymbol = function setSymbol(material) {
    if (material && material instanceof three__WEBPACK_IMPORTED_MODULE_1__["Material"]) {
      material.needsUpdate = true;
      material.vertexColors = this.getObject3d().material.vertexColors;
      var old = this.getObject3d().material.clone();
      this.getObject3d().material = material;

      this._fire('symbolchange', {
        'old': old,
        'new': material,
        'target': this
      });
    }

    return this;
  };

  _proto.setInfoWindow = function setInfoWindow(options) {
    this.removeInfoWindow();
    this.infoWindow = new maptalks__WEBPACK_IMPORTED_MODULE_0__["ui"].InfoWindow(options);
    this.infoWindow.addTo(this);
    return this;
  };

  _proto.getInfoWindow = function getInfoWindow() {
    return this.infoWindow;
  };

  _proto.openInfoWindow = function openInfoWindow(coordinate) {
    coordinate = coordinate || this.getCenter();

    if (!(coordinate instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"])) {
      coordinate = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"](coordinate);
    } // eslint-disable-next-line no-unused-expressions


    coordinate && this.infoWindow && this.infoWindow.show(coordinate);
    return this;
  };

  _proto.closeInfoWindow = function closeInfoWindow() {
    // eslint-disable-next-line no-unused-expressions
    this.infoWindow && this.infoWindow.hide();
    return this;
  };

  _proto.removeInfoWindow = function removeInfoWindow() {
    // eslint-disable-next-line no-unused-expressions
    this.infoWindow && this.infoWindow.remove() && delete this.infoWindow;
    return this;
  };

  _proto.setToolTip = function setToolTip(content, options) {
    this.removeToolTip();
    this.toolTip = new ToolTip(content, options);
    this.toolTip.addTo(this);
    return this;
  };

  _proto.getToolTip = function getToolTip() {
    return this.toolTip;
  };

  _proto.openToolTip = function openToolTip(coordinate) {
    coordinate = coordinate || this.getCenter();

    if (!(coordinate instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"])) {
      coordinate = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"](coordinate);
    } // eslint-disable-next-line no-unused-expressions


    coordinate && this.toolTip && this.toolTip.show(coordinate);
    return this;
  };

  _proto.closeToolTip = function closeToolTip() {
    // eslint-disable-next-line no-unused-expressions
    this.toolTip && this.toolTip.hide();
    return this;
  };

  _proto.removeToolTip = function removeToolTip() {
    // eslint-disable-next-line no-unused-expressions
    this.toolTip && this.toolTip.remove() && delete this.toolTip;
    return this;
  }
  /**
   * different components should implement their own animation methods
   * @param {*} options
   * @param {*} cb
   */
  // eslint-disable-next-line no-unused-vars
  ;

  _proto.animateShow = function animateShow(options, cb) {
    var _this2 = this;

    if (options === void 0) {
      options = {};
    }

    if (this._showPlayer) {
      this._showPlayer.cancel();
    }

    if (maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isFunction(options)) {
      options = {};
      cb = options;
    }

    var duration = options['duration'] || 1000,
        easing = options['easing'] || 'out';
    var player = this._showPlayer = maptalks__WEBPACK_IMPORTED_MODULE_0__["animation"].Animation.animate({
      'scale': 1
    }, {
      'duration': duration,
      'easing': easing
    }, function (frame) {
      var scale = frame.styles.scale;

      if (scale > 0) {
        _this2.getObject3d().scale.set(1, 1, scale);
      }

      if (cb) {
        cb(frame, scale);
      }
    });
    player.play();
    return player;
  };

  _proto.getMinZoom = function getMinZoom() {
    return this.getOptions().minZoom;
  };

  _proto.getMaxZoom = function getMaxZoom() {
    return this.getOptions().maxZoom;
  };

  _proto.isAsynchronous = function isAsynchronous() {
    return this.getOptions().asynchronous;
  };

  _proto.fire = function fire(eventType, param) {
    this._fire(eventType, param);

    if (this._vt && this._vt.onSelectMesh) {
      this._vt.onSelectMesh(eventType, param);
    }

    return this;
  };

  _proto.config = function config() {
    return this;
  };

  _proto.setPickObject3d = function setPickObject3d(object3d) {
    this.pickObject3d = object3d;
    this.pickObject3d.__parent = this;
    return this;
  }
  /**
   * more method support
   * @param {*} options
   */

  /**
   *
   * @param {*} options
   */
  ;

  _proto._initOptions = function _initOptions(options) {
    this.options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS, options);
    return this;
  };

  _proto._createMesh = function _createMesh(geometry, material) {
    this.object3d = new three__WEBPACK_IMPORTED_MODULE_1__["Mesh"](geometry, material);
    this.object3d.__parent = this;
    return this;
  };

  _proto._createGroup = function _createGroup() {
    this.object3d = new three__WEBPACK_IMPORTED_MODULE_1__["Group"]();
    this.object3d.__parent = this;
    return this;
  };

  _proto._createLine = function _createLine(geometry, material) {
    this.object3d = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
    this.object3d.computeLineDistances();
    this.object3d.__parent = this;
    return this;
  };

  _proto._createLine2 = function _createLine2(geometry, material) {
    this.object3d = new Line2(geometry, material);
    this.object3d.computeLineDistances();
    this.object3d.__parent = this;
    return this;
  } // eslint-disable-next-line no-unused-vars
  ;

  _proto._createPoints = function _createPoints(geometry, material) {
    //Serving for particles
    this.object3d = new three__WEBPACK_IMPORTED_MODULE_1__["Points"](geometry, material);
    this.object3d.__parent = this;
    return this;
  };

  _proto._createLineSegments = function _createLineSegments(geometry, material) {
    this.object3d = new three__WEBPACK_IMPORTED_MODULE_1__["LineSegments"](geometry, material);
    this.object3d.computeLineDistances();
    this.object3d.__parent = this;
    return this;
  };

  return BaseObject$$1;
}(Object(maptalks__WEBPACK_IMPORTED_MODULE_0__["Eventable"])(Base));

function mergeBufferGeometries(geometries) {
  var _mergeBufferGeometrie = mergeBufferGeometriesAttribute(geometries),
      position = _mergeBufferGeometrie.position,
      normal = _mergeBufferGeometrie.normal,
      uv = _mergeBufferGeometrie.uv,
      indices = _mergeBufferGeometrie.indices;

  var bufferGeomertry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
  var color = new Float32Array(position.length);
  color.fill(1, 0, position.length);
  addAttribute(bufferGeomertry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](color, 3));
  addAttribute(bufferGeomertry, 'normal', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](normal, 3));
  addAttribute(bufferGeomertry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](position, 3));

  if (uv && uv.length) {
    addAttribute(bufferGeomertry, 'uv', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](uv, 2));
  }

  bufferGeomertry.setIndex(new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](indices, 1));
  return bufferGeomertry;
}
function mergeBufferGeometriesAttribute(geometries) {
  var attributes = {},
      attributesLen = {};

  for (var i = 0; i < geometries.length; ++i) {
    var geometry = geometries[i];

    for (var name in geometry) {
      if (attributes[name] === undefined) {
        attributes[name] = [];
        attributesLen[name] = 0;
      }

      attributes[name].push(geometry[name]);
      attributesLen[name] += geometry[name].length;
    }
  } // merge attributes


  var mergedGeometry = {};
  var indexOffset = 0;
  var mergedIndex = [];

  for (var _name in attributes) {
    if (_name === 'indices') {
      var indices = attributes[_name];

      for (var _i = 0, len = indices.length; _i < len; _i++) {
        var index = indices[_i];

        for (var j = 0, len1 = index.length; j < len1; j++) {
          mergedIndex.push(index[j] + indexOffset);
        }

        indexOffset += attributes['position'][_i].length / 3;
      }
    } else {
      var mergedAttribute = mergeBufferAttributes(attributes[_name], attributesLen[_name]);
      if (!mergedAttribute) return null;
      mergedGeometry[_name] = mergedAttribute;
    }
  }

  mergedGeometry['indices'] = new Uint32Array(mergedIndex);
  return mergedGeometry;
}

function mergeBufferAttributes(attributes, arrayLength) {
  var array = new Float32Array(arrayLength);
  var offset = 0;

  for (var i = 0; i < attributes.length; ++i) {
    array.set(attributes[i], offset);
    offset += attributes[i].length;
  }

  return array;
}

var barGeometryCache = {};
var KEY = '-';
/**
 * Reuse Geometry   , Meter as unit
 * @param {*} property
 */

function getGeometry(property, isCache) {
  if (isCache === void 0) {
    isCache = true;
  }

  var height = property.height,
      radialSegments = property.radialSegments,
      radius = property.radius,
      _radius = property._radius,
      _height = property._height;

  if (!isCache) {
    //for bars
    var _geometry = new three__WEBPACK_IMPORTED_MODULE_1__["CylinderBufferGeometry"](radius, radius, height, radialSegments, 1);

    _geometry.rotateX(Math.PI / 2);

    var parray = _geometry.attributes.position.array;

    for (var j = 0, len1 = parray.length; j < len1; j += 3) {
      parray[j + 2] += height / 2;
    }

    return _geometry;
  }

  var geometry;

  for (var i = 0; i <= 4; i++) {
    var key = [_height + i, _radius, radialSegments].join(KEY).toString();
    geometry = barGeometryCache[key];
    if (geometry) break;
    key = [_height - i, _radius, radialSegments].join(KEY).toString();
    geometry = barGeometryCache[key];
    if (geometry) break;
  }

  if (!geometry) {
    var _key = [_height, _radius, radialSegments].join(KEY).toString();

    geometry = barGeometryCache[_key] = new three__WEBPACK_IMPORTED_MODULE_1__["CylinderBufferGeometry"](radius, radius, height, radialSegments, 1);
    geometry.rotateX(Math.PI / 2);
    var _parray = geometry.attributes.position.array;

    for (var _j = 0, _len = _parray.length; _j < _len; _j += 3) {
      _parray[_j + 2] += height / 2;
    }

    return geometry;
  }

  return geometry;
}
/**
 * init Colors
 * @param {*} geometry
 * @param {*} color
 * @param {*} _topColor
 */

function initVertexColors(geometry, color, _topColor, key, v) {
  if (key === void 0) {
    key = 'y';
  }

  if (v === void 0) {
    v = 0;
  }

  var offset = 0;

  if (key === 'y') {
    offset = 1;
  } else if (key === 'z') {
    offset = 2;
  }

  var position = geometry.attributes.position.array;
  var len = position.length;
  var bottomColor = color instanceof three__WEBPACK_IMPORTED_MODULE_1__["Color"] ? color : new three__WEBPACK_IMPORTED_MODULE_1__["Color"](color);
  var topColor = new three__WEBPACK_IMPORTED_MODULE_1__["Color"](_topColor);
  var colors = [];

  for (var i = 0; i < len; i += 3) {
    var y = position[i + offset];

    if (y > v) {
      colors.push(topColor.r, topColor.g, topColor.b);
    } else {
      colors.push(bottomColor.r, bottomColor.g, bottomColor.b);
    }
  }

  addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
  return colors;
}
function mergeBarGeometry(geometries) {
  var attributes = [],
      colors = [];

  for (var i = 0, len = geometries.length; i < len; i++) {
    var _geometries$i$attribu = geometries[i].attributes,
        color = _geometries$i$attribu.color,
        normal = _geometries$i$attribu.normal,
        position = _geometries$i$attribu.position,
        uv = _geometries$i$attribu.uv;
    var index = geometries[i].index;

    if (color) {
      for (var j = 0, len1 = color.array.length; j < len1; j++) {
        colors.push(color.array[j]);
      }
    }

    attributes.push({
      // color: color.array,
      normal: normal.array,
      uv: uv.array,
      position: position.array,
      indices: index.array
    });
  }

  var bufferGeometry = mergeBufferGeometries(attributes);

  if (colors.length) {
    for (var _i = 0, _len2 = colors.length; _i < _len2; _i++) {
      bufferGeometry.attributes.color.array[_i] = colors[_i];
    }
  }

  return bufferGeometry;
}

var OPTIONS$1 = {
  radius: 10,
  height: 100,
  radialSegments: 6,
  altitude: 0,
  topColor: null,
  bottomColor: '#2d2f61'
};
/**
 *
 */

var Bar = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(Bar, _BaseObject);

  function Bar(coordinate, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$1, options, {
      layer: layer,
      coordinate: coordinate
    });
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    var _options = options,
        height = _options.height,
        radius = _options.radius,
        topColor = _options.topColor,
        bottomColor = _options.bottomColor,
        altitude = _options.altitude;
    options.height = layer.distanceToVector3(height, height).x;
    options.radius = layer.distanceToVector3(radius, radius).x; // Meter as unit

    options._radius = _this.options.radius;
    options._height = _this.options.height;
    _this._h = options.height;
    var geometry = getGeometry(options);

    if (topColor && !material.map) {
      initVertexColors(geometry, bottomColor, topColor, 'z', options.height / 2);
      material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
    }

    _this._createMesh(geometry, material);

    var z = layer.distanceToVector3(altitude, altitude).x;
    var position = layer.coordinateToVector3(coordinate, z);

    _this.getObject3d().position.copy(position); // this.getObject3d().rotation.x = Math.PI / 2;
    // this.getObject3d().translateY(options.height / 2);


    return _this;
  }

  return Bar;
}(BaseObject$$1);

var earcut_1 = earcut;
var default_1 = earcut;

function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length,
      outerLen = hasHoles ? holeIndices[0] * dim : data.length,
      outerNode = linkedList(data, 0, outerLen, dim, true),
      triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];

    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }

  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
} // create a circular doubly linked list from polygon points in the specified winding order


function linkedList(data, start, end, dim, clockwise) {
  var i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  var p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  var minZ = zOrder(minTX, minTY, minX, minY, invSize),
      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  var p = start;

  do {
    var a = p.prev,
        b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;

  do {
    var b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [],
      i,
      len,
      start,
      end,
      list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  var p = outerNode,
      hx = hole.x,
      hy = hole.y,
      qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m,
      mx = m.x,
      my = m.y,
      tanMin = Infinity,
      tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
} // whether sector in vertex m contains sector in vertex p in the same coordinates


function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  var p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  var i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  var p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
} // for collinear points p, q, r, check if point q lies on segment pr


function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  var p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  var p = a,
      inside = false,
      px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
} // return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation


earcut.deviation = function (data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));

  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }

  var trianglesArea = 0;

  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
  }

  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
  var sum = 0;

  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
} // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts


earcut.flatten = function (data) {
  var dim = data[0][0].length,
      result = {
    vertices: [],
    holes: [],
    dimensions: dim
  },
      holeIndex = 0;

  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
    }

    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }

  return result;
};
earcut_1.default = default_1;

/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/
// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)
// square distance between 2 points
function getSqDist(p1, p2) {
  var dx = p1[0] - p2[0],
      dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
} // square distance from a point to a segment


function getSqSegDist(p, p1, p2) {
  var x = p1[0],
      y = p1[1],
      dx = p2[0] - x,
      dy = p2[1] - y;

  if (dx !== 0 || dy !== 0) {
    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x = p2[0];
      y = p2[1];
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }

  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
} // rest of the code doesn't care about point format
// basic distance-based simplification


function simplifyRadialDist(points, sqTolerance) {
  var prevPoint = points[0],
      newPoints = [prevPoint],
      point;

  for (var i = 1, len = points.length; i < len; i++) {
    point = points[i];

    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  }

  if (prevPoint !== point) newPoints.push(point);
  return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
  var maxSqDist = sqTolerance,
      index;

  for (var i = first + 1; i < last; i++) {
    var sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
} // simplification using Ramer-Douglas-Peucker algorithm


function simplifyDouglasPeucker(points, sqTolerance) {
  var last = points.length - 1;
  var simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);
  return simplified;
} // both algorithms combined for awesome performance


function simplify(points, tolerance, highestQuality) {
  if (points.length <= 2) return points;
  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  points = simplifyDouglasPeucker(points, sqTolerance);
  return points;
}

function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}
function v2Dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function normalize(out, v) {
  var x = v[0];
  var y = v[1];
  var z = v[2];
  var d = Math.sqrt(x * x + y * y + z * z);
  out[0] = x / d;
  out[1] = y / d;
  out[2] = z / d;
  return out;
}
function v2Normalize(out, v) {
  var x = v[0];
  var y = v[1];
  var d = Math.sqrt(x * x + y * y);
  out[0] = x / d;
  out[1] = y / d;
  return out;
}
function scale(out, v, s) {
  out[0] = v[0] * s;
  out[1] = v[1] * s;
  out[2] = v[2] * s;
  return out;
}
function scaleAndAdd(out, v1, v2, s) {
  out[0] = v1[0] + v2[0] * s;
  out[1] = v1[1] + v2[1] * s;
  out[2] = v1[2] + v2[2] * s;
  return out;
}
function v2Add(out, v1, v2) {
  out[0] = v1[0] + v2[0];
  out[1] = v1[1] + v2[1];
  return out;
}
function v3Sub(out, v1, v2) {
  out[0] = v1[0] - v2[0];
  out[1] = v1[1] - v2[1];
  out[2] = v1[2] - v2[2];
  return out;
}
function v3Normalize(out, v) {
  var x = v[0];
  var y = v[1];
  var z = v[2];
  var d = Math.sqrt(x * x + y * y + z * z);
  out[0] = x / d;
  out[1] = y / d;
  out[2] = z / d;
  return out;
}
function v3Cross(out, v1, v2) {
  var ax = v1[0],
      ay = v1[1],
      az = v1[2],
      bx = v2[0],
      by = v2[1],
      bz = v2[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
var rel = []; // start and end must be normalized

function slerp(out, start, end, t) {
  // https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/
  var cosT = dot(start, end);
  var theta = Math.acos(cosT) * t;
  scaleAndAdd(rel, end, start, -cosT);
  normalize(rel, rel); // start and rel Orthonormal basis

  scale(out, start, Math.cos(theta));
  scaleAndAdd(out, out, rel, Math.sin(theta));
  return out;
}
function area$1(points, start, end) {
  // Signed polygon area
  var n = end - start;

  if (n < 3) {
    return 0;
  }

  var area = 0;

  for (var i = (end - 1) * 2, j = start * 2; j < end * 2;) {
    var x0 = points[i];
    var y0 = points[i + 1];
    var x1 = points[j];
    var y1 = points[j + 1];
    i = j;
    j += 2;
    area += x0 * y1 - x1 * y0;
  }

  return area;
}

// TODO fitRect x, y are negative?
function triangulate(vertices, holes, dimensions) {
  if (dimensions === void 0) {
    dimensions = 2;
  }

  return earcut_1(vertices, holes, dimensions);
}
var v1 = [];
var v2 = [];
var v = [];

function innerOffsetPolygon(vertices, out, start, end, outStart, offset, miterLimit, close) {
  var checkMiterLimit = miterLimit != null;
  var outOff = outStart;
  var indicesMap = null;

  if (checkMiterLimit) {
    indicesMap = new Uint32Array(end - start);
  }

  for (var i = start; i < end; i++) {
    var nextIdx = i === end - 1 ? start : i + 1;
    var prevIdx = i === start ? end - 1 : i - 1;
    var x1 = vertices[prevIdx * 2];
    var y1 = vertices[prevIdx * 2 + 1];
    var x2 = vertices[i * 2];
    var y2 = vertices[i * 2 + 1];
    var x3 = vertices[nextIdx * 2];
    var y3 = vertices[nextIdx * 2 + 1];
    v1[0] = x2 - x1;
    v1[1] = y2 - y1;
    v2[0] = x3 - x2;
    v2[1] = y3 - y2;
    v2Normalize(v1, v1);
    v2Normalize(v2, v2);
    checkMiterLimit && (indicesMap[i] = outOff);

    if (!close && i === start) {
      v[0] = v2[1];
      v[1] = -v2[0];
      v2Normalize(v, v);
      out[outOff * 2] = x2 + v[0] * offset;
      out[outOff * 2 + 1] = y2 + v[1] * offset;
      outOff++;
    } else if (!close && i === end - 1) {
      v[0] = v1[1];
      v[1] = -v1[0];
      v2Normalize(v, v);
      out[outOff * 2] = x2 + v[0] * offset;
      out[outOff * 2 + 1] = y2 + v[1] * offset;
      outOff++;
    } else {
      // PENDING Why using sub will lost the direction info.
      v2Add(v, v2, v1);
      var tmp = v[1];
      v[1] = -v[0];
      v[0] = tmp;
      v2Normalize(v, v);
      var cosA = v2Dot(v, v2);
      var sinA = Math.sqrt(1 - cosA * cosA); // PENDING

      var miter = offset * Math.min(10, 1 / sinA);
      var isCovex = offset * cosA < 0;

      if (checkMiterLimit && 1 / sinA > miterLimit && isCovex) {
        var mx = x2 + v[0] * offset;
        var my = y2 + v[1] * offset;
        var halfA = Math.acos(sinA) / 2;
        var dist = Math.tan(halfA) * Math.abs(offset);
        out[outOff * 2] = mx + v[1] * dist;
        out[outOff * 2 + 1] = my - v[0] * dist;
        outOff++;
        out[outOff * 2] = mx - v[1] * dist;
        out[outOff * 2 + 1] = my + v[0] * dist;
        outOff++;
      } else {
        out[outOff * 2] = x2 + v[0] * miter;
        out[outOff * 2 + 1] = y2 + v[1] * miter;
        outOff++;
      }
    }
  }

  return indicesMap;
}

function offsetPolygon(vertices, holes, offset, miterLimit, close) {
  var offsetVertices = miterLimit != null ? [] : new Float32Array(vertices.length);
  var exteriorSize = holes && holes.length ? holes[0] : vertices.length / 2;
  innerOffsetPolygon(vertices, offsetVertices, 0, exteriorSize, 0, offset, miterLimit, close, false);

  if (holes) {
    for (var i = 0; i < holes.length; i++) {
      var start = holes[i];
      var end = holes[i + 1] || vertices.length / 2;
      innerOffsetPolygon(vertices, offsetVertices, start, end, miterLimit != null ? offsetVertices.length / 2 : start, offset, miterLimit, close);
    }
  }

  return offsetVertices;
}

function reversePoints(points, stride, start, end) {
  for (var i = 0; i < Math.floor((end - start) / 2); i++) {
    for (var j = 0; j < stride; j++) {
      var a = (i + start) * stride + j;
      var b = (end - i - 1) * stride + j;
      var tmp = points[a];
      points[a] = points[b];
      points[b] = tmp;
    }
  }

  return points;
}

function convertToClockwise(vertices, holes) {
  var polygonVertexCount = vertices.length / 2;
  var start = 0;
  var end = holes && holes.length ? holes[0] : polygonVertexCount;

  if (area$1(vertices, start, end) > 0) {
    reversePoints(vertices, 2, start, end);
  }

  for (var h = 1; h < (holes ? holes.length : 0) + 1; h++) {
    start = holes[h - 1];
    end = holes[h] || polygonVertexCount;

    if (area$1(vertices, start, end) < 0) {
      reversePoints(vertices, 2, start, end);
    }
  }
}

function normalizeOpts(opts) {
  opts.depth = opts.depth || 1;
  opts.bevelSize = opts.bevelSize || 0;
  opts.bevelSegments = opts.bevelSegments == null ? 2 : opts.bevelSegments;
  opts.smoothSide = opts.smoothSide || false;
  opts.smoothBevel = opts.smoothBevel || false;
  opts.simplify = opts.simplify || 0; // Normalize bevel options.

  if (typeof opts.depth === 'number') {
    opts.bevelSize = Math.min(!(opts.bevelSegments > 0) ? 0 : opts.bevelSize, opts.depth / 2);
  }

  if (!(opts.bevelSize > 0)) {
    opts.bevelSegments = 0;
  }

  opts.bevelSegments = Math.round(opts.bevelSegments);
  var boundingRect = opts.boundingRect;
  opts.translate = opts.translate || [0, 0];
  opts.scale = opts.scale || [1, 1];

  if (opts.fitRect) {
    var targetX = opts.fitRect.x == null ? boundingRect.x || 0 : opts.fitRect.x;
    var targetY = opts.fitRect.y == null ? boundingRect.y || 0 : opts.fitRect.y;
    var targetWidth = opts.fitRect.width;
    var targetHeight = opts.fitRect.height;

    if (targetWidth == null) {
      if (targetHeight != null) {
        targetWidth = targetHeight / boundingRect.height * boundingRect.width;
      } else {
        targetWidth = boundingRect.width;
        targetHeight = boundingRect.height;
      }
    } else if (targetHeight == null) {
      targetHeight = targetWidth / boundingRect.width * boundingRect.height;
    }

    opts.scale = [targetWidth / boundingRect.width, targetHeight / boundingRect.height];
    opts.translate = [(targetX - boundingRect.x) * opts.scale[0], (targetY - boundingRect.y) * opts.scale[1]];
  }
}

function generateNormal(indices, position) {
  function v3Set(p, a, b, c) {
    p[0] = a;
    p[1] = b;
    p[2] = c;
  }

  var p1 = [];
  var p2 = [];
  var p3 = [];
  var v21 = [];
  var v32 = [];
  var n = [];
  var len = indices.length;
  var normals = new Float32Array(position.length);

  for (var f = 0; f < len;) {
    var i1 = indices[f++] * 3;
    var i2 = indices[f++] * 3;
    var i3 = indices[f++] * 3;
    v3Set(p1, position[i1], position[i1 + 1], position[i1 + 2]);
    v3Set(p2, position[i2], position[i2 + 1], position[i2 + 2]);
    v3Set(p3, position[i3], position[i3 + 1], position[i3 + 2]);
    v3Sub(v21, p1, p2);
    v3Sub(v32, p2, p3);
    v3Cross(n, v21, v32); // Already be weighted by the triangle area

    for (var _i = 0; _i < 3; _i++) {
      normals[i1 + _i] = normals[i1 + _i] + n[_i];
      normals[i2 + _i] = normals[i2 + _i] + n[_i];
      normals[i3 + _i] = normals[i3 + _i] + n[_i];
    }
  }

  for (var i = 0; i < normals.length;) {
    v3Set(n, normals[i], normals[i + 1], normals[i + 2]);
    v3Normalize(n, n);
    normals[i++] = n[0];
    normals[i++] = n[1];
    normals[i++] = n[2];
  }

  return normals;
} // 0,0----1,0
// 0,1----1,1


var quadToTriangle = [[0, 0], [1, 0], [1, 1], [0, 0], [1, 1], [0, 1]]; // Add side vertices and indices. Include bevel.

function addExtrudeSide(out, _ref, start, end, cursors, opts) {
  var vertices = _ref.vertices,
      topVertices = _ref.topVertices,
      depth = _ref.depth,
      rect = _ref.rect;
  var ringVertexCount = end - start;
  var splitSide = opts.smoothSide ? 1 : 2;
  var splitRingVertexCount = ringVertexCount * splitSide;
  var splitBevel = opts.smoothBevel ? 1 : 2;
  var bevelSize = Math.min(depth / 2, opts.bevelSize);
  var bevelSegments = opts.bevelSegments;
  var vertexOffset = cursors.vertex;
  var size = Math.max(rect.width, rect.height, depth); // Side vertices

  if (bevelSize > 0) {
    var v0 = [0, 0, 1];
    var _v = [];
    var _v2 = [0, 0, -1];
    var _v3 = [];
    var ringCount = 0;
    var vLen = new Float32Array(ringVertexCount);

    for (var k = 0; k < 2; k++) {
      var z = k === 0 ? depth - bevelSize : bevelSize;

      for (var s = 0; s <= bevelSegments * splitBevel; s++) {
        var uLen = 0;
        var prevX = void 0;
        var prevY = void 0;

        for (var i = 0; i < ringVertexCount; i++) {
          for (var j = 0; j < splitSide; j++) {
            // TODO Cache and optimize
            var idx = ((i + j) % ringVertexCount + start) * 2;
            _v[0] = vertices[idx] - topVertices[idx];
            _v[1] = vertices[idx + 1] - topVertices[idx + 1];
            _v[2] = 0;
            var l = Math.sqrt(_v[0] * _v[0] + _v[1] * _v[1]);
            _v[0] /= l;
            _v[1] /= l;
            var t = (Math.floor(s / splitBevel) + s % splitBevel) / bevelSegments;
            k === 0 ? slerp(_v3, v0, _v, t) : slerp(_v3, _v, _v2, t);
            var t2 = k === 0 ? t : 1 - t;
            var a = bevelSize * Math.sin(t2 * Math.PI / 2);
            var b = l * Math.cos(t2 * Math.PI / 2); // ellipse radius

            var r = bevelSize * l / Math.sqrt(a * a + b * b);
            var x = _v3[0] * r + topVertices[idx];
            var y = _v3[1] * r + topVertices[idx + 1];
            var zz = _v3[2] * r + z;
            out.position[cursors.vertex * 3] = x;
            out.position[cursors.vertex * 3 + 1] = y;
            out.position[cursors.vertex * 3 + 2] = zz; // TODO Cache and optimize

            if (i > 0 || j > 0) {
              uLen += Math.sqrt((prevX - x) * (prevX - x) + (prevY - y) * (prevY - y));
            }

            if (s > 0 || k > 0) {
              var tmp = (cursors.vertex - splitRingVertexCount) * 3;
              var prevX2 = out.position[tmp];
              var prevY2 = out.position[tmp + 1];
              var prevZ2 = out.position[tmp + 2];
              vLen[i] += Math.sqrt((prevX2 - x) * (prevX2 - x) + (prevY2 - y) * (prevY2 - y) + (prevZ2 - zz) * (prevZ2 - zz));
            }

            out.uv[cursors.vertex * 2] = uLen / size;
            out.uv[cursors.vertex * 2 + 1] = vLen[i] / size;
            prevX = x;
            prevY = y;
            cursors.vertex++;
          }

          if (splitBevel > 1 && s % splitBevel || splitBevel === 1 && s >= 1) {
            for (var f = 0; f < 6; f++) {
              var m = (quadToTriangle[f][0] + i * splitSide) % splitRingVertexCount;
              var n = quadToTriangle[f][1] + ringCount;
              out.indices[cursors.index++] = (n - 1) * splitRingVertexCount + m + vertexOffset;
            }
          }
        }

        ringCount++;
      }
    }
  } else {
    for (var _k = 0; _k < 2; _k++) {
      var _z = _k === 0 ? depth - bevelSize : bevelSize;

      var _uLen = 0;

      var _prevX = void 0;

      var _prevY = void 0;

      for (var _i2 = 0; _i2 < ringVertexCount; _i2++) {
        for (var _m = 0; _m < splitSide; _m++) {
          var _idx = ((_i2 + _m) % ringVertexCount + start) * 2;

          var _x = vertices[_idx];
          var _y = vertices[_idx + 1];
          out.position[cursors.vertex * 3] = _x;
          out.position[cursors.vertex * 3 + 1] = _y;
          out.position[cursors.vertex * 3 + 2] = _z;

          if (_i2 > 0 || _m > 0) {
            _uLen += Math.sqrt((_prevX - _x) * (_prevX - _x) + (_prevY - _y) * (_prevY - _y));
          }

          out.uv[cursors.vertex * 2] = _uLen / size;
          out.uv[cursors.vertex * 2 + 1] = _z / size;
          _prevX = _x;
          _prevY = _y;
          cursors.vertex++;
        }
      }
    }
  } // Connect the side


  var sideStartRingN = bevelSize > 0 ? bevelSegments * splitBevel + 1 : 1;

  for (var _i3 = 0; _i3 < ringVertexCount; _i3++) {
    for (var _f = 0; _f < 6; _f++) {
      var _m2 = (quadToTriangle[_f][0] + _i3 * splitSide) % splitRingVertexCount;

      var _n = quadToTriangle[_f][1] + sideStartRingN;

      out.indices[cursors.index++] = (_n - 1) * splitRingVertexCount + _m2 + vertexOffset;
    }
  }
}

function addTopAndBottom(_ref2, out, cursors, opts) {
  var indices = _ref2.indices,
      vertices = _ref2.vertices,
      topVertices = _ref2.topVertices,
      rect = _ref2.rect,
      depth = _ref2.depth;

  if (vertices.length <= 4) {
    return;
  }

  var vertexOffset = cursors.vertex; // Top indices

  var indicesLen = indices.length;

  for (var i = 0; i < indicesLen; i++) {
    out.indices[cursors.index++] = vertexOffset + indices[i];
  }

  var size = Math.max(rect.width, rect.height); // Top and bottom vertices

  for (var k = 0; k < (opts.excludeBottom ? 1 : 2); k++) {
    for (var _i4 = 0; _i4 < topVertices.length; _i4 += 2) {
      var x = topVertices[_i4];
      var y = topVertices[_i4 + 1];
      out.position[cursors.vertex * 3] = x;
      out.position[cursors.vertex * 3 + 1] = y;
      out.position[cursors.vertex * 3 + 2] = (1 - k) * depth;
      out.uv[cursors.vertex * 2] = (x - rect.x) / size;
      out.uv[cursors.vertex * 2 + 1] = (y - rect.y) / size;
      cursors.vertex++;
    }
  } // Bottom indices


  if (!opts.excludeBottom) {
    var vertexCount = vertices.length / 2;

    for (var _i5 = 0; _i5 < indicesLen; _i5 += 3) {
      for (var _k2 = 0; _k2 < 3; _k2++) {
        out.indices[cursors.index++] = vertexOffset + vertexCount + indices[_i5 + 2 - _k2];
      }
    }
  }
}

function innerExtrudeTriangulatedPolygon(preparedData, opts) {
  var indexCount = 0;
  var vertexCount = 0;

  for (var p = 0; p < preparedData.length; p++) {
    var _preparedData$p = preparedData[p],
        indices = _preparedData$p.indices,
        vertices = _preparedData$p.vertices,
        holes = _preparedData$p.holes,
        depth = _preparedData$p.depth;
    var polygonVertexCount = vertices.length / 2;
    var bevelSize = Math.min(depth / 2, opts.bevelSize);
    var bevelSegments = !(bevelSize > 0) ? 0 : opts.bevelSegments;
    indexCount += indices.length * (opts.excludeBottom ? 1 : 2);
    vertexCount += polygonVertexCount * (opts.excludeBottom ? 1 : 2);
    var ringCount = 2 + bevelSegments * 2;
    var start = 0;
    var end = 0;

    for (var h = 0; h < (holes ? holes.length : 0) + 1; h++) {
      if (h === 0) {
        end = holes && holes.length ? holes[0] : polygonVertexCount;
      } else {
        start = holes[h - 1];
        end = holes[h] || polygonVertexCount;
      }

      indexCount += (end - start) * 6 * (ringCount - 1);
      var sideRingVertexCount = (end - start) * (opts.smoothSide ? 1 : 2);
      vertexCount += sideRingVertexCount * ringCount // Double the bevel vertex number if not smooth
      + (!opts.smoothBevel ? bevelSegments * sideRingVertexCount * 2 : 0);
    }
  }

  var data = {
    position: new Float32Array(vertexCount * 3),
    indices: new (vertexCount > 0xffff ? Uint32Array : Uint16Array)(indexCount),
    uv: new Float32Array(vertexCount * 2)
  };
  var cursors = {
    vertex: 0,
    index: 0
  };

  for (var d = 0; d < preparedData.length; d++) {
    addTopAndBottom(preparedData[d], data, cursors, opts);
  }

  for (var _d = 0; _d < preparedData.length; _d++) {
    var _preparedData$_d = preparedData[_d],
        _holes = _preparedData$_d.holes,
        _vertices = _preparedData$_d.vertices;
    var topVertexCount = _vertices.length / 2;
    var _start = 0;

    var _end = _holes && _holes.length ? _holes[0] : topVertexCount; // Add exterior


    addExtrudeSide(data, preparedData[_d], _start, _end, cursors, opts); // Add holes

    if (_holes) {
      for (var _h = 0; _h < _holes.length; _h++) {
        _start = _holes[_h];
        _end = _holes[_h + 1] || topVertexCount;
        addExtrudeSide(data, preparedData[_d], _start, _end, cursors, opts);
      }
    }
  } // Wrap uv


  for (var i = 0; i < data.uv.length; i++) {
    var val = data.uv[i];

    if (val > 0 && Math.round(val) === val) {
      data.uv[i] = 1;
    } else {
      data.uv[i] = val % 1;
    }
  }

  data.normal = generateNormal(data.indices, data.position); // PENDING

  data.boundingRect = preparedData[0] && preparedData[0].rect;
  return data;
}

function convertPolylineToTriangulatedPolygon(polyline, polylineIdx, opts) {
  var lineWidth = opts.lineWidth;
  var pointCount = polyline.length;
  var points = new Float32Array(pointCount * 2);
  var translate = opts.translate || [0, 0];
  var scale$$1 = opts.scale || [1, 1];

  for (var i = 0, k = 0; i < pointCount; i++) {
    points[k++] = polyline[i][0] * scale$$1[0] + translate[0];
    points[k++] = polyline[i][1] * scale$$1[1] + translate[1];
  }

  if (area$1(points, 0, pointCount) < 0) {
    reversePoints(points, 2, 0, pointCount);
  }

  var insidePoints = [];
  var outsidePoints = [];
  var miterLimit = opts.miterLimit;
  var outsideIndicesMap = innerOffsetPolygon(points, outsidePoints, 0, pointCount, 0, -lineWidth / 2, miterLimit, false);
  reversePoints(points, 2, 0, pointCount);
  var insideIndicesMap = innerOffsetPolygon(points, insidePoints, 0, pointCount, 0, -lineWidth / 2, miterLimit, false);
  var polygonVertexCount = (insidePoints.length + outsidePoints.length) / 2;
  var polygonVertices = new Float32Array(polygonVertexCount * 2);
  var offset = 0;
  var outsidePointCount = outsidePoints.length / 2;

  for (var _i6 = 0; _i6 < outsidePoints.length; _i6++) {
    polygonVertices[offset++] = outsidePoints[_i6];
  }

  for (var _i7 = 0; _i7 < insidePoints.length; _i7++) {
    polygonVertices[offset++] = insidePoints[_i7];
  } // Built indices


  var indices = new (polygonVertexCount > 0xffff ? Uint32Array : Uint16Array)(((pointCount - 1) * 2 + (polygonVertexCount - pointCount * 2)) * 3);
  var off = 0;

  for (var _i8 = 0; _i8 < pointCount - 1; _i8++) {
    var i2 = _i8 + 1;
    indices[off++] = outsidePointCount - 1 - outsideIndicesMap[_i8];
    indices[off++] = outsidePointCount - 1 - outsideIndicesMap[_i8] - 1;
    indices[off++] = insideIndicesMap[_i8] + 1 + outsidePointCount;
    indices[off++] = outsidePointCount - 1 - outsideIndicesMap[_i8];
    indices[off++] = insideIndicesMap[_i8] + 1 + outsidePointCount;
    indices[off++] = insideIndicesMap[_i8] + outsidePointCount;

    if (insideIndicesMap[i2] - insideIndicesMap[_i8] === 2) {
      indices[off++] = insideIndicesMap[_i8] + 2 + outsidePointCount;
      indices[off++] = insideIndicesMap[_i8] + 1 + outsidePointCount;
      indices[off++] = outsidePointCount - outsideIndicesMap[i2] - 1;
    } else if (outsideIndicesMap[i2] - outsideIndicesMap[_i8] === 2) {
      indices[off++] = insideIndicesMap[i2] + outsidePointCount;
      indices[off++] = outsidePointCount - 1 - (outsideIndicesMap[_i8] + 1);
      indices[off++] = outsidePointCount - 1 - (outsideIndicesMap[_i8] + 2);
    }
  }

  var topVertices = opts.bevelSize > 0 ? offsetPolygon(polygonVertices, [], opts.bevelSize, null, true) : polygonVertices;
  var boundingRect = opts.boundingRect;
  return {
    vertices: polygonVertices,
    indices: indices,
    topVertices: topVertices,
    rect: {
      x: boundingRect.x * scale$$1[0] + translate[0],
      y: boundingRect.y * scale$$1[1] + translate[1],
      width: boundingRect.width * scale$$1[0],
      height: boundingRect.height * scale$$1[1]
    },
    depth: typeof opts.depth === 'function' ? opts.depth(polylineIdx) : opts.depth,
    holes: []
  };
}

function removeClosePointsOfPolygon(polygon, epsilon) {
  var newPolygon = [];

  for (var k = 0; k < polygon.length; k++) {
    var points = polygon[k];
    var newPoints = [];
    var len = points.length;
    var x1 = points[len - 1][0];
    var y1 = points[len - 1][1];
    var dist = 0;

    for (var i = 0; i < len; i++) {
      var x2 = points[i][0];
      var y2 = points[i][1];
      var dx = x2 - x1;
      var dy = y2 - y1;
      dist += Math.sqrt(dx * dx + dy * dy);

      if (dist > epsilon) {
        newPoints.push(points[i]);
        dist = 0;
      }

      x1 = x2;
      y1 = y2;
    }

    if (newPoints.length >= 3) {
      newPolygon.push(newPoints);
    }
  }

  return newPolygon.length > 0 ? newPolygon : null;
}

function simplifyPolygon(polygon, tolerance) {
  var newPolygon = [];

  for (var k = 0; k < polygon.length; k++) {
    var points = polygon[k];
    points = simplify(points, tolerance, true);

    if (points.length >= 3) {
      newPolygon.push(points);
    }
  }

  return newPolygon.length > 0 ? newPolygon : null;
}
/**
 *
 * @param {Array} polygons Polygons array that match GeoJSON MultiPolygon geometry.
 * @param {Object} [opts]
 * @param {number|Function} [opts.depth]
 * @param {number} [opts.bevelSize = 0]
 * @param {number} [opts.bevelSegments = 2]
 * @param {number} [opts.simplify = 0]
 * @param {boolean} [opts.smoothSide = false]
 * @param {boolean} [opts.smoothBevel = false]
 * @param {boolean} [opts.excludeBottom = false]
 * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
 * @param {Array} [opts.translate]
 * @param {Array} [opts.scale]
 *
 * @return {Object} {indices, position, uv, normal, boundingRect}
 */


function extrudePolygon(polygons, opts) {
  opts = Object.assign({}, opts);
  var min = [Infinity, Infinity];
  var max = [-Infinity, -Infinity];

  for (var i = 0; i < polygons.length; i++) {
    updateBoundingRect(polygons[i][0], min, max);
  }

  opts.boundingRect = opts.boundingRect || {
    x: min[0],
    y: min[1],
    width: max[0] - min[0],
    height: max[1] - min[1]
  };
  normalizeOpts(opts);
  var preparedData = [];
  var translate = opts.translate || [0, 0];
  var scale$$1 = opts.scale || [1, 1];
  var boundingRect = opts.boundingRect;
  var transformdRect = {
    x: boundingRect.x * scale$$1[0] + translate[0],
    y: boundingRect.y * scale$$1[1] + translate[1],
    width: boundingRect.width * scale$$1[0],
    height: boundingRect.height * scale$$1[1]
  };
  var epsilon = Math.min(boundingRect.width, boundingRect.height) / 1e5;

  for (var _i9 = 0; _i9 < polygons.length; _i9++) {
    var newPolygon = removeClosePointsOfPolygon(polygons[_i9], epsilon);

    if (!newPolygon) {
      continue;
    }

    var simplifyTolerance = opts.simplify / Math.max(scale$$1[0], scale$$1[1]);

    if (simplifyTolerance > 0) {
      newPolygon = simplifyPolygon(newPolygon, simplifyTolerance);
    }

    if (!newPolygon) {
      continue;
    }

    var _earcut$flatten = earcut_1.flatten(newPolygon),
        vertices = _earcut$flatten.vertices,
        holes = _earcut$flatten.holes,
        dimensions = _earcut$flatten.dimensions;

    for (var k = 0; k < vertices.length;) {
      vertices[k] = vertices[k++] * scale$$1[0] + translate[0];
      vertices[k] = vertices[k++] * scale$$1[1] + translate[1];
    }

    convertToClockwise(vertices, holes);

    if (dimensions !== 2) {
      throw new Error('Only 2D polygon points are supported');
    }

    var topVertices = opts.bevelSize > 0 ? offsetPolygon(vertices, holes, opts.bevelSize, null, true) : vertices;
    var indices = triangulate(topVertices, holes, dimensions);
    preparedData.push({
      indices: indices,
      vertices: vertices,
      topVertices: topVertices,
      holes: holes,
      rect: transformdRect,
      depth: typeof opts.depth === 'function' ? opts.depth(_i9) : opts.depth
    });
  }

  return innerExtrudeTriangulatedPolygon(preparedData, opts);
}
/**
 *
 * @param {Array} polylines Polylines array that match GeoJSON MultiLineString geometry.
 * @param {Object} [opts]
 * @param {number} [opts.depth]
 * @param {number} [opts.bevelSize = 0]
 * @param {number} [opts.bevelSegments = 2]
 * @param {number} [opts.simplify = 0]
 * @param {boolean} [opts.smoothSide = false]
 * @param {boolean} [opts.smoothBevel = false]
 * @param {boolean} [opts.excludeBottom = false]
 * @param {boolean} [opts.lineWidth = 1]
 * @param {boolean} [opts.miterLimit = 2]
 * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
 * @param {Array} [opts.translate]
 * @param {Array} [opts.scale]
 * @param {Object} [opts.boundingRect]
 * @return {Object} {indices, position, uv, normal, boundingRect}
 */

function extrudePolyline(polylines, opts) {
  opts = Object.assign({}, opts);
  var min = [Infinity, Infinity];
  var max = [-Infinity, -Infinity];

  for (var i = 0; i < polylines.length; i++) {
    updateBoundingRect(polylines[i], min, max);
  }

  opts.boundingRect = opts.boundingRect || {
    x: min[0],
    y: min[1],
    width: max[0] - min[0],
    height: max[1] - min[1]
  };
  normalizeOpts(opts);
  var scale$$1 = opts.scale || [1, 1];

  if (opts.lineWidth == null) {
    opts.lineWidth = 1;
  }

  if (opts.miterLimit == null) {
    opts.miterLimit = 2;
  }

  var preparedData = []; // Extrude polyline to polygon

  for (var _i10 = 0; _i10 < polylines.length; _i10++) {
    var newPolyline = polylines[_i10];
    var simplifyTolerance = opts.simplify / Math.max(scale$$1[0], scale$$1[1]);

    if (simplifyTolerance > 0) {
      newPolyline = simplify(newPolyline, simplifyTolerance, true);
    }

    preparedData.push(convertPolylineToTriangulatedPolygon(newPolyline, _i10, opts));
  }

  return innerExtrudeTriangulatedPolygon(preparedData, opts);
}

function updateBoundingRect(points, min, max) {
  for (var i = 0; i < points.length; i++) {
    min[0] = Math.min(points[i][0], min[0]);
    min[1] = Math.min(points[i][1], min[1]);
    max[0] = Math.max(points[i][0], max[0]);
    max[1] = Math.max(points[i][1], max[1]);
  }
}

/* eslint-disable indent */
var TYPES = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

function getGeoJSONType(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var geometry = feature.geometry || {};
  return geometry.type;
}

function isGeoJSON(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var type = getGeoJSONType(feature);

  if (type) {
    for (var i = 0, len = TYPES.length; i < len; i++) {
      if (TYPES[i] === type) {
        return true;
      }
    }
  }

  return false;
}
function isGeoJSONPolygon(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var type = getGeoJSONType(feature);

  if (type && (type === TYPES[4] || type === TYPES[5])) {
    return true;
  }

  return false;
}
function isGeoJSONLine(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var type = getGeoJSONType(feature);

  if (type && (type === TYPES[2] || type === TYPES[3])) {
    return true;
  }

  return false;
}
function isGeoJSONPoint(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var type = getGeoJSONType(feature);

  if (type && (type === TYPES[0] || type === TYPES[1])) {
    return true;
  }

  return false;
}
function isGeoJSONMulti(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var type = getGeoJSONType(feature);

  if (type) {
    if (type.indexOf('Multi') > -1) {
      return true;
    }
  }

  return false;
}
function getGeoJSONCoordinates(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var geometry = feature.geometry || {};
  return geometry.coordinates || [];
}
function getGeoJSONCenter(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var type = getGeoJSONType(feature);

  if (!type) {
    return null;
  }

  var geometry = feature.geometry || {};
  var coordinates = geometry.coordinates;

  if (!coordinates) {
    return null;
  }

  var coords = [];

  switch (type) {
    case 'Point':
      {
        coords.push(coordinates);
        break;
      }

    case 'MultiPoint':
    case 'LineString':
      {
        for (var i = 0, len = coordinates.length; i < len; i++) {
          coords.push(coordinates[i]);
        }

        break;
      }

    case 'MultiLineString':
    case 'Polygon':
      {
        for (var _i = 0, _len = coordinates.length; _i < _len; _i++) {
          for (var j = 0, len1 = coordinates[_i].length; j < len1; j++) {
            coords.push(coordinates[_i][j]);
          }
        }

        break;
      }

    case 'MultiPolygon':
      {
        for (var _i2 = 0, _len2 = coordinates.length; _i2 < _len2; _i2++) {
          for (var _j = 0, _len3 = coordinates[_i2].length; _j < _len3; _j++) {
            for (var m = 0, len2 = coordinates[_i2][_j].length; m < len2; m++) {
              coords.push(coordinates[_i2][_j][m]);
            }
          }
        }

        break;
      }
  }

  var minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

  for (var _i3 = 0, _len4 = coords.length; _i3 < _len4; _i3++) {
    var c = coords[_i3];
    var x = c[0],
        y = c[1];
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  }

  return new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"]((minX + maxX) / 2, (minY + maxY) / 2);
}
function spliteGeoJSONMulti(feature) {
  if (feature === void 0) {
    feature = {};
  }

  var type = getGeoJSONType(feature);

  if (!type) {
    return null;
  }

  var geometry = feature.geometry || {};
  var properties = feature.properties || {};
  var coordinates = geometry.coordinates;

  if (!coordinates) {
    return null;
  }

  var features = [];
  var fType;

  switch (type) {
    case 'MultiPoint':
      {
        fType = 'Point';
        break;
      }

    case 'MultiLineString':
      {
        fType = 'LineString';
        break;
      }

    case 'MultiPolygon':
      {
        fType = 'Polygon';
        break;
      }
  }

  if (fType) {
    for (var i = 0, len = coordinates.length; i < len; i++) {
      features.push({
        type: 'Feature',
        geometry: {
          type: fType,
          coordinates: coordinates[i]
        },
        properties: properties
      });
    }
  } else {
    features.push(feature);
  }

  return features;
}

var COMMA = ',';
/**
 *
 * @param {maptalks.LineString} lineString
 * @param {ThreeLayer} layer
 */

function getLinePosition(lineString, layer, center) {
  var positions = [];
  var positionsV = [];

  if (Array.isArray(lineString) && lineString[0] instanceof three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]) {
    for (var i = 0, len = lineString.length; i < len; i++) {
      var v = lineString[i];
      positions.push(v.x, v.y, v.z);
      positionsV.push(v);
    }
  } else {
    if (Array.isArray(lineString)) {
      lineString = new maptalks__WEBPACK_IMPORTED_MODULE_0__["LineString"](lineString);
    }

    var z = 0; //support geojson

    var coordinates, cent;

    if (isGeoJSON(lineString)) {
      coordinates = getGeoJSONCoordinates(lineString);
      cent = getGeoJSONCenter(lineString);
    } else {
      coordinates = lineString.getCoordinates();
      cent = lineString.getCenter();
    }

    var centerPt = layer.coordinateToVector3(center || cent);

    for (var _i = 0, _len = coordinates.length; _i < _len; _i++) {
      var coordinate = coordinates[_i];

      if (Array.isArray(coordinate)) {
        coordinate = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"](coordinate);
      }

      var _v = layer.coordinateToVector3(coordinate, z).sub(centerPt);

      positions.push(_v.x, _v.y, _v.z);
      positionsV.push(_v);
    }
  }

  return {
    positions: positions,
    positionsV: positionsV
  };
}
/**
 *
 * @param {Array[Array]} chunkLines
 * @param {*} layer
 */

function getChunkLinesPosition(chunkLines, layer, positionMap, centerPt) {
  var positions = [],
      positionsV = [],
      lnglats = [];

  for (var i = 0, len = chunkLines.length; i < len; i++) {
    var line = chunkLines[i];

    for (var j = 0, len1 = line.length; j < len1; j++) {
      var lnglat = line[j];

      if (lnglats.length > 0) {
        var key = lnglat.join(COMMA).toString();
        var key1 = lnglats[lnglats.length - 1].join(COMMA).toString();

        if (key !== key1) {
          lnglats.push(lnglat);
        }
      } else {
        lnglats.push(lnglat);
      }
    }
  }

  var z = 0;

  for (var _i2 = 0, _len2 = lnglats.length; _i2 < _len2; _i2++) {
    var _lnglat = lnglats[_i2];
    var v = void 0;

    var _key = _lnglat.join(COMMA).toString();

    if (positionMap && positionMap[_key]) {
      v = positionMap[_key];
    } else {
      v = layer.coordinateToVector3(_lnglat, z).sub(centerPt);
    }

    positionsV.push(v);
    positions.push(v.x, v.y, v.z);
  }

  return {
    positions: positions,
    positionsV: positionsV,
    lnglats: lnglats
  };
}
/**
 *
 * @param {*} lineString
 * @param {*} lineWidth
 * @param {*} depth
 * @param {*} layer
 */

function getExtrudeLineParams(lineString, lineWidth, depth, layer, center) {
  if (lineWidth === void 0) {
    lineWidth = 1;
  }

  if (depth === void 0) {
    depth = 1;
  }

  var positions = getLinePosition(lineString, layer, center).positionsV;
  var ps = [];

  for (var i = 0, len = positions.length; i < len; i++) {
    var p = positions[i];
    ps.push([p.x, p.y]);
  }

  var _extrudePolyline2 = extrudePolyline([ps], {
    lineWidth: lineWidth,
    depth: depth
  }),
      indices = _extrudePolyline2.indices,
      position = _extrudePolyline2.position,
      normal = _extrudePolyline2.normal,
      uv = _extrudePolyline2.uv;

  return {
    position: position,
    normal: normal,
    indices: indices,
    uv: uv
  };
}
function LineStringSplit(lineString) {
  var lineStrings = [],
      center;

  if (lineString.getGeometries) {
    lineStrings = lineString.getGeometries();
    center = lineString.getCenter();
  } else if (lineString instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["LineString"]) {
    lineStrings.push(lineString);
    center = lineString.getCenter();
  } else if (isGeoJSON(lineString)) {
    center = getGeoJSONCenter(lineString);

    if (isGeoJSONMulti(lineString)) {
      lineStrings = spliteGeoJSONMulti(lineString);
    } else {
      lineStrings.push(lineString);
    }
  }

  return {
    lineStrings: lineStrings,
    center: center
  };
}

function initColors(cs) {
  var colors = [];

  if (cs && cs.length) {
    cs.forEach(function (color) {
      color = color instanceof three__WEBPACK_IMPORTED_MODULE_1__["Color"] ? color : new three__WEBPACK_IMPORTED_MODULE_1__["Color"](color);
      colors.push(color.r, color.g, color.b);
    });
  }

  return colors;
}

var OPTIONS$2 = {
  altitude: 0,
  colors: null
};
/**
 *
 */

var Line$1 = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(Line$$1, _BaseObject);

  function Line$$1(lineString, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$2, options, {
      layer: layer,
      lineString: lineString
    });
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    var _LineStringSplit = LineStringSplit(lineString),
        lineStrings = _LineStringSplit.lineStrings,
        center = _LineStringSplit.center;

    var ps = [];

    for (var i = 0, len = lineStrings.length; i < len; i++) {
      var _lineString = lineStrings[i];

      var _getLinePosition = getLinePosition(_lineString, layer, center),
          positionsV = _getLinePosition.positionsV;

      for (var j = 0, len1 = positionsV.length; j < len1; j++) {
        var _v = positionsV[j];

        if (j > 0 && j < len1 - 1) {
          ps.push(_v.x, _v.y, _v.z);
        }

        ps.push(_v.x, _v.y, _v.z);
      }
    }

    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
    addAttribute(geometry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](ps, 3));
    var colors = initColors(options.colors);

    if (colors && colors.length) {
      addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3));
      material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
    }

    _this._createLineSegments(geometry, material);

    var _options = options,
        altitude = _options.altitude;
    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v);

    return _this;
  }

  return Line$$1;
}(BaseObject$$1);

var OPTIONS$3 = {
  width: 3,
  height: 1,
  altitude: 0
};
/**
 *
 */

var ExtrudeLine = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(ExtrudeLine, _BaseObject);

  function ExtrudeLine(lineString, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$3, options, {
      layer: layer,
      lineString: lineString
    });
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    var _options = options,
        height = _options.height,
        width = _options.width;
    options.height = layer.distanceToVector3(height, height).x;
    options.width = layer.distanceToVector3(width, width).x;

    var _LineStringSplit = LineStringSplit(lineString),
        lineStrings = _LineStringSplit.lineStrings,
        center = _LineStringSplit.center;

    var extrudeParams = [];

    for (var i = 0, len = lineStrings.length; i < len; i++) {
      extrudeParams.push(getExtrudeLineParams(lineStrings[i], options.width, options.height, layer, center));
    }

    var geometry = mergeBufferGeometries(extrudeParams);

    _this._createMesh(geometry, material);

    var _options2 = options,
        altitude = _options2.altitude; // const center = (isGeoJSON(lineString) ? getGeoJSONCenter(lineString) : lineString.getCenter());

    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v);

    return _this;
  }

  return ExtrudeLine;
}(BaseObject$$1);

/**
 * this is for ExtrudeMesh util
 */

/**
 * Fix the bug in the center of multipoygon
 * @param {maptalks.Polygon} polygon
 * @param {*} layer
 */
// export function toShape(datas = []) {
//     const shapes = [];
//     for (let i = 0, len = datas.length; i < len; i++) {
//         const { outer, holes } = datas[i];
//         const shape = [outer];
//         if (holes && holes.length) {
//             for (let j = 0, len1 = holes.length; j < len1; j++) {
//                 shape.push(holes[j]);
//             }
//         }
//         shapes.push(shape);
//     }
//     return shapes;
// }

/**
 *  Support custom center point
 * @param {maptalks.Polygon|maptalks.MultiPolygon} polygon
 * @param {*} height
 * @param {*} layer
 */

function getExtrudeGeometry(polygon, height, layer, center) {
  var _getExtrudeGeometryPa = getExtrudeGeometryParams(polygon, height, layer, center),
      position = _getExtrudeGeometryPa.position,
      normal = _getExtrudeGeometryPa.normal,
      uv = _getExtrudeGeometryPa.uv,
      indices = _getExtrudeGeometryPa.indices;

  var color = new Float32Array(position.length);
  color.fill(1, 0, position.length);
  var bufferGeomertry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
  addAttribute(bufferGeomertry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](color, 3));
  addAttribute(bufferGeomertry, 'normal', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](normal, 3));
  addAttribute(bufferGeomertry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](position, 3));
  addAttribute(bufferGeomertry, 'uv', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](uv, 2));
  bufferGeomertry.setIndex(new three__WEBPACK_IMPORTED_MODULE_1__["Uint32BufferAttribute"](indices, 1));
  return bufferGeomertry;
}
function getExtrudeGeometryParams(polygon, height, layer, center, altCache) {
  var datas = getPolygonPositions(polygon, layer, center);
  var shapes = datas; //Possible later use of geojson

  if (!shapes) return null; //Reduce height and repeat calculation

  if (altCache) {
    if (altCache[height] == null) {
      altCache[height] = layer.distanceToVector3(height, height).x;
    }

    height = altCache[height];
  } else {
    height = layer.distanceToVector3(height, height).x;
  }

  var _extrudePolygon = extrudePolygon(shapes, {
    depth: height
  }),
      position = _extrudePolygon.position,
      normal = _extrudePolygon.normal,
      uv = _extrudePolygon.uv,
      indices = _extrudePolygon.indices;

  return {
    position: position,
    normal: normal,
    uv: uv,
    indices: indices
  };
}
/**
 *
 * @param {*} geometry
 * @param {*} color
 * @param {*} _topColor
 */

function initVertexColors$1(geometry, color, _topColor) {
  var position = geometry.attributes.position.array;
  var len = position.length;
  var bottomColor = color instanceof three__WEBPACK_IMPORTED_MODULE_1__["Color"] ? color : new three__WEBPACK_IMPORTED_MODULE_1__["Color"](color);
  var topColor = new three__WEBPACK_IMPORTED_MODULE_1__["Color"](_topColor);
  var colors = [];

  for (var i = 0; i < len; i += 3) {
    var z = position[i + 2];

    if (z > 0) {
      colors.push(topColor.r, topColor.g, topColor.b);
    } else {
      colors.push(bottomColor.r, bottomColor.g, bottomColor.b);
    }
  }

  addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
  return colors;
}
/**
 *Get the center point of the point set
 * @param {*} coordinates
 */

function getCenterOfPoints(coordinates) {
  if (coordinates === void 0) {
    coordinates = [];
  }

  var minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

  for (var i = 0, len = coordinates.length; i < len; i++) {
    var c = coordinates[i];
    var x = void 0,
        y = void 0;

    if (Array.isArray(c)) {
      x = c[0];
      y = c[1];
    } else if (c instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"]) {
      x = c.x;
      y = c.y;
    }

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  }

  return new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"]((minX + maxX) / 2, (minY + maxY) / 2);
}
/**
 *
 * @param {*} polygon
 * @param {*} layer
 * @param {*} center
 */

function getPolygonPositions(polygon, layer, center, isArrayBuff) {
  if (isArrayBuff === void 0) {
    isArrayBuff = false;
  }

  if (!polygon) {
    return null;
  }

  var datas = [];

  if (polygon instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["MultiPolygon"]) {
    datas = polygon.getGeometries().map(function (p) {
      return getSinglePolygonPositions(p, layer, center || polygon.getCenter(), isArrayBuff);
    });
  } else if (polygon instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Polygon"]) {
    var data = getSinglePolygonPositions(polygon, layer, center || polygon.getCenter(), isArrayBuff);
    datas.push(data);
  } else if (isGeoJSONPolygon(polygon)) {
    var cent = getGeoJSONCenter(polygon);

    if (!isGeoJSONMulti(polygon)) {
      var _data = getSinglePolygonPositions(polygon, layer, center || cent, isArrayBuff);

      datas.push(_data);
    } else {
      var fs = spliteGeoJSONMulti(polygon);

      for (var i = 0, len = fs.length; i < len; i++) {
        datas.push(getSinglePolygonPositions(fs[i], layer, center || cent, isArrayBuff));
      }
    }
  }

  return datas;
}
function getSinglePolygonPositions(polygon, layer, center, isArrayBuff) {
  if (isArrayBuff === void 0) {
    isArrayBuff = false;
  }

  var shell, holes; //it is pre for geojson,Possible later use of geojson

  if (isGeoJSONPolygon(polygon)) {
    var coordinates = getGeoJSONCoordinates(polygon);
    shell = coordinates[0];
    holes = coordinates.slice(1, coordinates.length);
    center = center || getGeoJSONCenter(polygon);
  } else {
    shell = polygon.getShell();
    holes = polygon.getHoles();
    center = center || polygon.getCenter();
  }

  var centerPt = layer.coordinateToVector3(center);
  var outer;

  if (isArrayBuff) {
    outer = new Float32Array(shell.length * 2);
  } else {
    outer = [];
  }

  for (var i = 0, len = shell.length; i < len; i++) {
    var c = shell[i];
    var v = layer.coordinateToVector3(c).sub(centerPt);

    if (isArrayBuff) {
      var idx = i * 2;
      outer[idx] = v.x;
      outer[idx + 1] = v.y; // outer[idx + 2] = v.z;
    } else {
      outer.push([v.x, v.y]);
    }
  }

  var data = [isArrayBuff ? outer.buffer : outer];

  if (holes && holes.length > 0) {
    for (var _i = 0, _len = holes.length; _i < _len; _i++) {
      var pts = isArrayBuff ? new Float32Array(holes[_i].length * 2) : [];

      for (var j = 0, len1 = holes[_i].length; j < len1; j++) {
        var _c = holes[_i][j];
        var pt = layer.coordinateToVector3(_c).sub(centerPt);

        if (isArrayBuff) {
          var _idx = j * 2;

          pts[_idx] = pt.x;
          pts[_idx + 1] = pt.y; // pts[idx + 2] = pt.z;
        } else {
          pts.push([pt.x, pt.y]);
        }
      }

      data.push(isArrayBuff ? pts.buffer : pts);
    }
  }

  return data;
}

var OPTIONS$4 = {
  altitude: 0,
  height: 1,
  topColor: null,
  bottomColor: '#2d2f61'
};
/**
 *
 */

var ExtrudePolygon = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(ExtrudePolygon, _BaseObject);

  function ExtrudePolygon(polygon, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$4, options, {
      layer: layer,
      polygon: polygon
    });
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    var _options = options,
        height = _options.height,
        topColor = _options.topColor,
        bottomColor = _options.bottomColor,
        altitude = _options.altitude;
    var geometry = getExtrudeGeometry(polygon, height, layer);
    var center = isGeoJSONPolygon(polygon) ? getGeoJSONCenter(polygon) : polygon.getCenter();

    if (topColor && !material.map) {
      initVertexColors$1(geometry, bottomColor, topColor);
      material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
    }

    _this._createMesh(geometry, material);

    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v);

    return _this;
  }

  return ExtrudePolygon;
}(BaseObject$$1);

var OPTIONS$5 = {
  altitude: 0,
  coordinate: null
};
/**
 * Model container
 */

var Model = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(Model, _BaseObject);

  function Model(model, options, layer) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    if (!options.coordinate) {
      console.warn('coordinate is null,it is important to locate the model');
      options.coordinate = layer.getMap().getCenter();
    }

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$5, options, {
      layer: layer,
      model: model
    });
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    _this._createGroup();

    _this.getObject3d().add(model);

    var _options = options,
        altitude = _options.altitude,
        coordinate = _options.coordinate;
    var z = layer.distanceToVector3(altitude, altitude).x;
    var position = layer.coordinateToVector3(coordinate, z);

    _this.getObject3d().position.copy(position);

    return _this;
  }

  return Model;
}(BaseObject$$1);

/**
 * provide a simple geo function
 */
var PI = Math.PI / 180;
var R = 6378137;
var MINLENGTH = 1;

function formatLineArray(polyline) {
  var lnglats = polyline.getCoordinates();
  return lnglats.map(function (lnglat) {
    return lnglat.toArray();
  });
}

function degreesToRadians(d) {
  return d * PI;
}

function distance(c1, c2) {
  if (!c1 || !c2) {
    return 0;
  }

  if (!Array.isArray(c1)) {
    c1 = c1.toArray();
  }

  if (!Array.isArray(c2)) {
    c2 = c2.toArray();
  }

  var b = degreesToRadians(c1[1]);
  var d = degreesToRadians(c2[1]),
      e = b - d,
      f = degreesToRadians(c1[0]) - degreesToRadians(c2[0]);
  b = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(e / 2), 2) + Math.cos(b) * Math.cos(d) * Math.pow(Math.sin(f / 2), 2)));
  b *= R;
  return Math.round(b * 1E5) / 1E5;
}

function getPercentLngLat(l, length) {
  var len = l.len,
      c1 = l.c1,
      c2 = l.c2;
  var dx = c2[0] - c1[0],
      dy = c2[1] - c1[1];
  var percent = length / len;
  var lng = c1[0] + percent * dx;
  var lat = c1[1] + percent * dy;
  return [lng, lat];
}
/**
 * This is not an accurate line segment cutting method, but rough, in order to speed up the calculation,
 * the correct cutting algorithm can be referred to. http://turfjs.org/docs/#lineChunk
 * @param {*} cs
 * @param {*} lineChunkLength
 */


function lineSlice(cs, lineChunkLength) {
  if (lineChunkLength === void 0) {
    lineChunkLength = 10;
  }

  lineChunkLength = Math.max(lineChunkLength, MINLENGTH);

  if (!Array.isArray(cs)) {
    cs = formatLineArray(cs);
  }

  var LEN = cs.length;
  var list = [];
  var totalLen = 0;

  for (var i = 0; i < LEN - 1; i++) {
    var len = distance(cs[i], cs[i + 1]);
    var floorlen = Math.floor(len);
    list.push({
      c1: cs[i],
      len: floorlen,
      c2: cs[i + 1]
    });
    totalLen += floorlen;
  }

  if (totalLen <= lineChunkLength) {
    var lnglats = list.map(function (d) {
      return [d.c1, d.c2];
    });
    return lnglats;
  }

  if (list.length === 1) {
    if (list[0].len <= lineChunkLength) {
      return [[list[0].c1, list[0].c2]];
    }
  }

  var LNGLATSLEN = list.length;
  var first = list[0];
  var idx = 0;
  var currentLngLat;
  var currentLen = 0;
  var lines = [];
  var lls = [first.c1];

  while (idx < LNGLATSLEN) {
    var _list$idx = list[idx],
        _len = _list$idx.len,
        c2 = _list$idx.c2;
    currentLen += _len;

    if (currentLen < lineChunkLength) {
      lls.push(c2);

      if (idx === LNGLATSLEN - 1) {
        lines.push(lls);
      }

      idx++;
    }

    if (currentLen === lineChunkLength) {
      lls.push(c2);
      currentLen = 0;
      lines.push(lls); //next

      lls = [c2];
      idx++;
    }

    if (currentLen > lineChunkLength) {
      var offsetLen = _len - currentLen + lineChunkLength;
      currentLngLat = getPercentLngLat(list[idx], offsetLen);
      lls.push(currentLngLat);
      lines.push(lls);
      currentLen = 0;
      list[idx].c1 = currentLngLat;
      list[idx].len = _len - offsetLen; //next

      lls = [];
      lls.push(currentLngLat);
    }
  }

  return lines;
}

var MAX_POINTS = 1000;
/**
 *
 * @param {THREE.BufferGeometry} geometry
 * @param {*} ps
 * @param {*} norls
 * @param {*} indices
 */

function setExtrudeLineGeometryAttribute(geometry, ps, norls, indices) {
  var len = ps.length;
  geometry.attributes.normal.count = len;
  geometry.attributes.position.count = len;
  var positions = geometry.attributes.position.array;
  var normals = geometry.attributes.normal.array;

  for (var i = 0; i < len; i++) {
    positions[i] = ps[i];
    normals[i] = norls[i];
  } // geometry.index.array = new Uint16Array(indices.length);


  geometry.index.count = indices.length; // geometry.index.needsUpdate = true;

  for (var _i = 0, len1 = indices.length; _i < len1; _i++) {
    geometry.index.array[_i] = indices[_i];
  } // geometry.setIndex(new THREE.Uint32BufferAttribute(indices, 1));
  // geometry.setDrawRange(0, len / 3);

}

var OPTIONS$6 = {
  trail: 5,
  chunkLength: 50,
  width: 2,
  height: 1,
  speed: 1,
  altitude: 0,
  interactive: false
};
/**
 *
 */

var ExtrudeLineTrail = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(ExtrudeLineTrail, _BaseObject);

  function ExtrudeLineTrail(lineString, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$6, options, {
      layer: layer,
      lineString: lineString
    });
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    var _options = options,
        width = _options.width,
        height = _options.height,
        altitude = _options.altitude,
        speed = _options.speed,
        chunkLength = _options.chunkLength,
        trail = _options.trail;
    var center, coordinates;

    if (isGeoJSON(lineString)) {
      center = getGeoJSONCenter(lineString);
      coordinates = getGeoJSONCoordinates(lineString);
    } else {
      center = lineString.getCenter();
      coordinates = lineString;
    }

    var chunkLines = lineSlice(coordinates, chunkLength);
    var centerPt = layer.coordinateToVector3(lineString.getCenter()); //cache position for  faster computing,reduce double counting

    var positionMap = {};

    for (var i = 0, len = chunkLines.length; i < len; i++) {
      var chunkLine = chunkLines[i];

      for (var j = 0, len1 = chunkLine.length; j < len1; j++) {
        var lnglat = chunkLine[j];
        var key = lnglat.join(',').toString();

        if (!positionMap[key]) {
          positionMap[key] = layer.coordinateToVector3(lnglat).sub(centerPt);
        }
      }
    }

    var positions = getChunkLinesPosition(chunkLines.slice(0, 1), layer, positionMap, centerPt).positionsV; //generate geometry

    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
    var ps = new Float32Array(MAX_POINTS * 3); // 3 vertices per point

    var norls = new Float32Array(MAX_POINTS * 3); // 3 vertices per point

    var inds = new Uint16Array(MAX_POINTS);
    addAttribute(geometry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](ps, 3));
    addAttribute(geometry, 'normal', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](norls, 3));
    geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](inds, 1));
    var lineWidth = layer.distanceToVector3(width, width).x;
    var depth = layer.distanceToVector3(height, height).x;
    var params = getExtrudeLineParams(positions, lineWidth, depth, layer);
    setExtrudeLineGeometryAttribute(geometry, params.position, params.normal, params.indices);

    _this._createMesh(geometry, material);

    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v);

    _this._params = {
      index: 0,
      chunkLines: chunkLines,
      geometries: [],
      layer: layer,
      trail: Math.max(1, trail),
      lineWidth: lineWidth,
      depth: depth,
      speed: Math.min(1, speed),
      idx: 0,
      loaded: false,
      positionMap: positionMap,
      centerPt: centerPt
    };

    _this._init(_this._params);

    return _this;
  }
  /**
   * Follow-up support for adding webworker
   * @param {*} params
   */


  var _proto = ExtrudeLineTrail.prototype;

  _proto._init = function _init(params) {
    var layer = params.layer,
        trail = params.trail,
        lineWidth = params.lineWidth,
        depth = params.depth,
        chunkLines = params.chunkLines,
        positionMap = params.positionMap,
        centerPt = params.centerPt;
    var len = chunkLines.length,
        geometries = [];

    for (var i = 0; i < len; i++) {
      var lines = chunkLines.slice(i, i + trail);
      var ps = getChunkLinesPosition(lines, layer, positionMap, centerPt).positionsV;
      geometries.push(getExtrudeLineParams(ps, lineWidth, depth, layer));
    }

    this._params.geometries = geometries;
    this._params.loaded = true;
  };

  _proto._animation = function _animation() {
    var _this$_params = this._params,
        index = _this$_params.index,
        geometries = _this$_params.geometries,
        speed = _this$_params.speed,
        idx = _this$_params.idx,
        chunkLines = _this$_params.chunkLines,
        trail = _this$_params.trail,
        lineWidth = _this$_params.lineWidth,
        depth = _this$_params.depth,
        loaded = _this$_params.loaded,
        layer = _this$_params.layer,
        positionMap = _this$_params.positionMap,
        centerPt = _this$_params.centerPt;
    if (!loaded) return;
    var i = Math.round(index);

    if (i > idx) {
      this._params.idx++;
      var p = geometries[i]; //if not init, this is will running

      if (!p) {
        var lines = chunkLines.slice(i, i + trail);
        var ps = getChunkLinesPosition(lines, layer, positionMap, centerPt).positionsV;
        p = getExtrudeLineParams(ps, lineWidth, depth, layer);
        geometries[i] = p;
      }

      setExtrudeLineGeometryAttribute(this.getObject3d().geometry, p.position, p.normal, p.indices);
      this.getObject3d().geometry.attributes.position.needsUpdate = true;
      this.getObject3d().geometry.attributes.normal.needsUpdate = true;
      this.getObject3d().geometry.index.needsUpdate = true;
    }

    if (index >= chunkLines.length - 1) {
      this._params.index = -1;
      this._params.idx = -1;
    }

    this._params.index += speed;
  };

  return ExtrudeLineTrail;
}(BaseObject$$1);

var EVENTS = ['click', 'mousemove', 'mousedown', 'mouseup', 'dblclick', 'contextmenu'].join(' ').toString();
/**
 * This is for the merger, MergedExtrudeMesh,Points ...
 * @param {*} Base
 */

var MergedMixin = function MergedMixin(Base) {
  return /*#__PURE__*/function (_Base) {
    _inheritsLoose(_class, _Base);

    function _class() {
      return _Base.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    // this._faceMap=[];
    // this._baseObjects = [];
    // this._datas = [];
    // this.faceIndex = null;
    // this.index=null;
    // this._geometriesAttributes = [];
    // this._geometryCache = geometry.clone();
    // this.isHide = false;

    /**
     *
     * @param {*} baseObjects
     */
    _proto._initBaseObjectsEvent = function _initBaseObjectsEvent(baseObjects) {
      if (baseObjects && Array.isArray(baseObjects) && baseObjects.length) {
        for (var i = 0, len = baseObjects.length; i < len; i++) {
          var baseObject = baseObjects[i];

          this._proxyEvent(baseObject);
        }
      }

      return this;
    }
    /**
     *Events representing the merge
     * @param {*} baseObject
     */
    ;

    _proto._proxyEvent = function _proxyEvent(baseObject) {
      var _this = this;

      baseObject.on('add', function (e) {
        _this._showGeometry(e.target, true);
      });
      baseObject.on('remove', function (e) {
        _this._showGeometry(e.target, false);
      });
      baseObject.on('mouseout', function (e) {
        _this._mouseover = false;

        _this.fire('mouseout', Object.assign({}, e, {
          target: _this,
          selectMesh: _this.getSelectMesh ? _this.getSelectMesh() : null
        })); // this._showGeometry(e.target, false);

      });
      baseObject.on(EVENTS, function (e) {
        _this.fire(e.type, Object.assign({}, e, {
          target: _this,
          selectMesh: _this.getSelectMesh ? _this.getSelectMesh() : null
        }));
      });
    }
    /**
     * Get the index of the monomer to be hidden
     * @param {*} attribute
     */
    ;

    _proto._getHideGeometryIndex = function _getHideGeometryIndex(attribute) {
      var indexs = [];
      var count = 0;

      for (var i = 0, len = this._geometriesAttributes.length; i < len; i++) {
        if (this._geometriesAttributes[i].hide === true) {
          indexs.push(i);
          count += this._geometriesAttributes[i][attribute].count;
        }
      }

      return {
        indexs: indexs,
        count: count
      };
    }
    /**
     * update geometry attributes
     * @param {*} bufferAttribute
     * @param {*} attribute
     */
    ;

    _proto._updateAttribute = function _updateAttribute(bufferAttribute, attribute) {
      var _this$_getHideGeometr = this._getHideGeometryIndex(attribute),
          indexs = _this$_getHideGeometr.indexs;

      var array = this._geometryCache.attributes[attribute].array;
      var len = array.length;

      for (var i = 0; i < len; i++) {
        bufferAttribute.array[i] = array[i];
      }

      var value = NaN;

      if (this.getObject3d() instanceof three__WEBPACK_IMPORTED_MODULE_1__["LineSegments"]) {
        value = 0;
      }

      for (var j = 0; j < indexs.length; j++) {
        var index = indexs[j];
        var _this$_geometriesAttr = this._geometriesAttributes[index][attribute],
            start = _this$_geometriesAttr.start,
            end = _this$_geometriesAttr.end;

        for (var _i = start; _i < end; _i++) {
          bufferAttribute.array[_i] = value;
        }
      }

      return this;
    }
    /**
     * show or hide monomer
     * @param {*} baseObject
     * @param {*} isHide
     */
    ;

    _proto._showGeometry = function _showGeometry(baseObject, isHide) {
      var index;

      if (baseObject) {
        index = baseObject.getOptions().index;
      }

      if (index != null) {
        var geometryAttributes = this._geometriesAttributes[index];
        var hide = geometryAttributes.hide;

        if (hide === isHide) {
          return this;
        }

        geometryAttributes.hide = isHide;
        var buffGeom = this.getObject3d().geometry;

        this._updateAttribute(buffGeom.attributes.position, 'position'); // this._updateAttribute(buffGeom.attributes.normal, 'normal', 3);
        // this._updateAttribute(buffGeom.attributes.color, 'color', 3);
        // this._updateAttribute(buffGeom.attributes.uv, 'uv', 2);


        buffGeom.attributes.position.needsUpdate = true; // buffGeom.attributes.color.needsUpdate = true;
        // buffGeom.attributes.normal.needsUpdate = true;
        // buffGeom.attributes.uv.needsUpdate = true;

        this.isHide = isHide;
      }

      return this;
    }
    /**
     * Get selected monomer
     */
    ;

    _proto.getSelectMesh = function getSelectMesh() {
      return {
        data: null,
        baseObject: null
      };
    };

    return _class;
  }(Base);
};

var name = "maptalks.three";
var version = "0.12.3";
var description = "A maptalks Layer to render with THREE.js.";
var license = "MIT";
var repository = {
	type: "git",
	url: "https://github.com/maptalks/maptalks.three.js.git"
};
var files = [
	"dist/maptalks.three.js",
	"dist/maptalks.three.min.js",
	"dist/maptalks.three.es.js",
	"dist/maptalks.three.js.map"
];
var main = "dist/maptalks.three.js";
var module$1 = "dist/maptalks.three.es.js";
var scripts = {
	dev: "rollup -w -c rollup.config.js",
	build: "rollup --environment BUILD:production -c rollup.config.js",
	"build-dev": "rollup -c rollup.config.js",
	preversion: "npm run lint",
	version: "npm run build && git add -A dist",
	lint: "eslint index.js src/**/*.js test/**/*.js",
	prepublish: "npm run lint && npm run build"
};
var devDependencies = {
	"@babel/core": "^7.0.0",
	"@babel/preset-env": "^7.0.0",
	"babel-eslint": "^9.0.0",
	eslint: "^4.19.1",
	"eslint-config-maptalks": "^0.3.0",
	"eslint-plugin-mocha": "^5.0.0",
	rollup: "^0.66.1",
	"rollup-plugin-babel": "^4.1.0-0",
	"rollup-plugin-commonjs": "^9.1.0",
	"rollup-plugin-json": "^4.0.0",
	"rollup-plugin-node-resolve": "^3.3.0",
	"rollup-plugin-uglify": "^6.0.0",
	three: "^0.97.0"
};
var peerDependencies = {
	maptalks: ">=0.39.0"
};
var dependencies = {
	"deyihu-geometry-extrude": "^0.1.3"
};
var pkg = {
	name: name,
	version: version,
	description: description,
	license: license,
	repository: repository,
	files: files,
	main: main,
	module: module$1,
	"jsnext:main": "dist/maptalks.three.es.js",
	scripts: scripts,
	devDependencies: devDependencies,
	peerDependencies: peerDependencies,
	dependencies: dependencies
};

var MeshActor;

if (maptalks__WEBPACK_IMPORTED_MODULE_0__["worker"]) {
  MeshActor = /*#__PURE__*/function (_maptalks$worker$Acto) {
    _inheritsLoose(MeshActor, _maptalks$worker$Acto);

    function MeshActor() {
      return _maptalks$worker$Acto.apply(this, arguments) || this;
    }

    var _proto = MeshActor.prototype;

    _proto.test = function test(info, cb) {
      //send data to worker thread
      this.send(info, null, cb);
    };

    _proto.pushQueue = function pushQueue(q) {
      if (q === void 0) {
        q = {};
      }

      var _q = q,
          type = _q.type,
          data = _q.data,
          callback = _q.callback,
          layer = _q.layer,
          key = _q.key,
          center = _q.center;
      var params;

      if (type === 'Polygon') {
        params = gengerateExtrudePolygons(data, center, layer);
      }

      this.send({
        type: type,
        datas: params.datas
      }, params.transfe, function (err, message) {
        if (err) {
          console.error(err);
        }

        message.key = key;
        callback(message);
      });
    } // eslint-disable-next-line no-unused-vars
    // receive(message) {
    //     console.log(message);
    // }
    ;

    return MeshActor;
  }(maptalks__WEBPACK_IMPORTED_MODULE_0__["worker"].Actor);
}

var actor;
function getActor() {
  if (!maptalks__WEBPACK_IMPORTED_MODULE_0__["worker"]) {
    console.error('maptalks.worker is not defined,You can\'t use ThreeVectorTileLayer');
  }

  if (!actor) {
    actor = new MeshActor(pkg.name);
  }

  return actor;
}
/**
 * generate extrudepolygons data for worker
 * @param {*} polygons
 * @param {*} layer
 */

function gengerateExtrudePolygons(polygons, center, layer) {
  if (polygons === void 0) {
    polygons = [];
  }

  var len = polygons.length;
  var datas = [],
      transfer = [],
      altCache = {};

  for (var i = 0; i < len; i++) {
    var polygon = polygons[i];
    var data = getPolygonPositions(polygon, layer, center, true);

    for (var j = 0, len1 = data.length; j < len1; j++) {
      var d = data[j];

      for (var m = 0, len2 = d.length; m < len2; m++) {
        //ring
        transfer.push(d[m]);
      }
    }

    var height = (isGeoJSONPolygon(polygon) ? polygon.properties : polygon.getProperties() || {}).height || 1;

    if (altCache[height] == null) {
      altCache[height] = layer.distanceToVector3(height, height).x;
    }

    height = altCache[height];
    datas.push({
      data: data,
      height: height
    });
  }

  return {
    datas: datas,
    transfer: transfer
  };
}

function updateAttribute(data) {
  //arraybuffer data
  var position = data.position,
      normal = data.normal,
      uv = data.uv,
      indices = data.indices;
  var color = new Float32Array(position.length);
  color.fill(1, 0, position.length);
  var bufferGeomertry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
  addAttribute(bufferGeomertry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](color, 3));
  addAttribute(bufferGeomertry, 'normal', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](new Float32Array(normal), 3));
  addAttribute(bufferGeomertry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](new Float32Array(position), 3));
  addAttribute(bufferGeomertry, 'uv', new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](new Float32Array(uv), 2));
  bufferGeomertry.setIndex(new three__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](new Uint32Array(indices), 1));
  return bufferGeomertry;
}

var OPTIONS$7 = {
  altitude: 0,
  height: 1,
  topColor: null,
  bottomColor: '#2d2f61'
};

var ExtrudePolygons = /*#__PURE__*/function (_MergedMixin) {
  _inheritsLoose(ExtrudePolygons, _MergedMixin);

  function ExtrudePolygons(polygons, options, material, layer) {
    var _this;

    if (!Array.isArray(polygons)) {
      polygons = [polygons];
    }

    var len = polygons.length;

    if (len === 0) {
      console.error('polygons is empty');
    } // const centers = [];


    var minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    for (var i = 0; i < len; i++) {
      var polygon = polygons[i];

      var _center = polygon.getCenter ? polygon.getCenter() : getGeoJSONCenter(polygon);

      var x = void 0,
          y = void 0;

      if (Array.isArray(_center)) {
        x = _center[0];
        y = _center[1];
      } else if (_center instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"]) {
        x = _center.x;
        y = _center.y;
      }

      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    } // Get the center point of the point set


    var center = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"]((minX + maxX) / 2, (minY + maxY) / 2);
    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$7, options, {
      layer: layer,
      polygons: polygons,
      coordinate: center
    });
    var _options = options,
        topColor = _options.topColor,
        bottomColor = _options.bottomColor,
        altitude = _options.altitude,
        asynchronous = _options.asynchronous;
    var bufferGeometry;
    var extrudePolygons = [],
        faceMap = [],
        geometriesAttributes = [];

    if (asynchronous) {
      var actor = getActor();
      var SIZE = 0.000001;
      bufferGeometry = new three__WEBPACK_IMPORTED_MODULE_1__["BoxBufferGeometry"](SIZE, SIZE, SIZE * 5);
      actor.pushQueue({
        type: 'Polygon',
        layer: layer,
        key: options.key,
        center: center,
        data: polygons,
        callback: function callback(e) {
          var faceMap = e.faceMap,
              geometriesAttributes = e.geometriesAttributes;
          _this._faceMap = faceMap;
          _this._geometriesAttributes = geometriesAttributes;
          var bufferGeometry = updateAttribute(e);

          if (topColor && !material.map) {
            initVertexColors$1(bufferGeometry, bottomColor, topColor);
            material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
          }

          _this.getObject3d().geometry.dispose();

          _this.getObject3d().geometry = bufferGeometry;
          _this.getObject3d().material.needsUpdate = true;
          _this._geometryCache = bufferGeometry.clone();

          _this._fire('workerload', {
            target: _assertThisInitialized(_this)
          });
        }
      });
    } else {
      var geometries = [];
      var faceIndex = 0,
          psIndex = 0,
          normalIndex = 0,
          uvIndex = 0;
      var altCache = {};

      for (var _i = 0; _i < len; _i++) {
        var _polygon = polygons[_i];
        var height = (isGeoJSONPolygon(_polygon) ? _polygon.properties : _polygon.getProperties() || {}).height || 1;
        var buffGeom = getExtrudeGeometryParams(_polygon, height, layer, center, altCache);
        geometries.push(buffGeom); // const extrudePolygon = new ExtrudePolygon(polygon, Object.assign({}, options, { height, index: i }), material, layer);
        // extrudePolygons.push(extrudePolygon);

        var position = buffGeom.position,
            normal = buffGeom.normal,
            uv = buffGeom.uv,
            indices = buffGeom.indices;
        var faceLen = indices.length / 3;
        faceMap[_i] = [faceIndex + 1, faceIndex + faceLen];
        faceIndex += faceLen;
        var psCount = position.length / 3,
            //  colorCount = buffGeom.attributes.color.count,
        normalCount = normal.length / 3,
            uvCount = uv.length / 2;
        geometriesAttributes[_i] = {
          position: {
            count: psCount,
            start: psIndex,
            end: psIndex + psCount * 3
          },
          normal: {
            count: normalCount,
            start: normalIndex,
            end: normalIndex + normalCount * 3
          },
          // color: {
          //     count: colorCount,
          //     start: colorIndex,
          //     end: colorIndex + colorCount * 3,
          // },
          uv: {
            count: uvCount,
            start: uvIndex,
            end: uvIndex + uvCount * 2
          },
          hide: false
        };
        psIndex += psCount * 3;
        normalIndex += normalCount * 3; // colorIndex += colorCount * 3;

        uvIndex += uvCount * 2;
      }

      bufferGeometry = mergeBufferGeometries(geometries);

      if (topColor && !material.map) {
        initVertexColors$1(bufferGeometry, bottomColor, topColor);
        material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
      }
    }

    _this = _MergedMixin.call(this) || this;

    _this._initOptions(options);

    _this._createMesh(bufferGeometry, material);

    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v); //Face corresponding to monomer


    _this._faceMap = faceMap;
    _this._baseObjects = extrudePolygons;
    _this._datas = polygons;
    _this._geometriesAttributes = geometriesAttributes;
    _this.faceIndex = null;
    _this._geometryCache = bufferGeometry.clone();
    _this.isHide = false;

    _this._initBaseObjectsEvent(extrudePolygons);

    return _this;
  } // eslint-disable-next-line consistent-return


  var _proto = ExtrudePolygons.prototype;

  _proto.getSelectMesh = function getSelectMesh() {
    var index = this._getIndex();

    if (index != null) {
      if (!this._baseObjects[index]) {
        var polygon = this._datas[index];
        var opts = Object.assign({}, this.options, isGeoJSONPolygon(polygon) ? polygon.properties : polygon.getProperties(), {
          index: index
        });
        this._baseObjects[index] = new ExtrudePolygon(polygon, opts, this.getObject3d().material, this.getLayer());

        this._proxyEvent(this._baseObjects[index]);
      }

      return {
        data: this._datas[index],
        baseObject: this._baseObjects[index]
      };
    }
  } // eslint-disable-next-line consistent-return
  ;

  _proto._getIndex = function _getIndex(faceIndex) {
    if (faceIndex == null) {
      faceIndex = this.faceIndex;
    }

    if (faceIndex != null) {
      for (var i = 0, _len = this._faceMap.length; i < _len; i++) {
        var _this$_faceMap$i = this._faceMap[i],
            start = _this$_faceMap$i[0],
            end = _this$_faceMap$i[1];

        if (start <= faceIndex && faceIndex < end) {
          return i;
        }
      }
    }
  };

  return ExtrudePolygons;
}(MergedMixin(BaseObject$$1));

/* eslint-disable indent */

function vector2Pixel(world_vector, size, camera) {
  // eslint-disable-next-line camelcase
  var vector = world_vector.project(camera);
  var halfWidth = size.width / 2;
  var halfHeight = size.height / 2;
  var result = {
    x: Math.round(vector.x * halfWidth + halfWidth),
    y: Math.round(-vector.y * halfHeight + halfHeight)
  };
  return result;
}

var OPTIONS$8 = {
  altitude: 0,
  height: 0
};
var vector = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

var Point = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(Point, _BaseObject);

  function Point(coordinate, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$8, options, {
      layer: layer,
      coordinate: coordinate
    });
    _this = _BaseObject.call(this) || this;
    var _options = options,
        height = _options.height,
        altitude = _options.altitude,
        color = _options.color;
    var vs = [],
        colors = [];

    if (color) {
      color = color instanceof three__WEBPACK_IMPORTED_MODULE_1__["Color"] ? color : new three__WEBPACK_IMPORTED_MODULE_1__["Color"](color);
      colors.push(color.r, color.g, color.b);
    }

    var z = layer.distanceToVector3(height, height).x;
    var v = layer.coordinateToVector3(coordinate, z);
    vs.push(0, 0, v.z);
    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
    addAttribute(geometry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](vs, 3, true));

    if (colors.length) {
      addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
    }

    options.positions = v;

    _this._initOptions(options);

    _this._createPoints(geometry, material);

    var z1 = layer.distanceToVector3(altitude, altitude).x;
    var v1 = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](v.x, v.y, z1);

    _this.getObject3d().position.copy(v1);

    return _this;
  }
  /**
   *
   * @param {maptalks.Coordinate} coordinate
   */


  var _proto = Point.prototype;

  _proto.identify = function identify(coordinate) {
    var layer = this.getLayer(),
        size = this.getMap().getSize(),
        camera = this.getLayer().getCamera(),
        positions = this.getOptions().positions,
        altitude = this.getOptions().altitude; //Size of points

    var pointSize = this.getObject3d().material.size;
    var pixel = this.getMap().coordToContainerPoint(coordinate);
    var z = layer.distanceToVector3(altitude, altitude).x;
    vector.x = positions.x;
    vector.y = positions.y;
    vector.z = positions.z + z; //3D vector to screen coordinates

    var p = vector2Pixel(vector, size, camera); //Distance between two points

    var distance = Math.sqrt(Math.pow(pixel.x - p.x, 2) + Math.pow(pixel.y - p.y, 2));

    if (distance <= pointSize / 2) {
      return true;
    }

    return false;
  };

  return Point;
}(BaseObject$$1);

var ROW = 30,
    COL = 30;

function contains(b, p) {
  var minx = b.minx,
      miny = b.miny,
      maxx = b.maxx,
      maxy = b.maxy;
  var x = p[0],
      y = p[1];

  if (minx <= x && x <= maxx && miny <= y && y <= maxy) {
    return true;
  }

  return false;
}

var BBox = /*#__PURE__*/function () {
  function BBox(minlng, minlat, maxlng, maxlat) {
    this.minlng = minlng;
    this.minlat = minlat;
    this.maxlng = maxlng;
    this.maxlat = maxlat;
    this.minx = Infinity;
    this.miny = Infinity;
    this.maxx = -Infinity;
    this.maxy = -Infinity;
    this.coordinates = [];
    this.positions = [];
    this.indexs = [];
    this.key = null;
  }
  /**
   *
   * @param {*} map
   */


  var _proto = BBox.prototype;

  _proto.updateBBoxPixel = function updateBBoxPixel(map) {
    var minx = Infinity,
        miny = Infinity,
        maxx = -Infinity,
        maxy = -Infinity;
    var minlng = this.minlng,
        minlat = this.minlat,
        maxlng = this.maxlng,
        maxlat = this.maxlat;
    [[minlng, minlat], [minlng, maxlat], [maxlng, minlat], [maxlng, maxlat]].map(function (lnglat) {
      return new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"](lnglat);
    }).map(function (coordinate) {
      return map.coordToContainerPoint(coordinate);
    }).forEach(function (pixel) {
      minx = Math.min(minx, pixel.x);
      miny = Math.min(miny, pixel.y);
      maxx = Math.max(maxx, pixel.x);
      maxy = Math.max(maxy, pixel.y);
    });
    this.minx = minx;
    this.miny = miny;
    this.maxx = maxx;
    this.maxy = maxy;
    return this;
  }
  /**
   *Determine whether a point is included
   * @param {*} c
   */
  ;

  _proto.containsCoordinate = function containsCoordinate(c) {
    var lng, lat;

    if (Array.isArray(c)) {
      lng = c[0];
      lat = c[1];
    } else if (c instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"]) {
      lng = c.x;
      lat = c.y;
    }

    var minlng = this.minlng,
        minlat = this.minlat,
        maxlng = this.maxlng,
        maxlat = this.maxlat;

    if (minlng <= lng && lng <= maxlng && minlat <= lat & lat <= maxlat) {
      return true;
    }

    return false;
  }
  /**
   *Judge rectangle intersection
   * @param {*} pixel
   * @param {*} size
   */
  ;

  _proto.isRecCross = function isRecCross(pixel, size) {
    var x = pixel.x,
        y = pixel.y;
    var rec = {
      minx: x - size / 2,
      miny: y - size / 2,
      maxx: x + size / 2,
      maxy: y + size / 2
    };
    var minx = rec.minx,
        miny = rec.miny,
        maxx = rec.maxx,
        maxy = rec.maxy;

    if (contains(this, [minx, miny]) || contains(this, [minx, maxy]) || contains(this, [maxx, miny]) || contains(this, [maxx, maxy]) || contains(rec, [this.minx, this.miny]) || contains(rec, [this.minx, this.maxy]) || contains(rec, this.maxx, this.miny) || contains(rec, this.maxx, this.maxy)) {
      return true;
    }

    return false;
  }
  /**
   *generate grids
   * @param {*} minlng
   * @param {*} minlat
   * @param {*} maxlng
   * @param {*} maxlat
   */
  ;

  BBox.initGrids = function initGrids(minlng, minlat, maxlng, maxlat) {
    var grids = [],
        offsetX = maxlng - minlng,
        offsetY = maxlat - minlat;
    var averageX = offsetX / COL,
        averageY = offsetY / ROW;
    var x = minlng,
        y = minlat;

    for (var i = 0; i < COL; i++) {
      x = minlng + i * averageX;

      for (var j = 0; j < ROW; j++) {
        y = minlat + j * averageY;
        var bounds = new BBox(x, y, x + averageX, y + averageY);
        bounds.key = j + '-' + i;
        grids.push(bounds);
      }
    }

    return grids;
  };

  return BBox;
}();

var OPTIONS$9 = {
  altitude: 0
};
var vector$1 = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
/**
 *points
 */

var Points$1 = /*#__PURE__*/function (_MergedMixin) {
  _inheritsLoose(Points$$1, _MergedMixin);

  function Points$$1(points, options, material, layer) {
    var _this;

    if (!Array.isArray(points)) {
      points = [points];
    }

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$9, options, {
      layer: layer,
      points: points
    });
    var minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    for (var i = 0, len = points.length; i < len; i++) {
      var coordinate = points[i].coordinate;
      var x = void 0,
          y = void 0;

      if (Array.isArray(coordinate)) {
        x = coordinate[0];
        y = coordinate[1];
      } else if (coordinate instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"]) {
        x = coordinate.x;
        y = coordinate.y;
      }

      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    }

    var centerPt = layer.coordinateToVector3([(minX + maxX) / 2, (minY + maxY) / 2]);
    var grids = BBox.initGrids(minX, minY, maxX, maxY);
    var gridslen = grids.length;
    var vs = [],
        vectors = [],
        colors = [],
        pointMeshes = [],
        geometriesAttributes = [];

    for (var _i = 0, _len = points.length; _i < _len; _i++) {
      var _points$_i = points[_i],
          _coordinate = _points$_i.coordinate,
          height = _points$_i.height,
          color = _points$_i.color;

      if (color) {
        color = color instanceof three__WEBPACK_IMPORTED_MODULE_1__["Color"] ? color : new three__WEBPACK_IMPORTED_MODULE_1__["Color"](color);
        colors.push(color.r, color.g, color.b);
      }

      var _z = layer.distanceToVector3(height, height).x;

      var _v = layer.coordinateToVector3(_coordinate, _z);

      var v1 = _v.clone().sub(centerPt);

      vs.push(v1.x, v1.y, v1.z);
      vectors.push(_v);
      geometriesAttributes[_i] = {
        position: {
          count: 1,
          start: _i * 3,
          end: _i * 3 + 3
        },
        hide: false
      };

      for (var j = 0; j < gridslen; j++) {
        if (grids[j].containsCoordinate(_coordinate)) {
          // grids[j].coordinates.push(coordinate);
          grids[j].positions.push(_v);
          grids[j].indexs.push(_i);
          break;
        }
      }
    }

    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
    addAttribute(geometry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](vs, 3, true));

    if (colors.length) {
      addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
    } //for identify


    options.positions = vectors;
    _this = _MergedMixin.call(this) || this;

    _this._initOptions(options);

    _this._createPoints(geometry, material);

    var altitude = options.altitude;
    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = centerPt.clone();
    v.z = z;

    _this.getObject3d().position.copy(v);

    _this._baseObjects = pointMeshes;
    _this._datas = points;
    _this.faceIndex = null;
    _this._geometriesAttributes = geometriesAttributes;
    _this._geometryCache = geometry.clone();
    _this.isHide = false;

    _this._initBaseObjectsEvent(pointMeshes);

    _this._grids = grids;

    _this._bindMapEvents();

    return _this;
  }

  var _proto = Points$$1.prototype;

  _proto._bindMapEvents = function _bindMapEvents() {
    var _this2 = this;

    var map = this.getMap();
    this.on('add', function () {
      _this2._updateGrids();

      map.on('zoomstart zooming zoomend movestart moving moveend pitch rotate', _this2._updateGrids, _this2);
    });
    this.on('remove', function () {
      map.off('zoomstart zooming zoomend movestart moving moveend pitch rotate', _this2._updateGrids, _this2);
    });
  };

  _proto._updateGrids = function _updateGrids() {
    var map = this.getMap();

    this._grids.forEach(function (b) {
      if (b.indexs.length) {
        b.updateBBoxPixel(map);
      }
    });
  } // eslint-disable-next-line consistent-return
  ;

  _proto.getSelectMesh = function getSelectMesh() {
    var index = this.faceIndex;

    if (index != null) {
      if (!this._baseObjects[index]) {
        var data = this._datas[index];
        var coordinate = data.coordinate,
            height = data.height,
            color = data.color;
        this._baseObjects[index] = new Point(coordinate, {
          height: height,
          index: index,
          color: color
        }, this.getObject3d().material, this.getLayer());

        this._proxyEvent(this._baseObjects[index]);
      }

      return {
        data: this._datas[index],
        baseObject: this._baseObjects[index]
      };
    }
  }
  /**
  *
  * @param {maptalks.Coordinate} coordinate
  */
  ;

  _proto.identify = function identify(coordinate) {
    var layer = this.getLayer(),
        size = this.getMap().getSize(),
        camera = this.getLayer().getCamera(),
        altitude = this.getOptions().altitude,
        map = this.getMap();
    var z = layer.distanceToVector3(altitude, altitude).x;
    var pointSize = this.getObject3d().material.size;
    var pixel = map.coordToContainerPoint(coordinate);
    var bs = [];

    this._grids.forEach(function (b) {
      if (b.indexs.length) {
        if (b.isRecCross(pixel, pointSize)) {
          bs.push(b);
        }
      }
    });

    if (bs.length < 1) {
      return false;
    }

    for (var i = 0, len = bs.length; i < len; i++) {
      for (var j = 0, len1 = bs[i].positions.length; j < len1; j++) {
        var v = bs[i].positions[j];
        vector$1.x = v.x;
        vector$1.y = v.y;
        vector$1.z = v.z + z;
        var p = vector2Pixel(vector$1, size, camera);
        var distance = Math.sqrt(Math.pow(pixel.x - p.x, 2) + Math.pow(pixel.y - p.y, 2));

        if (distance <= pointSize / 2) {
          this.faceIndex = bs[i].indexs[j];
          return true;
        }
      }
    } // for (let i = 0, len = positions.length; i < len; i++) {
    //     const v = positions[i];
    //     vector.x = v.x;
    //     vector.y = v.y;
    //     vector.z = v.z + z;
    //     const p = vector2Pixel(vector, size, camera);
    //     const distance = Math.sqrt(Math.pow(pixel.x - p.x, 2) + Math.pow(pixel.y - p.y, 2));
    //     if (distance <= pointSize / 2) {
    //         this.faceIndex = i;
    //         console.timeEnd(timer);
    //         return true;
    //     }
    // }


    return false;
  };

  return Points$$1;
}(MergedMixin(BaseObject$$1));

var OPTIONS$a = {
  coordinate: null,
  radius: 10,
  height: 100,
  radialSegments: 6,
  altitude: 0,
  topColor: null,
  bottomColor: '#2d2f61'
};
/**
 * merged bars
 */

var Bars = /*#__PURE__*/function (_MergedMixin) {
  _inheritsLoose(Bars, _MergedMixin);

  function Bars(points, options, material, layer) {
    var _this;

    if (!Array.isArray(points)) {
      points = [points];
    }

    var len = points.length;
    var geometries = [],
        bars = [],
        geometriesAttributes = [],
        faceMap = [];
    var faceIndex = 0,
        psIndex = 0,
        normalIndex = 0,
        uvIndex = 0;

    for (var i = 0; i < len; i++) {
      var opts = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({
        index: i
      }, OPTIONS$a, points[i]);
      var radius = opts.radius,
          radialSegments = opts.radialSegments,
          altitude = opts.altitude,
          topColor = opts.topColor,
          bottomColor = opts.bottomColor,
          height = opts.height,
          coordinate = opts.coordinate;
      var r = layer.distanceToVector3(radius, radius).x;
      var h = layer.distanceToVector3(height, height).x;
      var alt = layer.distanceToVector3(altitude, altitude).x;
      var buffGeom = getGeometry({
        radius: r,
        height: h,
        radialSegments: radialSegments
      }, false);

      if (topColor && !material.map) {
        initVertexColors(buffGeom, bottomColor, topColor, 'z', h / 2);
        material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
      } // buffGeom.rotateX(Math.PI / 2);


      var v = layer.coordinateToVector3(coordinate);
      var parray = buffGeom.attributes.position.array;

      for (var j = 0, len1 = parray.length; j < len1; j += 3) {
        parray[j + 2] += alt;
        parray[j] += v.x;
        parray[j + 1] += v.y;
        parray[j + 2] += v.z;
      }

      geometries.push(buffGeom);
      var bar = new Bar(coordinate, opts, material, layer);
      bars.push(bar);
      var faceLen = buffGeom.index.count / 3;
      faceMap[i] = [faceIndex + 1, faceIndex + faceLen];
      faceIndex += faceLen;
      var psCount = buffGeom.attributes.position.count,
          //  colorCount = buffGeom.attributes.color.count,
      normalCount = buffGeom.attributes.normal.count,
          uvCount = buffGeom.attributes.uv.count;
      geometriesAttributes[i] = {
        position: {
          count: psCount,
          start: psIndex,
          end: psIndex + psCount * 3
        },
        normal: {
          count: normalCount,
          start: normalIndex,
          end: normalIndex + normalCount * 3
        },
        // color: {
        //     count: colorCount,
        //     start: colorIndex,
        //     end: colorIndex + colorCount * 3,
        // },
        uv: {
          count: uvCount,
          start: uvIndex,
          end: uvIndex + uvCount * 2
        },
        hide: false
      };
      psIndex += psCount * 3;
      normalIndex += normalCount * 3; // colorIndex += colorCount * 3;

      uvIndex += uvCount * 2;
    }

    _this = _MergedMixin.call(this) || this;
    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, {
      altitude: 0,
      layer: layer,
      points: points
    }, options);

    _this._initOptions(options);

    var geometry = mergeBarGeometry(geometries);

    _this._createMesh(geometry, material);

    _this._faceMap = faceMap;
    _this._baseObjects = bars;
    _this._datas = points;
    _this._geometriesAttributes = geometriesAttributes;
    _this.faceIndex = null;
    _this._geometryCache = geometry.clone();
    _this.isHide = false;
    _this._colorMap = {};

    _this._initBaseObjectsEvent(bars);

    _this._setPickObject3d();

    _this._init();

    return _this;
  } // eslint-disable-next-line consistent-return


  var _proto = Bars.prototype;

  _proto.getSelectMesh = function getSelectMesh() {
    var index = this._getIndex();

    if (index != null) {
      return {
        data: this._datas[index],
        baseObject: this._baseObjects[index]
      };
    }
  } // eslint-disable-next-line consistent-return
  ;

  _proto._getIndex = function _getIndex(faceIndex) {
    if (faceIndex == null) {
      faceIndex = this.faceIndex || this.index;
    }

    return faceIndex;
  };

  _proto._init = function _init() {
    var _this2 = this;

    var pick = this.getLayer().getPick();
    this.on('add', function () {
      pick.add(_this2.pickObject3d);
    });
    this.on('remove', function () {
      pick.remove(_this2.pickObject3d);
    });
  };

  _proto._setPickObject3d = function _setPickObject3d() {
    var geometry = this.getObject3d().geometry.clone();
    var pick = this.getLayer().getPick();
    var _geometriesAttributes = this._geometriesAttributes;
    var colors = [];

    for (var i = 0, _len = _geometriesAttributes.length; i < _len; i++) {
      var _color = pick.getColor();

      var _colorIndex = _color.getHex();

      this._colorMap[_colorIndex] = i;
      var count = _geometriesAttributes[i].position.count;
      this._datas[i].colorIndex = _colorIndex;

      for (var j = 0; j < count; j++) {
        colors.push(_color.r, _color.g, _color.b);
      }
    }

    addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
    var material = new three__WEBPACK_IMPORTED_MODULE_1__["MeshBasicMaterial"]();
    material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
    var color = pick.getColor();
    var colorIndex = color.getHex();
    var mesh = new three__WEBPACK_IMPORTED_MODULE_1__["Mesh"](geometry, material);
    mesh.position.copy(this.getObject3d().position);
    mesh._colorIndex = colorIndex;
    this.setPickObject3d(mesh);
  } // eslint-disable-next-line no-unused-vars
  ;

  _proto.identify = function identify(coordinate) {
    return this.picked;
  };

  return Bars;
}(MergedMixin(BaseObject$$1));

var OPTIONS$b = {
  width: 3,
  height: 1,
  altitude: 0
};

var ExtrudeLines = /*#__PURE__*/function (_MergedMixin) {
  _inheritsLoose(ExtrudeLines, _MergedMixin);

  function ExtrudeLines(lineStrings, options, material, layer) {
    var _this;

    if (!Array.isArray(lineStrings)) {
      lineStrings = [lineStrings];
    }

    var centers = [],
        lineStringList = [];
    var len = lineStrings.length;

    for (var i = 0; i < len; i++) {
      var lineString = lineStrings[i];
      var result = LineStringSplit(lineString);
      centers.push(result.center);
      lineStringList.push(result.lineStrings);
    } // Get the center point of the point set


    var center = getCenterOfPoints(centers);
    var geometries = [],
        extrudeLines = [];
    var faceIndex = 0,
        faceMap = [],
        geometriesAttributes = [],
        psIndex = 0,
        normalIndex = 0;

    for (var _i = 0; _i < len; _i++) {
      var _lineString = lineStrings[_i];
      var opts = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$b, isGeoJSON(_lineString) ? _lineString.properties : _lineString.getProperties(), {
        index: _i
      });
      var height = opts.height,
          width = opts.width;
      var w = layer.distanceToVector3(width, width).x;
      var h = layer.distanceToVector3(height, height).x;
      var lls = lineStringList[_i];
      var extrudeParams = [];

      for (var m = 0, le = lls.length; m < le; m++) {
        extrudeParams.push(getExtrudeLineParams(lls[m], w, h, layer, center));
      }

      var buffGeom = mergeBufferGeometriesAttribute(extrudeParams);
      geometries.push(buffGeom);
      var extrudeLine = new ExtrudeLine(_lineString, opts, material, layer);
      extrudeLines.push(extrudeLine);
      var position = buffGeom.position,
          normal = buffGeom.normal,
          indices = buffGeom.indices;
      var faceLen = indices.length / 3;
      faceMap[_i] = [faceIndex + 1, faceIndex + faceLen];
      faceIndex += faceLen;
      var psCount = position.length / 3,
          //  colorCount = buffGeom.attributes.color.count,
      normalCount = normal.length / 3;
      geometriesAttributes[_i] = {
        position: {
          count: psCount,
          start: psIndex,
          end: psIndex + psCount * 3
        },
        normal: {
          count: normalCount,
          start: normalIndex,
          end: normalIndex + normalCount * 3
        },
        // color: {
        //     count: colorCount,
        //     start: colorIndex,
        //     end: colorIndex + colorCount * 3,
        // },
        // uv: {
        //     count: uvCount,
        //     start: uvIndex,
        //     end: uvIndex + uvCount * 2,
        // },
        hide: false
      };
      psIndex += psCount * 3;
      normalIndex += normalCount * 3; // colorIndex += colorCount * 3;
      // uvIndex += uvCount * 2;
    }

    var geometry = mergeBufferGeometries(geometries);
    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$b, options, {
      layer: layer,
      lineStrings: lineStrings,
      coordinate: center
    });
    _this = _MergedMixin.call(this) || this;

    _this._initOptions(options);

    _this._createMesh(geometry, material);

    var _options = options,
        altitude = _options.altitude;
    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v); //Face corresponding to monomer


    _this._faceMap = faceMap;
    _this._baseObjects = extrudeLines;
    _this._datas = lineStrings;
    _this._geometriesAttributes = geometriesAttributes;
    _this.faceIndex = null;
    _this._geometryCache = geometry.clone();
    _this.isHide = false;
    _this._colorMap = {};

    _this._initBaseObjectsEvent(extrudeLines);

    _this._setPickObject3d();

    _this._init();

    return _this;
  } // eslint-disable-next-line consistent-return


  var _proto = ExtrudeLines.prototype;

  _proto.getSelectMesh = function getSelectMesh() {
    var index = this._getIndex();

    if (index != null) {
      return {
        data: this._datas[index],
        baseObject: this._baseObjects[index]
      };
    }
  } // eslint-disable-next-line consistent-return
  ;

  _proto._getIndex = function _getIndex(faceIndex) {
    if (faceIndex == null) {
      faceIndex = this.faceIndex || this.index;
    }

    return faceIndex; // if (faceIndex != null) {
    //     for (let i = 0, len = this._faceMap.length; i < len; i++) {
    //         const [start, end] = this._faceMap[i];
    //         if (start <= faceIndex && faceIndex < end) {
    //             return i;
    //         }
    //     }
    // }
  };

  _proto._init = function _init() {
    var _this2 = this;

    var pick = this.getLayer().getPick();
    this.on('add', function () {
      pick.add(_this2.pickObject3d);
    });
    this.on('remove', function () {
      pick.remove(_this2.pickObject3d);
    });
  };

  _proto._setPickObject3d = function _setPickObject3d() {
    var geometry = this.getObject3d().geometry.clone();
    var pick = this.getLayer().getPick();
    var _geometriesAttributes = this._geometriesAttributes;
    var colors = [];

    for (var i = 0, _len = _geometriesAttributes.length; i < _len; i++) {
      var _color = pick.getColor();

      var _colorIndex = _color.getHex();

      this._colorMap[_colorIndex] = i;
      var count = _geometriesAttributes[i].position.count;
      this._datas[i].colorIndex = _colorIndex;

      for (var j = 0; j < count; j++) {
        colors.push(_color.r, _color.g, _color.b);
      }
    }

    addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
    var material = new three__WEBPACK_IMPORTED_MODULE_1__["MeshBasicMaterial"](); // material.color.set('#fff');

    material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
    var color = pick.getColor();
    var colorIndex = color.getHex();
    var mesh = new three__WEBPACK_IMPORTED_MODULE_1__["Mesh"](geometry, material);
    mesh.position.copy(this.getObject3d().position);
    mesh._colorIndex = colorIndex;
    this.setPickObject3d(mesh);
  } // eslint-disable-next-line no-unused-vars
  ;

  _proto.identify = function identify(coordinate) {
    return this.picked;
  };

  return ExtrudeLines;
}(MergedMixin(BaseObject$$1));

var OPTIONS$c = {
  altitude: 0,
  colors: null
};
/**
 *
 */

var Lines = /*#__PURE__*/function (_MergedMixin) {
  _inheritsLoose(Lines, _MergedMixin);

  function Lines(lineStrings, options, material, layer) {
    var _this;

    if (!Array.isArray(lineStrings)) {
      lineStrings = [lineStrings];
    }

    var centers = [],
        lineStringList = [];
    var len = lineStrings.length;

    for (var i = 0; i < len; i++) {
      var lineString = lineStrings[i];
      var result = LineStringSplit(lineString);
      centers.push(result.center);
      lineStringList.push(result.lineStrings);
    } // Get the center point of the point set


    var center = getCenterOfPoints(centers);
    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$c, options, {
      layer: layer,
      lineStrings: lineStrings,
      coordinate: center
    });
    var lines = [];
    var faceIndex = 0,
        faceMap = [],
        geometriesAttributes = [],
        psIndex = 0,
        ps = [];

    for (var _i = 0; _i < len; _i++) {
      var lls = lineStringList[_i];
      var psCount = 0;

      for (var m = 0, le = lls.length; m < le; m++) {
        var _getLinePosition = getLinePosition(lls[m], layer, center),
            positionsV = _getLinePosition.positionsV;

        psCount += positionsV.length * 2 - 2;

        for (var j = 0, len1 = positionsV.length; j < len1; j++) {
          var _v = positionsV[j];

          if (j > 0 && j < len1 - 1) {
            ps.push(_v.x, _v.y, _v.z);
          }

          ps.push(_v.x, _v.y, _v.z);
        }
      } // const line = new Line(lineString, opts, material, layer);
      // lines.push(line);
      // const psCount = positionsV.length + positionsV.length - 2;


      var faceLen = psCount;
      faceMap[_i] = [faceIndex, faceIndex + faceLen];
      faceIndex += faceLen;
      geometriesAttributes[_i] = {
        position: {
          count: psCount,
          start: psIndex,
          end: psIndex + psCount * 3
        },
        hide: false
      };
      psIndex += psCount * 3;
    }

    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
    addAttribute(geometry, 'position', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](ps, 3));
    _this = _MergedMixin.call(this) || this;

    _this._initOptions(options);

    _this._createLineSegments(geometry, material);

    var _options = options,
        altitude = _options.altitude;
    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v);

    _this._faceMap = faceMap;
    _this._baseObjects = lines;
    _this._datas = lineStrings;
    _this._geometriesAttributes = geometriesAttributes;
    _this.faceIndex = null;
    _this.index = null;
    _this._geometryCache = geometry.clone();
    _this.isHide = false;
    _this._colorMap = {};

    _this._initBaseObjectsEvent(lines);

    _this._setPickObject3d();

    _this._init();

    return _this;
  } // eslint-disable-next-line consistent-return


  var _proto = Lines.prototype;

  _proto.getSelectMesh = function getSelectMesh() {
    var index = this._getIndex();

    if (index != null) {
      if (!this._baseObjects[index]) {
        var lineString = this._datas[index];
        var opts = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, this.getOptions(), {
          index: index
        }, isGeoJSONLine(lineString) ? lineString.properties : lineString.getProperties());
        this._baseObjects[index] = new Line$1(lineString, opts, this.getObject3d().material, this.getLayer());

        this._proxyEvent(this._baseObjects[index]);
      }

      return {
        data: this._datas[index],
        baseObject: this._baseObjects[index]
      };
    }
  } // eslint-disable-next-line consistent-return
  ;

  _proto._getIndex = function _getIndex(faceIndex) {
    if (faceIndex == null) {
      faceIndex = this.faceIndex || this.index;
    }

    return faceIndex; // if (faceIndex != null) {
    //     for (let i = 0, len = this._faceMap.length; i < len; i++) {
    //         const [start, end] = this._faceMap[i];
    //         if (start <= faceIndex && faceIndex < end) {
    //             return i;
    //         }
    //     }
    // }
  };

  _proto._init = function _init() {
    var _this2 = this;

    var pick = this.getLayer().getPick();
    this.on('add', function () {
      pick.add(_this2.pickObject3d);
    });
    this.on('remove', function () {
      pick.remove(_this2.pickObject3d);
    });
  };

  _proto._setPickObject3d = function _setPickObject3d() {
    var geometry = this.getObject3d().geometry.clone();
    var pick = this.getLayer().getPick();
    var _geometriesAttributes = this._geometriesAttributes;
    var colors = [];

    for (var i = 0, _len = _geometriesAttributes.length; i < _len; i++) {
      var _color = pick.getColor();

      var _colorIndex = _color.getHex();

      this._colorMap[_colorIndex] = i;
      var count = _geometriesAttributes[i].position.count;
      this._datas[i].colorIndex = _colorIndex;

      for (var j = 0; j < count; j++) {
        colors.push(_color.r, _color.g, _color.b);
      }
    }

    addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
    var material = this.getObject3d().material.clone();
    material.color.set('#fff');
    material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
    var color = pick.getColor();
    var colorIndex = color.getHex();
    var mesh = new three__WEBPACK_IMPORTED_MODULE_1__["LineSegments"](geometry, material);
    mesh.position.copy(this.getObject3d().position);
    mesh._colorIndex = colorIndex;
    this.setPickObject3d(mesh);
  } // eslint-disable-next-line no-unused-vars
  ;

  _proto.identify = function identify(coordinate) {
    return this.picked;
  };

  return Lines;
}(MergedMixin(BaseObject$$1));

/*

Global sharing

*/
//Maximum concurrent
var MAX = 10;
var waitingQueue = [// {
  //     key,
  //     url,
  //     callback,
  //     img,
  //     vt
  // }
];
var currentQueue = [];
function getQueues() {
  return {
    waitingQueue: waitingQueue,
    currentQueue: currentQueue
  };
}
/**
 *
 * @param {*} key
 * @param {*} url
 * @param {*} callback
 * @param {*} img
 * @param {*} vt
 */

function pushQueue(key, url, callback, img, vt) {
  // url += `?key=${key}`;
  var q = {
    key: key,
    url: url,
    callback: callback,
    img: img,
    vt: vt
  };

  if (currentQueue.length < MAX) {
    currentQueue.push(q);
    vt.loopMessage(q);
  } else {
    waitingQueue.push(q);
  }
}
/**
 *
 * @param {*} index
 */

function outQueue(index) {
  var callback = deleteQueueItem(waitingQueue, index);

  if (callback) {
    callback(index);
  }
}
/**
 *
 * @param {*} queArray
 * @param {*} index
 */

function deleteQueueItem(queArray, index) {
  for (var i = 0, len = queArray.length; i < len; i++) {
    var q = queArray[i];

    if (q) {
      var key = q.key,
          callback = q.callback;

      if (index === key) {
        queArray.splice(i, 1);
        return callback;
      }
    }
  }

  return null;
}
/**
 *
 * @param {*} key
 * @param {*} vt
 */

function nextLoop(key, vt) {
  deleteQueueItem(currentQueue, key);

  if (waitingQueue.length) {
    currentQueue.push(waitingQueue[0]);
    waitingQueue.splice(0, 1);
    var last = currentQueue[currentQueue.length - 1];
    vt.loopMessage(last);
  }
} // function message(q) {
//     if (currentQueue.length > 0) {
//         const { key, url, callback, img, loopMessage } = q;
//         maptalks.Ajax.getJSON(url, {}, function (error, res) {
//             if (error) {
//                 console.error(error);
//                 callback(key, null, img);
//             } else {
//                 callback(key, res, img);
//             }
//             deleteQueueItem(currentQueue, key);
//             if (waitingQueue.length) {
//                 currentQueue.push(waitingQueue[0]);
//                 waitingQueue.splice(0, 1);
//                 const last = currentQueue[currentQueue.length - 1];
//                 message(last);
//                 //  循环消费
//             }
//         });
//     }
// }

var canvas = document.createElement('canvas');
var SIZE = 256;
canvas.width = canvas.height = SIZE;
function generateImage(key, debug) {
  var ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, SIZE, SIZE);
  ctx.save();

  if (debug) {
    ctx.fillStyle = 'red';
    ctx.strokeStyle = 'rgba(255,0,0,0.4)';
    ctx.lineWidth = 0.2;
    var text = key || 'tile';
    ctx.font = '18px sans-serif';
    ctx.rect(0, 0, SIZE, SIZE);
    ctx.stroke();
    ctx.fillText(text, 15, SIZE / 2);
  }

  return canvas.toDataURL();
}
function Canvas(width, height) {
  if (width === void 0) {
    width = 1;
  }

  if (height === void 0) {
    height = 1;
  }

  var canvas;

  if (typeof document === 'undefined') ; else {
    canvas = document.createElement('canvas');

    if (width) {
      canvas.width = width;
    }

    if (height) {
      canvas.height = height;
    }
  }

  return canvas;
}

/**
 *
 */

var BaseVectorTileLayer = /*#__PURE__*/function (_maptalks$TileLayer) {
  _inheritsLoose(BaseVectorTileLayer, _maptalks$TileLayer);

  function BaseVectorTileLayer(url, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _maptalks$TileLayer.call(this, maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].GUID(), maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({
      urlTemplate: url
    }, options)) || this;
    _this._opts = null;
    _this._layer = null;
    _this.material = null;
    _this.getMaterial = null;
    _this._baseObjectKeys = {};
    _this._loadTiles = {};
    _this._add = null;
    _this._layerLaodTime = new Date().getTime();
    return _this;
  }

  var _proto = BaseVectorTileLayer.prototype;

  _proto.isAsynchronous = function isAsynchronous() {
    return this._opts.worker;
  }
  /**
   *get current all baseobject
   */
  ;

  _proto.getBaseObjects = function getBaseObjects() {
    var loadTiles = this._loadTiles;
    var baseos = [];

    for (var key in loadTiles) {
      var baseobjects = this._baseObjectKeys[key];

      if (baseobjects && Array.isArray(baseobjects) && baseobjects.length) {
        for (var i = 0, len = baseobjects.length; i < len; i++) {
          baseos.push(baseobjects[i]);
        }
      }
    }

    return baseos;
  }
  /**
  * This method should be overridden for event handling
  * @param {*} type
  * @param {*} e
  */
  // eslint-disable-next-line no-unused-vars
  ;

  _proto.onSelectMesh = function onSelectMesh(type, e) {}
  /**
  * this is can override
  * @param {*} index
  * @param {*} json
  */
  // eslint-disable-next-line no-unused-vars
  ;

  _proto.formatBaseObjects = function formatBaseObjects(index, json) {} //queue loop
  // eslint-disable-next-line no-unused-vars
  ;

  _proto.loopMessage = function loopMessage(q) {}
  /**
  *
  * @param {*} q
  */
  ;

  _proto.getTileData = function getTileData(q) {
    var key = q.key,
        url = q.url,
        callback = q.callback,
        img = q.img;
    maptalks__WEBPACK_IMPORTED_MODULE_0__["Ajax"].getJSON(url, {}, function (error, res) {
      if (error) {
        console.error(error);
        callback(key, null, img);
      } else {
        callback(key, res, img);
      }
    });
  };

  _proto._getCurentTileKeys = function _getCurentTileKeys() {
    var tileGrids = this.getTiles().tileGrids || [];
    var keys = [],
        keysMap = {};

    for (var i = 0, len = tileGrids.length; i < len; i++) {
      var d = tileGrids[i];
      var tiles = d.tiles || [];

      for (var j = 0, len1 = tiles.length; j < len1; j++) {
        var dupKey = tiles[j].dupKey;
        keys.push(dupKey);
        keysMap[dupKey] = true;
      }
    }

    return {
      keys: keys,
      keysMap: keysMap
    };
  };

  _proto._isLoad = function _isLoad() {
    var _this$_getCurentTileK = this._getCurentTileKeys(),
        keys = _this$_getCurentTileK.keys;

    var keys1 = Object.keys(this._renderer.tilesInView);

    if (keys.length === keys1.length) {
      return true;
    }

    return false;
  };

  _proto._layerOnLoad = function _layerOnLoad() {
    // This event will be triggered multiple times per unit time
    var time = new Date().getTime();
    var offsetTime = time - this._layerLaodTime;

    if (offsetTime < 20) {
      return;
    }

    this._layerLaodTime = time;
    var tilesInView = this._renderer.tilesInView,
        loadTiles = this._loadTiles,
        threeLayer = this._layer,
        keys = this._baseObjectKeys;
    var tilesInViewLen = Object.keys(tilesInView).length,
        loadTilesLen = Object.keys(loadTiles).length;
    var needsRemoveBaseObjects = [];

    if (tilesInViewLen && loadTilesLen) {
      for (var index in loadTiles) {
        if (!tilesInView[index]) {
          if (keys[index]) {
            (keys[index] || []).forEach(function (baseobject) {
              needsRemoveBaseObjects.push(baseobject);
            });
          }
        }
      }
    }

    if (needsRemoveBaseObjects.length) {
      threeLayer.removeMesh(needsRemoveBaseObjects, false);
    }

    if (tilesInViewLen && loadTilesLen) {
      for (var _index in tilesInView) {
        if (!loadTiles[_index]) {
          if (keys[_index]) {
            var baseobject = keys[_index];
            threeLayer.addMesh(baseobject);
          } else {
            var _this$_getXYZOfIndex = this._getXYZOfIndex(_index),
                x = _this$_getXYZOfIndex.x,
                y = _this$_getXYZOfIndex.y,
                z = _this$_getXYZOfIndex.z;

            this.getTileUrl(x, y, z);
          }
        }
      }
    }

    this._loadTiles = Object.assign({}, tilesInView);

    this._diffCache();
  };

  _proto._init = function _init() {};

  _proto._workerLoad = function _workerLoad(e) {
    var baseobject = e.target;
    var img = baseobject._img;
    img.currentCount++;

    if (img.currentCount === img.needCount) {
      img.src = generateImage(img._key, this._opts.debug);
    }
  };

  _proto._generateBaseObjects = function _generateBaseObjects(index, res, img) {
    var _this2 = this;

    if (res && img) {
      var _this$_getCurentTileK2 = this._getCurentTileKeys(),
          keysMap = _this$_getCurentTileK2.keysMap; //not in current ,ignore


      if (!keysMap[index]) {
        img.src = generateImage(index, this._opts.debug);
        return;
      }

      var baseobjects = this.formatBaseObjects(index, res);

      if (baseobjects.length) {
        img.needCount = baseobjects.length;
        img.currentCount = 0;

        for (var i = 0, len = baseobjects.length; i < len; i++) {
          var baseobject = baseobjects[i];
          baseobject._img = img;
          baseobject._vt = this;

          if (!this.isVisible()) {
            baseobject.hide();
          }

          this._cachetile(index, baseobject);

          if (!baseobject.isAsynchronous()) {
            img.currentCount++;
          }
        }

        this._layer.addMesh(baseobjects, false);

        if (img.needCount === img.currentCount) {
          img.src = generateImage(index, this._opts.debug);
        }

        if (this.isAsynchronous()) {
          baseobjects.filter(function (baseobject) {
            return baseobject.isAsynchronous();
          }).forEach(function (baseobject) {
            baseobject.on('workerload', _this2._workerLoad, _this2);
          });
        } else {
          img.src = generateImage(index, this._opts.debug);
        }
      } else {
        img.src = generateImage(index, this._opts.debug);
      }

      this._loadTiles[index] = true;
    } else if (img) {
      img.src = generateImage(index, this._opts.debug);
    }
  };

  _proto._diffCache = function _diffCache() {
    var _this3 = this;

    // if (this._layer.getMap().isInteracting()) {
    //     return;
    // }
    if (Object.keys(this._baseObjectKeys).length > this._renderer.tileCache.max) {
      (function () {
        var tileCache = _this3._renderer.tileCache.data;
        var tilesInView = _this3._renderer.tilesInView;
        var needsRemoveBaseObjects = [];

        for (var index in _this3._baseObjectKeys) {
          if (!tileCache[index] && !tilesInView[index]) {
            (_this3._baseObjectKeys[index] || []).forEach(function (baseobject) {
              if (baseobject.isAdd) {
                needsRemoveBaseObjects.push(baseobject);
              }
            });

            _this3._diposeBaseObject(index);

            delete _this3._baseObjectKeys[index];
          }
        } // Batch deletion can have better performance


        if (needsRemoveBaseObjects.length) {
          _this3._layer.removeMesh(needsRemoveBaseObjects, false);
        }
      })();
    }
  };

  _proto._diposeBaseObject = function _diposeBaseObject(index) {
    var baseobjects = this._baseObjectKeys[index];

    if (baseobjects && baseobjects.length) {
      baseobjects.forEach(function (baseobject) {
        baseobject.getObject3d().geometry.dispose();

        if (baseobject._geometryCache) {
          baseobject._geometryCache.dispose();
        }

        var bos = baseobject._baseObjects;

        if (bos && bos.length) {
          bos.forEach(function (bo) {
            bo.getObject3d().geometry.dispose();
            bo = null;
          });
        }

        baseobject._datas = null;
        baseobject._geometriesAttributes = null;
        baseobject._faceMap = null;
        baseobject = null;
      });
    }
  };

  _proto._cachetile = function _cachetile(index, baseobject) {
    if (!this._baseObjectKeys[index]) {
      this._baseObjectKeys[index] = [];
    }

    this._baseObjectKeys[index].push(baseobject);
  };

  _proto._getXYZOfIndex = function _getXYZOfIndex(index) {
    var splitstr = index.indexOf('_') > -1 ? '_' : '-';

    var _index$split$slice = index.split(splitstr).slice(1, 4),
        y = _index$split$slice[0],
        x = _index$split$slice[1],
        z = _index$split$slice[2];

    x = parseInt(x);
    y = parseInt(y);
    z = parseInt(z);
    return {
      x: x,
      y: y,
      z: z
    };
  };

  _proto._getTileExtent = function _getTileExtent(x, y, z) {
    var map = this.getMap(),
        res = map._getResolution(z),
        tileConfig = this._getTileConfig(),
        tileExtent = tileConfig.getTilePrjExtent(x, y, res);

    return tileExtent;
  }
  /**
   *
   * @param {} x
   * @param {*} y
   * @param {*} z
   */
  ;

  _proto._getTileLngLatExtent = function _getTileLngLatExtent(x, y, z) {
    var tileExtent = this._getTileExtent(x, y, z);

    var max = tileExtent.getMax(),
        min = tileExtent.getMin();
    var map = this.getMap();
    var projection = map.getProjection();
    min = projection.unproject(min);
    max = projection.unproject(max);
    return new maptalks__WEBPACK_IMPORTED_MODULE_0__["Extent"](min, max);
  };

  return BaseVectorTileLayer;
}(maptalks__WEBPACK_IMPORTED_MODULE_0__["TileLayer"]);

var OPTIONS$d = {
  worker: false
};
/**
 *Provide a simple data loading layer with large amount of data
 */

var ThreeVectorTileLayer = /*#__PURE__*/function (_BaseVectorTileLayer) {
  _inheritsLoose(ThreeVectorTileLayer, _BaseVectorTileLayer);

  function ThreeVectorTileLayer(url, options, getMaterial, layer) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _BaseVectorTileLayer.call(this, maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].GUID(), maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({
      urlTemplate: url
    }, OPTIONS$d, options)) || this;
    _this._opts = options;
    _this._layer = layer;
    _this.getMaterial = getMaterial;
    _this._baseObjectKeys = {};
    _this._loadTiles = {};
    _this._add = null;
    _this._layerLaodTime = new Date().getTime();

    _this._init();

    return _this;
  }
  /**
   * this is can override
   * @param {*} index
   * @param {*} json
   */


  var _proto = ThreeVectorTileLayer.prototype;

  _proto.formatBaseObjects = function formatBaseObjects(index, json) {
    var opts = this._opts,
        baseobjects = [];
    var asynchronous = this.isAsynchronous();

    for (var layerName in json) {
      var geojson = json[layerName] || {};
      var features = void 0;

      if (Array.isArray(geojson)) {
        features = geojson;
      } else if (geojson.type === 'FeatureCollection') {
        features = geojson.features;
      }

      if (features && features.length) {
        var polygons = [],
            lineStrings = [],
            points = [];

        for (var i = 0, len = features.length; i < len; i++) {
          var feature = features[i];

          if (isGeoJSONPolygon(feature)) {
            polygons.push(feature);
          } else if (isGeoJSONLine(feature)) {
            var fs = spliteGeoJSONMulti(feature);

            for (var j = 0, len1 = fs.length; j < len1; j++) {
              lineStrings.push(fs[j]);
            }
          } else if (isGeoJSONPoint(feature)) {
            var _fs = spliteGeoJSONMulti(feature);

            for (var _j = 0, _len = _fs.length; _j < _len; _j++) {
              points.push(maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, _fs[_j].properties, _fs[_j], {
                coordinate: getGeoJSONCoordinates(_fs[_j])
              }));
            }
          }
        }

        if (polygons.length) {
          var material = this._getMaterial(layerName, polygons, index, geojson);

          if (material) {
            var extrudepolygons = this._layer.toExtrudePolygons(polygons, maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, {
              topColor: '#fff',
              layerName: layerName,
              asynchronous: asynchronous,
              key: index
            }, opts), material);

            baseobjects.push(extrudepolygons);
          }
        }

        if (lineStrings.length) {
          var _material = this._getMaterial(layerName, lineStrings, index, geojson);

          if (_material && (_material instanceof three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"] || _material instanceof three__WEBPACK_IMPORTED_MODULE_1__["LineDashedMaterial"])) {
            var lines = this._layer.toLines(lineStrings, maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, {
              layerName: layerName
            }, opts), _material);

            baseobjects.push(lines);
          }
        }

        if (points.length) {
          var _material2 = this._getMaterial(layerName, points, index, geojson);

          if (_material2 && _material2 instanceof three__WEBPACK_IMPORTED_MODULE_1__["PointsMaterial"]) {
            var ps = this._layer.toPoints(points, maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, {
              layerName: layerName
            }, opts), _material2);

            baseobjects.push(ps);
          }
        }
      }
    }

    return baseobjects;
  } //queue loop
  ;

  _proto.loopMessage = function loopMessage(q) {
    var _getQueues = getQueues(),
        currentQueue = _getQueues.currentQueue;

    if (currentQueue.length > 0) {
      this.getTileData(q);
    }
  };

  _proto._init = function _init() {
    var _this2 = this;

    this.on('layerload', this._layerOnLoad);
    this.on('add', function () {
      if (_this2._add === false) {
        var baseobjects = _this2.getBaseObjects();

        _this2._layer.addMesh(baseobjects);
      }

      _this2._add = true;
      /**
       * layerload have a bug ,Sometimes it doesn't trigger,I don't know why
       * Add heartbeat detection mechanism
       */

      _this2.intervalId = setInterval(function () {
        if (_this2._isLoad() && !_this2._layer.getMap().isInteracting()) {
          _this2.fire('layerload');
        }
      }, 1000);
    });
    this.on('remove', function () {
      _this2._add = false;

      var baseobjects = _this2.getBaseObjects();

      _this2._layer.removeMesh(baseobjects);

      clearInterval(_this2.intervalId);
    });
    this.on('show', function () {
      var baseobjects = _this2.getBaseObjects();

      baseobjects.forEach(function (baseobject) {
        baseobject.show();
      });

      for (var key in _this2._baseObjectKeys) {
        var _baseobjects = _this2._baseObjectKeys[key] || [];

        _baseobjects.forEach(function (baseobject) {
          baseobject.show();
        });
      }
    });
    this.on('hide', function () {
      var baseobjects = _this2.getBaseObjects();

      baseobjects.forEach(function (baseobject) {
        baseobject.hide();
      });

      for (var key in _this2._baseObjectKeys) {
        var _baseobjects2 = _this2._baseObjectKeys[key] || [];

        _baseobjects2.forEach(function (baseobject) {
          baseobject.hide();
        });
      }
    });
    this.on('renderercreate', function (e) {
      e.renderer.loadTile = function loadTile(tile) {
        var tileSize = this.layer.getTileSize();
        var tileImage = new Image();
        tileImage.width = tileSize['width'];
        tileImage.height = tileSize['height'];
        tileImage.onload = this.onTileLoad.bind(this, tileImage, tile);
        tileImage.onerror = this.onTileError.bind(this, tileImage, tile);
        this.loadTileImage(tileImage, tile['url'], tile.dupKey);
        return tileImage;
      };

      e.renderer.deleteTile = function (tile) {
        if (!tile || !tile.image) {
          return;
        }

        tile.image.onload = null;
        tile.image.onerror = null;
        var tileinfo = tile.info || {};
        outQueue(tileinfo.dupKey);
      };

      e.renderer.loadTileImage = function (img, url, key) {
        img._key = key;
        pushQueue(key, url, function (index, json, image) {
          // img.src = generateImage(key, this._opts.debug);
          _this2._generateBaseObjects(index, json, image);

          nextLoop(index, _this2);
        }, img, _this2);
      };
    });
  };

  _proto._getMaterial = function _getMaterial(layerName, data, index, geojson) {
    if (this.getMaterial && maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isFunction(this.getMaterial)) {
      return this.getMaterial(layerName, data, index, geojson);
    }

    return null;
  };

  return ThreeVectorTileLayer;
}(BaseVectorTileLayer);

var textureLoader = new three__WEBPACK_IMPORTED_MODULE_1__["TextureLoader"]();
var canvas$1 = document.createElement('canvas'),
    tileSize = 256;

function getRGBData(image, width, height) {
  if (width === void 0) {
    width = tileSize;
  }

  if (height === void 0) {
    height = tileSize;
  }

  canvas$1.width = width;
  canvas$1.height = height;
  var ctx = canvas$1.getContext('2d');
  ctx.drawImage(image, 0, 0, width, height);
  return ctx.getImageData(0, 0, width, height).data;
}

function generateImage$1(image) {
  if (!image) {
    return null;
  }

  var img;

  if (typeof image === 'string') {
    img = new Image();
    img.src = image;
  } else if (image instanceof HTMLCanvasElement) {
    img = new Image();
    img.src = image.toDataURL();
  } else if (image instanceof Image) {
    img = new Image();
    img.src = image.src;
    img.crossOrigin = image.crossOrigin;
  }

  if (img && !img.crossOrigin) {
    img.crossOrigin = 'Anonymous';
  }

  return img;
}

var OPTIONS$e = {
  interactive: false,
  altitude: 0,
  image: null,
  imageWidth: 256,
  imageHeight: 256,
  texture: null
};
/**
 *
 */

var Terrain = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(Terrain, _BaseObject);

  function Terrain(extent, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$e, options, {
      layer: layer,
      extent: extent
    });
    var _options = options,
        texture = _options.texture,
        image = _options.image,
        altitude = _options.altitude,
        imageHeight = _options.imageHeight,
        imageWidth = _options.imageWidth;

    if (!image) {
      console.error('not find image');
    }

    if (!(extent instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Extent"])) {
      extent = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Extent"](extent);
    }

    var _extent = extent,
        xmin = _extent.xmin,
        ymin = _extent.ymin,
        xmax = _extent.xmax,
        ymax = _extent.ymax;
    var coords = [[xmin, ymin], [xmin, ymax], [xmax, ymax], [xmax, ymin]];
    var vxmin = Infinity,
        vymin = Infinity,
        vxmax = -Infinity,
        vymax = -Infinity;
    coords.forEach(function (coord) {
      var v = layer.coordinateToVector3(coord);
      var x = v.x,
          y = v.y;
      vxmin = Math.min(x, vxmin);
      vymin = Math.min(y, vymin);
      vxmax = Math.max(x, vxmax);
      vymax = Math.max(y, vymax);
    });
    var w = Math.abs(vxmax - vxmin),
        h = Math.abs(vymax - vymin);
    var rgbImg = generateImage$1(image),
        img = generateImage$1(texture);
    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["PlaneBufferGeometry"](w, h, imageWidth - 1, imageHeight - 1);
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    _this._createMesh(geometry, material);

    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(extent.getCenter(), z);

    _this.getObject3d().position.copy(v);

    material.transparent = true;

    if (rgbImg) {
      material.opacity = 0;

      rgbImg.onload = function () {
        var width = imageWidth,
            height = imageHeight;
        var imgdata = getRGBData(rgbImg, width, height);
        var idx = 0; //rgb to height  https://docs.mapbox.com/help/troubleshooting/access-elevation-data/

        for (var i = 0, len = imgdata.length; i < len; i += 4) {
          var R = imgdata[i],
              G = imgdata[i + 1],
              B = imgdata[i + 2];

          var _height = -10000 + (R * 256 * 256 + G * 256 + B) * 0.1;

          var _z = layer.distanceToVector3(_height, _height).x;
          geometry.attributes.position.array[idx * 3 + 2] = _z;
          idx++;
        }

        geometry.attributes.position.needsUpdate = true;

        if (img) {
          textureLoader.load(img.src, function (texture) {
            material.map = texture;
            material.opacity = 1;
            material.needsUpdate = true;
          });
        } else {
          material.opacity = 1;
        }
      };

      rgbImg.onerror = function () {
        console.error("not load " + rgbImg.src);
      };
    }

    return _this;
  }

  return Terrain;
}(BaseObject$$1);

var OPTIONS$f = {
  // worker: false
  scale: 1
};
/**
 *
 */

var TerrainVectorTileLayer = /*#__PURE__*/function (_BaseVectorTileLayer) {
  _inheritsLoose(TerrainVectorTileLayer, _BaseVectorTileLayer);

  function TerrainVectorTileLayer(url, options, material, layer) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _BaseVectorTileLayer.call(this, maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].GUID(), maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({
      urlTemplate: url
    }, OPTIONS$f, options)) || this;
    _this._opts = options;
    _this._layer = layer;
    _this.material = material;
    _this._baseObjectKeys = {};
    _this._loadTiles = {};
    _this._add = null;
    _this._imgQueue = {};
    _this._layerLaodTime = new Date().getTime();

    _this._init();

    return _this;
  }

  var _proto = TerrainVectorTileLayer.prototype;

  _proto.isAsynchronous = function isAsynchronous() {
    return false;
  }
  /**
   * this is can override
   * @param {*} index
   * @param {*} json
   */
  ;

  _proto.formatBaseObjects = function formatBaseObjects(index, image) {
    var opts = this.options,
        baseobjects = [];
    var scale = opts.scale;

    var _this$_getXYZOfIndex = this._getXYZOfIndex(index),
        x = _this$_getXYZOfIndex.x,
        y = _this$_getXYZOfIndex.y,
        z = _this$_getXYZOfIndex.z;

    var zoom = this.getMap().getZoom();
    var textUrl = this.getTileUrl(x, y, z);
    var _this$options$tileSiz = this.options.tileSize,
        imageWidth = _this$options$tileSiz[0],
        imageHeight = _this$options$tileSiz[1];

    var extent = this._getTileLngLatExtent(x, y, z);

    var material = this.material.clone();

    if (z + 1 >= Math.round(zoom)) {
      var terrain = new Terrain(extent, {
        image: image,
        imageWidth: imageWidth / 8,
        imageHeight: imageHeight / 8,
        texture: textUrl
      }, material, this._layer);
      terrain.getObject3d().scale.set(scale, scale, 1);
      baseobjects.push(terrain);
    }

    return baseobjects;
  } //queue loop
  ;

  _proto.loopMessage = function loopMessage(q) {
    this.getTileData(q);
  };

  _proto._init = function _init() {
    var _this2 = this;

    this.on('layerload', this._layerOnLoad);
    this.on('add', function () {
      if (_this2._add === false) {
        var baseobjects = _this2.getBaseObjects();

        _this2._layer.addMesh(baseobjects);
      }

      _this2._add = true;
      /**
       * layerload have a bug ,Sometimes it doesn't trigger,I don't know why
       * Add heartbeat detection mechanism
       */

      _this2.intervalId = setInterval(function () {
        if (_this2._isLoad() && !_this2._layer.getMap().isInteracting()) {
          _this2.fire('layerload');
        }
      }, 1000);
    });
    this.on('remove', function () {
      _this2._add = false;

      var baseobjects = _this2.getBaseObjects();

      _this2._layer.removeMesh(baseobjects);

      clearInterval(_this2.intervalId);
    });
    this.on('show', function () {
      var baseobjects = _this2.getBaseObjects();

      baseobjects.forEach(function (baseobject) {
        baseobject.show();
      });

      for (var key in _this2._baseObjectKeys) {
        var _baseobjects = _this2._baseObjectKeys[key] || [];

        _baseobjects.forEach(function (baseobject) {
          baseobject.show();
        });
      }
    });
    this.on('hide', function () {
      var baseobjects = _this2.getBaseObjects();

      baseobjects.forEach(function (baseobject) {
        baseobject.hide();
      });

      for (var key in _this2._baseObjectKeys) {
        var _baseobjects2 = _this2._baseObjectKeys[key] || [];

        _baseobjects2.forEach(function (baseobject) {
          baseobject.hide();
        });
      }
    });
    this.on('renderercreate', function (e) {
      e.renderer.loadTile = function loadTile(tile) {
        var tileSize = this.layer.getTileSize();
        var tileImage = new Image();
        tileImage.width = tileSize['width'];
        tileImage.height = tileSize['height'];
        tileImage.onload = this.onTileLoad.bind(this, tileImage, tile);
        tileImage.onerror = this.onTileError.bind(this, tileImage, tile);
        this.loadTileImage(tileImage, tile['url'], tile.dupKey);
        return tileImage;
      };

      e.renderer.deleteTile = function (tile) {
        if (!tile || !tile.image) {
          return;
        }

        tile.image.onload = null;
        tile.image.onerror = null;
        var tileinfo = tile.info || {};
        var rgbImage = _this2._imgQueue[tileinfo.dupKey];

        if (rgbImage) {
          rgbImage.src = '';
          rgbImage.onload = null;
          rgbImage.onerror = null;
          delete _this2._imgQueue[tileinfo.dupKey];
        }
      };

      e.renderer.loadTileImage = function (img, url, key) {
        img._key = key;
        var rgbImage = new Image();
        _this2._imgQueue[key] = rgbImage;
        var q = {
          key: key,
          url: url,
          rgbImage: rgbImage,
          callback: function callback(index, rgbImage, image) {
            _this2._generateBaseObjects(index, rgbImage, image);
          },
          img: img,
          vt: _this2
        };

        _this2.loopMessage(q);
      };
    });
  };

  return TerrainVectorTileLayer;
}(BaseVectorTileLayer);

/*!
 * Code from baidu mapv
 * License: BSD-3
 * https://github.com/huiyan-fe/mapv
 *
 */
/**
 * Category
 * @param {Object} [options]   Available options:
 *                             {Object} gradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"}
 */

function Intensity(options) {
  options = options || {};
  this.gradient = options.gradient || {
    0.25: 'rgba(0, 0, 255, 1)',
    0.55: 'rgba(0, 255, 0, 1)',
    0.85: 'rgba(255, 255, 0, 1)',
    1.0: 'rgba(255, 0, 0, 1)'
  };
  this.maxSize = options.maxSize || 35;
  this.minSize = options.minSize || 0;
  this.max = options.max || 100;
  this.min = options.min || 0;
  this.initPalette();
}

Intensity.prototype.setMax = function (value) {
  this.max = value || 100;
};

Intensity.prototype.setMin = function (value) {
  this.min = value || 0;
};

Intensity.prototype.setMaxSize = function (maxSize) {
  this.maxSize = maxSize || 35;
};

Intensity.prototype.setMinSize = function (minSize) {
  this.minSize = minSize || 0;
};

Intensity.prototype.initPalette = function () {
  var gradient = this.gradient;
  var canvas = new Canvas(256, 1);
  var paletteCtx = this.paletteCtx = canvas.getContext('2d');
  var lineGradient = paletteCtx.createLinearGradient(0, 0, 256, 1);

  for (var key in gradient) {
    lineGradient.addColorStop(parseFloat(key), gradient[key]);
  }

  paletteCtx.fillStyle = lineGradient;
  paletteCtx.fillRect(0, 0, 256, 1);
};

Intensity.prototype.getColor = function (value) {
  var imageData = this.getImageData(value);
  return 'rgba(' + imageData[0] + ', ' + imageData[1] + ', ' + imageData[2] + ', ' + imageData[3] / 256 + ')';
};

Intensity.prototype.getImageData = function (value) {
  var imageData = this.paletteCtx.getImageData(0, 0, 256, 1).data;

  if (value === undefined) {
    return imageData;
  }

  var max = this.max;
  var min = this.min;

  if (value > max) {
    value = max;
  }

  if (value < min) {
    value = min;
  }

  var index = Math.floor((value - min) / (max - min) * (256 - 1)) * 4;
  return [imageData[index], imageData[index + 1], imageData[index + 2], imageData[index + 3]];
};
/**
 * @param Number value 
 * @param Number max of value
 * @param Number max of size
 * @param Object other options
 */


Intensity.prototype.getSize = function (value) {
  var size = 0;
  var max = this.max;
  var min = this.min;
  var maxSize = this.maxSize;
  var minSize = this.minSize;

  if (value > max) {
    value = max;
  }

  if (value < min) {
    value = min;
  }

  if (max > min) {
    size = minSize + (value - min) / (max - min) * (maxSize - minSize);
  } else {
    return maxSize;
  }

  return size;
};

Intensity.prototype.getLegend = function (options) {
  var gradient = this.gradient;
  var width = options.width || 20;
  var height = options.height || 180;
  var canvas = new Canvas(width, height);
  var paletteCtx = canvas.getContext('2d');
  var lineGradient = paletteCtx.createLinearGradient(0, height, 0, 0);

  for (var key in gradient) {
    lineGradient.addColorStop(parseFloat(key), gradient[key]);
  }

  paletteCtx.fillStyle = lineGradient;
  paletteCtx.fillRect(0, 0, width, height);
  return canvas;
};

/*!
 * Code from baidu mapv
 * License: BSD-3
 * https://github.com/huiyan-fe/mapv
 *
 */

function createCircle(size) {
  var shadowBlur = size / 2;
  var r2 = size + shadowBlur;
  var offsetDistance = 10000;
  var circle = new Canvas(r2 * 2, r2 * 2);
  var context = circle.getContext('2d');
  context.shadowBlur = shadowBlur;
  context.shadowColor = 'black';
  context.shadowOffsetX = context.shadowOffsetY = offsetDistance;
  context.beginPath();
  context.arc(r2 - offsetDistance, r2 - offsetDistance, size, 0, Math.PI * 2, true);
  context.closePath();
  context.fill();
  return circle;
}

function colorize(pixels, gradient, options) {
  var max = getMax(options);
  var min = getMin(options);
  var diff = max - min;
  var range = options.range || null;
  var jMin = 0;
  var jMax = 1024;

  if (range && range.length === 2) {
    jMin = (range[0] - min) / diff * 1024;
  }

  if (range && range.length === 2) {
    jMax = (range[1] - min) / diff * 1024;
  }

  var maxOpacity = options.maxOpacity || 0.8;
  var minOpacity = options.minOpacity || 0; // var range = options.range;

  for (var i = 3, len = pixels.length, j; i < len; i += 4) {
    j = pixels[i] * 4; // get gradient color from opacity value

    if (pixels[i] / 256 > maxOpacity) {
      pixels[i] = 256 * maxOpacity;
    }

    if (pixels[i] / 256 < minOpacity) {
      pixels[i] = 256 * minOpacity;
    }

    if (j && j >= jMin && j <= jMax) {
      pixels[i - 3] = gradient[j];
      pixels[i - 2] = gradient[j + 1];
      pixels[i - 1] = gradient[j + 2];
    } else {
      pixels[i] = 0;
    }
  }
}

function getMax(options) {
  var max = options.max || 100;
  return max;
}

function getMin(options) {
  var min = options.min || 0;
  return min;
}

function drawGray(context, dataSet, options) {
  var max = getMax(options); // var min = getMin(options);
  // console.log(max)

  var size = options._size || options.size || 13;
  var circle = createCircle(size);
  var circleHalfWidth = circle.width / 2;
  var circleHalfHeight = circle.height / 2;
  var data = dataSet;
  var dataOrderByAlpha = {};
  data.forEach(function (item) {
    var count = item.count === undefined ? 1 : item.count;
    var alpha = Math.min(1, count / max).toFixed(2);
    dataOrderByAlpha[alpha] = dataOrderByAlpha[alpha] || [];
    dataOrderByAlpha[alpha].push(item);
  });

  for (var i in dataOrderByAlpha) {
    if (isNaN(i)) continue;
    var _data = dataOrderByAlpha[i];
    context.beginPath();

    if (!options.withoutAlpha) {
      context.globalAlpha = i;
    } // context.strokeStyle = intensity.getColor(i * max);


    _data.forEach(function (item) {
      var coordinates = item.coordinate;
      var count = item.count === undefined ? 1 : item.count;
      context.globalAlpha = count / max;
      context.drawImage(circle, coordinates[0] - circleHalfWidth, coordinates[1] - circleHalfHeight);
    });
  }
}

function draw$1(context, data, options) {
  if (context.canvas.width <= 0 || context.canvas.height <= 0) {
    return;
  }

  var strength = options.strength || 0.3;
  context.strokeStyle = 'rgba(0,0,0,' + strength + ')'; // var shadowCanvas = new Canvas(context.canvas.width, context.canvas.height);

  var shadowCanvas = new Canvas(context.canvas.width, context.canvas.height);
  var shadowContext = shadowCanvas.getContext('2d');
  shadowContext.scale(devicePixelRatio, devicePixelRatio);
  options = options || {}; // var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;

  context.save();
  var intensity = new Intensity({
    gradient: options.gradient
  });
  drawGray(shadowContext, data, options); // return false;

  if (!options.absolute) {
    var colored = shadowContext.getImageData(0, 0, context.canvas.width, context.canvas.height);
    colorize(colored.data, intensity.getImageData(), options);
    context.putImageData(colored, 0, 0);
    context.restore();
  }

  intensity = null;
  shadowCanvas = null;
}

var HeatMapUitl = {
  draw: draw$1,
  drawGray: drawGray,
  colorize: colorize
};

var OPTIONS$g = {
  interactive: false,
  min: 0,
  max: 100,
  size: 13,
  gradient: {
    0.25: 'rgb(0,0,255)',
    0.55: 'rgb(0,255,0)',
    0.85: 'yellow',
    1.0: 'rgb(255,0,0)'
  },
  gridScale: 0.5
};
var CANVAS_MAX_SIZE = 2048;
/**
 *
 */

var HeatMap = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(HeatMap, _BaseObject);

  function HeatMap(data, options, material, layer) {
    var _this;

    if (!Array.isArray(data)) {
      data = [data];
    }

    var minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
    var vs = []; //Calculate bbox

    for (var i = 0, len = data.length; i < len; i++) {
      var _data$i = data[i],
          coordinate = _data$i.coordinate,
          lnglat = _data$i.lnglat,
          xy = _data$i.xy;
      var coord = coordinate || lnglat || xy;

      if (!coord) {
        console.warn('not find coordinate');
        continue;
      }

      var v = layer.coordinateToVector3(coord);
      vs.push(v);
      var x = v.x,
          y = v.y;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    }

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$g, options, {
      layer: layer,
      points: data
    }); // Calculate canvas width and height

    var _options = options,
        gridScale = _options.gridScale,
        altitude = _options.altitude;
    var offsetX = Math.abs(maxX - minX),
        offsetY = Math.abs(maxY - minY);
    var maxOffset = Math.max(offsetX * gridScale, offsetY * gridScale);

    if (maxOffset > CANVAS_MAX_SIZE) {
      console.warn("gridScale: " + gridScale + " it's too big. I hope it's a smaller value,canvas max size is " + CANVAS_MAX_SIZE + "* " + CANVAS_MAX_SIZE);
      var offset = maxOffset / gridScale;
      gridScale = CANVAS_MAX_SIZE / offset;
    }

    var canvasWidth = Math.ceil(offsetX * gridScale),
        canvasHeight = Math.ceil(offsetY * gridScale);
    var scaleX = canvasWidth / offsetX,
        scaleY = canvasHeight / offsetY;
    var pixels = [];

    for (var _i = 0, _len = vs.length; _i < _len; _i++) {
      var _v = vs[_i];
      _v.x -= minX;
      _v.y -= minY;
      _v.x *= scaleX;
      _v.y *= scaleY;
      _v.y = canvasHeight - _v.y; //for heat draw data

      pixels.push({
        coordinate: [_v.x, _v.y],
        count: data[_i].count
      });
    }

    var shadowCanvas = new Canvas(canvasWidth, canvasHeight);
    var shadowContext = shadowCanvas.getContext('2d'); // shadowContext.scale(devicePixelRatio, devicePixelRatio);

    HeatMapUitl.drawGray(shadowContext, pixels, options);
    var colored = shadowContext.getImageData(0, 0, shadowContext.canvas.width, shadowContext.canvas.height);
    var maxAlpha = -Infinity;
    var blackps = {},
        alphas = [];

    for (var _i2 = 3, _len2 = colored.data.length, j = 0; _i2 < _len2; _i2 += 4) {
      var alpha = colored.data[_i2];
      maxAlpha = Math.max(maxAlpha, alpha);
      alphas.push(alpha); //Points that do not need to be drawn

      if (alpha <= 0) {
        blackps[j] = 1;
      }

      j++;
    }

    var intensity = new Intensity({
      gradient: options.gradient
    });
    HeatMapUitl.colorize(colored.data, intensity.getImageData(), options);
    shadowCanvas = null;
    shadowContext = null;
    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["PlaneBufferGeometry"](offsetX, offsetY, canvasWidth - 1, canvasHeight - 1);
    var index = geometry.getIndex().array;
    var position = geometry.attributes.position.array; // Index of the points that really need to be drawn

    var filterIndex = [];
    var colors = [];
    var color = new three__WEBPACK_IMPORTED_MODULE_1__["Color"]();

    for (var _i3 = 0, _len3 = position.length, _j = 0, len1 = index.length, m = 0, len2 = colored.data.length, n = 0; _i3 < Math.max(_len3, len1, len2); _i3 += 3) {
      if (_i3 < _len3) {
        var _alpha = alphas[n];

        if (_alpha > 0) {
          position[_i3 + 2] = _alpha / maxAlpha;
        }
      }

      if (_j < len1) {
        var a = index[_j],
            b = index[_j + 1],
            c = index[_j + 2];

        if (!blackps[a] || !blackps[b] || !blackps[c]) {
          filterIndex.push(a, b, c);
        }
      }

      if (m < len2) {
        var r = colored.data[m],
            g = colored.data[m + 1],
            _b = colored.data[m + 2]; // a = colored.data[i + 3];

        var rgb = "rgb(" + r + "," + g + "," + _b + ")";
        color.setStyle(rgb);
        colors.push(color.r, color.g, color.b);
      }

      _j += 3;
      m += 4;
      n++;
    }

    geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_1__["Uint32BufferAttribute"](filterIndex, 1));
    addAttribute(geometry, 'color', new three__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](colors, 3, true));
    material.vertexColors = three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"];
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    _this._createMesh(geometry, material);

    var z = layer.distanceToVector3(altitude, altitude).x;

    _this.getObject3d().position.copy(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]((minX + maxX) / 2, (minY + maxY) / 2, z));

    return _this;
  }

  return HeatMap;
}(BaseObject$$1);

var color = new three__WEBPACK_IMPORTED_MODULE_1__["Color"]();
var colorIndex = 1;
/**
 *https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_cubes_gpu.html
 */

var GPUPick = /*#__PURE__*/function () {
  function GPUPick(layer) {
    this.object3ds = [];
    this.layer = layer;
    this.camera = layer.getCamera();
    this.renderer = layer.getThreeRenderer();
    this.pickingTexture = new three__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderTarget"](1, 1);
    this.pickingScene = new three__WEBPACK_IMPORTED_MODULE_1__["Scene"]();
  }

  var _proto = GPUPick.prototype;

  _proto.getColor = function getColor() {
    color.setHex(colorIndex);
    colorIndex++;
    return color;
  };

  _proto.add = function add(object3d) {
    if (object3d) {
      var _colorIndex = object3d._colorIndex;

      if (_colorIndex) {
        this.object3ds[_colorIndex] = object3d;
        this.pickingScene.add(object3d);
      }
    }

    return this;
  };

  _proto.remove = function remove(object3d) {
    if (object3d) {
      var _colorIndex2 = object3d._colorIndex;

      if (_colorIndex2) {
        this.object3ds[_colorIndex2] = null;
        this.pickingScene.remove(object3d);
      }
    }

    return this;
  };

  _proto.isEmpty = function isEmpty() {
    if (this.pickingScene.children.length === 0) {
      return true;
    }

    for (var i = 0, len = this.pickingScene.children.length; i < len; i++) {
      var mesh = this.pickingScene.children[i];

      if (mesh) {
        var object3d = mesh.__parent;

        if (object3d && object3d.getOptions().interactive === true) {
          return false;
        }
      }
    }

    return true;
  };

  _proto.pick = function pick(pixel) {
    if (!pixel) {
      return;
    }

    if (this.isEmpty()) {
      return;
    }

    var camera = this.camera,
        renderer$$1 = this.renderer,
        pickingTexture = this.pickingTexture,
        pickingScene = this.pickingScene,
        object3ds = this.object3ds,
        layer = this.layer;
    var len = this.pickingScene.children.length; // reset all object3d picked

    for (var i = 0; i < len; i++) {
      var _object3d = this.pickingScene.children[i];

      if (_object3d && _object3d.__parent) {
        _object3d.__parent.picked = false;
      }
    } //resize size


    var _layer$_getRenderer$c = layer._getRenderer().canvas,
        width = _layer$_getRenderer$c.width,
        height = _layer$_getRenderer$c.height;

    var pw = pickingTexture.width,
        ph = pickingTexture.height;

    if (width !== pw || height !== ph) {
      pickingTexture.setSize(width, height);
    } //render the picking scene off-screen
    // set the view offset to represent just a single pixel under the mouse
    // camera.setViewOffset(width, height, mouse.x, mouse.y, 1, 1);
    // render the scene


    renderer$$1.setRenderTarget(pickingTexture);
    renderer$$1.clear();
    renderer$$1.render(pickingScene, camera); // clear the view offset so rendering returns to normal
    // camera.clearViewOffset();
    //create buffer for reading single pixel

    var pixelBuffer = new Uint8Array(4); //read the pixel

    var x = pixel.x,
        y = pixel.y;
    var devicePixelRatio = window.devicePixelRatio;
    var offsetX = x * devicePixelRatio,
        offsetY = pickingTexture.height - y * devicePixelRatio;
    renderer$$1.readRenderTargetPixels(pickingTexture, Math.round(offsetX), Math.round(offsetY), 1, 1, pixelBuffer); //interpret the pixel as an ID

    var id = pixelBuffer[0] << 16 | pixelBuffer[1] << 8 | pixelBuffer[2];
    var object3d = object3ds[id];

    if (object3d) {
      if (object3d.__parent) {
        object3ds[id].__parent.picked = true;
      }
    } else {
      //for merged mesh
      for (var _i = 0; _i < len; _i++) {
        var _object3d2 = this.pickingScene.children[_i];

        if (_object3d2 && _object3d2.__parent) {
          var parent = _object3d2.__parent;

          if (parent._colorMap && parent._colorMap[id] != null) {
            parent.picked = true;
            parent.index = parent._colorMap[id];
            break;
          }
        }
      }
    }

    renderer$$1.setRenderTarget(null);
  };

  return GPUPick;
}();

var OPTIONS$h = {
  altitude: 0
};

var FatLine = /*#__PURE__*/function (_BaseObject) {
  _inheritsLoose(FatLine, _BaseObject);

  function FatLine(lineString, options, material, layer) {
    var _this;

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$h, options, {
      layer: layer,
      lineString: lineString
    });
    _this = _BaseObject.call(this) || this;

    _this._initOptions(options);

    var _LineStringSplit = LineStringSplit(lineString),
        lineStrings = _LineStringSplit.lineStrings,
        center = _LineStringSplit.center;

    var ps = [];

    for (var m = 0, le = lineStrings.length; m < le; m++) {
      var positionsV = getLinePosition(lineStrings[m], layer, center).positionsV;

      for (var i = 0, len = positionsV.length; i < len; i++) {
        var _v = positionsV[i];

        if (i > 0 && i < len - 1) {
          ps.push(_v.x, _v.y, _v.z);
        }

        ps.push(_v.x, _v.y, _v.z);
      }
    }

    var geometry = new LineGeometry();
    geometry.setPositions(ps);

    _this._setMaterialRes(layer, material);

    _this._createLine2(geometry, material);

    var _options = options,
        altitude = _options.altitude;
    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v);

    _this._setPickObject3d(ps, material.linewidth);

    _this._init();

    return _this;
  }

  var _proto = FatLine.prototype;

  _proto._init = function _init() {
    var _this2 = this;

    var pick = this.getLayer().getPick();
    this.on('add', function () {
      pick.add(_this2.pickObject3d);
    });
    this.on('remove', function () {
      pick.remove(_this2.pickObject3d);
    });
  };

  _proto._setMaterialRes = function _setMaterialRes(layer, material) {
    var map = layer.getMap();
    var size = map.getSize();
    var width = size.width,
        height = size.height;
    material.resolution.set(width, height);
  };

  _proto._setPickObject3d = function _setPickObject3d(ps, linewidth) {
    var geometry = new LineGeometry();
    geometry.setPositions(ps);
    var pick = this.getLayer().getPick();
    var color = pick.getColor();
    var colors = [];

    for (var i = 0, len = ps.length / 3; i < len; i++) {
      colors.push(color.r, color.g, color.b);
    }

    geometry.setColors(colors);
    var material = new LineMaterial({
      color: '#fff',
      // side: THREE.BackSide,
      linewidth: linewidth,
      vertexColors: three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"]
    });

    this._setMaterialRes(this.getLayer(), material);

    var colorIndex = color.getHex();
    var mesh = new Line2(geometry, material);
    mesh.position.copy(this.getObject3d().position);
    mesh._colorIndex = colorIndex;
    this.setPickObject3d(mesh);
  } // eslint-disable-next-line no-unused-vars
  ;

  _proto.identify = function identify(coordinate) {
    return this.picked;
  };

  _proto.setSymbol = function setSymbol(material) {
    if (material && material instanceof three__WEBPACK_IMPORTED_MODULE_1__["Material"]) {
      material.needsUpdate = true;
      var size = this.getMap().getSize();
      var width = size.width,
          height = size.height;
      material.resolution.set(width, height);
      this.getObject3d().material = material;
    }

    return this;
  };

  return FatLine;
}(BaseObject$$1);

var OPTIONS$i = {
  altitude: 0,
  colors: null
};
/**
 *
 */

var FatLines = /*#__PURE__*/function (_MergedMixin) {
  _inheritsLoose(FatLines, _MergedMixin);

  function FatLines(lineStrings, options, material, layer) {
    var _this;

    if (!Array.isArray(lineStrings)) {
      lineStrings = [lineStrings];
    }

    var centers = [],
        lineStringList = [];
    var len = lineStrings.length;

    for (var i = 0; i < len; i++) {
      var lineString = lineStrings[i];
      var result = LineStringSplit(lineString);
      centers.push(result.center);
      lineStringList.push(result.lineStrings);
    } // Get the center point of the point set


    var center = getCenterOfPoints(centers);
    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, OPTIONS$i, options, {
      layer: layer,
      lineStrings: lineStrings,
      coordinate: center
    });
    var lines = [];
    var faceIndex = 0,
        faceMap = [],
        geometriesAttributes = [],
        psIndex = 0,
        ps = []; //LineSegmentsGeometry

    for (var _i = 0; _i < len; _i++) {
      var lls = lineStringList[_i];
      var psCount = 0;

      for (var m = 0, le = lls.length; m < le; m++) {
        var _getLinePosition = getLinePosition(lls[m], layer, center),
            positionsV = _getLinePosition.positionsV;

        psCount += positionsV.length * 2 - 2;

        for (var j = 0, len1 = positionsV.length; j < len1; j++) {
          var _v = positionsV[j];

          if (j > 0 && j < len1 - 1) {
            ps.push(_v.x, _v.y, _v.z);
          }

          ps.push(_v.x, _v.y, _v.z);
        }
      } // const psCount = positionsV.length + positionsV.length - 2;


      var faceLen = psCount;
      faceMap[_i] = [faceIndex, faceIndex + faceLen];
      faceIndex += faceLen;
      geometriesAttributes[_i] = {
        position: {
          count: psCount,
          start: psIndex,
          end: psIndex + psCount * 3
        },
        instanceStart: {
          count: psCount,
          start: psIndex,
          end: psIndex + psCount * 3
        },
        instanceEnd: {
          count: psCount,
          start: psIndex,
          end: psIndex + psCount * 3
        },
        hide: false
      };
      psIndex += psCount * 3;
    }

    _this = _MergedMixin.call(this) || this;

    _this._initOptions(options);

    var geometry = new LineGeometry();
    geometry.setPositions(ps);

    _this._setMaterialRes(layer, material);

    _this._createLine2(geometry, material);

    var _options = options,
        altitude = _options.altitude;
    var z = layer.distanceToVector3(altitude, altitude).x;
    var v = layer.coordinateToVector3(center, z);

    _this.getObject3d().position.copy(v);

    _this._faceMap = faceMap;
    _this._baseObjects = lines;
    _this._datas = lineStrings;
    _this._geometriesAttributes = geometriesAttributes;
    _this.faceIndex = null;
    _this.index = null;
    _this._geometryCache = new LineGeometry();

    _this._geometryCache.setPositions(ps);

    _this._colorMap = {};
    _this.isHide = false;

    _this._initBaseObjectsEvent(lines);

    _this._setPickObject3d(ps, material.linewidth);

    _this._init();

    return _this;
  }

  var _proto = FatLines.prototype;

  _proto._init = function _init() {
    var _this2 = this;

    var pick = this.getLayer().getPick();
    this.on('add', function () {
      pick.add(_this2.pickObject3d);
    });
    this.on('remove', function () {
      pick.remove(_this2.pickObject3d);
    });
  };

  _proto._setMaterialRes = function _setMaterialRes(layer, material) {
    var map = layer.getMap();
    var size = map.getSize();
    var width = size.width,
        height = size.height;
    material.resolution.set(width, height);
  };

  _proto._setPickObject3d = function _setPickObject3d(ps, linewidth) {
    var geometry = new LineGeometry();
    geometry.setPositions(ps);
    var pick = this.getLayer().getPick();
    var _geometriesAttributes = this._geometriesAttributes;
    var colors = [];

    for (var i = 0, _len = _geometriesAttributes.length; i < _len; i++) {
      var _color = pick.getColor();

      var _colorIndex = _color.getHex();

      this._colorMap[_colorIndex] = i;
      var count = _geometriesAttributes[i].position.count;
      this._datas[i].colorIndex = _colorIndex;

      for (var j = 0; j < count; j++) {
        colors.push(_color.r, _color.g, _color.b);
      }
    }

    geometry.setColors(colors);
    var material = new LineMaterial({
      // color: color.getStyle(),
      // side: THREE.BackSide,
      color: '#fff',
      linewidth: linewidth,
      vertexColors: three__WEBPACK_IMPORTED_MODULE_1__["VertexColors"] // dashed: false

    });

    this._setMaterialRes(this.getLayer(), material);

    var color = pick.getColor();
    var colorIndex = color.getHex();
    var mesh = new Line2(geometry, material);
    mesh.position.copy(this.getObject3d().position);
    mesh._colorIndex = colorIndex;
    this.setPickObject3d(mesh);
  } // eslint-disable-next-line no-unused-vars
  ;

  _proto.identify = function identify(coordinate) {
    return this.picked;
  };

  _proto.setSymbol = function setSymbol(material) {
    if (material && material instanceof three__WEBPACK_IMPORTED_MODULE_1__["Material"]) {
      material.needsUpdate = true;
      var size = this.getMap().getSize();
      var width = size.width,
          height = size.height;
      material.resolution.set(width, height);
      this.getObject3d().material = material;
    }

    return this;
  } // eslint-disable-next-line consistent-return
  ;

  _proto.getSelectMesh = function getSelectMesh() {
    var index = this._getIndex();

    if (index != null) {
      if (!this._baseObjects[index]) {
        var lineString = this._datas[index];
        var opts = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, this.getOptions(), {
          index: index
        }, isGeoJSONLine(lineString) ? lineString.properties : lineString.getProperties());
        this._baseObjects[index] = new FatLine(lineString, opts, this.getObject3d().material, this.getLayer());

        this._proxyEvent(this._baseObjects[index]);
      }

      return {
        data: this._datas[index],
        baseObject: this._baseObjects[index]
      };
    }
  } // eslint-disable-next-line consistent-return
  ;

  _proto._getIndex = function _getIndex(faceIndex) {
    if (faceIndex == null) {
      faceIndex = this.faceIndex || this.index;
    }

    return faceIndex;
  }
  /**
     * update geometry attributes
     * @param {*} bufferAttribute
     * @param {*} attribute
     */
  ;

  _proto._updateAttribute = function _updateAttribute(bufferAttribute, attribute) {
    var _this$_getHideGeometr = this._getHideGeometryIndex(attribute),
        indexs = _this$_getHideGeometr.indexs;

    var array = this._geometryCache.attributes[attribute].array;
    var len = array.length;

    for (var i = 0; i < len; i++) {
      bufferAttribute.array[i] = array[i];
    }

    var value = -100000;

    for (var j = 0; j < indexs.length; j++) {
      var index = indexs[j];
      var _this$_geometriesAttr = this._geometriesAttributes[index][attribute],
          start = _this$_geometriesAttr.start,
          end = _this$_geometriesAttr.end;

      for (var _i2 = start; _i2 < end; _i2++) {
        bufferAttribute.array[_i2] = value;
      }
    }

    return this;
  };

  _proto._showGeometry = function _showGeometry(baseObject, isHide) {
    var index;

    if (baseObject) {
      index = baseObject.getOptions().index;
    }

    if (index != null) {
      var geometryAttributes = this._geometriesAttributes[index];
      var hide = geometryAttributes.hide;

      if (hide === isHide) {
        return this;
      }

      geometryAttributes.hide = isHide;
      var buffGeom = this.getObject3d().geometry;

      this._updateAttribute(buffGeom.attributes.instanceStart, 'instanceStart');

      this._updateAttribute(buffGeom.attributes.instanceEnd, 'instanceEnd'); // this._updateAttribute(buffGeom.attributes.instanceDistanceStart, 'instanceDistanceStart');
      // this._updateAttribute(buffGeom.attributes.instanceDistanceEnd, 'instanceDistanceEnd');


      buffGeom.attributes.instanceStart.data.needsUpdate = true;
      buffGeom.attributes.instanceEnd.data.needsUpdate = true; // buffGeom.attributes.instanceDistanceStart.data.needsUpdate = true;
      // buffGeom.attributes.instanceDistanceEnd.data.needsUpdate = true;

      this.isHide = isHide;
    }

    return this;
  };

  return FatLines;
}(MergedMixin(BaseObject$$1));

var options = {
  'renderer': 'gl',
  'doubleBuffer': false,
  'glOptions': null,
  'geometryEvents': true,
  'identifyCountOnEvent': 0
};
var RADIAN = Math.PI / 180;
var LINEPRECISIONS = [[4000, 220], [2000, 100], [1000, 30], [500, 15], [100, 5], [50, 2], [10, 1], [5, 0.7], [2, 0.1], [1, 0.05], [0.5, 0.02]];
var EVENTS$1 = ['mousemove', 'click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'touchstart', 'touchmove', 'touchend']; // const MATRIX4 = new THREE.Matrix4();

/**
 * A Layer to render with THREE.JS (http://threejs.org), the most popular library for WebGL. <br>
 *
 * @classdesc
 * A layer to render with THREE.JS
 * @example
 *  var layer = new maptalks.ThreeLayer('three');
 *
 *  layer.prepareToDraw = function (gl, scene, camera) {
 *      var size = map.getSize();
 *      return [size.width, size.height]
 *  };
 *
 *  layer.draw = function (gl, view, scene, camera, width,height) {
 *      //...
 *  };
 *  layer.addTo(map);
 * @class
 * @category layer
 * @extends {maptalks.CanvasLayer}
 * @param {String|Number} id - layer's id
 * @param {Object} options - options defined in [options]{@link maptalks.ThreeLayer#options}
 */

var ThreeLayer = /*#__PURE__*/function (_maptalks$CanvasLayer) {
  _inheritsLoose(ThreeLayer, _maptalks$CanvasLayer);

  function ThreeLayer() {
    return _maptalks$CanvasLayer.apply(this, arguments) || this;
  }

  var _proto = ThreeLayer.prototype;

  /**
   * Draw method of ThreeLayer
   * In default, it calls renderScene, refresh the camera and the scene
   */
  _proto.draw = function draw() {
    this.renderScene();
  }
  /**
   * Draw method of ThreeLayer when map is interacting
   * In default, it calls renderScene, refresh the camera and the scene
   */
  ;

  _proto.drawOnInteracting = function drawOnInteracting() {
    this.renderScene();
  }
  /**
   * Convert a geographic coordinate to THREE Vector3
   * @param  {maptalks.Coordinate} coordinate - coordinate
   * @param {Number} [z=0] z value
   * @return {THREE.Vector3}
   */
  ;

  _proto.coordinateToVector3 = function coordinateToVector3(coordinate, z) {
    if (z === void 0) {
      z = 0;
    }

    var map = this.getMap();

    if (!map) {
      return null;
    }

    if (!(coordinate instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"])) {
      coordinate = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"](coordinate);
    }

    var p = map.coordinateToPoint(coordinate, getTargetZoom(map));
    return new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](p.x, p.y, z);
  }
  /**
   * Convert geographic distance to THREE Vector3
   * @param  {Number} w - width
   * @param  {Number} h - height
   * @return {THREE.Vector3}
   */
  ;

  _proto.distanceToVector3 = function distanceToVector3(w, h, coord) {
    var map = this.getMap();
    var zoom = getTargetZoom(map);
    var center = coord || map.getCenter();

    if (!(center instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"])) {
      center = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"](center);
    }

    var target = map.locate(center, w, h);
    var p0 = map.coordinateToPoint(center, zoom),
        p1 = map.coordinateToPoint(target, zoom);
    var x = Math.abs(p1.x - p0.x) * maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].sign(w);
    var y = Math.abs(p1.y - p0.y) * maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].sign(h);
    return new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](x, y, 0);
  }
  /**
   * Convert a Polygon or a MultiPolygon to THREE shape
   * @param  {maptalks.Polygon|maptalks.MultiPolygon} polygon - polygon or multipolygon
   * @return {THREE.Shape}
   */
  ;

  _proto.toShape = function toShape(polygon) {
    var _this = this;

    if (!polygon) {
      return null;
    }

    if (polygon instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["MultiPolygon"]) {
      return polygon.getGeometries().map(function (c) {
        return _this.toShape(c);
      });
    }

    var center = polygon.getCenter();
    var centerPt = this.coordinateToVector3(center);
    var shell = polygon.getShell();
    var outer = shell.map(function (c) {
      return _this.coordinateToVector3(c).sub(centerPt);
    });
    var shape = new three__WEBPACK_IMPORTED_MODULE_1__["Shape"](outer);
    var holes = polygon.getHoles();

    if (holes && holes.length > 0) {
      shape.holes = holes.map(function (item) {
        var pts = item.map(function (c) {
          return _this.coordinateToVector3(c).sub(centerPt);
        });
        return new three__WEBPACK_IMPORTED_MODULE_1__["Shape"](pts);
      });
    }

    return shape;
  }
  /**
   * todo   This should also be extracted as a component
   * @param {*} polygon
   * @param {*} altitude
   * @param {*} material
   * @param {*} height
   */
  ;

  _proto.toExtrudeMesh = function toExtrudeMesh(polygon, altitude, material, height) {
    var _this2 = this;

    if (!polygon) {
      return null;
    }

    if (polygon instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["MultiPolygon"]) {
      return polygon.getGeometries().map(function (c) {
        return _this2.toExtrudeMesh(c, altitude, material, height);
      });
    }

    var rings = polygon.getCoordinates();
    rings.forEach(function (ring) {
      var length = ring.length;

      for (var i = length - 1; i >= 1; i--) {
        if (ring[i].equals(ring[i - 1])) {
          ring.splice(i, 1);
        }
      }
    });
    polygon.setCoordinates(rings);
    var shape = this.toShape(polygon);
    var center = this.coordinateToVector3(polygon.getCenter());
    height = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isNumber(height) ? height : altitude;
    height = this.distanceToVector3(height, height).x;
    var amount = this.distanceToVector3(altitude, altitude).x; //{ amount: extrudeH, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

    var config = {
      'bevelEnabled': false,
      'bevelSize': 1
    };
    var name = parseInt(three__WEBPACK_IMPORTED_MODULE_1__["REVISION"]) >= 93 ? 'depth' : 'amount';
    config[name] = height;
    var geom = new three__WEBPACK_IMPORTED_MODULE_1__["ExtrudeGeometry"](shape, config);
    var buffGeom = new three__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
    buffGeom.fromGeometry(geom);
    var mesh = new three__WEBPACK_IMPORTED_MODULE_1__["Mesh"](buffGeom, material);
    mesh.position.set(center.x, center.y, amount - height);
    return mesh;
  }
  /**
   *
   * @param {maptalks.Polygon|maptalks.MultiPolygon} polygon
   * @param {Object} options
   * @param {THREE.Material} material
   */
  ;

  _proto.toExtrudePolygon = function toExtrudePolygon(polygon, options, material) {
    return new ExtrudePolygon(polygon, options, material, this);
  }
  /**
   *
   * @param {maptalks.Coordinate} coordinate
   * @param {Object} options
   * @param {THREE.Material} material
   */
  ;

  _proto.toBar = function toBar(coordinate, options, material) {
    return new Bar(coordinate, options, material, this);
  }
  /**
  *
  * @param {maptalks.LineString} lineString
  * @param {Object} options
  * @param {THREE.LineMaterial} material
  */
  ;

  _proto.toLine = function toLine(lineString, options, material) {
    return new Line$1(lineString, options, material, this);
  }
  /**
   *
   * @param {maptalks.LineString} lineString
   * @param {Object} options
   * @param {THREE.Material} material
   */
  ;

  _proto.toExtrudeLine = function toExtrudeLine(lineString, options, material) {
    return new ExtrudeLine(lineString, options, material, this);
  }
  /**
   *
   * @param {THREE.Mesh|THREE.Group} model
   * @param {Object} options
   */
  ;

  _proto.toModel = function toModel(model, options) {
    return new Model(model, options, this);
  }
  /**
   *
   * @param {maptalks.LineString} lineString
   * @param {*} options
   * @param {THREE.Material} material
   */
  ;

  _proto.toExtrudeLineTrail = function toExtrudeLineTrail(lineString, options, material) {
    return new ExtrudeLineTrail(lineString, options, material, this);
  }
  /**
   *
   * @param {*} polygons
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toExtrudePolygons = function toExtrudePolygons(polygons, options, material) {
    return new ExtrudePolygons(polygons, options, material, this);
  }
  /**
   *
   * @param {maptalks.Coordinate} coordinate
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toPoint = function toPoint(coordinate, options, material) {
    return new Point(coordinate, options, material, this);
  }
  /**
   *
   * @param {Array} points
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toPoints = function toPoints(points, options, material) {
    return new Points$1(points, options, material, this);
  }
  /**
   *
   * @param {Array} points
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toBars = function toBars(points, options, material) {
    return new Bars(points, options, material, this);
  }
  /**
   *
   * @param {Array[maptalks.LineString]} lineStrings
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toExtrudeLines = function toExtrudeLines(lineStrings, options, material) {
    return new ExtrudeLines(lineStrings, options, material, this);
  }
  /**
   *
   * @param {Array[maptalks.LineString]} lineStrings
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toLines = function toLines(lineStrings, options, material) {
    return new Lines(lineStrings, options, material, this);
  }
  /**
   *
   * @param {*} url
   * @param {*} options
   * @param {*} getMaterial
   * @param {*} worker
   */
  ;

  _proto.toThreeVectorTileLayer = function toThreeVectorTileLayer(url, options, getMaterial) {
    return new ThreeVectorTileLayer(url, options, getMaterial, this);
  }
  /**
   *
   * @param {*} extent
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toTerrain = function toTerrain(extent, options, material) {
    return new Terrain(extent, options, material, this);
  }
  /**
   *
   * @param {*} url
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toTerrainVectorTileLayer = function toTerrainVectorTileLayer(url, options, material) {
    return new TerrainVectorTileLayer(url, options, material, this);
  }
  /**
   *
   * @param {*} data
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toHeatMap = function toHeatMap(data, options, material) {
    return new HeatMap(data, options, material, this);
  }
  /**
   *
   * @param {*} lineString
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toFatLine = function toFatLine(lineString, options, material) {
    return new FatLine(lineString, options, material, this);
  }
  /**
   *
   * @param {*} lineStrings
   * @param {*} options
   * @param {*} material
   */
  ;

  _proto.toFatLines = function toFatLines(lineStrings, options, material) {
    return new FatLines(lineStrings, options, material, this);
  };

  _proto.getBaseObjects = function getBaseObjects() {
    return this.getMeshes().filter(function (mesh) {
      return mesh instanceof BaseObject$$1;
    });
  };

  _proto.getMeshes = function getMeshes() {
    var scene = this.getScene();

    if (!scene) {
      return [];
    }

    var meshes = [];

    for (var i = 0, len = scene.children.length; i < len; i++) {
      var child = scene.children[i];

      if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__["Object3D"] && !(child instanceof three__WEBPACK_IMPORTED_MODULE_1__["Camera"])) {
        meshes.push(child.__parent || child);
      }
    }

    return meshes;
  };

  _proto.clear = function clear() {
    return this.clearMesh();
  };

  _proto.clearMesh = function clearMesh() {
    var scene = this.getScene();

    if (!scene) {
      return this;
    }

    for (var i = scene.children.length - 1; i >= 0; i--) {
      var child = scene.children[i];

      if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__["Object3D"] && !(child instanceof three__WEBPACK_IMPORTED_MODULE_1__["Camera"])) {
        scene.remove(child);
        var parent = child.__parent;

        if (parent && parent instanceof BaseObject$$1) {
          parent.isAdd = false;

          parent._fire('remove', {
            target: parent
          });

          delete this._animationBaseObjectMap[child.uuid];
        }
      }
    }

    return this;
  };

  _proto.lookAt = function lookAt(vector) {
    var renderer$$1 = this._getRenderer();

    if (renderer$$1) {
      renderer$$1.context.lookAt(vector);
    }

    return this;
  };

  _proto.getCamera = function getCamera() {
    var renderer$$1 = this._getRenderer();

    if (renderer$$1) {
      return renderer$$1.camera;
    }

    return null;
  };

  _proto.getScene = function getScene() {
    var renderer$$1 = this._getRenderer();

    if (renderer$$1) {
      return renderer$$1.scene;
    }

    return null;
  };

  _proto.renderScene = function renderScene() {
    var renderer$$1 = this._getRenderer();

    if (renderer$$1) {
      renderer$$1.clearCanvas();
      renderer$$1.renderScene();
    }

    return this;
  };

  _proto.renderPickScene = function renderPickScene() {
    var renderer$$1 = this._getRenderer();

    if (renderer$$1) {
      var pick = renderer$$1.pick;

      if (pick) {
        pick.pick(this._containerPoint);
      }
    }

    return this;
  };

  _proto.getThreeRenderer = function getThreeRenderer() {
    var renderer$$1 = this._getRenderer();

    if (renderer$$1) {
      return renderer$$1.context;
    }

    return null;
  };

  _proto.getPick = function getPick() {
    var renderer$$1 = this._getRenderer();

    if (renderer$$1) {
      return renderer$$1.pick;
    }

    return null;
  }
  /**
   * add object3ds
   * @param {BaseObject} meshes
   */
  ;

  _proto.addMesh = function addMesh(meshes, render) {
    var _this3 = this;

    if (render === void 0) {
      render = true;
    }

    if (!meshes) return this;

    if (!Array.isArray(meshes)) {
      meshes = [meshes];
    }

    var scene = this.getScene();
    meshes.forEach(function (mesh) {
      if (mesh instanceof BaseObject$$1) {
        scene.add(mesh.getObject3d());

        if (!mesh.isAdd) {
          mesh.isAdd = true;

          mesh._fire('add', {
            target: mesh
          });
        }

        if (mesh._animation && maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isFunction(mesh._animation)) {
          _this3._animationBaseObjectMap[mesh.getObject3d().uuid] = mesh;
        }
      } else if (mesh instanceof three__WEBPACK_IMPORTED_MODULE_1__["Object3D"]) {
        scene.add(mesh);
      }
    });

    this._zoomend();

    if (render) {
      this.renderScene();
    }

    return this;
  }
  /**
   * remove object3ds
   * @param {BaseObject} meshes
   */
  ;

  _proto.removeMesh = function removeMesh(meshes, render) {
    var _this4 = this;

    if (render === void 0) {
      render = true;
    }

    if (!meshes) return this;

    if (!Array.isArray(meshes)) {
      meshes = [meshes];
    }

    var scene = this.getScene();
    meshes.forEach(function (mesh) {
      if (mesh instanceof BaseObject$$1) {
        scene.remove(mesh.getObject3d());

        if (mesh.isAdd) {
          mesh.isAdd = false;

          mesh._fire('remove', {
            target: mesh
          });
        }

        if (mesh._animation && maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isFunction(mesh._animation)) {
          delete _this4._animationBaseObjectMap[mesh.getObject3d().uuid];
        }
      } else if (mesh instanceof three__WEBPACK_IMPORTED_MODULE_1__["Object3D"]) {
        scene.remove(mesh);
      }
    });

    if (render) {
      this.renderScene();
    }

    return this;
  };

  _proto._initRaycaster = function _initRaycaster() {
    if (!this._raycaster) {
      this._raycaster = new three__WEBPACK_IMPORTED_MODULE_1__["Raycaster"]();
      this._mouse = new three__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();
    }

    return this;
  }
  /**
   *
   * @param {Coordinate} coordinate
   * @param {Object} options
   * @return {Array}
   */
  ;

  _proto.identify = function identify(coordinate, options) {
    var _this5 = this;

    if (!coordinate) {
      console.error('coordinate is null,it should be Coordinate');
      return [];
    }

    if (Array.isArray(coordinate)) {
      coordinate = new maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"](coordinate);
    }

    if (!(coordinate instanceof maptalks__WEBPACK_IMPORTED_MODULE_0__["Coordinate"])) {
      console.error('coordinate type is error,it should be Coordinate');
      return [];
    }

    var p = this.getMap().coordToContainerPoint(coordinate);
    this._containerPoint = p;
    var x = p.x,
        y = p.y;

    this._initRaycaster();

    var raycaster = this._raycaster,
        mouse = this._mouse,
        camera = this.getCamera(),
        scene = this.getScene(),
        size = this.getMap().getSize(); //fix Errors will be reported when the layer is not initialized

    if (!scene) {
      return [];
    }

    var width = size.width,
        height = size.height;
    mouse.x = x / width * 2 - 1;
    mouse.y = -(y / height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera); //set linePrecision for THREE.Line

    setRaycasterLinePrecision(raycaster, this._getLinePrecision(this.getMap().getResolution()));
    var children = [],
        hasidentifyChildren = [];
    scene.children.forEach(function (mesh) {
      var parent = mesh.__parent;

      if (parent && parent.getOptions) {
        var interactive = parent.getOptions().interactive;

        if (interactive && parent.isVisible()) {
          //If baseobject has its own hit detection
          if (parent.identify && maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isFunction(parent.identify)) {
            hasidentifyChildren.push(parent);
          } else {
            children.push(mesh);
          }
        }
      } else if (mesh instanceof three__WEBPACK_IMPORTED_MODULE_1__["Mesh"] || mesh instanceof three__WEBPACK_IMPORTED_MODULE_1__["Group"]) {
        children.push(mesh);
      }
    });
    var baseObjects = [];
    var intersects = raycaster.intersectObjects(children, true);

    if (intersects && Array.isArray(intersects) && intersects.length) {
      baseObjects = intersects.map(function (intersect) {
        var object = intersect.object;
        object = _this5._recursionMesh(object);
        var baseObject = object.__parent || object;
        baseObject.faceIndex = intersect.faceIndex;
        baseObject.index = intersect.index;
        return baseObject;
      });
    }

    this.renderPickScene();

    if (hasidentifyChildren.length) {
      hasidentifyChildren.forEach(function (baseObject) {
        // baseObject identify
        if (baseObject.identify(coordinate)) {
          baseObjects.push(baseObject);
        }
      });
    }

    options = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].extend({}, options);
    var count = options.count;
    return maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isNumber(count) && count > 0 ? baseObjects.slice(0, count) : baseObjects;
  }
  /**
  * Recursively finding the root node of mesh,Until it is scene node
  * @param {*} mesh
  */
  ;

  _proto._recursionMesh = function _recursionMesh(mesh) {
    while (mesh && !(mesh.parent instanceof three__WEBPACK_IMPORTED_MODULE_1__["Scene"])) {
      mesh = mesh.parent;
    }

    return mesh || {};
  } //get Line Precision by Resolution
  ;

  _proto._getLinePrecision = function _getLinePrecision(res) {
    if (res === void 0) {
      res = 10;
    }

    for (var i = 0, len = LINEPRECISIONS.length; i < len; i++) {
      var _LINEPRECISIONS$i = LINEPRECISIONS[i],
          resLevel = _LINEPRECISIONS$i[0],
          precision = _LINEPRECISIONS$i[1];

      if (res > resLevel) {
        return precision;
      }
    }

    return 0.01;
  }
  /**
   * fire baseObject events
   * @param {*} e
   */
  ;

  _proto._identifyBaseObjectEvents = function _identifyBaseObjectEvents(e) {
    if (!this.options.geometryEvents) {
      return this;
    }

    var map = this.map || this.getMap(); //When map interaction, do not carry out mouse movement detection, which can have better performance
    // if (map.isInteracting() && e.type === 'mousemove') {
    //     return this;
    // }

    var type = e.type,
        coordinate = e.coordinate;
    var now = maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].now();

    if (this._mousemoveTimeOut && type === 'mousemove') {
      if (now - this._mousemoveTimeOut < 16) {
        return this;
      }
    }

    this._mousemoveTimeOut = now;
    map.resetCursor('default');
    var identifyCountOnEvent = this.options['identifyCountOnEvent'];
    var count = Math.max(0, maptalks__WEBPACK_IMPORTED_MODULE_0__["Util"].isNumber(identifyCountOnEvent) ? identifyCountOnEvent : 0);

    if (count === 0) {
      count = Infinity;
    }

    var baseObjects = this.identify(coordinate, {
      count: count
    });
    var scene = this.getScene();

    if (baseObjects.length === 0 && scene) {
      for (var i = 0, len = scene.children.length; i < len; i++) {
        var child = scene.children[i] || {};
        var parent = child.__parent;

        if (parent) {
          parent.fire('empty', Object.assign({}, e, {
            target: parent
          }));
        }
      }
    }

    if (type === 'mousemove') {
      if (baseObjects.length) {
        map.setCursor('pointer');
      } // mouseout objects


      var outBaseObjects = [];

      if (this._baseObjects) {
        this._baseObjects.forEach(function (baseObject) {
          var isOut = true;
          baseObjects.forEach(function (baseO) {
            if (baseObject === baseO) {
              isOut = false;
            }
          });

          if (isOut) {
            outBaseObjects.push(baseObject);
          }
        });
      }

      outBaseObjects.forEach(function (baseObject) {
        if (baseObject instanceof BaseObject$$1) {
          // reset _mouseover status
          // Deal with the mergedmesh
          if (baseObject.getSelectMesh) {
            if (!baseObject.isHide) {
              baseObject._mouseover = false;
              baseObject.fire('mouseout', Object.assign({}, e, {
                target: baseObject,
                type: 'mouseout',
                selectMesh: null
              }));
              baseObject.closeToolTip();
            }
          } else {
            baseObject._mouseover = false;
            baseObject.fire('mouseout', Object.assign({}, e, {
              target: baseObject,
              type: 'mouseout'
            }));
            baseObject.closeToolTip();
          }
        }
      });
      baseObjects.forEach(function (baseObject) {
        if (baseObject instanceof BaseObject$$1) {
          if (!baseObject._mouseover) {
            baseObject.fire('mouseover', Object.assign({}, e, {
              target: baseObject,
              type: 'mouseover',
              selectMesh: baseObject.getSelectMesh ? baseObject.getSelectMesh() : null
            }));
            baseObject._mouseover = true;
          }

          baseObject.fire(type, Object.assign({}, e, {
            target: baseObject,
            selectMesh: baseObject.getSelectMesh ? baseObject.getSelectMesh() : null
          })); // tooltip

          var tooltip = baseObject.getToolTip();

          if (tooltip && !tooltip._owner) {
            tooltip.addTo(baseObject);
          }

          baseObject.openToolTip(coordinate);
        }
      });
    } else {
      baseObjects.forEach(function (baseObject) {
        if (baseObject instanceof BaseObject$$1) {
          baseObject.fire(type, Object.assign({}, e, {
            target: baseObject,
            selectMesh: baseObject.getSelectMesh ? baseObject.getSelectMesh() : null
          }));

          if (type === 'click') {
            var infoWindow = baseObject.getInfoWindow();

            if (infoWindow && !infoWindow._owner) {
              infoWindow.addTo(baseObject);
            }

            baseObject.openInfoWindow(coordinate);
          }
        }
      });
    }

    this._baseObjects = baseObjects;
    return this;
  }
  /**
   *map zoom event
   */
  ;

  _proto._zoomend = function _zoomend() {
    var scene = this.getScene();

    if (!scene) {
      return;
    }

    var zoom = this.getMap().getZoom();
    scene.children.forEach(function (mesh) {
      var parent = mesh.__parent;

      if (parent && parent.getOptions) {
        var minZoom = parent.getMinZoom(),
            maxZoom = parent.getMaxZoom();

        if (zoom < minZoom || zoom > maxZoom) {
          if (parent.isVisible()) {
            parent.getObject3d().visible = false;
          }

          parent._zoomVisible = false;
        } else if (minZoom <= zoom && zoom <= maxZoom) {
          if (parent._visible) {
            parent.getObject3d().visible = true;
          }

          parent._zoomVisible = true;
        }
      }
    });
  };

  _proto.onAdd = function onAdd() {
    var _this6 = this;

    _maptalks$CanvasLayer.prototype.onAdd.call(this);

    var map = this.map || this.getMap();
    if (!map) return this;
    EVENTS$1.forEach(function (event) {
      map.on(event, _this6._identifyBaseObjectEvents, _this6);
    });
    this._needsUpdate = true;

    if (!this._animationBaseObjectMap) {
      this._animationBaseObjectMap = {};
    }

    map.on('zooming zoomend', this._zoomend, this);
    return this;
  };

  _proto.onRemove = function onRemove() {
    var _this7 = this;

    _maptalks$CanvasLayer.prototype.onRemove.call(this);

    var map = this.map || this.getMap();
    if (!map) return this;
    EVENTS$1.forEach(function (event) {
      map.off(event, _this7._identifyBaseObjectEvents, _this7);
    });
    map.off('zooming zoomend', this._zoomend, this);
    return this;
  };

  _proto._callbackBaseObjectAnimation = function _callbackBaseObjectAnimation() {
    var layer = this;

    if (layer._animationBaseObjectMap) {
      for (var uuid in layer._animationBaseObjectMap) {
        var baseObject = layer._animationBaseObjectMap[uuid];

        baseObject._animation();
      }
    }

    return this;
  }
  /**
   * To make map's 2d point's 1 pixel euqal with 1 pixel on XY plane in THREE's scene:
   * 1. fov is 90 and camera's z is height / 2 * scale,
   * 2. if fov is not 90, a ratio is caculated to transfer z to the equivalent when fov is 90
   * @return {Number} fov ratio on z axis
   */
  ;

  _proto._getFovRatio = function _getFovRatio() {
    var map = this.getMap();
    var fov = map.getFov();
    return Math.tan(fov / 2 * RADIAN);
  };

  return ThreeLayer;
}(maptalks__WEBPACK_IMPORTED_MODULE_0__["CanvasLayer"]);

ThreeLayer.mergeOptions(options);

var ThreeRenderer = /*#__PURE__*/function (_maptalks$renderer$Ca) {
  _inheritsLoose(ThreeRenderer, _maptalks$renderer$Ca);

  function ThreeRenderer() {
    return _maptalks$renderer$Ca.apply(this, arguments) || this;
  }

  var _proto2 = ThreeRenderer.prototype;

  _proto2.getPrepareParams = function getPrepareParams() {
    return [this.scene, this.camera];
  };

  _proto2.getDrawParams = function getDrawParams() {
    return [this.scene, this.camera];
  };

  _proto2._drawLayer = function _drawLayer() {
    _maptalks$renderer$Ca.prototype._drawLayer.apply(this, arguments); // this.renderScene();

  };

  _proto2.hitDetect = function hitDetect() {
    return false;
  };

  _proto2.createCanvas = function createCanvas() {
    _maptalks$renderer$Ca.prototype.createCanvas.call(this);

    this.createContext();
  };

  _proto2.createContext = function createContext() {
    if (this.canvas.gl && this.canvas.gl.wrap) {
      this.gl = this.canvas.gl.wrap();
    } else {
      var layer = this.layer;
      var attributes = layer.options.glOptions || {
        alpha: true,
        depth: true,
        antialias: true,
        stencil: true
      };
      attributes.preserveDrawingBuffer = true;
      this.gl = this.gl || this._createGLContext(this.canvas, attributes);
    }

    this._initThreeRenderer();

    this.layer.onCanvasCreate(this.context, this.scene, this.camera);
  };

  _proto2._initThreeRenderer = function _initThreeRenderer() {
    this.matrix4 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    var renderer$$1 = new three__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderer"]({
      'context': this.gl,
      alpha: true
    });
    renderer$$1.autoClear = false;
    renderer$$1.setClearColor(new three__WEBPACK_IMPORTED_MODULE_1__["Color"](1, 1, 1), 0);
    renderer$$1.setSize(this.canvas.width, this.canvas.height);
    renderer$$1.clear();
    renderer$$1.canvas = this.canvas;
    this.context = renderer$$1;
    var scene = this.scene = new three__WEBPACK_IMPORTED_MODULE_1__["Scene"]();
    var map = this.layer.getMap();
    var fov = map.getFov() * Math.PI / 180;
    var camera = this.camera = new three__WEBPACK_IMPORTED_MODULE_1__["PerspectiveCamera"](fov, map.width / map.height, map.cameraNear, map.cameraFar);
    camera.matrixAutoUpdate = false;

    this._syncCamera();

    scene.add(camera);
    this.pick = new GPUPick(this.layer);
  };

  _proto2.onCanvasCreate = function onCanvasCreate() {
    _maptalks$renderer$Ca.prototype.onCanvasCreate.call(this);
  };

  _proto2.resizeCanvas = function resizeCanvas(canvasSize) {
    if (!this.canvas) {
      return;
    }

    var size,
        map = this.getMap();

    if (!canvasSize) {
      size = map.getSize();
    } else {
      size = canvasSize;
    } // const r = maptalks.Browser.retina ? 2 : 1;


    var r = map.getDevicePixelRatio ? map.getDevicePixelRatio() : maptalks__WEBPACK_IMPORTED_MODULE_0__["Browser"].retina ? 2 : 1;
    var canvas = this.canvas; //retina support

    canvas.height = r * size['height'];
    canvas.width = r * size['width'];

    if (this.layer._canvas && canvas.style) {
      canvas.style.width = size.width + 'px';
      canvas.style.height = size.height + 'px';
    }

    this.context.setSize(canvas.width, canvas.height);
  };

  _proto2.clearCanvas = function clearCanvas() {
    if (!this.canvas) {
      return;
    }

    this.context.clear();
  };

  _proto2.prepareCanvas = function prepareCanvas() {
    if (!this.canvas) {
      this.createCanvas();
    } else {
      this.clearCanvas();
    }

    this.layer.fire('renderstart', {
      'context': this.context
    });
    return null;
  };

  _proto2.renderScene = function renderScene() {
    this.layer._callbackBaseObjectAnimation();

    this._syncCamera();

    this.context.render(this.scene, this.camera);
    this.completeRender();
  };

  _proto2.remove = function remove() {
    delete this._drawContext;

    _maptalks$renderer$Ca.prototype.remove.call(this);
  };

  _proto2._syncCamera = function _syncCamera() {
    var map = this.getMap();
    var camera = this.camera;
    camera.matrix.elements = map.cameraWorldMatrix;
    camera.projectionMatrix.elements = map.projMatrix; //https://github.com/mrdoob/three.js/commit/d52afdd2ceafd690ac9e20917d0c968ff2fa7661

    if (this.matrix4.invert) {
      camera.projectionMatrixInverse.elements = this.matrix4.copy(camera.projectionMatrix).invert().elements;
    } else {
      camera.projectionMatrixInverse.elements = this.matrix4.getInverse(camera.projectionMatrix).elements;
    }
  };

  _proto2._createGLContext = function _createGLContext(canvas, options) {
    var names = ['webgl2', 'webgl', 'experimental-webgl'];
    var context = null;
    /* eslint-disable no-empty */

    for (var i = 0; i < names.length; ++i) {
      try {
        context = canvas.getContext(names[i], options);
      } catch (e) {}

      if (context) {
        break;
      }
    }

    return context;
    /* eslint-enable no-empty */
  };

  return ThreeRenderer;
}(maptalks__WEBPACK_IMPORTED_MODULE_0__["renderer"].CanvasLayerRenderer);

ThreeLayer.registerRenderer('gl', ThreeRenderer);

function getTargetZoom(map) {
  return map.getGLZoom();
}



typeof console !== 'undefined' && console.log('maptalks.three v0.12.3, requires maptalks@>=0.39.0.');

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "../node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/3.png":
/*!**********************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/3.png ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAYAAAA71pVKAAAKN2lDQ1BzUkdCIElFQzYxOTY2LTIuMQAAeJydlndUU9kWh8+9N71QkhCKlNBraFICSA29SJEuKjEJEErAkAAiNkRUcERRkaYIMijggKNDkbEiioUBUbHrBBlE1HFwFBuWSWStGd+8ee/Nm98f935rn73P3Wfvfda6AJD8gwXCTFgJgAyhWBTh58WIjYtnYAcBDPAAA2wA4HCzs0IW+EYCmQJ82IxsmRP4F726DiD5+yrTP4zBAP+flLlZIjEAUJiM5/L42VwZF8k4PVecJbdPyZi2NE3OMErOIlmCMlaTc/IsW3z2mWUPOfMyhDwZy3PO4mXw5Nwn4405Er6MkWAZF+cI+LkyviZjg3RJhkDGb+SxGXxONgAoktwu5nNTZGwtY5IoMoIt43kA4EjJX/DSL1jMzxPLD8XOzFouEiSniBkmXFOGjZMTi+HPz03ni8XMMA43jSPiMdiZGVkc4XIAZs/8WRR5bRmyIjvYODk4MG0tbb4o1H9d/JuS93aWXoR/7hlEH/jD9ld+mQ0AsKZltdn6h21pFQBd6wFQu/2HzWAvAIqyvnUOfXEeunxeUsTiLGcrq9zcXEsBn2spL+jv+p8Of0NffM9Svt3v5WF485M4knQxQ143bmZ6pkTEyM7icPkM5p+H+B8H/nUeFhH8JL6IL5RFRMumTCBMlrVbyBOIBZlChkD4n5r4D8P+pNm5lona+BHQllgCpSEaQH4eACgqESAJe2Qr0O99C8ZHA/nNi9GZmJ37z4L+fVe4TP7IFiR/jmNHRDK4ElHO7Jr8WgI0IABFQAPqQBvoAxPABLbAEbgAD+ADAkEoiARxYDHgghSQAUQgFxSAtaAYlIKtYCeoBnWgETSDNnAYdIFj4DQ4By6By2AE3AFSMA6egCnwCsxAEISFyBAVUod0IEPIHLKFWJAb5AMFQxFQHJQIJUNCSAIVQOugUqgcqobqoWboW+godBq6AA1Dt6BRaBL6FXoHIzAJpsFasBFsBbNgTzgIjoQXwcnwMjgfLoK3wJVwA3wQ7oRPw5fgEVgKP4GnEYAQETqiizARFsJGQpF4JAkRIauQEqQCaUDakB6kH7mKSJGnyFsUBkVFMVBMlAvKHxWF4qKWoVahNqOqUQdQnag+1FXUKGoK9RFNRmuizdHO6AB0LDoZnYsuRlegm9Ad6LPoEfQ4+hUGg6FjjDGOGH9MHCYVswKzGbMb0445hRnGjGGmsVisOtYc64oNxXKwYmwxtgp7EHsSewU7jn2DI+J0cLY4X1w8TogrxFXgWnAncFdwE7gZvBLeEO+MD8Xz8MvxZfhGfA9+CD+OnyEoE4wJroRIQiphLaGS0EY4S7hLeEEkEvWITsRwooC4hlhJPEQ8TxwlviVRSGYkNimBJCFtIe0nnSLdIr0gk8lGZA9yPFlM3kJuJp8h3ye/UaAqWCoEKPAUVivUKHQqXFF4pohXNFT0VFysmK9YoXhEcUjxqRJeyUiJrcRRWqVUo3RU6YbStDJV2UY5VDlDebNyi/IF5UcULMWI4kPhUYoo+yhnKGNUhKpPZVO51HXURupZ6jgNQzOmBdBSaaW0b2iDtCkVioqdSrRKnkqNynEVKR2hG9ED6On0Mvph+nX6O1UtVU9Vvuom1TbVK6qv1eaoeajx1UrU2tVG1N6pM9R91NPUt6l3qd/TQGmYaYRr5Grs0Tir8XQObY7LHO6ckjmH59zWhDXNNCM0V2ju0xzQnNbS1vLTytKq0jqj9VSbru2hnaq9Q/uE9qQOVcdNR6CzQ+ekzmOGCsOTkc6oZPQxpnQ1df11Jbr1uoO6M3rGelF6hXrtevf0Cfos/ST9Hfq9+lMGOgYhBgUGrQa3DfGGLMMUw12G/YavjYyNYow2GHUZPTJWMw4wzjduNb5rQjZxN1lm0mByzRRjyjJNM91tetkMNrM3SzGrMRsyh80dzAXmu82HLdAWThZCiwaLG0wS05OZw2xljlrSLYMtCy27LJ9ZGVjFW22z6rf6aG1vnW7daH3HhmITaFNo02Pzq62ZLde2xvbaXPJc37mr53bPfW5nbse322N3055qH2K/wb7X/oODo4PIoc1h0tHAMdGx1vEGi8YKY21mnXdCO3k5rXY65vTW2cFZ7HzY+RcXpkuaS4vLo3nG8/jzGueNueq5clzrXaVuDLdEt71uUnddd457g/sDD30PnkeTx4SnqWeq50HPZ17WXiKvDq/XbGf2SvYpb8Tbz7vEe9CH4hPlU+1z31fPN9m31XfKz95vhd8pf7R/kP82/xsBWgHcgOaAqUDHwJWBfUGkoAVB1UEPgs2CRcE9IXBIYMj2kLvzDecL53eFgtCA0O2h98KMw5aFfR+OCQ8Lrwl/GGETURDRv4C6YMmClgWvIr0iyyLvRJlESaJ6oxWjE6Kbo1/HeMeUx0hjrWJXxl6K04gTxHXHY+Oj45vipxf6LNy5cDzBPqE44foi40V5iy4s1licvvj4EsUlnCVHEtGJMYktie85oZwGzvTSgKW1S6e4bO4u7hOeB28Hb5Lvyi/nTyS5JpUnPUp2Td6ePJninlKR8lTAFlQLnqf6p9alvk4LTduf9ik9Jr09A5eRmHFUSBGmCfsytTPzMoezzLOKs6TLnJftXDYlChI1ZUPZi7K7xTTZz9SAxESyXjKa45ZTk/MmNzr3SJ5ynjBvYLnZ8k3LJ/J9879egVrBXdFboFuwtmB0pefK+lXQqqWrelfrry5aPb7Gb82BtYS1aWt/KLQuLC98uS5mXU+RVtGaorH1futbixWKRcU3NrhsqNuI2ijYOLhp7qaqTR9LeCUXS61LK0rfb+ZuvviVzVeVX33akrRlsMyhbM9WzFbh1uvb3LcdKFcuzy8f2x6yvXMHY0fJjpc7l+y8UGFXUbeLsEuyS1oZXNldZVC1tep9dUr1SI1XTXutZu2m2te7ebuv7PHY01anVVda926vYO/Ner/6zgajhop9mH05+x42Rjf2f836urlJo6m06cN+4X7pgYgDfc2Ozc0tmi1lrXCrpHXyYMLBy994f9Pdxmyrb6e3lx4ChySHHn+b+O31w0GHe4+wjrR9Z/hdbQe1o6QT6lzeOdWV0iXtjusePhp4tLfHpafje8vv9x/TPVZzXOV42QnCiaITn07mn5w+lXXq6enk02O9S3rvnIk9c60vvG/wbNDZ8+d8z53p9+w/ed71/LELzheOXmRd7LrkcKlzwH6g4wf7HzoGHQY7hxyHui87Xe4Znjd84or7ldNXva+euxZw7dLI/JHh61HXb95IuCG9ybv56Fb6ree3c27P3FlzF3235J7SvYr7mvcbfjT9sV3qID0+6j068GDBgztj3LEnP2X/9H686CH5YcWEzkTzI9tHxyZ9Jy8/Xvh4/EnWk5mnxT8r/1z7zOTZd794/DIwFTs1/lz0/NOvm1+ov9j/0u5l73TY9P1XGa9mXpe8UX9z4C3rbf+7mHcTM7nvse8rP5h+6PkY9PHup4xPn34D94Tz+49wZioAAAAJcEhZcwAACxIAAAsSAdLdfvwAAALeSURBVHicVZPNaxNBGMbfnZ3srmuakCZpGpNSWjDZYgqW3LzYgkir1kDBHPwHBA96UHrUkwdBT56KFPFv6KEWpBUMtBFaanuoVULSpMQkzUeTNNtssh/OmxrBuQ0zz/PM+76/oZZlAa7JSSIYhiKyvSgBDFiEuIhlOUyOa3CmWWsDNDmO03j+h7a/b3ZQQ/tCXQ87ZJ64QNdljudlKghuSZbdeqdTb6uqKBuGA3heVfVwjd1voAHtCy/xvM/kDJ8oi+6Z23PvBUGwsySLJ8Q6b7fr28nNV6WT4h67J5zrYQxsUHwqJqLw5vStR3fuzce7eheOsllo1Ovg9XpBURRPLBZ782F5+W1yK7Em83zn3FA0ijXiU5VI5MazxcUHkiRBOpOGcrkMzUYD7HY7DA0NwejoKO/xep8/efzod+HouGJxnEixOVhjbGHhRSAQ4Cy4aGClXOkZ+P1+CAaDgH11uVxk9u791x+XlqYl0xyg2FWv3389rCh8tVoFTB4cHISpqSnIHecgEolAu92GWq0GrVYLxsbGiNPtvlqpVDSK47CJ4khLVUkqlYKLxQEhHESuRSD5LQl6V4f+SJkRL0pSgOmyFOfITtRMJsPOLU5VVWg2z3rieDwOiUQCsrkcCDYbsAmAYRiWZZqnqKMIQPP0dDudTuuiKNq63W7vUig0AU6nE6LRKHQ6HSgWi6BpGk7AaDWbv1BHkZxGtZrP53J7V0ZGosyg193h4WHGBA9ejxfGx8fBNE3AnhTy+WSrXj9pc1yTInJIztbm18WZy7MrysSE7PF4YMDhAHYGoiSCz+eDs7MzODw4KO5sJ18SSlWWrFFkFZFDcjY+f5onAO/cbndIFIQeuoQQKJVKnS/r6z/XVleeMuaKqmHUKD3UKDKKqCFySM7G6urD/d3dkD8YnGMmAVbrQa1S2Slks98x8a/wgm10/2fAkENySoVCo1gqpf77VazG3lNZYv9X/QEJM4cEk5QMqQAAAABJRU5ErkJggg=="

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/5.png":
/*!**********************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/5.png ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAKCAYAAABSfLWiAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0NTE4ZWRhOC03NjQ5LTNjNGUtYjYxZi0xNjVhZmQzNmJmMzciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MUJCN0UxQjY3RTk2MTFFOEFCNzVFRTYzMkFGMUE2MUIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MUJCN0UxQjU3RTk2MTFFOEFCNzVFRTYzMkFGMUE2MUIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NDUxOGVkYTgtNzY0OS0zYzRlLWI2MWYtMTY1YWZkMzZiZjM3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ1MThlZGE4LTc2NDktM2M0ZS1iNjFmLTE2NWFmZDM2YmYzNyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pvm07Z8AAADSSURBVHjaYvj//z8DPswIBI6Ojiz41LAwEAAzpk1bw83Lyw5k+uBUhM+GyRMnzv3+/ft/EJ4+dWodLnU4Dejr6en+9OnTfxh48eLF/6amJneiDelsb6969+7df3Rw+fLln+np6XIEDWloaMgA2YoL7N6163lYWBgnTkPqa2oiHz169J8QWLx48RFQrGEYUlpa6n379u1//4kAP378+D9xwoR+FEPy8vJsr1y58uc/CeDly5f/66qrw8CGZGZmSp85ffrVfzLA5UuXvuakpMgDBBgAQbLv2dsvRWYAAAAASUVORK5CYII="

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/5_1.png":
/*!************************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/5_1.png ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAKCAYAAABSfLWiAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxY2VjNGU4ZS1iOGY2LTliNGQtOTI4Ny00NDllN2M2NDNlOTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MkI4MDFBOTY3RTk2MTFFODhENTE4NERCOTYxNjg4MjUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MkI4MDFBOTU3RTk2MTFFODhENTE4NERCOTYxNjg4MjUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MWNlYzRlOGUtYjhmNi05YjRkLTkyODctNDQ5ZTdjNjQzZTk0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFjZWM0ZThlLWI4ZjYtOWI0ZC05Mjg3LTQ0OWU3YzY0M2U5NCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PmUmXhQAAADFSURBVHjaYshKSpK/fOnS1/9kgNOnTr1KT0+XZgCBmsrKsJcvX5JkwJUrV/7k5OTYMiCDCRMm9P/48YMoA27duvWvuLjYmwELYFy0aNERQgY8evTof111dSQDLhASEsK5a+fO57gMePHixf/6+voMBkIgLS1N7tKlSz/RDXj37t3/zvb2KgZiQWNjozvIVhj49OnT/97u7m4GUsH0qVPrvn///h+EJ0+YMJeBXLBkyZItM6dNW8tACbC3t2cBxRohdQABBgAt8yx0KlQQZgAAAABJRU5ErkJggg=="

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/close-2.png":
/*!****************************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/close-2.png ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHCAIAAACk8qu6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA0ppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTM3RTZFNDFBOTZDMTFFNUE2QTA4M0M3MDI4QUVDMTQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTM3RTZFNDBBOTZDMTFFNUE2QTA4M0M3MDI4QUVDMTQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo3ZmI2MGZkMi1hOTZjLTExZTUtYWU4Yi1kYzQ2ODQxNzA1ZmIiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo3ZmI2MGZkMi1hOTZjLTExZTUtYWU4Yi1kYzQ2ODQxNzA1ZmIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6Qths+AAAAgElEQVR42iSNMQ4EERiFrd3KKHEBKkeYYziAxAXVCiq9SkPpDMQ0s9k/s694yZd8eQ/NOccY3yettfu+31LKnLMQopQSQsAYv2qt3ntQEELHcVhrsdZaKYWenOfJOf/EGHvvhJDrulJKjDG81qKUOueMMSACIljZe/8fgaF/AgwARJdHBal88EIAAAAASUVORK5CYII="

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/ico-dot.png":
/*!****************************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/ico-dot.png ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAICAYAAAAx8TU7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA0ppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTM3QjEyRDNBOTZDMTFFNUE2QTA4M0M3MDI4QUVDMTQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTM3QjEyRDJBOTZDMTFFNUE2QTA4M0M3MDI4QUVDMTQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo3ZmI2MGZkMi1hOTZjLTExZTUtYWU4Yi1kYzQ2ODQxNzA1ZmIiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo3ZmI2MGZkMi1hOTZjLTExZTUtYWU4Yi1kYzQ2ODQxNzA1ZmIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4r2gBAAAAASklEQVR42mL4////HCBmB2IGGAYRIHACiKXRBUHgORBbgwQZ/4Ol4OA3EOcxMaCCf2AJJO1PgNgC2cyjQCyJbNEMIGZDdhJAgAEACP9sQulYHrwAAAAASUVORK5CYII="

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/infownd-close-hover.png":
/*!****************************************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/infownd-close-hover.png ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAKN2lDQ1BzUkdCIElFQzYxOTY2LTIuMQAAeJydlndUU9kWh8+9N71QkhCKlNBraFICSA29SJEuKjEJEErAkAAiNkRUcERRkaYIMijggKNDkbEiioUBUbHrBBlE1HFwFBuWSWStGd+8ee/Nm98f935rn73P3Wfvfda6AJD8gwXCTFgJgAyhWBTh58WIjYtnYAcBDPAAA2wA4HCzs0IW+EYCmQJ82IxsmRP4F726DiD5+yrTP4zBAP+flLlZIjEAUJiM5/L42VwZF8k4PVecJbdPyZi2NE3OMErOIlmCMlaTc/IsW3z2mWUPOfMyhDwZy3PO4mXw5Nwn4405Er6MkWAZF+cI+LkyviZjg3RJhkDGb+SxGXxONgAoktwu5nNTZGwtY5IoMoIt43kA4EjJX/DSL1jMzxPLD8XOzFouEiSniBkmXFOGjZMTi+HPz03ni8XMMA43jSPiMdiZGVkc4XIAZs/8WRR5bRmyIjvYODk4MG0tbb4o1H9d/JuS93aWXoR/7hlEH/jD9ld+mQ0AsKZltdn6h21pFQBd6wFQu/2HzWAvAIqyvnUOfXEeunxeUsTiLGcrq9zcXEsBn2spL+jv+p8Of0NffM9Svt3v5WF485M4knQxQ143bmZ6pkTEyM7icPkM5p+H+B8H/nUeFhH8JL6IL5RFRMumTCBMlrVbyBOIBZlChkD4n5r4D8P+pNm5lona+BHQllgCpSEaQH4eACgqESAJe2Qr0O99C8ZHA/nNi9GZmJ37z4L+fVe4TP7IFiR/jmNHRDK4ElHO7Jr8WgI0IABFQAPqQBvoAxPABLbAEbgAD+ADAkEoiARxYDHgghSQAUQgFxSAtaAYlIKtYCeoBnWgETSDNnAYdIFj4DQ4By6By2AE3AFSMA6egCnwCsxAEISFyBAVUod0IEPIHLKFWJAb5AMFQxFQHJQIJUNCSAIVQOugUqgcqobqoWboW+godBq6AA1Dt6BRaBL6FXoHIzAJpsFasBFsBbNgTzgIjoQXwcnwMjgfLoK3wJVwA3wQ7oRPw5fgEVgKP4GnEYAQETqiizARFsJGQpF4JAkRIauQEqQCaUDakB6kH7mKSJGnyFsUBkVFMVBMlAvKHxWF4qKWoVahNqOqUQdQnag+1FXUKGoK9RFNRmuizdHO6AB0LDoZnYsuRlegm9Ad6LPoEfQ4+hUGg6FjjDGOGH9MHCYVswKzGbMb0445hRnGjGGmsVisOtYc64oNxXKwYmwxtgp7EHsSewU7jn2DI+J0cLY4X1w8TogrxFXgWnAncFdwE7gZvBLeEO+MD8Xz8MvxZfhGfA9+CD+OnyEoE4wJroRIQiphLaGS0EY4S7hLeEEkEvWITsRwooC4hlhJPEQ8TxwlviVRSGYkNimBJCFtIe0nnSLdIr0gk8lGZA9yPFlM3kJuJp8h3ye/UaAqWCoEKPAUVivUKHQqXFF4pohXNFT0VFysmK9YoXhEcUjxqRJeyUiJrcRRWqVUo3RU6YbStDJV2UY5VDlDebNyi/IF5UcULMWI4kPhUYoo+yhnKGNUhKpPZVO51HXURupZ6jgNQzOmBdBSaaW0b2iDtCkVioqdSrRKnkqNynEVKR2hG9ED6On0Mvph+nX6O1UtVU9Vvuom1TbVK6qv1eaoeajx1UrU2tVG1N6pM9R91NPUt6l3qd/TQGmYaYRr5Grs0Tir8XQObY7LHO6ckjmH59zWhDXNNCM0V2ju0xzQnNbS1vLTytKq0jqj9VSbru2hnaq9Q/uE9qQOVcdNR6CzQ+ekzmOGCsOTkc6oZPQxpnQ1df11Jbr1uoO6M3rGelF6hXrtevf0Cfos/ST9Hfq9+lMGOgYhBgUGrQa3DfGGLMMUw12G/YavjYyNYow2GHUZPTJWMw4wzjduNb5rQjZxN1lm0mByzRRjyjJNM91tetkMNrM3SzGrMRsyh80dzAXmu82HLdAWThZCiwaLG0wS05OZw2xljlrSLYMtCy27LJ9ZGVjFW22z6rf6aG1vnW7daH3HhmITaFNo02Pzq62ZLde2xvbaXPJc37mr53bPfW5nbse322N3055qH2K/wb7X/oODo4PIoc1h0tHAMdGx1vEGi8YKY21mnXdCO3k5rXY65vTW2cFZ7HzY+RcXpkuaS4vLo3nG8/jzGueNueq5clzrXaVuDLdEt71uUnddd457g/sDD30PnkeTx4SnqWeq50HPZ17WXiKvDq/XbGf2SvYpb8Tbz7vEe9CH4hPlU+1z31fPN9m31XfKz95vhd8pf7R/kP82/xsBWgHcgOaAqUDHwJWBfUGkoAVB1UEPgs2CRcE9IXBIYMj2kLvzDecL53eFgtCA0O2h98KMw5aFfR+OCQ8Lrwl/GGETURDRv4C6YMmClgWvIr0iyyLvRJlESaJ6oxWjE6Kbo1/HeMeUx0hjrWJXxl6K04gTxHXHY+Oj45vipxf6LNy5cDzBPqE44foi40V5iy4s1licvvj4EsUlnCVHEtGJMYktie85oZwGzvTSgKW1S6e4bO4u7hOeB28Hb5Lvyi/nTyS5JpUnPUp2Td6ePJninlKR8lTAFlQLnqf6p9alvk4LTduf9ik9Jr09A5eRmHFUSBGmCfsytTPzMoezzLOKs6TLnJftXDYlChI1ZUPZi7K7xTTZz9SAxESyXjKa45ZTk/MmNzr3SJ5ynjBvYLnZ8k3LJ/J9879egVrBXdFboFuwtmB0pefK+lXQqqWrelfrry5aPb7Gb82BtYS1aWt/KLQuLC98uS5mXU+RVtGaorH1futbixWKRcU3NrhsqNuI2ijYOLhp7qaqTR9LeCUXS61LK0rfb+ZuvviVzVeVX33akrRlsMyhbM9WzFbh1uvb3LcdKFcuzy8f2x6yvXMHY0fJjpc7l+y8UGFXUbeLsEuyS1oZXNldZVC1tep9dUr1SI1XTXutZu2m2te7ebuv7PHY01anVVda926vYO/Ner/6zgajhop9mH05+x42Rjf2f836urlJo6m06cN+4X7pgYgDfc2Ozc0tmi1lrXCrpHXyYMLBy994f9Pdxmyrb6e3lx4ChySHHn+b+O31w0GHe4+wjrR9Z/hdbQe1o6QT6lzeOdWV0iXtjusePhp4tLfHpafje8vv9x/TPVZzXOV42QnCiaITn07mn5w+lXXq6enk02O9S3rvnIk9c60vvG/wbNDZ8+d8z53p9+w/ed71/LELzheOXmRd7LrkcKlzwH6g4wf7HzoGHQY7hxyHui87Xe4Znjd84or7ldNXva+euxZw7dLI/JHh61HXb95IuCG9ybv56Fb6ree3c27P3FlzF3235J7SvYr7mvcbfjT9sV3qID0+6j068GDBgztj3LEnP2X/9H686CH5YcWEzkTzI9tHxyZ9Jy8/Xvh4/EnWk5mnxT8r/1z7zOTZd794/DIwFTs1/lz0/NOvm1+ov9j/0u5l73TY9P1XGa9mXpe8UX9z4C3rbf+7mHcTM7nvse8rP5h+6PkY9PHup4xPn34D94Tz+49wZioAAAAJcEhZcwAACxIAAAsSAdLdfvwAAADwSURBVHicYwmrmMXPxsVzgoF48ImFlZGHiZGBQYMETe9ZSFAMBxiaZET5GQzUpBm2HL3GwMLMxOBvq8Ow/9wdhnefvuHWFONuzKCpIMYgws/FIMjLxWCgKsXAx83OMH/radya5m49xVAZ68TgaKQC5j95/ZFh7YHL+J33/tN3hudvPjEI83GB+feevWP49PUHfk0pvmYMOkoSDI9ffWDg4mBjsNNXBBr0jWHdwcu4NV29/4JBGOifiauOMHBysDLkhdgw3HnyBr9Nhy/eB2MQ+PL9J0Pt7B3oSjA1EQPI0/T77oZPLFpemsRqYPzL9hcAyOZIEFj9ZVMAAAAASUVORK5CYII="

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/infownd-close.png":
/*!**********************************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/infownd-close.png ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAKN2lDQ1BzUkdCIElFQzYxOTY2LTIuMQAAeJydlndUU9kWh8+9N71QkhCKlNBraFICSA29SJEuKjEJEErAkAAiNkRUcERRkaYIMijggKNDkbEiioUBUbHrBBlE1HFwFBuWSWStGd+8ee/Nm98f935rn73P3Wfvfda6AJD8gwXCTFgJgAyhWBTh58WIjYtnYAcBDPAAA2wA4HCzs0IW+EYCmQJ82IxsmRP4F726DiD5+yrTP4zBAP+flLlZIjEAUJiM5/L42VwZF8k4PVecJbdPyZi2NE3OMErOIlmCMlaTc/IsW3z2mWUPOfMyhDwZy3PO4mXw5Nwn4405Er6MkWAZF+cI+LkyviZjg3RJhkDGb+SxGXxONgAoktwu5nNTZGwtY5IoMoIt43kA4EjJX/DSL1jMzxPLD8XOzFouEiSniBkmXFOGjZMTi+HPz03ni8XMMA43jSPiMdiZGVkc4XIAZs/8WRR5bRmyIjvYODk4MG0tbb4o1H9d/JuS93aWXoR/7hlEH/jD9ld+mQ0AsKZltdn6h21pFQBd6wFQu/2HzWAvAIqyvnUOfXEeunxeUsTiLGcrq9zcXEsBn2spL+jv+p8Of0NffM9Svt3v5WF485M4knQxQ143bmZ6pkTEyM7icPkM5p+H+B8H/nUeFhH8JL6IL5RFRMumTCBMlrVbyBOIBZlChkD4n5r4D8P+pNm5lona+BHQllgCpSEaQH4eACgqESAJe2Qr0O99C8ZHA/nNi9GZmJ37z4L+fVe4TP7IFiR/jmNHRDK4ElHO7Jr8WgI0IABFQAPqQBvoAxPABLbAEbgAD+ADAkEoiARxYDHgghSQAUQgFxSAtaAYlIKtYCeoBnWgETSDNnAYdIFj4DQ4By6By2AE3AFSMA6egCnwCsxAEISFyBAVUod0IEPIHLKFWJAb5AMFQxFQHJQIJUNCSAIVQOugUqgcqobqoWboW+godBq6AA1Dt6BRaBL6FXoHIzAJpsFasBFsBbNgTzgIjoQXwcnwMjgfLoK3wJVwA3wQ7oRPw5fgEVgKP4GnEYAQETqiizARFsJGQpF4JAkRIauQEqQCaUDakB6kH7mKSJGnyFsUBkVFMVBMlAvKHxWF4qKWoVahNqOqUQdQnag+1FXUKGoK9RFNRmuizdHO6AB0LDoZnYsuRlegm9Ad6LPoEfQ4+hUGg6FjjDGOGH9MHCYVswKzGbMb0445hRnGjGGmsVisOtYc64oNxXKwYmwxtgp7EHsSewU7jn2DI+J0cLY4X1w8TogrxFXgWnAncFdwE7gZvBLeEO+MD8Xz8MvxZfhGfA9+CD+OnyEoE4wJroRIQiphLaGS0EY4S7hLeEEkEvWITsRwooC4hlhJPEQ8TxwlviVRSGYkNimBJCFtIe0nnSLdIr0gk8lGZA9yPFlM3kJuJp8h3ye/UaAqWCoEKPAUVivUKHQqXFF4pohXNFT0VFysmK9YoXhEcUjxqRJeyUiJrcRRWqVUo3RU6YbStDJV2UY5VDlDebNyi/IF5UcULMWI4kPhUYoo+yhnKGNUhKpPZVO51HXURupZ6jgNQzOmBdBSaaW0b2iDtCkVioqdSrRKnkqNynEVKR2hG9ED6On0Mvph+nX6O1UtVU9Vvuom1TbVK6qv1eaoeajx1UrU2tVG1N6pM9R91NPUt6l3qd/TQGmYaYRr5Grs0Tir8XQObY7LHO6ckjmH59zWhDXNNCM0V2ju0xzQnNbS1vLTytKq0jqj9VSbru2hnaq9Q/uE9qQOVcdNR6CzQ+ekzmOGCsOTkc6oZPQxpnQ1df11Jbr1uoO6M3rGelF6hXrtevf0Cfos/ST9Hfq9+lMGOgYhBgUGrQa3DfGGLMMUw12G/YavjYyNYow2GHUZPTJWMw4wzjduNb5rQjZxN1lm0mByzRRjyjJNM91tetkMNrM3SzGrMRsyh80dzAXmu82HLdAWThZCiwaLG0wS05OZw2xljlrSLYMtCy27LJ9ZGVjFW22z6rf6aG1vnW7daH3HhmITaFNo02Pzq62ZLde2xvbaXPJc37mr53bPfW5nbse322N3055qH2K/wb7X/oODo4PIoc1h0tHAMdGx1vEGi8YKY21mnXdCO3k5rXY65vTW2cFZ7HzY+RcXpkuaS4vLo3nG8/jzGueNueq5clzrXaVuDLdEt71uUnddd457g/sDD30PnkeTx4SnqWeq50HPZ17WXiKvDq/XbGf2SvYpb8Tbz7vEe9CH4hPlU+1z31fPN9m31XfKz95vhd8pf7R/kP82/xsBWgHcgOaAqUDHwJWBfUGkoAVB1UEPgs2CRcE9IXBIYMj2kLvzDecL53eFgtCA0O2h98KMw5aFfR+OCQ8Lrwl/GGETURDRv4C6YMmClgWvIr0iyyLvRJlESaJ6oxWjE6Kbo1/HeMeUx0hjrWJXxl6K04gTxHXHY+Oj45vipxf6LNy5cDzBPqE44foi40V5iy4s1licvvj4EsUlnCVHEtGJMYktie85oZwGzvTSgKW1S6e4bO4u7hOeB28Hb5Lvyi/nTyS5JpUnPUp2Td6ePJninlKR8lTAFlQLnqf6p9alvk4LTduf9ik9Jr09A5eRmHFUSBGmCfsytTPzMoezzLOKs6TLnJftXDYlChI1ZUPZi7K7xTTZz9SAxESyXjKa45ZTk/MmNzr3SJ5ynjBvYLnZ8k3LJ/J9879egVrBXdFboFuwtmB0pefK+lXQqqWrelfrry5aPb7Gb82BtYS1aWt/KLQuLC98uS5mXU+RVtGaorH1futbixWKRcU3NrhsqNuI2ijYOLhp7qaqTR9LeCUXS61LK0rfb+ZuvviVzVeVX33akrRlsMyhbM9WzFbh1uvb3LcdKFcuzy8f2x6yvXMHY0fJjpc7l+y8UGFXUbeLsEuyS1oZXNldZVC1tep9dUr1SI1XTXutZu2m2te7ebuv7PHY01anVVda926vYO/Ner/6zgajhop9mH05+x42Rjf2f836urlJo6m06cN+4X7pgYgDfc2Ozc0tmi1lrXCrpHXyYMLBy994f9Pdxmyrb6e3lx4ChySHHn+b+O31w0GHe4+wjrR9Z/hdbQe1o6QT6lzeOdWV0iXtjusePhp4tLfHpafje8vv9x/TPVZzXOV42QnCiaITn07mn5w+lXXq6enk02O9S3rvnIk9c60vvG/wbNDZ8+d8z53p9+w/ed71/LELzheOXmRd7LrkcKlzwH6g4wf7HzoGHQY7hxyHui87Xe4Znjd84or7ldNXva+euxZw7dLI/JHh61HXb95IuCG9ybv56Fb6ree3c27P3FlzF3235J7SvYr7mvcbfjT9sV3qID0+6j068GDBgztj3LEnP2X/9H686CH5YcWEzkTzI9tHxyZ9Jy8/Xvh4/EnWk5mnxT8r/1z7zOTZd794/DIwFTs1/lz0/NOvm1+ov9j/0u5l73TY9P1XGa9mXpe8UX9z4C3rbf+7mHcTM7nvse8rP5h+6PkY9PHup4xPn34D94Tz+49wZioAAAAJcEhZcwAACxIAAAsSAdLdfvwAAADrSURBVHicY/n//z8DqYAFRDAxMTESq+Hfv3//WUi2BmYTMmhqatL7+/fv5cbGxv/19fWSbGxsf6urq1/h1ARU5A+0fj0jI+MsILsXKLTv169fP1atWqUeFhb2D6smFhaWi3/+/HkMZKYBNcYBA4kDyJ6NrAFDU21t7QOgDSlA5k6QBqDGW0A6C6+fmpublYA2zQOxgRq+ATWoAZnTgDgdpyagBk0gJQXUMI2ZmbkPyN8P5DsAbWcFBsxvrJqAEluBtmkDFd8EOvV/a2urOTAg/iJrwNAE9dcNGBsY1C/Q5bFqIgaANYGSBimaAADgbhvLwt8+AAAAAElFTkSuQmCC"

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/kedu.png":
/*!*************************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/kedu.png ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAKCAIAAADU9YKPAAAACXBIWXMAAAsTAAALEwEAmpwYAAA5wmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPnhtcC5kaWQ6RTM3RTZFMzlBOTZDMTFFNUE2QTA4M0M3MDI4QUVDMTQ8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6YWU0YTg0NGMtNjZmNS1kMDRmLWE5ZjAtMDk0ZTI2MTY3OWZhPC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD5hZG9iZTpkb2NpZDpwaG90b3Nob3A6N2ZiNjBmZDItYTk2Yy0xMWU1LWFlOGItZGM0Njg0MTcwNWZiPC9zdFJlZjppbnN0YW5jZUlEPgogICAgICAgICAgICA8c3RSZWY6ZG9jdW1lbnRJRD5hZG9iZTpkb2NpZDpwaG90b3Nob3A6N2ZiNjBmZDItYTk2Yy0xMWU1LWFlOGItZGM0Njg0MTcwNWZiPC9zdFJlZjpkb2N1bWVudElEPgogICAgICAgICA8L3htcE1NOkRlcml2ZWRGcm9tPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6RTM3RTZFMzlBOTZDMTFFNUE2QTA4M0M3MDI4QUVDMTQ8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmFlNGE4NDRjLTY2ZjUtZDA0Zi1hOWYwLTA5NGUyNjE2NzlmYTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNS0xMi0yM1QyMzoxMzo0MyswODowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE1LTEyLTIzVDIwOjAxOjI0KzA4OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTUtMTItMjNUMjM6MTM6NDMrMDg6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE1LTEyLTIzVDIzOjEzOjQzKzA4OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT42NTUzNTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MjE8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MTA8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pt3JU14AAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAADVJREFUeNpiNPGMY6AAMDFQBgZaPwsyh5GRUUJMBL+G5y9f08z+////oxk/7MMfAAAA//8DAJVuCav6Kz+hAAAAAElFTkSuQmCC"

/***/ }),

/***/ "../node_modules/maptalks/dist/images/control/layer.png":
/*!**************************************************************!*\
  !*** ../node_modules/maptalks/dist/images/control/layer.png ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAUCAYAAABvVQZ0AAAAAXNSR0IArs4c6QAAAUVJREFUOBGdkjFuAjEQRUmBqJC4AvWWSCm24xp0EX3Sp9uLIOUQaejSUXEMGhSJGyzvOx7Ha3mMxEgf2+M/j/HAbNaIcRxXaECnuK4a9vpVBrmxz0NnwR9DZYrmHHIkt0NaLXwoDg/S573j65EP5fIDlZ1MIDlQewf6rosrsvhm83gef0C9Rn6Lq2Ab5LdetIXXG8kmWTE159GA/I8EU4dejepAv8i7c1U96vTMC1L8oG0DKo/GkTqRH6lOcRFsj351ilGDDtx5EJWpfh8aYbNEnzHJEmIClZHsFilvIYjqlgZacJhHswd9w+NCVI8W+rYz0nAHFP5jrDUo6fCc1In8SHWqPwt2QBYeVF15EKs92FN7MkfLsk6gwcQH+bwTs6su/TjmldmDrrmz57QhiRY3FagBtNY7KSHluYA+B6lAX8pc7XwHMYFxBb/kUuEAAAAASUVORK5CYII="

/***/ }),

/***/ "../node_modules/maptalks/dist/maptalks.css":
/*!**************************************************!*\
  !*** ../node_modules/maptalks/dist/maptalks.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js??ref--8-1!../../postcss-loader/src??ref--8-2!../../sass-loader/dist/cjs.js!./maptalks.css */ "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/dist/cjs.js!../node_modules/maptalks/dist/maptalks.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "../node_modules/maptalks/dist/maptalks.es.js":
/*!****************************************************!*\
  !*** ../node_modules/maptalks/dist/maptalks.es.js ***!
  \****************************************************/
/*! exports provided: Util, DomUtil, StringUtil, MapboxUtil, Map, ui, control, renderer, symbolizer, animation, Browser, Ajax, Canvas, Promise, Class, Eventable, JSONAble, Handlerable, Handler, DragHandler, MapTool, DrawTool, AreaTool, DistanceTool, SpatialReference, INTERNAL_LAYER_PREFIX, GEOMETRY_COLLECTION_TYPES, GEOJSON_TYPES, RESOURCE_PROPERTIES, RESOURCE_SIZE_PROPERTIES, NUMERICAL_PROPERTIES, COLOR_PROPERTIES, DEFAULT_TEXT_SIZE, projection, measurer, Coordinate, CRS, Extent, Point, PointExtent, Size, Transformation, Layer, TileLayer, GroupTileLayer, WMSTileLayer, CanvasTileLayer, ImageLayer, OverlayLayer, VectorLayer, CanvasLayer, ParticleLayer, TileSystem, TileConfig, ArcCurve, Circle, ConnectorLine, ArcConnectorLine, CubicBezierCurve, Curve, Ellipse, GeoJSON, Geometry, GeometryCollection, Label, LineString, Marker, MultiLineString, MultiPoint, MultiPolygon, Polygon, QuadBezierCurve, Rectangle, Sector, TextBox, TextMarker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Util", function() { return index$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomUtil", function() { return dom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringUtil", function() { return strings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapboxUtil", function() { return index; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ui", function() { return index$4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "control", function() { return index$5; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderer", function() { return index$6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symbolizer", function() { return index$3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animation", function() { return Animation$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Browser", function() { return Browser$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ajax", function() { return Ajax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Canvas", function() { return Canvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Promise", function() { return Promise$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Class", function() { return Class; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Eventable", function() { return Eventable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONAble", function() { return JSONAble; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Handlerable", function() { return Handlerable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Handler", function() { return Handler$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DragHandler", function() { return DragHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapTool", function() { return MapTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawTool", function() { return DrawTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaTool", function() { return AreaTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistanceTool", function() { return DistanceTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpatialReference", function() { return SpatialReference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTERNAL_LAYER_PREFIX", function() { return INTERNAL_LAYER_PREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOMETRY_COLLECTION_TYPES", function() { return GEOMETRY_COLLECTION_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOJSON_TYPES", function() { return GEOJSON_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOURCE_PROPERTIES", function() { return RESOURCE_PROPERTIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOURCE_SIZE_PROPERTIES", function() { return RESOURCE_SIZE_PROPERTIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMERICAL_PROPERTIES", function() { return NUMERICAL_PROPERTIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_PROPERTIES", function() { return COLOR_PROPERTIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TEXT_SIZE", function() { return DEFAULT_TEXT_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measurer", function() { return index$2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Coordinate", function() { return Coordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CRS", function() { return CRS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Extent", function() { return Extent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointExtent", function() { return PointExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Size", function() { return Size; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transformation", function() { return Transformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layer", function() { return Layer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileLayer", function() { return TileLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupTileLayer", function() { return GroupTileLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WMSTileLayer", function() { return WMSTileLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTileLayer", function() { return CanvasTileLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLayer", function() { return ImageLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayLayer", function() { return OverlayLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorLayer", function() { return VectorLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasLayer", function() { return CanvasLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleLayer", function() { return ParticleLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileSystem", function() { return TileSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileConfig", function() { return TileConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectorLine", function() { return ConnectorLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcConnectorLine", function() { return ArcConnectorLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ellipse", function() { return Ellipse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoJSON", function() { return GeoJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryCollection", function() { return GeometryCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return Label; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineString", function() { return LineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Marker", function() { return Marker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiLineString", function() { return MultiLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiPoint", function() { return MultiPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiPolygon", function() { return MultiPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadBezierCurve", function() { return QuadBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rectangle", function() { return Rectangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sector", function() { return Sector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBox", function() { return TextBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextMarker", function() { return TextMarker; });
/*!
 * maptalks v0.49.1
 * LICENSE : BSD-3-Clause
 * (c) 2016-2020 maptalks.org
 */
var version = "0.49.1";

var INTERNAL_LAYER_PREFIX = '_maptalks__internal_layer_';
var GEOMETRY_COLLECTION_TYPES = ['MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];
var GEOJSON_TYPES = ['FeatureCollection', 'Feature', 'Point', 'LineString', 'Polygon'].concat(GEOMETRY_COLLECTION_TYPES);
var RESOURCE_PROPERTIES = ['markerFile', 'polygonPatternFile', 'linePatternFile', 'markerFillPatternFile', 'markerLinePatternFile'];
var RESOURCE_SIZE_PROPERTIES = [['markerWidth', 'markerHeight'], [], [null, 'lineWidth'], [], [null, 'markerLineWidth']];
var NUMERICAL_PROPERTIES = {
  'lineWidth': 1,
  'lineOpacity': 1,
  'lineDx': 1,
  'lineDy': 1,
  'polygonOpacity': 1,
  'markerWidth': 1,
  'markerHeight': 1,
  'markerDx': 1,
  'markerDy': 1,
  'markerOpacity': 1,
  'markerFillOpacity': 1,
  'markerLineWidth': 1,
  'markerLineOpacity': 1,
  'textSize': 1,
  'textOpacity': 1,
  'textHaloRadius': 1,
  'textWrapWidth': 1,
  'textLineSpacing': 1,
  'textDx': 1,
  'textDy': 1
};
var COLOR_PROPERTIES = ['lineColor', 'polygonFill', 'markerFill', 'markerLineColor', 'textFill'];
var DEFAULT_TEXT_SIZE = 14;

function now() {
  return Date.now();
}
function extend(dest) {
  for (var i = 1; i < arguments.length; i++) {
    var src = arguments[i];

    for (var k in src) {
      dest[k] = src[k];
    }
  }

  return dest;
}
function isNil(obj) {
  return obj == null;
}
function isNumber(val) {
  return typeof val === 'number' && !isNaN(val);
}
function isInteger(n) {
  return (n | 0) === n;
}
function isObject(obj) {
  return typeof obj === 'object' && !!obj;
}
function isString(obj) {
  if (isNil(obj)) {
    return false;
  }

  return typeof obj === 'string' || obj.constructor !== null && obj.constructor === String;
}
function isFunction(obj) {
  if (isNil(obj)) {
    return false;
  }

  return typeof obj === 'function' || obj.constructor !== null && obj.constructor === Function;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function join(arr, seperator) {
  if (arr.join) {
    return arr.join(seperator || ',');
  } else {
    return Array.prototype.join.call(arr, seperator || ',');
  }
}
function isEmpty(object) {
  var property;

  for (property in object) {
    return false;
  }

  return !property;
}
var pi = Math.PI / 180;
function toRadian(d) {
  return d * pi;
}
function toDegree(r) {
  return r / pi;
}

var IS_NODE = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]' && !process.versions['electron'] && !process.versions['nw'] && !process.versions['node-webkit'];

var requestAnimFrame, cancelAnimFrame;

(function () {
  if (IS_NODE) {
    requestAnimFrame = function requestAnimFrame(fn) {
      return setTimeout(fn, 16);
    };

    cancelAnimFrame = clearTimeout;
    return;
  }

  var requestFn, cancelFn;
  var timeToCall = 1000 / 30;

  function timeoutDefer(fn) {
    return setTimeout(fn, timeToCall);
  }

  function getPrefixed(name) {
    return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  if (typeof window != 'undefined') {
    requestFn = window['requestAnimationFrame'] || getPrefixed('RequestAnimationFrame') || timeoutDefer;

    cancelFn = window['cancelAnimationFrame'] || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
      window.clearTimeout(id);
    };
  } else {
    requestFn = timeoutDefer;
    cancelFn = clearTimeout;
  }

  requestAnimFrame = function requestAnimFrame(fn) {
    return requestFn(fn);
  };

  cancelAnimFrame = function cancelAnimFrame(id) {
    if (id) {
      cancelFn(id);
    }
  };
})();
function isSVG(url) {
  var prefix = 'data:image/svg+xml';

  if (url.length > 4 && url.slice(-4) === '.svg') {
    return 1;
  } else if (url.slice(0, prefix.length) === prefix) {
    return 2;
  }

  return 0;
}
function loadImage(img, imgDesc) {
  if (IS_NODE && loadImage.node) {
    loadImage.node(img, imgDesc);
    return;
  }

  img.src = imgDesc[0];
}
var uid = 0;
function UID() {
  return uid++;
}
var GUID = UID;
function parseJSON(str) {
  if (!str || !isString(str)) {
    return str;
  }

  return JSON.parse(str);
}
function pushIn(dest) {
  for (var i = 1; i < arguments.length; i++) {
    var src = arguments[i];

    if (src) {
      for (var ii = 0, ll = src.length; ii < ll; ii++) {
        dest.push(src[ii]);
      }
    }
  }

  return dest.length;
}
function removeFromArray(obj, array) {
  var i = array.indexOf(obj);

  if (i > -1) {
    array.splice(i, 1);
  }
}
function forEachCoord(arr, fn, context) {
  if (!Array.isArray(arr)) {
    return context ? fn.call(context, arr) : fn(arr);
  }

  var result = [];
  var p, pp;

  for (var i = 0, len = arr.length; i < len; i++) {
    p = arr[i];

    if (isNil(p)) {
      result.push(null);
      continue;
    }

    if (Array.isArray(p)) {
      result.push(forEachCoord(p, fn, context));
    } else {
      pp = context ? fn.call(context, p) : fn(p);
      result.push(pp);
    }
  }

  return result;
}
function getValueOrDefault(v, d) {
  return v === undefined ? d : v;
}
function sign(x) {
  if (Math.sign) {
    return Math.sign(x);
  }

  x = +x;

  if (x === 0 || isNaN(x)) {
    return Number(x);
  }

  return x > 0 ? 1 : -1;
}
function log2(x) {
  if (Math.log2) {
    return Math.log2(x);
  }

  var v = Math.log(x) * Math.LOG2E;
  var rounded = Math.round(v);

  if (Math.abs(rounded - v) < 1E-14) {
    return rounded;
  } else {
    return v;
  }
}
function interpolate(a, b, t) {
  return a * (1 - t) + b * t;
}
function wrap(n, min, max) {
  if (n === max || n === min) {
    return n;
  }

  var d = max - min;
  var w = ((n - min) % d + d) % d + min;
  return w;
}
function clamp(n, min, max) {
  return Math.min(max, Math.max(min, n));
}
function isArrayHasData(obj) {
  return Array.isArray(obj) && obj.length > 0;
}
var urlPattern = /^([a-z][a-z\d+\-.]*:)?\/\//i;
function isURL(url) {
  return urlPattern.test(url);
}
var cssUrlReWithQuote = /^url\((['"])(.+)\1\)$/i;
var cssUrlRe = /^url\(([^'"].*[^'"])\)$/i;
function isCssUrl(str) {
  if (!isString(str)) {
    return 0;
  }

  if (cssUrlRe.test(str)) {
    return 1;
  }

  if (cssUrlReWithQuote.test(str)) {
    return 2;
  }

  return 3;
}
function extractCssUrl(str) {
  var test = isCssUrl(str);
  var matches;

  if (test === 3) {
    return str;
  } else if (test === 1) {
    matches = cssUrlRe.exec(str);
    return matches[1];
  } else if (test === 2) {
    matches = cssUrlReWithQuote.exec(str);
    return matches[2];
  } else {
    return str;
  }
}
var b64chrs = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
function btoa(input) {
  if (typeof window !== 'undefined' && window.btoa) {
    return window.btoa(input);
  }

  var str = String(input);
  var output = '';

  for (var block, charCode, idx = 0, map = b64chrs; str.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);

    if (charCode > 0xFF) {
      throw new Error('\'btoa\' failed: The string to be encoded contains characters outside of the Latin1 range.');
    }

    block = block << 8 | charCode;
  }

  return output;
}
function b64toBlob(b64Data, contentType) {
  var byteCharacters = atob(b64Data);
  var arraybuffer = new ArrayBuffer(byteCharacters.length);
  var view = new Uint8Array(arraybuffer);

  for (var i = 0; i < byteCharacters.length; i++) {
    view[i] = byteCharacters.charCodeAt(i) & 0xff;
  }

  var blob = new Blob([arraybuffer], {
    type: contentType
  });
  return blob;
}
function computeDegree(x0, y0, x1, y1) {
  var dx = x1 - x0;
  var dy = y1 - y0;
  return Math.atan2(dy, dx);
}
var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
function equalMapView(obj1, obj2) {
  if (!obj1 && !obj2) {
    return true;
  } else if (!obj1 || !obj2) {
    return false;
  }

  for (var p in obj1) {
    if (p === 'center') {
      if (!obj2[p] || !approx(obj1[p][0], obj2[p][0]) || !approx(obj1[p][1], obj2[p][1])) {
        return false;
      }
    } else if (obj1[p] !== obj2[p]) {
      return false;
    }
  }

  return true;
}

function approx(val, expected, delta) {
  if (delta == null) {
    delta = 1e-6;
  }

  return val >= expected - delta && val <= expected + delta;
}

function flash(interval, count, cb, context) {
  if (!interval) {
    interval = 100;
  }

  if (!count) {
    count = 4;
  }

  var me = this;
  count *= 2;

  if (this._flashTimeout) {
    clearTimeout(this._flashTimeout);
  }

  function flashGeo() {
    if (count === 0) {
      me.show();

      if (cb) {
        if (context) {
          cb.call(context);
        } else {
          cb();
        }
      }

      return;
    }

    if (count % 2 === 0) {
      me.hide();
    } else {
      me.show();
    }

    count--;
    me._flashTimeout = setTimeout(flashGeo, interval);
  }

  this._flashTimeout = setTimeout(flashGeo, interval);
  return this;
}
function _defaults(obj, defaults) {
  var keys = Object.getOwnPropertyNames(defaults);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = Object.getOwnPropertyDescriptor(defaults, key);

    if (value && value.configurable && obj[key] === undefined) {
      Object.defineProperty(obj, key, value);
    }
  }

  return obj;
}

var types = ['Unknown', 'Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];
function createFilter(filter) {
  return new Function('f', "var p = (f && f.properties || {}); return " + compile(filter));
}

function compile(filter) {
  if (!filter) return 'true';
  var op = filter[0];
  if (filter.length <= 1) return op === 'any' ? 'false' : 'true';
  var str = op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) : op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) : op === '<' || op === '>' || op === '<=' || op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) : op === 'any' ? compileLogicalOp(filter.slice(1), '||') : op === 'all' ? compileLogicalOp(filter.slice(1), '&&') : op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) : op === 'in' ? compileInOp(filter[1], filter.slice(2)) : op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) : op === 'has' ? compileHasOp(filter[1]) : op === '!has' ? compileNegation(compileHasOp(filter[1])) : 'true';
  return "(" + str + ")";
}

function compilePropertyReference(property) {
  return property[0] === '$' ? 'f.' + property.substring(1) : 'p[' + JSON.stringify(property) + ']';
}

function compileComparisonOp(property, value, op, checkType) {
  var left = compilePropertyReference(property);
  var right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);
  return (checkType ? "typeof " + left + "=== typeof " + right + "&&" : '') + left + op + right;
}

function compileLogicalOp(expressions, op) {
  return expressions.map(compile).join(op);
}

function compileInOp(property, values) {
  if (property === '$type') values = values.map(function (value) {
    return types.indexOf(value);
  });
  var left = JSON.stringify(values.sort(compare));
  var right = compilePropertyReference(property);
  if (values.length <= 200) return left + ".indexOf(" + right + ") !== -1";
  return "function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(" + right + ", " + left + ",0," + (values.length - 1) + ")";
}

function compileHasOp(property) {
  return property === '$id' ? '"id" in f' : JSON.stringify(property) + " in p";
}

function compileNegation(expression) {
  return "!(" + expression + ")";
}

function compare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

function getFilterFeature(geometry) {
  var json = geometry._toJSON(),
      g = json['feature'];

  g['type'] = types.indexOf(g['geometry']['type']);
  g['subType'] = json['subType'];
  return g;
}
function compileStyle(styles) {
  if (!Array.isArray(styles)) {
    return compileStyle([styles]);
  }

  var compiled = [];

  for (var i = 0; i < styles.length; i++) {
    var filter = void 0;

    if (styles[i]['filter'] === true) {
      filter = function filter() {
        return true;
      };
    } else {
      filter = createFilter(styles[i]['filter']);
    }

    compiled.push(extend$1({}, styles[i], {
      filter: filter
    }));
  }

  return compiled;
}

function extend$1(dest) {
  for (var i = 1; i < arguments.length; i++) {
    var src = arguments[i];

    for (var k in src) {
      dest[k] = src[k];
    }
  }

  return dest;
}

function createFunction(parameters, defaultType) {
  var fun;
  var isFeatureConstant, isZoomConstant;

  if (!isFunctionDefinition(parameters)) {
    fun = function fun() {
      return parameters;
    };

    isFeatureConstant = true;
    isZoomConstant = true;
  } else {
    var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    var type = parameters.type || defaultType || 'exponential';
    var innerFun;

    if (type === 'exponential') {
      innerFun = evaluateExponentialFunction;
    } else if (type === 'interval') {
      innerFun = evaluateIntervalFunction;
    } else if (type === 'categorical') {
      innerFun = evaluateCategoricalFunction;
    } else if (type === 'identity') {
      innerFun = evaluateIdentityFunction;
    } else {
      throw new Error('Unknown function type "' + type + '"');
    }

    if (zoomAndFeatureDependent) {
      var featureFunctions = {};
      var featureFunctionStops = [];

      for (var s = 0; s < parameters.stops.length; s++) {
        var stop = parameters.stops[s];

        if (featureFunctions[stop[0].zoom] === undefined) {
          featureFunctions[stop[0].zoom] = {
            zoom: stop[0].zoom,
            type: parameters.type,
            property: parameters.property,
            default: parameters.default,
            stops: []
          };
        }

        featureFunctions[stop[0].zoom].stops.push([stop[0].value, stop[1]]);
      }

      for (var z in featureFunctions) {
        featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z])]);
      }

      fun = function fun(zoom, feature) {
        var value = evaluateExponentialFunction({
          stops: featureFunctionStops,
          base: parameters.base
        }, zoom)(zoom, feature);
        return typeof value === 'function' ? value(zoom, feature) : value;
      };

      isFeatureConstant = false;
      isZoomConstant = false;
    } else if (zoomDependent) {
      fun = function fun(zoom) {
        var value = innerFun(parameters, zoom);
        return typeof value === 'function' ? value(zoom) : value;
      };

      isFeatureConstant = true;
      isZoomConstant = false;
    } else {
      fun = function fun(zoom, feature) {
        var value = innerFun(parameters, feature ? feature[parameters.property] : null);
        return typeof value === 'function' ? value(zoom, feature) : value;
      };

      isFeatureConstant = false;
      isZoomConstant = true;
    }
  }

  fun.isZoomConstant = isZoomConstant;
  fun.isFeatureConstant = isFeatureConstant;
  return fun;
}

function coalesce(a, b, c) {
  if (a !== undefined) return a;
  if (b !== undefined) return b;
  if (c !== undefined) return c;
  return null;
}

function evaluateCategoricalFunction(parameters, input) {
  for (var i = 0; i < parameters.stops.length; i++) {
    if (input === parameters.stops[i][0]) {
      return parameters.stops[i][1];
    }
  }

  return parameters.default;
}

function evaluateIntervalFunction(parameters, input) {
  for (var i = 0; i < parameters.stops.length; i++) {
    if (input < parameters.stops[i][0]) break;
  }

  return parameters.stops[Math.max(i - 1, 0)][1];
}

function evaluateExponentialFunction(parameters, input) {
  var base = parameters.base !== undefined ? parameters.base : 1;
  var i = 0;

  while (true) {
    if (i >= parameters.stops.length) break;else if (input <= parameters.stops[i][0]) break;else i++;
  }

  if (i === 0) {
    return parameters.stops[i][1];
  } else if (i === parameters.stops.length) {
    return parameters.stops[i - 1][1];
  } else {
    return interpolate$1(input, base, parameters.stops[i - 1][0], parameters.stops[i][0], parameters.stops[i - 1][1], parameters.stops[i][1]);
  }
}

function evaluateIdentityFunction(parameters, input) {
  return coalesce(input, parameters.default);
}

function interpolate$1(input, base, inputLower, inputUpper, outputLower, outputUpper) {
  if (typeof outputLower === 'function') {
    return function () {
      var evaluatedLower = outputLower.apply(undefined, arguments);
      var evaluatedUpper = outputUpper.apply(undefined, arguments);
      return interpolate$1(input, base, inputLower, inputUpper, evaluatedLower, evaluatedUpper);
    };
  } else if (outputLower.length) {
    return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);
  } else {
    return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);
  }
}

function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {
  var difference = inputUpper - inputLower;
  var progress = input - inputLower;
  var ratio;

  if (base === 1) {
    ratio = progress / difference;
  } else {
    ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
  }

  return outputLower * (1 - ratio) + outputUpper * ratio;
}

function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {
  var output = [];

  for (var i = 0; i < outputLower.length; i++) {
    output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);
  }

  return output;
}

function isFunctionDefinition(obj) {
  return obj && typeof obj === 'object' && (obj.stops || obj.property && obj.type === 'identity');
}
function hasFunctionDefinition(obj) {
  for (var p in obj) {
    if (isFunctionDefinition(obj[p])) {
      return true;
    }
  }

  return false;
}
function interpolated(parameters) {
  return createFunction1(parameters, 'exponential');
}
function piecewiseConstant(parameters) {
  return createFunction1(parameters, 'interval');
}
function loadFunctionTypes(obj, argFn) {
  if (!obj) {
    return null;
  }

  var hit = false;

  if (Array.isArray(obj)) {
    var multResult = [],
        loaded;

    for (var i = 0; i < obj.length; i++) {
      loaded = loadFunctionTypes(obj[i], argFn);

      if (!loaded) {
        multResult.push(obj[i]);
      } else {
        multResult.push(loaded);
        hit = true;
      }
    }

    return hit ? multResult : obj;
  }

  var result = {
    '__fn_types_loaded': true
  },
      props = [],
      p;

  for (p in obj) {
    if (obj.hasOwnProperty(p)) {
      props.push(p);
    }
  }

  var buildFn = function buildFn(p) {
    Object.defineProperty(result, p, {
      get: function get() {
        if (!this['__fn_' + p]) {
          this['__fn_' + p] = interpolated(this['_' + p]);
        }

        return this['__fn_' + p].apply(this, argFn());
      },
      set: function set(v) {
        this['_' + p] = v;
      },
      configurable: true,
      enumerable: true
    });
  };

  for (var _i = 0, len = props.length; _i < len; _i++) {
    p = props[_i];

    if (isFunctionDefinition(obj[p])) {
      hit = true;
      result['_' + p] = obj[p];
      buildFn(p);
    } else {
      result[p] = obj[p];
    }
  }

  return hit ? result : obj;
}
function getFunctionTypeResources(t) {
  if (!t || !t.stops) {
    return [];
  }

  var res = [];

  for (var i = 0, l = t.stops.length; i < l; i++) {
    res.push(t.stops[i][1]);
  }

  return res;
}

function createFunction1(parameters, defaultType) {
  if (!isFunctionDefinition(parameters)) {
    return function () {
      return parameters;
    };
  }

  parameters = JSON.parse(JSON.stringify(parameters));
  var isZoomConstant = true;
  var isFeatureConstant = true;
  var stops = parameters.stops;

  if (stops) {
    for (var i = 0; i < stops.length; i++) {
      if (isFunctionDefinition(stops[i][1])) {
        var _fn = createFunction1(stops[i][1], defaultType);

        isZoomConstant = isZoomConstant && _fn.isZoomConstant;
        isFeatureConstant = isFeatureConstant && _fn.isFeatureConstant;
        stops[i] = [stops[i][0], _fn];
      }
    }
  }

  var fn = createFunction(parameters, defaultType);
  fn.isZoomConstant = isZoomConstant && fn.isZoomConstant;
  fn.isFeatureConstant = isFeatureConstant && fn.isFeatureConstant;
  return fn;
}



var index = /*#__PURE__*/Object.freeze({
  createFilter: createFilter,
  getFilterFeature: getFilterFeature,
  compileStyle: compileStyle,
  isFunctionDefinition: isFunctionDefinition,
  hasFunctionDefinition: hasFunctionDefinition,
  interpolated: interpolated,
  piecewiseConstant: piecewiseConstant,
  loadFunctionTypes: loadFunctionTypes,
  getFunctionTypeResources: getFunctionTypeResources
});

function translateToSVGStyles(s) {
  var result = {
    'stroke': {
      'stroke': s['markerLineColor'],
      'stroke-width': s['markerLineWidth'],
      'stroke-opacity': s['markerLineOpacity'],
      'stroke-dasharray': null,
      'stroke-linecap': 'butt',
      'stroke-linejoin': 'round'
    },
    'fill': {
      'fill': s['markerFill'],
      'fill-opacity': s['markerFillOpacity']
    }
  };

  if (result['stroke']['stroke-width'] === 0) {
    result['stroke']['stroke-opacity'] = 0;
  }

  return result;
}
function getMarkerPathBase64(symbol, width, height) {
  if (!symbol['markerPath']) {
    return null;
  }

  var op = 1;
  var styles = translateToSVGStyles(symbol);

  if (isNumber(symbol['markerOpacity'])) {
    op = symbol['markerOpacity'];
  }

  if (isNumber(symbol['opacity'])) {
    op *= symbol['opacity'];
  }

  var svgStyles = {};

  if (styles) {
    for (var p in styles['stroke']) {
      if (styles['stroke'].hasOwnProperty(p)) {
        if (!isNil(styles['stroke'][p])) {
          svgStyles[p] = styles['stroke'][p];
        }
      }
    }

    for (var _p in styles['fill']) {
      if (styles['fill'].hasOwnProperty(_p)) {
        if (!isNil(styles['fill'][_p])) {
          svgStyles[_p] = styles['fill'][_p];
        }
      }
    }
  }

  var pathes = Array.isArray(symbol['markerPath']) ? symbol['markerPath'] : [symbol['markerPath']];
  var path;
  var pathesToRender = [];

  for (var i = 0; i < pathes.length; i++) {
    path = isString(pathes[i]) ? {
      'path': pathes[i]
    } : pathes[i];
    path = extend({}, path, svgStyles);
    path['d'] = path['path'];
    delete path['path'];
    pathesToRender.push(path);
  }

  var svg = ['<svg version="1.1"', 'xmlns="http://www.w3.org/2000/svg"'];

  if (op < 1) {
    svg.push('opacity="' + op + '"');
  }

  if (symbol['markerPathWidth'] && symbol['markerPathHeight']) {
    svg.push('viewBox="0 0 ' + symbol['markerPathWidth'] + ' ' + symbol['markerPathHeight'] + '"');
  }

  svg.push('preserveAspectRatio="none"');

  if (width) {
    svg.push('width="' + width + '"');
  }

  if (height) {
    svg.push('height="' + height + '"');
  }

  svg.push('><defs></defs>');

  for (var _i = 0; _i < pathesToRender.length; _i++) {
    var strPath = '<path ';

    for (var _p2 in pathesToRender[_i]) {
      if (pathesToRender[_i].hasOwnProperty(_p2)) {
        strPath += ' ' + _p2 + '="' + pathesToRender[_i][_p2] + '"';
      }
    }

    strPath += '></path>';
    svg.push(strPath);
  }

  svg.push('</svg>');
  var b64 = 'data:image/svg+xml;base64,' + btoa(svg.join(' '));
  return b64;
}
function getExternalResources(symbol, toAbsolute) {
  if (!symbol) {
    return [];
  }

  var symbols = symbol;

  if (!Array.isArray(symbol)) {
    symbols = [symbol];
  }

  var resources = [];
  var props = RESOURCE_PROPERTIES;
  var res, resSizeProp;
  var w, h;

  for (var i = symbols.length - 1; i >= 0; i--) {
    symbol = symbols[i];

    if (!symbol) {
      continue;
    }

    if (toAbsolute) {
      symbol = convertResourceUrl(symbol);
    }

    for (var ii = 0; ii < props.length; ii++) {
      res = symbol[props[ii]];

      if (isFunctionDefinition(res)) {
        res = getFunctionTypeResources(res);
      }

      if (!res) {
        continue;
      }

      if (!Array.isArray(res)) {
        res = [res];
      }

      for (var iii = 0; iii < res.length; iii++) {
        if (res[iii].slice(0, 4) === 'url(') {
          res[iii] = extractCssUrl(res[iii]);
        }

        resSizeProp = RESOURCE_SIZE_PROPERTIES[ii];
        resources.push([res[iii], symbol[resSizeProp[0]], symbol[resSizeProp[1]]]);
      }
    }

    if (symbol['markerType'] === 'path' && symbol['markerPath']) {
      w = isFunctionDefinition(symbol['markerWidth']) ? 200 : symbol['markerWidth'];
      h = isFunctionDefinition(symbol['markerHeight']) ? 200 : symbol['markerHeight'];

      if (isFunctionDefinition(symbol['markerPath'])) {
        res = getFunctionTypeResources(symbol['markerPath']);
        var path = symbol['markerPath'];

        for (var _iii = 0; _iii < res.length; _iii++) {
          symbol['markerPath'] = res[_iii];
          resources.push([getMarkerPathBase64(symbol), w, h]);
        }

        symbol['markerPath'] = path;
      } else {
        resources.push([getMarkerPathBase64(symbol), w, h]);
      }
    }
  }

  return resources;
}
function convertResourceUrl(symbol) {
  if (!symbol) {
    return null;
  }

  var s = symbol;

  if (IS_NODE) {
    return s;
  }

  var props = RESOURCE_PROPERTIES;
  var res;

  for (var ii = 0, len = props.length; ii < len; ii++) {
    res = s[props[ii]];

    if (!res) {
      continue;
    }

    s[props[ii]] = _convertUrl(res);
  }

  return s;
}

function _convertUrl(res) {
  if (isFunctionDefinition(res)) {
    var stops = res.stops;

    for (var i = 0; i < stops.length; i++) {
      stops[i][1] = _convertUrl(stops[i][1]);
    }

    return res;
  }

  if (res.slice(0, 4) === 'url(') {
    res = extractCssUrl(res);
  }

  return res;
}

function isGradient(g) {
  return g && g['colorStops'];
}
function getGradientStamp(g) {
  var keys = [g['type']];

  if (g['places']) {
    keys.push(g['places'].join());
  }

  if (g['colorStops']) {
    var stops = [];

    for (var i = g['colorStops'].length - 1; i >= 0; i--) {
      stops.push(g['colorStops'][i].join());
    }

    keys.push(stops.join(','));
  }

  return keys.join('_');
}
function getSymbolStamp(symbol) {
  var keys = [];

  if (Array.isArray(symbol)) {
    for (var i = 0; i < symbol.length; i++) {
      keys.push(getSymbolStamp(symbol[i]));
    }

    return '[ ' + keys.join(' , ') + ' ]';
  }

  for (var p in symbol) {
    if (hasOwn(symbol, p)) {
      if (!isFunction(symbol[p])) {
        if (isGradient(symbol[p])) {
          keys.push(p + '=' + getGradientStamp(symbol[p]));
        } else {
          keys.push(p + '=' + symbol[p]);
        }
      }
    }
  }

  return keys.join(';');
}
function lowerSymbolOpacity(symbol, ratio) {
  function s(_symbol, _ratio) {
    var op = _symbol['opacity'];

    if (isNil(op)) {
      _symbol['opacity'] = _ratio;
    } else {
      _symbol['opacity'] *= _ratio;
    }
  }

  var lower;

  if (Array.isArray(symbol)) {
    lower = [];

    for (var i = 0; i < symbol.length; i++) {
      var d = extend({}, symbol[i]);
      s(d, ratio);
      lower.push(d);
    }
  } else {
    lower = extend({}, symbol);
    s(lower, ratio);
  }

  return lower;
}
function extendSymbol(symbol) {
  var sources = Array.prototype.slice.call(arguments, 1);

  if (!sources || !sources.length) {
    sources = [{}];
  }

  if (Array.isArray(symbol)) {
    var s, dest;
    var result = [];

    for (var i = 0, l = symbol.length; i < l; i++) {
      s = symbol[i];
      dest = {};

      for (var ii = 0, ll = sources.length; ii < ll; ii++) {
        if (!Array.isArray(sources[ii])) {
          extend(dest, s, sources[ii] ? sources[ii] : {});
        } else if (!isNil(sources[ii][i])) {
          extend(dest, s, sources[ii][i]);
        } else {
          extend(dest, s ? s : {});
        }
      }

      result.push(dest);
    }

    return result;
  } else {
    var args = [{}, symbol];
    args.push.apply(args, sources);
    return extend.apply(this, args);
  }
}
function parseStyleRootPath(style) {
  if (style.symbol) {
    style = [style];
  }

  if (Array.isArray(style)) {
    return style;
  }

  var root = style['$root'];
  var iconset = style['$iconset'];
  style = style.style;

  if (root || iconset) {
    if (root && root[root.length - 1] === '/') {
      root = root.substring(0, root.length - 1);
    }

    if (iconset && iconset[iconset.length - 1] === '/') {
      iconset = iconset.substring(0, iconset.length - 1);
    }

    var replacer = function replacer(match) {
      if (match === '{$root}') {
        return root;
      } else if (match === '{$iconset}') {
        return iconset;
      }

      return null;
    };

    style = convertStylePath(style, replacer);
  }

  return style;
}
function convertStylePath(styles, replacer) {
  for (var i = 0; i < styles.length; i++) {
    var symbol = styles[i].symbol;

    if (symbol) {
      parseSymbolPath(symbol, replacer);
    }
  }
}
var URL_PATTERN = /(\{\$root\}|\{\$iconset\})/g;

function parseSymbolPath(symbol, replacer) {
  for (var p in symbol) {
    if (symbol.hasOwnProperty(p) && p !== 'textName') {
      if (isString(symbol[p]) && symbol[p].length > 2) {
        symbol[p] = symbol[p].replace(URL_PATTERN, replacer);
      } else if (isFunctionDefinition(symbol[p])) {
        symbol[p] = parseStops(symbol[p], replacer);
      } else if (isObject(symbol[p])) {
        parseSymbolPath(symbol[p], replacer);
      }
    }
  }
}

function parseStops(value, replacer) {
  var defaultValue = value['default'];

  if (isString(defaultValue)) {
    value['default'] = defaultValue.replace(URL_PATTERN, replacer);
  }

  var stops = value.stops;

  for (var i = 0; i < stops.length; i++) {
    if (!Array.isArray(stops[i])) {
      continue;
    }

    if (isString(stops[i][1])) {
      stops[i][1] = stops[i][1].replace(URL_PATTERN, replacer);
    } else if (isFunctionDefinition(stops[i][1])) {
      stops[i][1] = parseStops(stops[i][1], replacer);
    }
  }

  return value;
}



var index$1 = /*#__PURE__*/Object.freeze({
  now: now,
  extend: extend,
  isNil: isNil,
  isNumber: isNumber,
  isInteger: isInteger,
  isObject: isObject,
  isString: isString,
  isFunction: isFunction,
  hasOwn: hasOwn,
  join: join,
  isEmpty: isEmpty,
  toRadian: toRadian,
  toDegree: toDegree,
  IS_NODE: IS_NODE,
  get requestAnimFrame () { return requestAnimFrame; },
  get cancelAnimFrame () { return cancelAnimFrame; },
  isSVG: isSVG,
  loadImage: loadImage,
  UID: UID,
  GUID: GUID,
  parseJSON: parseJSON,
  pushIn: pushIn,
  removeFromArray: removeFromArray,
  forEachCoord: forEachCoord,
  getValueOrDefault: getValueOrDefault,
  sign: sign,
  log2: log2,
  interpolate: interpolate,
  wrap: wrap,
  clamp: clamp,
  isArrayHasData: isArrayHasData,
  isURL: isURL,
  isCssUrl: isCssUrl,
  extractCssUrl: extractCssUrl,
  btoa: btoa,
  b64toBlob: b64toBlob,
  computeDegree: computeDegree,
  emptyImageUrl: emptyImageUrl,
  equalMapView: equalMapView,
  flash: flash,
  _defaults: _defaults,
  translateToSVGStyles: translateToSVGStyles,
  getMarkerPathBase64: getMarkerPathBase64,
  getExternalResources: getExternalResources,
  convertResourceUrl: convertResourceUrl,
  isGradient: isGradient,
  getGradientStamp: getGradientStamp,
  getSymbolStamp: getSymbolStamp,
  lowerSymbolOpacity: lowerSymbolOpacity,
  extendSymbol: extendSymbol,
  parseStyleRootPath: parseStyleRootPath,
  convertStylePath: convertStylePath
});

var Browser = {};

if (!IS_NODE) {
  var ua = navigator.userAgent.toLowerCase(),
      doc = document.documentElement,
      ie = 'ActiveXObject' in window,
      webkit = ua.indexOf('webkit') !== -1,
      phantomjs = ua.indexOf('phantom') !== -1,
      android23 = ua.search('android [23]') !== -1,
      chrome = ua.indexOf('chrome') !== -1,
      gecko = ua.indexOf('gecko') !== -1 && !webkit && !window.opera && !ie,
      mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
      msPointer = !window.PointerEvent && window.MSPointerEvent,
      pointer = window.PointerEvent && navigator.pointerEnabled || msPointer,
      ie3d = ie && 'transition' in doc.style,
      webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23,
      gecko3d = 'MozPerspective' in doc.style,
      opera12 = 'OTransition' in doc.style,
      any3d = (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs;
  var chromeVersion = 0;

  if (chrome) {
    chromeVersion = ua.match(/chrome\/([\d.]+)/)[1];
  }

  var touch = !phantomjs && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);
  var webgl;

  try {
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    webgl = gl && gl instanceof WebGLRenderingContext;
  } catch (err) {
    webgl = false;
  }

  var devicePixelRatio = window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI;
  Browser = {
    ie: ie,
    ielt9: ie && !document.addEventListener,
    edge: 'msLaunchUri' in navigator && !('documentMode' in document),
    webkit: webkit,
    gecko: gecko,
    android: ua.indexOf('android') !== -1,
    android23: android23,
    chrome: chrome,
    chromeVersion: chromeVersion,
    safari: !chrome && ua.indexOf('safari') !== -1,
    phantomjs: phantomjs,
    ie3d: ie3d,
    webkit3d: webkit3d,
    gecko3d: gecko3d,
    opera12: opera12,
    any3d: any3d,
    mobile: mobile,
    mobileWebkit: mobile && webkit,
    mobileWebkit3d: mobile && webkit3d,
    mobileOpera: mobile && window.opera,
    mobileGecko: mobile && gecko,
    touch: !!touch,
    msPointer: !!msPointer,
    pointer: !!pointer,
    retina: devicePixelRatio > 1,
    devicePixelRatio: devicePixelRatio,
    language: navigator.browserLanguage ? navigator.browserLanguage : navigator.language,
    ie9: ie && document.documentMode === 9,
    ie10: ie && document.documentMode === 10,
    webgl: webgl
  };
}

var Browser$1 = Browser;

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var Position = function () {
  function Position(x, y) {
    if (!isNil(x) && !isNil(y)) {
      this.x = +x;
      this.y = +y;
    } else if (!isNil(x.x) && !isNil(x.y)) {
      this.x = +x.x;
      this.y = +x.y;
    } else if (Array.isArray(x)) {
      this.x = +x[0];
      this.y = +x[1];
    }

    if (this._isNaN()) {
      throw new Error('Position is NaN');
    }
  }

  var _proto = Position.prototype;

  _proto.set = function set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };

  _proto.abs = function abs() {
    return new this.constructor(Math.abs(this.x), Math.abs(this.y));
  };

  _proto._abs = function _abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    return this;
  };

  _proto._round = function _round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  };

  _proto.round = function round() {
    return new this.constructor(Math.round(this.x), Math.round(this.y));
  };

  _proto._ceil = function _ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  };

  _proto.ceil = function ceil() {
    return new this.constructor(Math.ceil(this.x), Math.ceil(this.y));
  };

  _proto.distanceTo = function distanceTo(point) {
    var x = point.x - this.x,
        y = point.y - this.y;
    return Math.sqrt(x * x + y * y);
  };

  _proto._floor = function _floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  };

  _proto.floor = function floor() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y));
  };

  _proto.copy = function copy() {
    return new this.constructor(this.x, this.y);
  };

  _proto._add = function _add(x, y) {
    if (!isNil(x.x)) {
      this.x += x.x;
      this.y += x.y;
    } else if (!isNil(x[0])) {
      this.x += x[0];
      this.y += x[1];
    } else {
      this.x += x;
      this.y += y;
    }

    return this;
  };

  _proto.add = function add(x, y) {
    var nx, ny;

    if (!isNil(x.x)) {
      nx = this.x + x.x;
      ny = this.y + x.y;
    } else if (!isNil(x[0])) {
      nx = this.x + x[0];
      ny = this.y + x[1];
    } else {
      nx = this.x + x;
      ny = this.y + y;
    }

    return new this.constructor(nx, ny);
  };

  _proto._sub = function _sub(x, y) {
    if (!isNil(x.x)) {
      this.x -= x.x;
      this.y -= x.y;
    } else if (!isNil(x[0])) {
      this.x -= x[0];
      this.y -= x[1];
    } else {
      this.x -= x;
      this.y -= y;
    }

    return this;
  };

  _proto._substract = function _substract() {
    return this._sub.apply(this, arguments);
  };

  _proto.sub = function sub(x, y) {
    var nx, ny;

    if (!isNil(x.x)) {
      nx = this.x - x.x;
      ny = this.y - x.y;
    } else if (!isNil(x[0])) {
      nx = this.x - x[0];
      ny = this.y - x[1];
    } else {
      nx = this.x - x;
      ny = this.y - y;
    }

    return new this.constructor(nx, ny);
  };

  _proto.substract = function substract() {
    return this.sub.apply(this, arguments);
  };

  _proto.multi = function multi(ratio) {
    return new this.constructor(this.x * ratio, this.y * ratio);
  };

  _proto._multi = function _multi(ratio) {
    this.x *= ratio;
    this.y *= ratio;
    return this;
  };

  _proto.div = function div(n) {
    return this.multi(1 / n);
  };

  _proto._div = function _div(n) {
    return this._multi(1 / n);
  };

  _proto.equals = function equals(c) {
    if (!(c instanceof this.constructor)) {
      return false;
    }

    return this.x === c.x && this.y === c.y;
  };

  _proto._isNaN = function _isNaN() {
    return isNaN(this.x) || isNaN(this.y);
  };

  _proto.isZero = function isZero() {
    return this.x === 0 && this.y === 0;
  };

  _proto.toArray = function toArray() {
    return [this.x, this.y];
  };

  _proto.toFixed = function toFixed(n) {
    return new this.constructor(this.x.toFixed(n), this.y.toFixed(n));
  };

  _proto.toJSON = function toJSON() {
    return {
      x: this.x,
      y: this.y
    };
  };

  return Position;
}();

var Point = function (_Position) {
  _inheritsLoose(Point, _Position);

  function Point() {
    return _Position.apply(this, arguments) || this;
  }

  var _proto = Point.prototype;

  _proto.closeTo = function closeTo(p, delta) {
    if (!delta) {
      delta = 0;
    }

    return this.x >= p.x - delta && this.x <= p.x + delta && this.y >= p.y - delta && this.y <= p.y + delta;
  };

  _proto.mag = function mag() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };

  _proto.unit = function unit() {
    return this.copy()._unit();
  };

  _proto._unit = function _unit() {
    this._div(this.mag());

    return this;
  };

  _proto.perp = function perp() {
    return this.copy()._perp();
  };

  _proto._perp = function _perp() {
    var y = this.y;
    this.y = this.x;
    this.x = -y;
    return this;
  };

  _proto.angleWith = function angleWith(b) {
    return this.angleWithSep(b.x, b.y);
  };

  _proto.angleWithSep = function angleWithSep(x, y) {
    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);
  };

  _proto._rotate = function _rotate(angle) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle),
        x = cos * this.x - sin * this.y,
        y = sin * this.x + cos * this.y;
    this.x = x;
    this.y = y;
    return this;
  };

  _proto.rotate = function rotate(a) {
    return this.copy()._rotate(a);
  };

  return Point;
}(Position);

var Size = function () {
  function Size(width, height) {
    if (isNumber(width) && isNumber(height)) {
      this.width = width;
      this.height = height;
    } else if (isNumber(width['width'])) {
      this.width = width.width;
      this.height = width.height;
    } else if (Array.isArray(width)) {
      this.width = width[0];
      this.height = width[1];
    }
  }

  var _proto = Size.prototype;

  _proto.copy = function copy() {
    return new Size(this['width'], this['height']);
  };

  _proto.add = function add(x, y) {
    var w, h;

    if (x instanceof Size) {
      w = this.width + x.width;
      h = this.height + x.height;
    } else {
      w = this.width + x;
      h = this.height + y;
    }

    return new Size(w, h);
  };

  _proto.equals = function equals(size) {
    return this['width'] === size['width'] && this['height'] === size['height'];
  };

  _proto.multi = function multi(ratio) {
    return new Size(this['width'] * ratio, this['height'] * ratio);
  };

  _proto._multi = function _multi(ratio) {
    this['width'] *= ratio;
    this['height'] *= ratio;
    return this;
  };

  _proto._round = function _round() {
    this['width'] = Math.round(this['width']);
    this['height'] = Math.round(this['height']);
    return this;
  };

  _proto.toPoint = function toPoint() {
    return new Point(this['width'], this['height']);
  };

  _proto.toArray = function toArray() {
    return [this['width'], this['height']];
  };

  _proto.toJSON = function toJSON() {
    return {
      'width': this['width'],
      'height': this['height']
    };
  };

  return Size;
}();

function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}
var specialPattern = /[\b\t\r\v\f]/igm;
function escapeSpecialChars(str) {
  if (!isString(str)) {
    return str;
  }

  return str.replace(specialPattern, '');
}
function splitWords(chr) {
  return trim(chr).split(/\s+/);
}
var rulerCtx = typeof document !== 'undefined' ? document.createElement('canvas').getContext('2d') : null;
function stringWidth(text, font) {
  if (stringWidth.node) {
    return stringWidth.node(text, font);
  }

  rulerCtx.font = font;
  return rulerCtx.measureText(text).width;
}
function stringLength(text, font, size) {
  var w = stringWidth(text, font);
  return new Size(w, size || DEFAULT_TEXT_SIZE);
}
function getFontHeight(font) {
  var domRuler = getDomRuler('span');

  if (font !== '_default_') {
    domRuler.style.font = font;
  }

  domRuler.innerHTML = '秦';
  var h = domRuler.clientHeight;
  removeDomNode(domRuler);
  return h;
}
function splitContent(content, font, wrapWidth, textWidth) {
  if (!content || content.length === 0) {
    return [{
      'text': '',
      'width': 0
    }];
  }

  var width = isNil(textWidth) ? stringWidth(content, font) : textWidth;
  var chrWidth = width / content.length,
      minChrCount = Math.floor(wrapWidth / chrWidth / 2);

  if (chrWidth >= wrapWidth || minChrCount <= 0) {
    return [{
      'text': '',
      'width': wrapWidth
    }];
  }

  if (width <= wrapWidth) return [{
    'text': content,
    'width': width
  }];
  var result = [];
  var testStr = content.substring(0, minChrCount),
      prew = chrWidth * minChrCount;

  for (var i = minChrCount, l = content.length; i < l; i++) {
    var chr = content[i];
    var w = stringWidth(testStr + chr);

    if (w >= wrapWidth) {
      result.push({
        'text': testStr,
        'width': prew
      });
      testStr = content.substring(i, minChrCount + i);
      i += minChrCount - 1;
      prew = chrWidth * minChrCount;
    } else {
      testStr += chr;
      prew = w;
    }

    if (i >= l - 1) {
      prew = stringWidth(testStr);
      result.push({
        'text': testStr,
        'width': prew
      });
    }
  }

  return result;
}
var contentExpRe = /\{([\w_]+)\}/g;
function replaceVariable(str, props) {
  if (!isString(str)) {
    return str;
  }

  return str.replace(contentExpRe, function (str, key) {
    if (!props) {
      return '';
    }

    var value = props[key];

    if (isNil(value)) {
      return '';
    } else if (Array.isArray(value)) {
      return value.join();
    }

    return value;
  });
}
function getAlignPoint(size, horizontalAlignment, verticalAlignment) {
  var width = size['width'],
      height = size['height'];
  var alignW, alignH;

  if (horizontalAlignment === 'left') {
    alignW = -width;
  } else if (horizontalAlignment === 'right') {
    alignW = 0;
  } else {
    alignW = -width / 2;
  }

  if (verticalAlignment === 'top') {
    alignH = -height;
  } else if (verticalAlignment === 'bottom') {
    alignH = 0;
  } else {
    alignH = -height / 2;
  }

  return new Point(alignW, alignH);
}
var DEFAULT_FONT = 'monospace';
function getFont(style) {
  if (style['textFont']) {
    return style['textFont'];
  } else {
    return (style['textStyle'] && style['textStyle'] !== 'normal' ? style['textStyle'] + ' ' : '') + (style['textWeight'] && style['textWeight'] !== 'normal' ? style['textWeight'] + ' ' : '') + style['textSize'] + 'px ' + (!style['textFaceName'] ? DEFAULT_FONT : style['textFaceName'][0] === '"' ? style['textFaceName'] : '"' + style['textFaceName'] + '"');
  }
}
function splitTextToRow(text, style) {
  var font = getFont(style),
      lineSpacing = style['textLineSpacing'] || 0,
      size = stringLength(text, font, style['textSize']),
      textWidth = size['width'],
      textHeight = size['height'],
      wrapChar = style['textWrapCharacter'],
      textRows = [];
  var wrapWidth = style['textWrapWidth'];

  if (!wrapWidth || wrapWidth > textWidth) {
    wrapWidth = textWidth;
  }

  if (!isString(text)) {
    text += '';
  }

  var actualWidth = 0;

  if (wrapChar && text.indexOf(wrapChar) >= 0) {
    var texts = text.split(wrapChar);

    for (var i = 0, l = texts.length; i < l; i++) {
      var t = texts[i];
      var tWidth = stringWidth(t, font);

      if (tWidth > wrapWidth) {
        var contents = splitContent(t, font, wrapWidth, tWidth);

        for (var ii = 0, ll = contents.length; ii < ll; ii++) {
          var w = contents[ii].width;

          if (w > actualWidth) {
            actualWidth = w;
          }

          textRows.push({
            'text': contents[ii].text,
            'size': new Size(w, textHeight)
          });
        }
      } else {
        if (tWidth > actualWidth) {
          actualWidth = tWidth;
        }

        textRows.push({
          'text': t,
          'size': new Size(tWidth, textHeight)
        });
      }
    }
  } else if (textWidth > wrapWidth) {
    var _contents = splitContent(text, font, wrapWidth, textWidth);

    for (var _i = 0; _i < _contents.length; _i++) {
      var _w = _contents[_i].width;

      if (_w > actualWidth) {
        actualWidth = _w;
      }

      textRows.push({
        'text': _contents[_i].text,
        'size': new Size(_w, textHeight)
      });
    }
  } else {
    if (textWidth > actualWidth) {
      actualWidth = textWidth;
    }

    textRows.push({
      'text': text,
      'size': size
    });
  }

  var rowNum = textRows.length;
  var textSize = new Size(actualWidth, textHeight * rowNum + lineSpacing * (rowNum - 1));
  return {
    'total': rowNum,
    'size': textSize,
    'rows': textRows,
    'rawSize': size
  };
}

var strings = /*#__PURE__*/Object.freeze({
  trim: trim,
  escapeSpecialChars: escapeSpecialChars,
  splitWords: splitWords,
  stringWidth: stringWidth,
  stringLength: stringLength,
  getFontHeight: getFontHeight,
  splitContent: splitContent,
  replaceVariable: replaceVariable,
  getAlignPoint: getAlignPoint,
  getFont: getFont,
  splitTextToRow: splitTextToRow
});

var first = function first(props) {
  return props[0];
};

var testProp = IS_NODE ? first : function (props) {
  var style = document.documentElement.style;

  for (var i = 0; i < props.length; i++) {
    if (props[i] in style) {
      return props[i];
    }
  }

  return false;
};
var TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);
var TRANSFORMORIGIN = testProp(['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin']);
var TRANSITION = testProp(['transition', 'WebkitTransition', 'OTransition', 'MozTransition', 'msTransition']);
var CSSFILTER = testProp(['filter', 'WebkitFilter', 'OFilter', 'MozFilter', 'msFilter']);
function createEl(tagName, className) {
  var el = document.createElement(tagName);

  if (className) {
    setClass(el, className);
  }

  return el;
}
function createElOn(tagName, style, container) {
  var el = createEl(tagName);

  if (style) {
    setStyle(el, style);
  }

  if (container) {
    container.appendChild(el);
  }

  return el;
}
function removeDomNode(node) {
  if (!node) {
    return this;
  }

  if (Browser$1.ielt9 || Browser$1.ie9) {
    var d = createEl('div');
    d.appendChild(node);
    d.innerHTML = '';
    d = null;
  } else if (node.parentNode) {
    node.parentNode.removeChild(node);
  }

  return this;
}
function addDomEvent(obj, typeArr, handler, context) {
  if (!obj || !obj.addEventListener || !typeArr || !handler) {
    return this;
  }

  var eventHandler = function eventHandler(e) {
    if (!e) {
      e = window.event;
    }

    handler.call(context || obj, e);
    return;
  };

  var types = typeArr.split(' ');

  for (var i = types.length - 1; i >= 0; i--) {
    var type = types[i];

    if (!type) {
      continue;
    }

    if (!obj['Z__' + type]) {
      obj['Z__' + type] = [];
    }

    var hit = listensDomEvent(obj, type, handler);

    if (hit >= 0) {
      removeDomEvent(obj, type, handler);
    }

    obj['Z__' + type].push({
      callback: eventHandler,
      src: handler
    });

    if (Browser$1.ie) {
      obj.addEventListener(type, eventHandler, false);
    } else {
      obj.addEventListener(type, eventHandler, {
        capture: false,
        passive: false
      });
    }
  }

  return this;
}
function removeDomEvent(obj, typeArr, handler) {
  function doRemove(type, callback) {
    if (type === 'mousewheel' && Browser$1.gecko) {
      type = 'DOMMouseScroll';
    }

    obj.removeEventListener(type, callback, false);
  }

  if (!obj || !obj.removeEventListener || !typeArr) {
    return this;
  }

  var types = typeArr.split(' ');

  for (var i = types.length - 1; i >= 0; i--) {
    var type = types[i];

    if (!type) {
      continue;
    }

    if (!handler && obj['Z__' + type]) {
      var handlers = obj['Z__' + type];

      for (var j = 0, jlen = handlers.length; j < jlen; j++) {
        doRemove(handlers[j].callback);
      }

      delete obj['Z__' + type];
      return this;
    }

    var hit = listensDomEvent(obj, type, handler);

    if (hit < 0) {
      return this;
    }

    var hitHandler = obj['Z__' + type][hit];
    doRemove(type, hitHandler.callback);
    obj['Z__' + type].splice(hit, 1);
  }

  return this;
}
function listensDomEvent(obj, type, handler) {
  if (!obj || !obj['Z__' + type] || !handler) {
    return -1;
  }

  var handlers = obj['Z__' + type];

  for (var i = 0, len = handlers.length; i < len; i++) {
    if (handlers[i].src === handler) {
      return i;
    }
  }

  return -1;
}
function preventDefault(event) {
  if (event.preventDefault) {
    event.preventDefault();
  } else {
    event.returnValue = false;
  }

  return this;
}
function stopPropagation(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  } else {
    e.cancelBubble = true;
  }

  return this;
}
function preventSelection(dom) {
  dom.onselectstart = function () {
    return false;
  };

  dom.ondragstart = function () {
    return false;
  };

  dom.setAttribute('unselectable', 'on');
  return this;
}
function offsetDom(dom, offset) {
  if (!dom) {
    return null;
  }

  if (Browser$1.any3d) {
    setTransform(dom, offset);
  } else {
    dom.style.left = offset.x + 'px';
    dom.style.top = offset.y + 'px';
  }

  return offset;
}
function computeDomPosition(dom) {
  var style = window.getComputedStyle(dom);
  var padding = [parseInt(style['padding-left']), parseInt(style['padding-top'])];
  var rect = dom.getBoundingClientRect();
  var offsetWidth = dom.offsetWidth,
      offsetHeight = dom.offsetHeight;
  var scaleX = offsetWidth ? rect.width / offsetWidth : 1,
      scaleY = offsetHeight ? rect.height / offsetHeight : 1;
  dom.__position = [rect.left + padding[0], rect.top + padding[1], scaleX, scaleY];
  return dom.__position;
}
function getEventContainerPoint(ev, dom) {
  if (!ev) {
    ev = window.event;
  }

  var domPos = dom.__position;

  if (!domPos) {
    domPos = computeDomPosition(dom);
  }

  return new Point((ev.clientX - domPos[0] - dom.clientLeft) / domPos[2], (ev.clientY - domPos[1] - dom.clientTop) / domPos[3]);
}

function endsWith(str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) === l;
}

function setStyle(dom, strCss) {
  var cssText = dom.style.cssText;

  if (!endsWith(cssText, ';')) {
    cssText += ';';
  }

  dom.style.cssText = cssText + strCss;
  return this;
}
function hasClass(el, name) {
  if (el.classList !== undefined) {
    return el.classList.contains(name);
  }

  var className = getClass(el);
  return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}
function addClass(el, name) {
  if (el.classList !== undefined && !hasClass(el, name)) {
    var classes = splitWords(name);

    for (var i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else {
    var className = getClass(el);
    setClass(el, (className ? className + ' ' : '') + name);
  }

  return this;
}
function setClass(el, name) {
  if (isNil(el.className.baseVal)) {
    el.className = name;
  } else {
    el.className.baseVal = name;
  }

  return this;
}
function getClass(el) {
  return isNil(el.className.baseVal) ? el.className : el.className.baseVal;
}
function setOpacity(el, value) {
  el.style.opacity = value;
  return this;
}
function setTransform(el, offset) {
  var pos = offset || new Point(0, 0);
  el.style[TRANSFORM] = Browser$1.any3d ? 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0px)' : 'translate(' + pos.x + 'px,' + pos.y + 'px)';
  return this;
}
function setTransformMatrix(el, m) {
  var text = 'matrix(' + (isString(m) ? m : m.join()) + ')';

  if (el.style[TRANSFORM] !== text) {
    el.style[TRANSFORM] = text;
  }

  return this;
}
function removeTransform(el) {
  if (el.style[TRANSFORM]) {
    el.style[TRANSFORM] = '';
  }

  return this;
}
function isHTML(str) {
  return /<[a-z\][\s\S]*>/i.test(str);
}
function measureDom(parentTag, dom) {
  var ruler = getDomRuler(parentTag);

  if (isString(dom)) {
    ruler.innerHTML = dom;
  } else {
    ruler.appendChild(dom);
  }

  var result = new Size(ruler.clientWidth, ruler.clientHeight);
  removeDomNode(ruler);
  return result;
}
function getDomRuler(tag) {
  var span = document.createElement(tag);
  span.style.cssText = 'position:absolute;left:-10000px;top:-10000px;';
  document.body.appendChild(span);
  return span;
}
var on = addDomEvent;
var off = removeDomEvent;

var dom = /*#__PURE__*/Object.freeze({
  TRANSFORM: TRANSFORM,
  TRANSFORMORIGIN: TRANSFORMORIGIN,
  TRANSITION: TRANSITION,
  CSSFILTER: CSSFILTER,
  createEl: createEl,
  createElOn: createElOn,
  removeDomNode: removeDomNode,
  addDomEvent: addDomEvent,
  removeDomEvent: removeDomEvent,
  listensDomEvent: listensDomEvent,
  preventDefault: preventDefault,
  stopPropagation: stopPropagation,
  preventSelection: preventSelection,
  offsetDom: offsetDom,
  computeDomPosition: computeDomPosition,
  getEventContainerPoint: getEventContainerPoint,
  setStyle: setStyle,
  hasClass: hasClass,
  addClass: addClass,
  setClass: setClass,
  getClass: getClass,
  setOpacity: setOpacity,
  setTransform: setTransform,
  setTransformMatrix: setTransformMatrix,
  removeTransform: removeTransform,
  isHTML: isHTML,
  measureDom: measureDom,
  getDomRuler: getDomRuler,
  on: on,
  off: off
});

var Ajax = {
  jsonp: function jsonp(url, callback) {
    var name = '_maptalks_jsonp_' + UID();
    if (url.match(/\?/)) url += '&callback=' + name;else url += '?callback=' + name;
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;

    window[name] = function (data) {
      callback(null, data);
      document.getElementsByTagName('head')[0].removeChild(script);
      script = null;
      delete window[name];
    };

    document.getElementsByTagName('head')[0].appendChild(script);
    return this;
  },
  get: function get(url, options, cb) {
    if (isFunction(options)) {
      var t = cb;
      cb = options;
      options = t;
    }

    if (IS_NODE && Ajax.get.node) {
      return Ajax.get.node(url, cb, options);
    }

    var client = Ajax._getClient(cb);

    client.open('GET', url, true);

    if (options) {
      for (var k in options.headers) {
        client.setRequestHeader(k, options.headers[k]);
      }

      client.withCredentials = options.credentials === 'include';

      if (options['responseType']) {
        client.responseType = options['responseType'];
      }
    }

    client.send(null);
    return client;
  },
  post: function post(url, options, cb) {
    var postData;

    if (!isString(url)) {
      var t = cb;
      postData = options;
      options = url;
      url = options.url;
      cb = t;
    } else {
      if (isFunction(options)) {
        var _t = cb;
        cb = options;
        options = _t;
      }

      options = options || {};
      postData = options.postData;
    }

    if (IS_NODE && Ajax.post.node) {
      options.url = url;
      return Ajax.post.node(options, postData, cb);
    }

    var client = Ajax._getClient(cb);

    client.open('POST', options.url, true);

    if (!options.headers) {
      options.headers = {};
    }

    if (!options.headers['Content-Type']) {
      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
    }

    if ('setRequestHeader' in client) {
      for (var p in options.headers) {
        if (options.headers.hasOwnProperty(p)) {
          client.setRequestHeader(p, options.headers[p]);
        }
      }
    }

    if (!isString(postData)) {
      postData = JSON.stringify(postData);
    }

    client.send(postData);
    return client;
  },
  _wrapCallback: function _wrapCallback(client, cb) {
    return function () {
      if (client.readyState === 4) {
        if (client.status === 200) {
          if (client.responseType === 'arraybuffer') {
            var response = client.response;

            if (response.byteLength === 0) {
              cb(new Error('http status 200 returned without content.'));
            } else {
              cb(null, {
                data: client.response,
                cacheControl: client.getResponseHeader('Cache-Control'),
                expires: client.getResponseHeader('Expires'),
                contentType: client.getResponseHeader('Content-Type')
              });
            }
          } else {
            cb(null, client.responseText);
          }
        } else {
          cb(new Error(client.statusText + ',' + client.status));
        }
      }
    };
  },
  _getClient: function _getClient(cb) {
    var client;

    try {
      client = new XMLHttpRequest();
    } catch (e) {
      try {
        client = new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e) {
        try {
          client = new ActiveXObject('Microsoft.XMLHTTP');
        } catch (e) {}
      }
    }

    client.onreadystatechange = Ajax._wrapCallback(client, cb);
    return client;
  },
  getArrayBuffer: function getArrayBuffer(url, options, cb) {
    if (isFunction(options)) {
      var t = cb;
      cb = options;
      options = t;
    }

    if (!options) {
      options = {};
    }

    options['responseType'] = 'arraybuffer';
    return Ajax.get(url, options, cb);
  },
  getImage: function getImage(img, url, options) {
    return Ajax.getArrayBuffer(url, options, function (err, imgData) {
      if (err) {
        if (img.onerror) {
          img.onerror(err);
        }
      } else if (imgData) {
        var URL = window.URL || window.webkitURL;
        var onload = img.onload;

        img.onload = function () {
          if (onload) {
            onload();
          }

          URL.revokeObjectURL(img.src);
        };

        var blob = new Blob([new Uint8Array(imgData.data)], {
          type: imgData.contentType
        });
        img.cacheControl = imgData.cacheControl;
        img.expires = imgData.expires;
        img.src = imgData.data.byteLength ? URL.createObjectURL(blob) : emptyImageUrl;
      }
    });
  }
};

Ajax.getJSON = function (url, options, cb) {
  if (isFunction(options)) {
    var t = cb;
    cb = options;
    options = t;
  }

  var callback = function callback(err, resp) {
    var data = resp ? parseJSON(resp) : null;
    cb(err, data);
  };

  if (options && options['jsonp']) {
    return Ajax.jsonp(url, callback);
  }

  return Ajax.get(url, options, callback);
};

var DEFAULT_STROKE_COLOR = '#000';
var DEFAULT_FILL_COLOR = 'rgba(255,255,255,0)';
var DEFAULT_TEXT_COLOR = '#000';
var hitTesting = false;
var TEMP_CANVAS = null;
var RADIAN = Math.PI / 180;
var textOffsetY = 1;
var Canvas = {
  setHitTesting: function setHitTesting(testing) {
    hitTesting = testing;
  },
  createCanvas: function createCanvas(width, height, canvasClass) {
    var canvas;

    if (!IS_NODE) {
      canvas = createEl('canvas');
      canvas.width = width;
      canvas.height = height;
    } else {
      canvas = new canvasClass(width, height);
    }

    return canvas;
  },
  prepareCanvasFont: function prepareCanvasFont(ctx, style) {
    ctx.textBaseline = 'top';
    ctx.font = getFont(style);
    var fill = style['textFill'];

    if (!fill) {
      fill = DEFAULT_TEXT_COLOR;
    }

    ctx.fillStyle = Canvas.getRgba(fill, style['textOpacity']);
  },
  prepareCanvas: function prepareCanvas(ctx, style, resources, testing) {
    if (!style) {
      return;
    }

    var strokeWidth = style['lineWidth'];

    if (!isNil(strokeWidth) && ctx.lineWidth !== strokeWidth) {
      ctx.lineWidth = strokeWidth;
    }

    var strokePattern = style['linePatternFile'];
    var strokeColor = style['lineColor'] || DEFAULT_STROKE_COLOR;

    if (testing) {
      ctx.strokeStyle = '#000';
    } else if (strokePattern && resources) {
      var patternOffset;

      if (style['linePatternDx'] || style['linePatternDy']) {
        patternOffset = [style['linePatternDx'], style['linePatternDy']];
      }

      Canvas._setStrokePattern(ctx, strokePattern, strokeWidth, patternOffset, resources);

      style['lineDasharray'] = [];
    } else if (isGradient(strokeColor)) {
      if (style['lineGradientExtent']) {
        ctx.strokeStyle = Canvas._createGradient(ctx, strokeColor, style['lineGradientExtent']);
      } else {
        ctx.strokeStyle = DEFAULT_STROKE_COLOR;
      }
    } else {
        ctx.strokeStyle = strokeColor;
      }

    if (style['lineJoin']) {
      ctx.lineJoin = style['lineJoin'];
    }

    if (style['lineCap']) {
      ctx.lineCap = style['lineCap'];
    }

    if (ctx.setLineDash && isArrayHasData(style['lineDasharray'])) {
      ctx.setLineDash(style['lineDasharray']);
    }

    var polygonPattern = style['polygonPatternFile'];
    var fill = style['polygonFill'] || DEFAULT_FILL_COLOR;

    if (testing) {
      ctx.fillStyle = '#000';
    } else if (polygonPattern && resources) {
      var fillImgUrl = extractImageUrl(polygonPattern);
      var fillTexture = resources.getImage([fillImgUrl, null, null]);

      if (!fillTexture) {
        fillTexture = resources.getImage([fillImgUrl + '-texture', null, strokeWidth]);
      }

      if (isSVG(fillImgUrl) && fillTexture instanceof Image && (Browser$1.edge || Browser$1.ie)) {
        var w = fillTexture.width || 20,
            h = fillTexture.height || 20;
        var canvas = Canvas.createCanvas(w, h);
        Canvas.image(canvas.getContext('2d'), fillTexture, 0, 0, w, h);
        fillTexture = canvas;
      }

      if (!fillTexture) {
        if (typeof console !== 'undefined') {
          console.warn('img not found for', fillImgUrl);
        }
      } else {
        ctx.fillStyle = ctx.createPattern(fillTexture, 'repeat');

        if (style['polygonPatternDx'] || style['polygonPatternDy']) {
          ctx.fillStyle['polygonPatternOffset'] = [style['polygonPatternDx'], style['polygonPatternDy']];
        }
      }
    } else if (isGradient(fill)) {
      if (style['polygonGradientExtent']) {
        ctx.fillStyle = Canvas._createGradient(ctx, fill, style['polygonGradientExtent']);
      } else {
        ctx.fillStyle = 'rgba(255,255,255,0)';
      }
    } else {
        ctx.fillStyle = fill;
      }
  },
  _createGradient: function _createGradient(ctx, g, extent) {
    var gradient = null,
        places = g['places'];
    var min = extent.getMin(),
        max = extent.getMax(),
        width = extent.getWidth(),
        height = extent.getHeight();

    if (!g['type'] || g['type'] === 'linear') {
      if (!places) {
        places = [min.x, min.y, max.x, min.y];
      } else {
        if (places.length !== 4) {
          throw new Error('A linear gradient\'s places should have 4 numbers.');
        }

        places = [min.x + places[0] * width, min.y + places[1] * height, min.x + places[2] * width, min.y + places[3] * height];
      }

      gradient = ctx.createLinearGradient.apply(ctx, places);
    } else if (g['type'] === 'radial') {
      if (!places) {
        var c = extent.getCenter()._round();

        places = [c.x, c.y, Math.abs(c.x - min.x), c.x, c.y, 0];
      } else {
        if (places.length !== 6) {
          throw new Error('A radial gradient\'s places should have 6 numbers.');
        }

        places = [min.x + places[0] * width, min.y + places[1] * height, width * places[2], min.x + places[3] * width, min.y + places[4] * height, width * places[5]];
      }

      gradient = ctx.createRadialGradient.apply(ctx, places);
    }

    g['colorStops'].forEach(function (stop) {
      gradient.addColorStop.apply(gradient, stop);
    });
    return gradient;
  },
  _setStrokePattern: function _setStrokePattern(ctx, strokePattern, strokeWidth, linePatternOffset, resources) {
    var imgUrl = extractImageUrl(strokePattern);
    var imageTexture;

    if (IS_NODE) {
      imageTexture = resources.getImage([imgUrl, null, strokeWidth]);
    } else {
      var key = imgUrl + '-texture-' + strokeWidth;
      imageTexture = resources.getImage(key);

      if (!imageTexture) {
        var imageRes = resources.getImage([imgUrl, null, null]);

        if (imageRes) {
          var w;

          if (!imageRes.width || !imageRes.height) {
            w = strokeWidth;
          } else {
            w = Math.round(imageRes.width * strokeWidth / imageRes.height);
          }

          var patternCanvas = Canvas.createCanvas(w, strokeWidth, ctx.canvas.constructor);
          Canvas.image(patternCanvas.getContext('2d'), imageRes, 0, 0, w, strokeWidth);
          resources.addResource([key, null, strokeWidth], patternCanvas);
          imageTexture = patternCanvas;
        }
      }
    }

    if (imageTexture) {
      ctx.strokeStyle = ctx.createPattern(imageTexture, 'repeat');
      ctx.strokeStyle['linePatternOffset'] = linePatternOffset;
    } else if (typeof console !== 'undefined') {
      console.warn('img not found for', imgUrl);
    }
  },
  clearRect: function clearRect(ctx, x1, y1, x2, y2) {
    ctx.canvas._drawn = false;
    ctx.clearRect(x1, y1, x2, y2);
  },
  fillCanvas: function fillCanvas(ctx, fillOpacity, x, y) {
    if (hitTesting) {
      fillOpacity = 1;
    }

    ctx.canvas._drawn = true;

    if (fillOpacity === 0) {
      return;
    }

    var isPattern = Canvas._isPattern(ctx.fillStyle);

    var offset = ctx.fillStyle && ctx.fillStyle['polygonPatternOffset'];
    var dx = offset ? offset[0] : 0,
        dy = offset ? offset[1] : 0;

    if (isNil(fillOpacity)) {
      fillOpacity = 1;
    }

    var alpha;

    if (fillOpacity < 1) {
      alpha = ctx.globalAlpha;
      ctx.globalAlpha *= fillOpacity;
    }

    if (isPattern) {
      x = x || 0;
      y = y || 0;
      ctx.translate(x + dx, y + dy);
    }

    ctx.fill();

    if (isPattern) {
      ctx.translate(-x - dx, -y - dy);
    }

    if (fillOpacity < 1) {
      ctx.globalAlpha = alpha;
    }
  },
  getRgba: function getRgba(color, op) {
    if (isNil(op)) {
      op = 1;
    }

    if (color[0] !== '#') {
      return color;
    }

    var r, g, b;

    if (color.length === 7) {
      r = parseInt(color.substring(1, 3), 16);
      g = parseInt(color.substring(3, 5), 16);
      b = parseInt(color.substring(5, 7), 16);
    } else {
      r = parseInt(color.substring(1, 2), 16) * 17;
      g = parseInt(color.substring(2, 3), 16) * 17;
      b = parseInt(color.substring(3, 4), 16) * 17;
    }

    return 'rgba(' + r + ',' + g + ',' + b + ',' + op + ')';
  },
  image: function image(ctx, img, x, y, width, height) {
    ctx.canvas._drawn = true;

    try {
      if (isNumber(width) && isNumber(height)) {
        ctx.drawImage(img, x, y, width, height);
      } else {
        ctx.drawImage(img, x, y);
      }
    } catch (error) {
      if (console) {
        console.warn('error when drawing image on canvas:', error);
        console.warn(img);
      }
    }
  },
  text: function text(ctx, _text, pt, style, textDesc) {
    Canvas._textOnMultiRow(ctx, textDesc['rows'], style, pt, textDesc['size'], textDesc['rawSize']);
  },
  _textOnMultiRow: function _textOnMultiRow(ctx, texts, style, point, splitTextSize, textSize) {
    var ptAlign = getAlignPoint(splitTextSize, style['textHorizontalAlignment'], style['textVerticalAlignment']),
        lineHeight = textSize['height'] + style['textLineSpacing'],
        basePoint = point.add(0, ptAlign.y),
        maxHeight = style['textMaxHeight'];
    var text,
        rowAlign,
        height = 0;

    for (var i = 0, len = texts.length; i < len; i++) {
      text = texts[i]['text'];
      rowAlign = getAlignPoint(texts[i]['size'], style['textHorizontalAlignment'], style['textVerticalAlignment']);

      Canvas._textOnLine(ctx, text, basePoint.add(rowAlign.x, i * lineHeight), style['textHaloRadius'], style['textHaloFill'], style['textHaloOpacity']);

      if (maxHeight > 0) {
        height += lineHeight;

        if (height + textSize['height'] >= maxHeight) {
          break;
        }
      }
    }
  },
  _textOnLine: function _textOnLine(ctx, text, pt, textHaloRadius, textHaloFill, textHaloAlpha) {
    if (hitTesting) {
      textHaloAlpha = 1;
    }

    var drawHalo = textHaloAlpha !== 0 && textHaloRadius !== 0;
    ctx.textBaseline = 'top';
    var gco, fill;
    var shadowBlur = ctx.shadowBlur,
        shadowOffsetX = ctx.shadowOffsetX,
        shadowOffsetY = ctx.shadowOffsetY;

    if (drawHalo) {
      var alpha = ctx.globalAlpha;
      ctx.globalAlpha *= textHaloAlpha;
      ctx.miterLimit = 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.lineWidth = textHaloRadius * 2;
      ctx.strokeStyle = textHaloFill;
      ctx.strokeText(text, pt.x, pt.y + textOffsetY);
      ctx.miterLimit = 10;
      ctx.globalAlpha = alpha;
      gco = ctx.globalCompositeOperation;
      ctx.globalCompositeOperation = 'destination-out';
      fill = ctx.fillStyle;
      ctx.fillStyle = '#000';
    }

    if (shadowBlur && drawHalo) {
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    }

    Canvas.fillText(ctx, text, pt);

    if (gco) {
      ctx.globalCompositeOperation = gco;
      Canvas.fillText(ctx, text, pt, fill);

      if (shadowBlur) {
        ctx.shadowBlur = shadowBlur;
        ctx.shadowOffsetX = shadowOffsetX;
        ctx.shadowOffsetY = shadowOffsetY;
      }
    }
  },
  fillText: function fillText(ctx, text, pt, rgba) {
    ctx.canvas._drawn = true;

    if (rgba) {
      ctx.fillStyle = rgba;
    }

    ctx.fillText(text, pt.x, pt.y + textOffsetY);
  },
  _stroke: function _stroke(ctx, strokeOpacity, x, y) {
    if (hitTesting) {
      strokeOpacity = 1;
    }

    ctx.canvas._drawn = true;

    if (strokeOpacity === 0) {
      return;
    }

    var offset = ctx.strokeStyle && ctx.strokeStyle['linePatternOffset'];
    var dx = offset ? offset[0] : 0,
        dy = offset ? offset[1] : 0;
    var isPattern = Canvas._isPattern(ctx.strokeStyle) && (!isNil(x) && !isNil(y) || !isNil(dx) && !isNil(dy));

    if (isNil(strokeOpacity)) {
      strokeOpacity = 1;
    }

    var alpha;

    if (strokeOpacity < 1) {
      alpha = ctx.globalAlpha;
      ctx.globalAlpha *= strokeOpacity;
    }

    if (isPattern) {
      x = x || 0;
      y = y || 0;
      ctx.translate(x + dx, y + dy);
    }

    ctx.stroke();

    if (isPattern) {
      ctx.translate(-x - dx, -y - dy);
    }

    if (strokeOpacity < 1) {
      ctx.globalAlpha = alpha;
    }
  },
  _path: function _path(ctx, points, lineDashArray, lineOpacity, ignoreStrokePattern) {
    if (!isArrayHasData(points)) {
      return;
    }

    function fillWithPattern(p1, p2) {
      var degree = computeDegree(p1.x, p1.y, p2.x, p2.y);
      ctx.save();
      var cosd = Math.cos(degree);

      if (Math.abs(cosd) < 1E-7) {
        ctx.translate(p1.x - ctx.lineWidth / 2, p1.y);
      } else {
        ctx.translate(p1.x, p1.y - ctx.lineWidth / 2 / cosd);
      }

      ctx.rotate(degree);

      Canvas._stroke(ctx, lineOpacity);

      ctx.restore();
    }

    var isDashed = isArrayHasData(lineDashArray);
    var isPatternLine = ignoreStrokePattern === true ? false : Canvas._isPattern(ctx.strokeStyle);
    var point, prePoint, nextPoint;

    for (var i = 0, len = points.length; i < len; i++) {
      point = points[i];

      if (!isDashed || ctx.setLineDash) {
        ctx.lineTo(point.x, point.y);

        if (isPatternLine && i > 0) {
          prePoint = points[i - 1];
          fillWithPattern(prePoint, point);
          ctx.beginPath();
          ctx.moveTo(point.x, point.y);
        }
      } else if (isDashed) {
        if (i === len - 1) {
          break;
        }

        nextPoint = points[i + 1];
        drawDashLine(ctx, point, nextPoint, lineDashArray, isPatternLine);
      }
    }
  },
  path: function path(ctx, points, lineOpacity, fillOpacity, lineDashArray) {
    if (!isArrayHasData(points)) {
      return;
    }

    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);

    Canvas._path(ctx, points, lineDashArray, lineOpacity);

    Canvas._stroke(ctx, lineOpacity);
  },
  _multiClip: function _multiClip(ctx, points) {
    if (!points || points.length === 0) return;
    points = points[0];

    for (var i = 0, len = points.length; i < len; i++) {
      var point = points[i];
      var x = point.x,
          y = point.y;

      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }

      if (i === len - 1) {
        x = points[0].x;
        y = points[0].y;
        ctx.lineTo(x, y);
      }
    }
  },
  polygon: function polygon(ctx, points, lineOpacity, fillOpacity, lineDashArray, smoothness) {
    if (ctx.isMultiClip) {
      Canvas._multiClip(ctx, points);

      return;
    }

    if (!isArrayHasData(points)) {
      return;
    }

    var isPatternLine = Canvas._isPattern(ctx.strokeStyle),
        fillFirst = isArrayHasData(lineDashArray) && !ctx.setLineDash || isPatternLine && !smoothness;

    if (!isArrayHasData(points[0])) {
      points = [points];
    }

    var savedCtx = ctx;

    if (points.length > 1 && !IS_NODE) {
      if (!TEMP_CANVAS) {
        TEMP_CANVAS = Canvas.createCanvas(1, 1);
      }

      ctx.canvas._drawn = false;
      TEMP_CANVAS.width = ctx.canvas.width;
      TEMP_CANVAS.height = ctx.canvas.height;
      ctx = TEMP_CANVAS.getContext('2d');
      copyProperties(ctx, savedCtx);
    }

    var op, i, len;

    if (fillFirst) {
      ctx.save();

      for (i = 0, len = points.length; i < len; i++) {
        if (!isArrayHasData(points[i])) {
          continue;
        }

        Canvas._ring(ctx, points[i], null, 0, true);

        op = fillOpacity;

        if (i > 0) {
          ctx.globalCompositeOperation = 'destination-out';
          op = 1;
        }

        Canvas.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);

        if (i > 0) {
          ctx.globalCompositeOperation = 'source-over';
        } else if (len > 1) {
          ctx.fillStyle = '#fff';
        }

        Canvas._stroke(ctx, 0);
      }

      ctx.restore();
    }

    for (i = 0, len = points.length; i < len; i++) {
      if (!isArrayHasData(points[i])) {
        continue;
      }

      if (smoothness) {
        Canvas.paintSmoothLine(ctx, points[i], lineOpacity, smoothness, true);
        ctx.closePath();
      } else {
        Canvas._ring(ctx, points[i], lineDashArray, lineOpacity);
      }

      if (!fillFirst) {
        op = fillOpacity;

        if (i > 0) {
          ctx.globalCompositeOperation = 'destination-out';
          op = 1;
        }

        Canvas.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);

        if (i > 0) {
          ctx.globalCompositeOperation = 'source-over';
        } else if (len > 1) {
          ctx.fillStyle = '#fff';
        }
      }

      Canvas._stroke(ctx, lineOpacity);
    }

    if (points.length > 1 && !IS_NODE) {
      savedCtx.drawImage(TEMP_CANVAS, 0, 0);
      savedCtx.canvas._drawn = ctx.canvas._drawn;
      copyProperties(savedCtx, ctx);
    }
  },
  _ring: function _ring(ctx, ring, lineDashArray, lineOpacity, ignorePattern) {
    var isPattern = Canvas._isPattern(ctx.strokeStyle);

    if (!ignorePattern && isPattern && !ring[0].equals(ring[ring.length - 1])) {
      ring = ring.concat([ring[0]]);
    }

    ctx.beginPath();
    ctx.moveTo(ring[0].x, ring[0].y);

    Canvas._path(ctx, ring, lineDashArray, lineOpacity, ignorePattern);

    if (!isPattern) {
      ctx.closePath();
    }
  },
  paintSmoothLine: function paintSmoothLine(ctx, points, lineOpacity, smoothValue, close, tailIdx, tailRatio) {
    if (!points) {
      return;
    }

    if (points.length <= 2 || !smoothValue) {
      Canvas.path(ctx, points, lineOpacity);
      return;
    }

    function interpolate$$1(t0, t1, x1, y1, bx1, by1, bx2, by2, x2, y2) {
      var u0 = 1.0 - t0;
      var u1 = 1.0 - t1;
      var qxa = x1 * u0 * u0 + bx1 * 2 * t0 * u0 + bx2 * t0 * t0;
      var qxb = x1 * u1 * u1 + bx1 * 2 * t1 * u1 + bx2 * t1 * t1;
      var qxc = bx1 * u0 * u0 + bx2 * 2 * t0 * u0 + x2 * t0 * t0;
      var qxd = bx1 * u1 * u1 + bx2 * 2 * t1 * u1 + x2 * t1 * t1;
      var qya = y1 * u0 * u0 + by1 * 2 * t0 * u0 + by2 * t0 * t0;
      var qyb = y1 * u1 * u1 + by1 * 2 * t1 * u1 + by2 * t1 * t1;
      var qyc = by1 * u0 * u0 + by2 * 2 * t0 * u0 + y2 * t0 * t0;
      var qyd = by1 * u1 * u1 + by2 * 2 * t1 * u1 + y2 * t1 * t1;
      var xb = qxa * u1 + qxc * t1;
      var xc = qxb * u0 + qxd * t0;
      var xd = qxb * u1 + qxd * t1;
      var yb = qya * u1 + qyc * t1;
      var yc = qyb * u0 + qyd * t0;
      var yd = qyb * u1 + qyd * t1;
      return [xb, yb, xc, yc, xd, yd];
    }

    function getCubicControlPoints(x0, y0, x1, y1, x2, y2, x3, y3, smoothValue, t) {
      var xc1 = (x0 + x1) / 2.0,
          yc1 = (y0 + y1) / 2.0;
      var xc2 = (x1 + x2) / 2.0,
          yc2 = (y1 + y2) / 2.0;
      var xc3 = (x2 + x3) / 2.0,
          yc3 = (y2 + y3) / 2.0;
      var len1 = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
      var len2 = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      var len3 = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));
      var k1 = len1 / (len1 + len2);
      var k2 = len2 / (len2 + len3);
      var xm1 = xc1 + (xc2 - xc1) * k1,
          ym1 = yc1 + (yc2 - yc1) * k1;
      var xm2 = xc2 + (xc3 - xc2) * k2,
          ym2 = yc2 + (yc3 - yc2) * k2;
      var ctrl1X = xm1 + (xc2 - xm1) * smoothValue + x1 - xm1,
          ctrl1Y = ym1 + (yc2 - ym1) * smoothValue + y1 - ym1,
          ctrl2X = xm2 + (xc2 - xm2) * smoothValue + x2 - xm2,
          ctrl2Y = ym2 + (yc2 - ym2) * smoothValue + y2 - ym2;
      var ctrlPoints = [ctrl1X, ctrl1Y, ctrl2X, ctrl2Y];

      if (t < 1) {
        return interpolate$$1(0, t, x1, y1, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, x2, y2);
      } else {
        return ctrlPoints;
      }
    }

    var count = points.length;
    var l = close ? count : count - 1;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    if (tailRatio !== undefined) l -= Math.max(l - tailIdx - 1, 0);
    var preCtrlPoints;

    for (var i = 0; i < l; i++) {
      var x1 = points[i].x,
          y1 = points[i].y;
      var x0 = void 0,
          y0 = void 0,
          x2 = void 0,
          y2 = void 0,
          x3 = void 0,
          y3 = void 0;

      if (i - 1 < 0) {
        if (!close) {
          x0 = points[i + 1].x;
          y0 = points[i + 1].y;
        } else {
          x0 = points[l - 1].x;
          y0 = points[l - 1].y;
        }
      } else {
        x0 = points[i - 1].x;
        y0 = points[i - 1].y;
      }

      if (i + 1 < count) {
        x2 = points[i + 1].x;
        y2 = points[i + 1].y;
      } else {
        x2 = points[i + 1 - count].x;
        y2 = points[i + 1 - count].y;
      }

      if (i + 2 < count) {
        x3 = points[i + 2].x;
        y3 = points[i + 2].y;
      } else if (!close) {
        x3 = points[i].x;
        y3 = points[i].y;
      } else {
        x3 = points[i + 2 - count].x;
        y3 = points[i + 2 - count].y;
      }

      var ctrlPoints = getCubicControlPoints(x0, y0, x1, y1, x2, y2, x3, y3, smoothValue, i === l - 1 ? tailRatio : 1);

      if (i === l - 1 && tailRatio >= 0 && tailRatio < 1) {
        ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], ctrlPoints[4], ctrlPoints[5]);
        points.splice(l - 1, count - (l - 1) - 1);
        var lastPoint = new Point(ctrlPoints[4], ctrlPoints[5]);
        lastPoint.prevCtrlPoint = new Point(ctrlPoints[2], ctrlPoints[3]);
        points.push(lastPoint);
        count = points.length;
      } else {
        ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], x2, y2);
      }

      points[i].nextCtrlPoint = ctrlPoints.slice(0, 2);
      points[i].prevCtrlPoint = preCtrlPoints ? preCtrlPoints.slice(2) : null;
      preCtrlPoints = ctrlPoints;
    }

    if (!close && points[1].prevCtrlPoint) {
      points[0].nextCtrlPoint = points[1].prevCtrlPoint;
      delete points[0].prevCtrlPoint;
    }

    if (!points[count - 1].prevCtrlPoint) {
      points[count - 1].prevCtrlPoint = points[count - 2].nextCtrlPoint;
    }

    Canvas._stroke(ctx, lineOpacity);
  },
  _arcBetween: function _arcBetween(ctx, p1, p2, degree) {
    var a = degree,
        dist = p1.distanceTo(p2),
        r = dist / 2 / Math.sin(a / 2);
    var p1p2 = Math.asin((p2.y - p1.y) / dist);

    if (p1.x > p2.x) {
      p1p2 = Math.PI - p1p2;
    }

    var cp2 = 90 * RADIAN - a / 2,
        da = p1p2 - cp2;
    var dx = Math.cos(da) * r,
        dy = Math.sin(da) * r,
        cx = p1.x + dx,
        cy = p1.y + dy;
    var startAngle = Math.asin((p2.y - cy) / r);

    if (cx > p2.x) {
      startAngle = Math.PI - startAngle;
    }

    var endAngle = startAngle + a;
    ctx.beginPath();
    ctx.arc(cx, cy, r, startAngle, endAngle);
    return [cx, cy];
  },
  _lineTo: function _lineTo(ctx, p) {
    ctx.lineTo(p.x, p.y);
  },
  bezierCurveAndFill: function bezierCurveAndFill(ctx, points, lineOpacity, fillOpacity) {
    ctx.beginPath();
    var start = points[0];
    ctx.moveTo(start.x, start.y);
    var args = [ctx];
    args.push.apply(args, points.splice(1));

    Canvas._bezierCurveTo.apply(Canvas, args);

    Canvas.fillCanvas(ctx, fillOpacity);

    Canvas._stroke(ctx, lineOpacity);
  },
  _bezierCurveTo: function _bezierCurveTo(ctx, p1, p2, p3) {
    ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
  },
  ellipse: function ellipse(ctx, pt, width, heightTop, heightBottom, lineOpacity, fillOpacity) {
    function bezierEllipse(x, y, a, b, b1) {
      var k = 0.5522848,
          ox = a * k,
          oy = b * k,
          oy1 = b1 * k;
      ctx.moveTo(x - a, y);
      ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
      ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
      ctx.bezierCurveTo(x + a, y + oy1, x + ox, y + b1, x, y + b1);
      ctx.bezierCurveTo(x - ox, y + b1, x - a, y + oy1, x - a, y);
      ctx.closePath();
    }

    ctx.beginPath();

    if (width === heightTop && width === heightBottom) {
      ctx.arc(pt.x, pt.y, width, 0, 2 * Math.PI);
    } else if (ctx.ellipse) {
      if (heightTop !== heightBottom) {
        ctx.ellipse(pt.x, pt.y, width, heightTop, 0, RADIAN * 180, RADIAN * 360, false);
        ctx.ellipse(pt.x, pt.y, width, heightBottom, 0, 0, RADIAN * 180, false);
      } else {
        ctx.ellipse(pt.x, pt.y, width, heightTop, 0, 0, RADIAN * 360, false);
      }
    } else {
      bezierEllipse(pt.x, pt.y, width, heightTop, heightBottom);
    }

    Canvas.fillCanvas(ctx, fillOpacity, pt.x - width, pt.y - heightTop);

    Canvas._stroke(ctx, lineOpacity, pt.x - width, pt.y - heightTop);
  },
  rectangle: function rectangle(ctx, pt, size, lineOpacity, fillOpacity) {
    var x = pt.x,
        y = pt.y;
    ctx.beginPath();
    ctx.rect(x, y, size['width'], size['height']);
    Canvas.fillCanvas(ctx, fillOpacity, x, y);

    Canvas._stroke(ctx, lineOpacity, x, y);
  },
  sector: function sector(ctx, pt, size, angles, lineOpacity, fillOpacity) {
    var rad = RADIAN;
    var startAngle = angles[0],
        endAngle = angles[1];

    function sector(ctx, x, y, radius, startAngle, endAngle) {
      var sDeg = rad * -endAngle;
      var eDeg = rad * -startAngle;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, radius, sDeg, eDeg);
      ctx.lineTo(x, y);
      Canvas.fillCanvas(ctx, fillOpacity, x - radius, y - radius);

      Canvas._stroke(ctx, lineOpacity, x - radius, y - radius);
    }

    sector(ctx, pt.x, pt.y, size, startAngle, endAngle);
  },
  _isPattern: function _isPattern(style) {
    return !isString(style) && !('addColorStop' in style);
  },
  drawCross: function drawCross(ctx, x, y, lineWidth, color) {
    ctx.canvas._drawn = true;
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.moveTo(x - 5, y);
    ctx.lineTo(x + 5, y);
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x, y + 5);
    ctx.stroke();
  },
  copy: function copy(canvas, c) {
    var target = c || createEl('canvas');
    target.width = canvas.width;
    target.height = canvas.height;
    target.getContext('2d').drawImage(canvas, 0, 0);
    return target;
  }
};

function drawDashLine(ctx, startPoint, endPoint, dashArray) {
  var fromX = startPoint.x,
      fromY = startPoint.y,
      toX = endPoint.x,
      toY = endPoint.y;
  var pattern = dashArray;

  var lt = function lt(a, b) {
    return a <= b;
  };

  var gt = function gt(a, b) {
    return a >= b;
  };

  var capmin = function capmin(a, b) {
    return Math.min(a, b);
  };

  var capmax = function capmax(a, b) {
    return Math.max(a, b);
  };

  var checkX = {
    thereYet: gt,
    cap: capmin
  };
  var checkY = {
    thereYet: gt,
    cap: capmin
  };

  if (fromY - toY > 0) {
    checkY.thereYet = lt;
    checkY.cap = capmax;
  }

  if (fromX - toX > 0) {
    checkX.thereYet = lt;
    checkX.cap = capmax;
  }

  ctx.moveTo(fromX, fromY);
  var offsetX = fromX;
  var offsetY = fromY;
  var idx = 0,
      dash = true;
  var ang, len;

  while (!(checkX.thereYet(offsetX, toX) && checkY.thereYet(offsetY, toY))) {
    ang = Math.atan2(toY - fromY, toX - fromX);
    len = pattern[idx];
    offsetX = checkX.cap(toX, offsetX + Math.cos(ang) * len);
    offsetY = checkY.cap(toY, offsetY + Math.sin(ang) * len);

    if (dash) {
      ctx.lineTo(offsetX, offsetY);
    } else {
      ctx.moveTo(offsetX, offsetY);
    }

    idx = (idx + 1) % pattern.length;
    dash = !dash;
  }
}

var prefix = 'data:image/';

function extractImageUrl(url) {
  if (url.substring(0, prefix.length) === prefix) {
    return url;
  }

  return extractCssUrl(url);
}

function copyProperties(ctx, savedCtx) {
  ctx.filter = savedCtx.filter;
  ctx.fillStyle = savedCtx.fillStyle;
  ctx.globalAlpha = savedCtx.globalAlpha;
  ctx.lineCap = savedCtx.lineCap;
  ctx.lineDashOffset = savedCtx.lineDashOffset;
  ctx.lineJoin = savedCtx.lineJoin;
  ctx.lineWidth = savedCtx.lineWidth;
  ctx.shadowBlur = savedCtx.shadowBlur;
  ctx.shadowColor = savedCtx.shadowColor;
  ctx.shadowOffsetX = savedCtx.shadowOffsetX;
  ctx.shadowOffsetY = savedCtx.shadowOffsetY;
  ctx.strokeStyle = savedCtx.strokeStyle;
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var zousanMin = createCommonjsModule(function (module) {
  !function (t) {

    function e(t) {
      if (t) {
        var e = this;
        t(function (t) {
          e.resolve(t);
        }, function (t) {
          e.reject(t);
        });
      }
    }

    function n(t, e) {
      if ("function" == typeof t.y) try {
        var n = t.y.call(i, e);
        t.p.resolve(n);
      } catch (o) {
        t.p.reject(o);
      } else t.p.resolve(e);
    }

    function o(t, e) {
      if ("function" == typeof t.n) try {
        var n = t.n.call(i, e);
        t.p.resolve(n);
      } catch (o) {
        t.p.reject(o);
      } else t.p.reject(e);
    }

    var r,
        i,
        c = "fulfilled",
        u = "rejected",
        s = "undefined",
        f = function () {
      function e() {
        for (; n.length - o;) {
          try {
            n[o]();
          } catch (e) {
            t.console && t.console.error(e);
          }

          n[o++] = i, o == r && (n.splice(0, r), o = 0);
        }
      }

      var n = [],
          o = 0,
          r = 1024,
          c = function () {
        if (typeof MutationObserver !== s) {
          var t = document.createElement("div"),
              n = new MutationObserver(e);
          return n.observe(t, {
            attributes: !0
          }), function () {
            t.setAttribute("a", 0);
          };
        }

        return typeof setImmediate !== s ? function () {
          setImmediate(e);
        } : function () {
          setTimeout(e, 0);
        };
      }();

      return function (t) {
        n.push(t), n.length - o == 1 && c();
      };
    }();

    e.prototype = {
      resolve: function resolve(t) {
        if (this.state === r) {
          if (t === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
          var e = this;
          if (t && ("function" == typeof t || "object" == typeof t)) try {
            var o = !0,
                i = t.then;
            if ("function" == typeof i) return void i.call(t, function (t) {
              o && (o = !1, e.resolve(t));
            }, function (t) {
              o && (o = !1, e.reject(t));
            });
          } catch (u) {
            return void (o && this.reject(u));
          }
          this.state = c, this.v = t, e.c && f(function () {
            for (var o = 0, r = e.c.length; r > o; o++) {
              n(e.c[o], t);
            }
          });
        }
      },
      reject: function reject(n) {
        if (this.state === r) {
          this.state = u, this.v = n;
          var i = this.c;
          i ? f(function () {
            for (var t = 0, e = i.length; e > t; t++) {
              o(i[t], n);
            }
          }) : !e.suppressUncaughtRejectionError && t.console && t.console.log("You upset Zousan. Please catch rejections: ", n, n ? n.stack : null);
        }
      },
      then: function then(t, i) {
        var u = new e(),
            s = {
          y: t,
          n: i,
          p: u
        };
        if (this.state === r) this.c ? this.c.push(s) : this.c = [s];else {
          var l = this.state,
              a = this.v;
          f(function () {
            l === c ? n(s, a) : o(s, a);
          });
        }
        return u;
      },
      "catch": function _catch(t) {
        return this.then(null, t);
      },
      "finally": function _finally(t) {
        return this.then(t, t);
      },
      timeout: function timeout(t, n) {
        n = n || "Timeout";
        var o = this;
        return new e(function (e, r) {
          setTimeout(function () {
            r(Error(n));
          }, t), o.then(function (t) {
            e(t);
          }, function (t) {
            r(t);
          });
        });
      }
    }, e.resolve = function (t) {
      var n = new e();
      return n.resolve(t), n;
    }, e.reject = function (t) {
      var n = new e();
      return n.reject(t), n;
    }, e.all = function (t) {
      function n(n, c) {
        n && "function" == typeof n.then || (n = e.resolve(n)), n.then(function (e) {
          o[c] = e, r++, r == t.length && i.resolve(o);
        }, function (t) {
          i.reject(t);
        });
      }

      for (var o = [], r = 0, i = new e(), c = 0; c < t.length; c++) {
        n(t[c], c);
      }

      return t.length || i.resolve(o), i;
    }, module.exports && (module.exports = e), t.define && t.define.amd && t.define([], function () {
      return e;
    }), t.Zousan = e, e.soon = f;
  }("undefined" != typeof commonjsGlobal ? commonjsGlobal : commonjsGlobal);
});

var promise;

if (typeof Promise !== 'undefined') {
  promise = Promise;
} else {
  promise = zousanMin;
}

var Promise$1 = promise;

var Eventable = function Eventable(Base) {
  return function (_Base) {
    _inheritsLoose(_class, _Base);

    function _class() {
      return _Base.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.on = function on$$1(eventsOn, handler, context) {
      if (!eventsOn) {
        return this;
      }

      if (!isString(eventsOn)) {
        return this._switch('on', eventsOn, handler);
      }

      if (!handler) {
        return this;
      }

      if (!this._eventMap) {
        this._eventMap = {};
      }

      var eventTypes = eventsOn.toLowerCase().split(' ');
      var evtType;

      if (!context) {
        context = this;
      }

      var handlerChain;

      for (var ii = 0, ll = eventTypes.length; ii < ll; ii++) {
        evtType = eventTypes[ii];
        handlerChain = this._eventMap[evtType];

        if (!handlerChain) {
          handlerChain = [];
          this._eventMap[evtType] = handlerChain;
        }

        var l = handlerChain.length;

        if (l > 0) {
          for (var i = 0; i < l; i++) {
            if (handler === handlerChain[i].handler && handlerChain[i].context === context) {
              return this;
            }
          }
        }

        handlerChain.push({
          handler: handler,
          context: context
        });
      }

      return this;
    };

    _proto.addEventListener = function addEventListener() {
      return this.on.apply(this, arguments);
    };

    _proto.once = function once(eventTypes, handler, context) {
      if (!isString(eventTypes)) {
        var once = {};

        for (var p in eventTypes) {
          if (eventTypes.hasOwnProperty(p)) {
            once[p] = this._wrapOnceHandler(p, eventTypes[p], context);
          }
        }

        return this._switch('on', once);
      }

      var evetTypes = eventTypes.split(' ');

      for (var i = 0, l = evetTypes.length; i < l; i++) {
        this.on(evetTypes[i], this._wrapOnceHandler(evetTypes[i], handler, context));
      }

      return this;
    };

    _proto.off = function off$$1(eventsOff, handler, context) {
      if (!this._eventMap || !eventsOff) {
        return this;
      }

      if (!isString(eventsOff)) {
        return this._switch('off', eventsOff, handler);
      }

      if (!handler) {
        return this;
      }

      var eventTypes = eventsOff.split(' ');
      var eventType, listeners, wrapKey;

      if (!context) {
        context = this;
      }

      for (var j = 0, jl = eventTypes.length; j < jl; j++) {
        eventType = eventTypes[j].toLowerCase();
        wrapKey = 'Z__' + eventType;
        listeners = this._eventMap[eventType];

        if (!listeners) {
          return this;
        }

        for (var i = listeners.length - 1; i >= 0; i--) {
          var listener = listeners[i];

          if ((handler === listener.handler || handler === listener.handler[wrapKey]) && listener.context === context) {
            delete listener.handler[wrapKey];
            listeners.splice(i, 1);
          }
        }

        if (!listeners.length) {
          delete this._eventMap[eventType];
        }
      }

      return this;
    };

    _proto.removeEventListener = function removeEventListener() {
      return this.off.apply(this, arguments);
    };

    _proto.listens = function listens(eventType, handler, context) {
      if (!this._eventMap || !isString(eventType)) {
        return 0;
      }

      var handlerChain = this._eventMap[eventType.toLowerCase()];

      if (!handlerChain || !handlerChain.length) {
        return 0;
      }

      if (!handler) {
        return handlerChain.length;
      }

      for (var i = 0, len = handlerChain.length; i < len; i++) {
        if (handler === handlerChain[i].handler && (isNil(context) || handlerChain[i].context === context)) {
          return 1;
        }
      }

      return 0;
    };

    _proto.getListeningEvents = function getListeningEvents() {
      if (!this._eventMap) {
        return [];
      }

      return Object.keys(this._eventMap);
    };

    _proto.copyEventListeners = function copyEventListeners(target) {
      var eventMap = target._eventMap;

      if (!eventMap) {
        return this;
      }

      var handlerChain;

      for (var eventType in eventMap) {
        handlerChain = eventMap[eventType];

        for (var i = 0, len = handlerChain.length; i < len; i++) {
          this.on(eventType, handlerChain[i].handler, handlerChain[i].context);
        }
      }

      return this;
    };

    _proto.fire = function fire() {
      if (this._eventParent) {
        return this._eventParent.fire.apply(this._eventParent, arguments);
      }

      return this._fire.apply(this, arguments);
    };

    _proto._wrapOnceHandler = function _wrapOnceHandler(evtType, handler, context) {
      var me = this;
      var key = 'Z__' + evtType;
      var called = false;

      var fn = function onceHandler() {
        if (called) {
          return;
        }

        delete fn[key];
        called = true;

        if (context) {
          handler.apply(context, arguments);
        } else {
          handler.apply(this, arguments);
        }

        me.off(evtType, onceHandler, this);
      };

      fn[key] = handler;
      return fn;
    };

    _proto._switch = function _switch(to, eventKeys, context) {
      for (var p in eventKeys) {
        if (eventKeys.hasOwnProperty(p)) {
          this[to](p, eventKeys[p], context);
        }
      }

      return this;
    };

    _proto._clearListeners = function _clearListeners(eventType) {
      if (!this._eventMap || !isString(eventType)) {
        return;
      }

      var handlerChain = this._eventMap[eventType.toLowerCase()];

      if (!handlerChain) {
        return;
      }

      this._eventMap[eventType] = null;
    };

    _proto._clearAllListeners = function _clearAllListeners() {
      this._eventMap = null;
    };

    _proto._setEventParent = function _setEventParent(parent) {
      this._eventParent = parent;
      return this;
    };

    _proto._setEventTarget = function _setEventTarget(target) {
      this._eventTarget = target;
      return this;
    };

    _proto._fire = function _fire(eventType, param) {
      if (!this._eventMap) {
        return this;
      }

      var handlerChain = this._eventMap[eventType.toLowerCase()];

      if (!handlerChain) {
        return this;
      }

      if (!param) {
        param = {};
      }

      param['type'] = eventType;
      param['target'] = this._eventTarget || this;
      var queue = handlerChain.slice(0);
      var context, bubble, passed;

      for (var i = 0, len = queue.length; i < len; i++) {
        if (!queue[i]) {
          continue;
        }

        context = queue[i].context;
        bubble = true;
        passed = extend({}, param);

        if (context) {
          bubble = queue[i].handler.call(context, passed);
        } else {
          bubble = queue[i].handler(passed);
        }

        if (bubble === false) {
          if (param['domEvent']) {
            stopPropagation(param['domEvent']);
          }
        }
      }

      return this;
    };

    return _class;
  }(Base);
};

var Handler = function () {
  function Handler(target) {
    this.target = target;
  }

  var _proto = Handler.prototype;

  _proto.enable = function enable() {
    if (this._enabled) {
      return this;
    }

    this._enabled = true;
    this.addHooks();
    return this;
  };

  _proto.disable = function disable() {
    if (!this._enabled) {
      return this;
    }

    this._enabled = false;
    this.removeHooks();
    return this;
  };

  _proto.enabled = function enabled() {
    return !!this._enabled;
  };

  _proto.remove = function remove() {
    this.disable();
    delete this.target;
    delete this.dom;
  };

  return Handler;
}();

var Handler$1 = Eventable(Handler);

var Class = function () {
  function Class(options) {
    if (!this || !this.setOptions) {
      throw new Error('Class instance is being created without "new" operator.');
    }

    this.setOptions(options);
    this.callInitHooks();
  }

  var _proto = Class.prototype;

  _proto.callInitHooks = function callInitHooks() {
    var proto = Object.getPrototypeOf(this);

    this._visitInitHooks(proto);

    return this;
  };

  _proto.setOptions = function setOptions(options) {
    if (!this.hasOwnProperty('options')) {
      this.options = this.options ? Object.create(this.options) : {};
    }

    if (!options) {
      return this;
    }

    for (var i in options) {
      this.options[i] = options[i];
    }

    return this;
  };

  _proto.config = function config(conf) {
    if (!conf) {
      var config = {};

      for (var p in this.options) {
        if (this.options.hasOwnProperty(p)) {
          config[p] = this.options[p];
        }
      }

      return config;
    } else {
      if (arguments.length === 2) {
        var t = {};
        t[conf] = arguments[1];
        conf = t;
      }

      for (var i in conf) {
        this.options[i] = conf[i];

        if (this[i] && this[i] instanceof Handler$1) {
          if (conf[i]) {
            this[i].enable();
          } else {
            this[i].disable();
          }
        }
      }

      this.onConfig(conf);
    }

    return this;
  };

  _proto.onConfig = function onConfig() {};

  _proto._visitInitHooks = function _visitInitHooks(proto) {
    if (this._initHooksCalled) {
      return;
    }

    var parentProto = Object.getPrototypeOf(proto);

    if (parentProto._visitInitHooks) {
      parentProto._visitInitHooks.call(this, parentProto);
    }

    this._initHooksCalled = true;
    var hooks = proto._initHooks;

    if (hooks && hooks !== parentProto._initHooks) {
      for (var i = 0; i < hooks.length; i++) {
        hooks[i].call(this);
      }
    }
  };

  Class.addInitHook = function addInitHook(fn) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var init = typeof fn === 'function' ? fn : function () {
      this[fn].apply(this, args);
    };
    var proto = this.prototype;
    var parentProto = Object.getPrototypeOf(proto);

    if (!proto._initHooks || proto._initHooks === parentProto._initHooks) {
      proto._initHooks = [];
    }

    proto._initHooks.push(init);

    return this;
  };

  Class.include = function include() {
    for (var i = 0; i < arguments.length; i++) {
      extend(this.prototype, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }

    return this;
  };

  Class.mergeOptions = function mergeOptions(options) {
    var proto = this.prototype;
    var parentProto = Object.getPrototypeOf(proto);

    if (!proto.options || proto.options === parentProto.options) {
      proto.options = proto.options ? Object.create(proto.options) : {};
    }

    extend(proto.options, options);
    return this;
  };

  return Class;
}();

var registeredTypes = {};
var JSONAble = (function (Base) {
  return function (_Base) {
    _inheritsLoose(_class, _Base);

    function _class() {
      return _Base.apply(this, arguments) || this;
    }

    _class.registerJSONType = function registerJSONType(type) {
      if (!type) {
        return this;
      }

      registeredTypes[type] = this;
      return this;
    };

    _class.getJSONClass = function getJSONClass(type) {
      if (!type) {
        return null;
      }

      return registeredTypes[type];
    };

    var _proto = _class.prototype;

    _proto.getJSONType = function getJSONType() {
      if (this._jsonType === undefined) {
        var clazz = Object.getPrototypeOf(this).constructor;

        for (var p in registeredTypes) {
          if (registeredTypes[p] === clazz) {
            this._jsonType = p;
            break;
          }
        }
      }

      if (!this._jsonType) {
        throw new Error('Found an unregistered geometry class!');
      }

      return this._jsonType;
    };

    return _class;
  }(Base);
});

function Handlerable (Base) {
  return function (_Base) {
    _inheritsLoose(_class, _Base);

    function _class() {
      return _Base.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.addHandler = function addHandler(name, handlerClass) {
      if (!handlerClass) {
        return this;
      }

      if (!this._handlers) {
        this._handlers = [];
      }

      if (this[name]) {
        this[name].enable();
        return this;
      }

      var handler = this[name] = new handlerClass(this);

      this._handlers.push(handler);

      if (this.options[name]) {
        handler.enable();
      }

      return this;
    };

    _proto.removeHandler = function removeHandler(name) {
      if (!name) {
        return this;
      }

      var handler = this[name];

      if (handler) {
        var hit = this._handlers.indexOf(handler);

        if (hit >= 0) {
          this._handlers.splice(hit, 1);
        }

        this[name].remove();
        delete this[name];
      }

      return this;
    };

    _proto._clearHandlers = function _clearHandlers() {
      for (var i = 0, len = this._handlers.length; i < len; i++) {
        this._handlers[i].remove();
      }

      this._handlers = [];
    };

    return _class;
  }(Base);
}

var START_EVENTS = 'touchstart mousedown';
var MOVE_EVENTS = {
  mousedown: 'mousemove',
  touchstart: 'touchmove',
  pointerdown: 'touchmove',
  MSPointerDown: 'touchmove'
};
var END_EVENTS = {
  mousedown: 'mouseup',
  touchstart: 'touchend',
  pointerdown: 'touchend',
  MSPointerDown: 'touchend'
};

var DragHandler = function (_Handler) {
  _inheritsLoose(DragHandler, _Handler);

  function DragHandler(dom, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Handler.call(this, null) || this;
    _this.dom = dom;
    _this.options = options;
    return _this;
  }

  var _proto = DragHandler.prototype;

  _proto.enable = function enable() {
    if (!this.dom) {
      return this;
    }

    this._onMouseDown = function (e) {
      return this.onMouseDown(e);
    };

    on(this.dom, START_EVENTS, this._onMouseDown, this);
    return this;
  };

  _proto.disable = function disable() {
    if (!this.dom) {
      return this;
    }

    this._offEvents();

    off(this.dom, START_EVENTS, this._onMouseDown);
    delete this._onMouseDown;
    return this;
  };

  _proto.onMouseDown = function onMouseDown(event) {
    if (!this.options['rightclick'] && event.button === 2) {
      return;
    }

    if (event.touches && event.touches.length > 1) {
      return;
    }

    if (this.options['cancelOn'] && this.options['cancelOn'](event) === true) {
      return;
    }

    var dom = this.dom;

    if (dom.setCapture) {
      dom.setCapture();
    } else if (window.captureEvents) {
      window.captureEvents(window['Event'].MOUSEMOVE | window['Event'].MOUSEUP);
    }

    dom['ondragstart'] = function () {
      return false;
    };

    delete this.moved;
    var actual = event.touches ? event.touches[0] : event;
    this.startPos = new Point(actual.clientX, actual.clientY);
    on(document, MOVE_EVENTS[event.type], this.onMouseMove, this);
    on(document, END_EVENTS[event.type], this.onMouseUp, this);

    if (!this.options['ignoreMouseleave']) {
      on(this.dom, 'mouseleave', this.onMouseUp, this);
    }

    this.fire('mousedown', {
      'domEvent': event,
      'mousePos': new Point(actual.clientX, actual.clientY)
    });
  };

  _proto.onMouseMove = function onMouseMove(event) {
    if (event.touches && event.touches.length > 1) {
      if (this.moved) {
        this.interupted = true;
        this.onMouseUp(event);
      }

      return;
    }

    var actual = event.touches ? event.touches[0] : event;
    var newPos = new Point(actual.clientX, actual.clientY),
        offset = newPos.sub(this.startPos);

    if (!offset.x && !offset.y) {
      return;
    }

    if (!this.moved) {
      this.fire('dragstart', {
        'domEvent': event,
        'mousePos': this.startPos.copy()
      });
      this.moved = true;
    } else {
      this.fire('dragging', {
        'domEvent': event,
        'mousePos': new Point(actual.clientX, actual.clientY)
      });
    }
  };

  _proto.onMouseUp = function onMouseUp(event) {
    var actual = event.changedTouches ? event.changedTouches[0] : event;

    this._offEvents();

    var param = {
      'domEvent': event
    };

    if (isNumber(actual.clientX)) {
      param['mousePos'] = new Point(parseInt(actual.clientX, 0), parseInt(actual.clientY, 0));
    }

    if (this.moved) {
        param.interupted = this.interupted;
        this.fire('dragend', param);
        delete this.interupted;
        delete this.moved;
      }

    this.fire('mouseup', param);
  };

  _proto._offEvents = function _offEvents() {
    var dom = this.dom;
    off(dom, 'mouseleave', this.onMouseUp, this);

    if (typeof document === 'undefined' || typeof window === 'undefined') {
      return;
    }

    for (var i in MOVE_EVENTS) {
      off(document, MOVE_EVENTS[i], this.onMouseMove, this);
      off(document, END_EVENTS[i], this.onMouseUp, this);
    }

    if (dom['releaseCapture']) {
      dom['releaseCapture']();
    } else if (window.captureEvents) {
      window.captureEvents(window['Event'].MOUSEMOVE | window['Event'].MOUSEUP);
    }
  };

  return DragHandler;
}(Handler$1);

var Coordinate = function (_Position) {
  _inheritsLoose(Coordinate, _Position);

  function Coordinate() {
    return _Position.apply(this, arguments) || this;
  }

  Coordinate.toNumberArrays = function toNumberArrays(coordinates) {
    if (!Array.isArray(coordinates)) {
      return [coordinates.x, coordinates.y];
    }

    return forEachCoord(coordinates, function (coord) {
      return [coord.x, coord.y];
    });
  };

  Coordinate.toCoordinates = function toCoordinates(coordinates) {
    if (isNumber(coordinates[0]) && isNumber(coordinates[1])) {
      return new Coordinate(coordinates);
    }

    var result = [];

    for (var i = 0, len = coordinates.length; i < len; i++) {
      var child = coordinates[i];

      if (Array.isArray(child)) {
        if (isNumber(child[0])) {
          result.push(new Coordinate(child));
        } else {
          result.push(Coordinate.toCoordinates(child));
        }
      } else {
        result.push(new Coordinate(child));
      }
    }

    return result;
  };

  return Coordinate;
}(Position);

var CRS = function () {
  function CRS(type, properties) {
    this.type = type;
    this.properties = properties;
  }

  CRS.createProj4 = function createProj4(proj) {
    return new CRS('proj4', {
      'proj': proj
    });
  };

  CRS.fromProjectionCode = function fromProjectionCode(code) {
    if (!code) {
      return null;
    }

    code = code.toUpperCase().replace(':', '');
    return CRS[code] || null;
  };

  return CRS;
}();

CRS.WGS84 = CRS.createProj4('+proj=longlat +datum=WGS84 +no_defs');
CRS.EPSG4326 = CRS.WGS84;
CRS.EPSG3857 = CRS.createProj4('+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs');
CRS.IDENTITY = CRS.createProj4('+proj=identity +no_defs');
CRS.CGCS2000 = CRS.createProj4('+proj=longlat +datum=CGCS2000');
CRS.EPSG4490 = CRS.CGCS2000;
CRS.BD09LL = CRS.createProj4('+proj=longlat +datum=BD09');
CRS.GCJ02 = CRS.createProj4('+proj=longlat +datum=GCJ02');

var TEMP_POINT0 = new Point(0, 0);
var TEMP_COORD0 = new Coordinate(0, 0);
var TEMP_COORD1 = new Coordinate(0, 0);
var TEMP_COORD2 = new Coordinate(0, 0);
var TEMP_COORD3 = new Coordinate(0, 0);
var TEMP_COORD4 = new Coordinate(0, 0);
var TEMP_COORD5 = new Coordinate(0, 0);
var TEMP_COORD6 = new Coordinate(0, 0);
var TEMP_COORD7 = new Coordinate(0, 0);
var MINMAX = [];
var TEMP_EXTENT;
var TEMP_COMBINE = [];

var Extent = function () {
  function Extent(p1, p2, p3, p4) {
    this._clazz = Coordinate;
    var l = arguments.length;
    var proj = l > 0 ? arguments[l - 1] : null;

    if (proj && proj.unproject) {
      this.projection = arguments[l - 1];
    }

    this._dirty = true;

    this._initialize(p1, p2, p3, p4);
  }

  var _proto = Extent.prototype;

  _proto._initialize = function _initialize(p1, p2, p3, p4) {
    this.xmin = null;
    this.xmax = null;
    this.ymin = null;
    this.ymax = null;

    if (isNil(p1)) {
      return;
    }

    var projection = this.projection;

    if (isNumber(p1) && isNumber(p2) && isNumber(p3) && isNumber(p4)) {
      if (projection) {
        this.set(p1, p2, p3, p4);
      } else {
        this.set(Math.min(p1, p3), Math.min(p2, p4), Math.max(p1, p3), Math.max(p2, p4));
      }

      return;
    } else if (Array.isArray(p1)) {
      if (projection) {
        this.set(p1[0], p1[1], p1[2], p1[3]);
      } else {
        this.set(Math.min(p1[0], p1[2]), Math.min(p1[1], p1[3]), Math.max(p1[0], p1[2]), Math.max(p1[1], p1[3]));
      }
    } else if (isNumber(p1.x) && isNumber(p2.x) && isNumber(p1.y) && isNumber(p2.y)) {
      if (projection) {
        this.set(p1.x, p1.y, p2.x, p2.y);
      } else {
        if (p1.x > p2.x) {
          this['xmin'] = p2.x;
          this['xmax'] = p1.x;
        } else {
          this['xmin'] = p1.x;
          this['xmax'] = p2.x;
        }

        if (p1.y > p2.y) {
          this['ymin'] = p2.y;
          this['ymax'] = p1.y;
        } else {
          this['ymin'] = p1.y;
          this['ymax'] = p2.y;
        }
      }
    } else if (isNumber(p1['xmin']) && isNumber(p1['xmax']) && isNumber(p1['ymin']) && isNumber(p1['ymax'])) {
      this.set(p1['xmin'], p1['ymin'], p1['xmax'], p1['ymax']);
    }
  };

  _proto._add = function _add(p) {
    this._dirty = true;

    if (!isNil(p.x)) {
      this['xmin'] += p.x;
      this['ymin'] += p.y;
      this['xmax'] += p.x;
      this['ymax'] += p.y;
    } else if (!isNil(p.xmin)) {
      this['xmin'] += p.xmin;
      this['ymin'] += p.ymin;
      this['xmax'] += p.xmax;
      this['ymax'] += p.ymax;
    } else if (!isNil(p[0])) {
      this['xmin'] += p[0];
      this['ymin'] += p[1];
      this['xmax'] += p[0];
      this['ymax'] += p[1];
    }

    return this;
  };

  _proto.add = function add() {
    var e = new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
    return e._add.apply(e, arguments);
  };

  _proto._scale = function _scale(s) {
    this._dirty = true;
    this['xmin'] *= s;
    this['ymin'] *= s;
    this['xmax'] *= s;
    this['ymax'] *= s;
    return this;
  };

  _proto._sub = function _sub(p) {
    this._dirty = true;

    if (!isNil(p.x)) {
      this['xmin'] -= p.x;
      this['ymin'] -= p.y;
      this['xmax'] -= p.x;
      this['ymax'] -= p.y;
    } else if (!isNil(p.xmin)) {
      this['xmin'] -= p.xmin;
      this['ymin'] -= p.ymin;
      this['xmax'] -= p.xmax;
      this['ymax'] -= p.ymax;
    } else if (!isNil(p[0])) {
      this['xmin'] -= p[0];
      this['ymin'] -= p[1];
      this['xmax'] -= p[0];
      this['ymax'] -= p[1];
    }

    return this;
  };

  _proto._substract = function _substract() {
    return this._sub.apply(this, arguments);
  };

  _proto.sub = function sub() {
    var e = new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
    return e._sub.apply(e, arguments);
  };

  _proto.substract = function substract() {
    return this.sub.apply(this, arguments);
  };

  _proto.round = function round() {
    return new this.constructor(Math.round(this['xmin']), Math.round(this['ymin']), Math.round(this['xmax']), Math.round(this['ymax']), this.projection);
  };

  _proto._round = function _round() {
    this._dirty = true;
    this['xmin'] = Math.round(this['xmin']);
    this['ymin'] = Math.round(this['ymin']);
    this['xmax'] = Math.round(this['xmax']);
    this['ymax'] = Math.round(this['ymax']);
    return this;
  };

  _proto.getMin = function getMin(out) {
    if (out) {
      out.set(this['xmin'], this['ymin']);
      return out;
    }

    return new this._clazz(this['xmin'], this['ymin']);
  };

  _proto.getMax = function getMax(out) {
    if (out) {
      out.set(this['xmax'], this['ymax']);
      return out;
    }

    return new this._clazz(this['xmax'], this['ymax']);
  };

  _proto.getCenter = function getCenter(out) {
    var x = (this['xmin'] + this['xmax']) / 2;
    var y = (this['ymin'] + this['ymax']) / 2;

    if (out) {
      out.set(x, y);
      return out;
    }

    return new this._clazz(x, y);
  };

  _proto.isValid = function isValid() {
    return !isNil(this['xmin']) && !isNil(this['ymin']) && !isNil(this['xmax']) && !isNil(this['ymax']);
  };

  _proto.equals = function equals(ext2) {
    return this['xmin'] === ext2['xmin'] && this['xmax'] === ext2['xmax'] && this['ymin'] === ext2['ymin'] && this['ymax'] === ext2['ymax'];
  };

  _proto.intersects = function intersects(ext2) {
    this._project(this);

    this._project(ext2);

    var rxmin = Math.max(this['pxmin'], ext2['pxmin']);
    var rymin = Math.max(this['pymin'], ext2['pymin']);
    var rxmax = Math.min(this['pxmax'], ext2['pxmax']);
    var rymax = Math.min(this['pymax'], ext2['pymax']);
    var intersects = !(rxmin > rxmax || rymin > rymax);
    return intersects;
  };

  _proto.within = function within(extent) {
    this._project(this);

    this._project(extent);

    return this.pxmin >= extent.pxmin && this.pxmax <= extent.pxmax && this.pymin >= extent.pymin && this.pymax <= extent.pymax;
  };

  _proto.contains = function contains(c) {
    if (!c) {
      return false;
    }

    this._project(this);

    var proj = this.projection;

    if (proj) {
      if (c.x !== undefined) {
        var coord = TEMP_COORD0;

        if (Array.isArray(c)) {
          coord.x = c[0];
          coord.y = c[1];
        } else {
          coord.x = c.x;
          coord.y = c.y;
        }

        c = proj.project(coord, coord);
      } else if (c.xmin !== undefined) {
        this._project(c);
      }
    }

    return (c.x || c.pxmin || 0) >= this.pxmin && (c.x || c.pxmax || 0) <= this.pxmax && (c.y || c.pymin || 0) >= this.pymin && (c.y || c.pymax || 0) <= this.pymax;
  };

  _proto.getWidth = function getWidth() {
    return Math.abs(this['xmax'] - this['xmin']);
  };

  _proto.getHeight = function getHeight() {
    return Math.abs(this['ymax'] - this['ymin']);
  };

  _proto.getSize = function getSize() {
    return new Size(this.getWidth(), this.getHeight());
  };

  _proto.set = function set(xmin, ymin, xmax, ymax) {
    this.xmin = xmin;
    this.ymin = ymin;
    this.xmax = xmax;
    this.ymax = ymax;
    this._dirty = true;
    return this;
  };

  _proto.__combine = function __combine(extent) {
    if (extent.x !== undefined) {
      TEMP_EXTENT.xmin = TEMP_EXTENT.xmax = extent.x;
      TEMP_EXTENT.ymin = TEMP_EXTENT.ymax = extent.y;
      extent = TEMP_EXTENT;
    }

    this._project(extent);

    this._project(this);

    var inited = isNumber(this.pxmin);
    var xmin, ymin, xmax, ymax;

    if (!inited) {
      xmin = extent['pxmin'];
      ymin = extent['pymin'];
      xmax = extent['pxmax'];
      ymax = extent['pymax'];
    } else {
      xmin = Math.min(this['pxmin'], extent['pxmin']);
      ymin = Math.min(this['pymin'], extent['pymin']);
      xmax = Math.max(this['pxmax'], extent['pxmax']);
      ymax = Math.max(this['pymax'], extent['pymax']);
    }

    var proj = this.projection;

    if (proj) {
      TEMP_COORD1.set(xmin, ymin);
      TEMP_COORD2.set(xmax, ymax);
      var min = proj.unproject(TEMP_COORD1, TEMP_COORD1),
          max = proj.unproject(TEMP_COORD2, TEMP_COORD2);
      xmin = min.x;
      ymin = min.y;
      xmax = max.x;
      ymax = max.y;
    }

    TEMP_COMBINE[0] = xmin;
    TEMP_COMBINE[1] = ymin;
    TEMP_COMBINE[2] = xmax;
    TEMP_COMBINE[3] = ymax;
    return TEMP_COMBINE;
  };

  _proto._combine = function _combine(extent) {
    if (!extent || extent.isValid && !extent.isValid()) {
      return this;
    }

    var ext = this.__combine(extent);

    this.set(ext[0], ext[1], ext[2], ext[3]);
    this._dirty = true;
    return this;
  };

  _proto.combine = function combine(extent) {
    if (!extent || extent.isValid && !extent.isValid()) {
      return this;
    }

    var ext = this.__combine(extent);

    return new this.constructor(ext[0], ext[1], ext[2], ext[3], this.projection);
  };

  _proto.intersection = function intersection(extent) {
    if (!this.intersects(extent)) {
      return null;
    }

    TEMP_COORD3.x = Math.max(this['pxmin'], extent['pxmin']);
    TEMP_COORD3.y = Math.max(this['pymin'], extent['pymin']);
    TEMP_COORD4.x = Math.min(this['pxmax'], extent['pxmax']);
    TEMP_COORD4.y = Math.min(this['pymax'], extent['pymax']);
    var min = TEMP_COORD3,
        max = TEMP_COORD4;
    var proj = this.projection;

    if (proj) {
      min = proj.unproject(min, min);
      max = proj.unproject(max, max);
    }

    return new this.constructor(min, max, proj);
  };

  _proto.expand = function expand(distance) {
    var w, h;

    if (!isNumber(distance)) {
      w = distance['width'] || distance['x'] || distance[0] || 0;
      h = distance['height'] || distance['y'] || distance[1] || 0;
    } else {
      w = h = distance;
    }

    return new this.constructor(this['xmin'] - w, this['ymin'] - h, this['xmax'] + w, this['ymax'] + h, this.projection);
  };

  _proto._expand = function _expand(distance) {
    var w, h;

    if (!isNumber(distance)) {
      w = distance['width'] || distance['x'] || distance[0] || 0;
      h = distance['height'] || distance['y'] || distance[1] || 0;
    } else {
      w = h = distance;
    }

    this['xmin'] -= w;
    this['ymin'] -= h;
    this['xmax'] += w;
    this['ymax'] += h;
    this._dirty = true;
    return this;
  };

  _proto.toJSON = function toJSON() {
    return {
      'xmin': this['xmin'],
      'ymin': this['ymin'],
      'xmax': this['xmax'],
      'ymax': this['ymax']
    };
  };

  _proto.toArray = function toArray() {
    var xmin = this['xmin'],
        ymin = this['ymin'],
        xmax = this['xmax'],
        ymax = this['ymax'];
    return [new this._clazz([xmin, ymax]), new this._clazz([xmax, ymax]), new this._clazz([xmax, ymin]), new this._clazz([xmin, ymin]), new this._clazz([xmin, ymax])];
  };

  _proto.toString = function toString() {
    return this.xmin + "," + this.ymin + "," + this.xmax + "," + this.ymax;
  };

  _proto.copy = function copy() {
    return new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
  };

  _proto.convertTo = function convertTo(fn, out) {
    if (!this.isValid()) {
      return null;
    }

    var e = out || new this.constructor();

    if (out) {
      e.set(null, null, null, null);
    }

    var coord;

    if (this._clazz === Coordinate) {
      coord = TEMP_COORD5;
    } else if (this._clazz === Point) {
      coord = TEMP_POINT0;
    }

    coord.x = this.xmin;
    coord.y = this.ymax;

    e._combine(fn(coord));

    coord.x = this.xmax;

    e._combine(fn(coord));

    coord.y = this.ymin;

    e._combine(fn(coord));

    coord.x = this.xmin;

    e._combine(fn(coord));

    return e;
  };

  _proto._project = function _project(ext) {
    if (!ext || !ext.isValid()) {
      if (ext) {
        ext.pxmin = ext.pxmax = ext.pymin = ext.pymax = null;
      }

      return;
    }

    var proj = this.projection;

    if (proj) {
      if (ext._dirty) {
        TEMP_COORD6.set(ext.xmax, ext.ymin);
        TEMP_COORD7.set(ext.xmin, ext.ymax);
        MINMAX[0] = TEMP_COORD6;
        MINMAX[1] = TEMP_COORD7;
        var minmax = proj.projectCoords(MINMAX);
        var min = minmax[0],
            max = minmax[1];
        ext.pxmin = Math.min(min.x, max.x);
        ext.pymin = Math.min(min.y, max.y);
        ext.pxmax = Math.max(min.x, max.x);
        ext.pymax = Math.max(min.y, max.y);
      }

      delete ext._dirty;
    } else {
      ext.pxmin = ext.xmin;
      ext.pxmax = ext.xmax;
      ext.pymin = ext.ymin;
      ext.pymax = ext.ymax;
    }
  };

  return Extent;
}();

TEMP_EXTENT = new Extent(0, 0, 0, 0);

var PointExtent = function (_Extent) {
  _inheritsLoose(PointExtent, _Extent);

  function PointExtent(p1, p2, p3, p4) {
    var _this;

    _this = _Extent.call(this, p1, p2, p3, p4) || this;
    _this._clazz = Point;
    return _this;
  }

  return PointExtent;
}(Extent);

var Transformation = function () {
  function Transformation(matrix) {
    this.matrix = matrix;
  }

  var _proto = Transformation.prototype;

  _proto.transform = function transform(coordinates, scale, out) {
    var x = this.matrix[0] * (coordinates.x - this.matrix[2]) / scale;
    var y = -this.matrix[1] * (coordinates.y - this.matrix[3]) / scale;

    if (out) {
      out.x = x;
      out.y = y;
      return out;
    }

    return new Point(x, y);
  };

  _proto.untransform = function untransform(point, scale, out) {
    var x = point.x * scale / this.matrix[0] + this.matrix[2];
    var y = point.y * scale / -this.matrix[1] + this.matrix[3];

    if (out) {
      out.x = x;
      out.y = y;
      return out;
    }

    return new Coordinate(x, y);
  };

  return Transformation;
}();

var Common = {
  project: function project() {},
  unproject: function unproject() {},
  projectCoords: function projectCoords(coordinates) {
    var _this = this;

    if (!coordinates) {
      return [];
    }

    if (!Array.isArray(coordinates)) {
      return this.project(coordinates);
    }

    if (coordinates.length === 0) {
      return [];
    }

    if (!this.isSphere()) {
      return forEachCoord(coordinates, this.project, this);
    }

    if (Array.isArray(coordinates[0])) {
      return coordinates.map(function (coords) {
        return _this.projectCoords(coords);
      });
    } else {
      var circum = this.getCircum();
      var extent = this.getSphereExtent(),
          sx = extent.sx,
          sy = extent.sy;
      var wrapX, wrapY;
      var pre = coordinates[0],
          current,
          dx,
          dy,
          p;
      var prj = [this.project(pre)];

      for (var i = 1, l = coordinates.length; i < l; i++) {
        current = coordinates[i];
        dx = current.x - pre.x;
        dy = current.y - pre.y;
        p = this.project(current);

        if (Math.abs(dx) > 180) {
          if (wrapX === undefined) {
            wrapX = current.x > pre.x;
          }

          if (wrapX) {
            p._add(-circum.x * sign(dx) * sx, 0);

            current._add(-360 * sign(dx), 0);
          }
        }

        if (Math.abs(dy) > 90) {
          if (wrapY === undefined) {
            wrapY = current.y < pre.y;
          }

          if (wrapY) {
            p._add(0, -circum.y * sign(dy) * sy);

            current._add(0, -180 * sign(dy));
          }
        }

        pre = current;
        prj.push(p);
      }

      return prj;
    }
  },
  unprojectCoords: function unprojectCoords(projCoords) {
    if (!projCoords) {
      return [];
    }

    if (!Array.isArray(projCoords)) {
      return this.unproject(projCoords);
    }

    return forEachCoord(projCoords, this.unproject, this);
  },
  isSphere: function isSphere() {
    return !!this.sphere;
  },
  isOutSphere: function isOutSphere(pcoord) {
    if (!this.isSphere()) {
      return false;
    }

    var extent = this.getSphereExtent();
    return !extent.contains(pcoord);
  },
  wrapCoord: function wrapCoord(pcoord) {
    if (!this.isSphere()) {
      return pcoord;
    }

    var extent = this.getSphereExtent();
    var wrapped = new Coordinate(pcoord);

    if (!extent.contains(wrapped)) {
      wrapped.x = wrap(pcoord.x, extent.xmin, extent.xmax);
      wrapped.y = wrap(pcoord.y, extent.ymin, extent.ymax);
    }

    return wrapped;
  },
  getCircum: function getCircum() {
    if (!this.circum && this.isSphere()) {
      var extent = this.getSphereExtent();
      this.circum = {
        x: extent.getWidth(),
        y: extent.getHeight()
      };
    }

    return this.circum;
  },
  getSphereExtent: function getSphereExtent() {
    if (!this.extent && this.isSphere()) {
      var max = this.project(new Coordinate(180, 90)),
          min = this.project(new Coordinate(-180, -90));
      this.extent = new Extent(min, max, this);
      this.extent.sx = max.x > min.x ? 1 : -1;
      this.extent.sy = max.y > min.y ? 1 : -1;
    }

    return this.extent;
  }
};

var Common$1 = {
  measureLength: function measureLength(c1, c2) {
    if (!Array.isArray(c1)) {
      return this.measureLenBetween(c1, c2);
    }

    var len = 0;

    for (var i = 0, l = c1.length; i < l - 1; i++) {
      len += this.measureLenBetween(c1[i], c1[i + 1]);
    }

    return len;
  }
};

var Identity = extend({
  'measure': 'IDENTITY',
  measureLenBetween: function measureLenBetween(c1, c2) {
    if (!c1 || !c2) {
      return 0;
    }

    try {
      return Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
    } catch (err) {
      return 0;
    }
  },
  measureArea: function measureArea(coordinates) {
    if (!Array.isArray(coordinates)) {
      return 0;
    }

    var area = 0;

    for (var i = 0, len = coordinates.length; i < len; i++) {
      var c1 = coordinates[i];
      var c2 = null;

      if (i === len - 1) {
        c2 = coordinates[0];
      } else {
        c2 = coordinates[i + 1];
      }

      area += c1.x * c2.y - c1.y * c2.x;
    }

    return Math.abs(area / 2);
  },
  locate: function locate(c, xDist, yDist) {
    c = new Coordinate(c.x, c.y);
    return this._locate(c, xDist, yDist);
  },
  _locate: function _locate(c, xDist, yDist) {
    if (!c) {
      return null;
    }

    if (!xDist) {
      xDist = 0;
    }

    if (!yDist) {
      yDist = 0;
    }

    if (!xDist && !yDist) {
      return c;
    }

    c.x = c.x + xDist;
    c.y = c.y + yDist;
    return c;
  },
  rotate: function rotate(c, pivot, angle) {
    c = new Coordinate(c.x, c.y);
    return this._rotate(c, pivot, angle);
  },
  _rotate: function () {
    var tmp = new Point(0, 0);
    return function (c, pivot, angle) {
      tmp.x = c.x - pivot.x;
      tmp.y = c.y - pivot.y;

      tmp._rotate(angle * Math.PI / 180);

      c.x = pivot.x + tmp.x;
      c.y = pivot.y + tmp.y;
      return c;
    };
  }()
}, Common$1);

var Sphere = function () {
  function Sphere(radius) {
    this.radius = radius;
  }

  var _proto = Sphere.prototype;

  _proto.measureLenBetween = function measureLenBetween(c1, c2) {
    if (!c1 || !c2) {
      return 0;
    }

    var b = toRadian(c1.y);
    var d = toRadian(c2.y),
        e = b - d,
        f = toRadian(c1.x) - toRadian(c2.x);
    b = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(e / 2), 2) + Math.cos(b) * Math.cos(d) * Math.pow(Math.sin(f / 2), 2)));
    b *= this.radius;
    return Math.round(b * 1E5) / 1E5;
  };

  _proto.measureArea = function measureArea(coordinates) {
    var a = toRadian(this.radius);
    var b = 0,
        c = coordinates,
        d = c.length;

    if (d < 3) {
      return 0;
    }

    var i;

    for (i = 0; i < d - 1; i++) {
      var e = c[i],
          f = c[i + 1];
      b += e.x * a * Math.cos(toRadian(e.y)) * f.y * a - f.x * a * Math.cos(toRadian(f.y)) * e.y * a;
    }

    d = c[i];
    c = c[0];
    b += d.x * a * Math.cos(toRadian(d.y)) * c.y * a - c.x * a * Math.cos(toRadian(c.y)) * d.y * a;
    return 0.5 * Math.abs(b);
  };

  _proto.locate = function locate(c, xDist, yDist) {
    c = new Coordinate(c.x, c.y);
    return this._locate(c, xDist, yDist);
  };

  _proto._locate = function _locate(c, xDist, yDist) {
    if (!c) {
      return null;
    }

    if (!xDist) {
      xDist = 0;
    }

    if (!yDist) {
      yDist = 0;
    }

    if (!xDist && !yDist) {
      return c;
    }

    var x, y;
    var ry = toRadian(c.y);

    if (yDist !== 0) {
      var dy = Math.abs(yDist);
      var sy = Math.sin(dy / (2 * this.radius)) * 2;
      ry = ry + sy * (yDist > 0 ? 1 : -1);
      y = wrap(ry * 180 / Math.PI, -90, 90);
    } else {
      y = c.y;
    }

    if (xDist !== 0) {
      var dx = Math.abs(xDist);
      var rx = toRadian(c.x);
      var sx = 2 * Math.sqrt(Math.pow(Math.sin(dx / (2 * this.radius)), 2) / Math.pow(Math.cos(ry), 2));
      rx = rx + sx * (xDist > 0 ? 1 : -1);
      x = wrap(rx * 180 / Math.PI, -180, 180);
    } else {
      x = c.x;
    }

    c.x = x;
    c.y = y;
    return c;
  };

  _proto.rotate = function rotate(c, pivot, angle) {
    c = new Coordinate(c);
    return this._rotate(c, pivot, angle);
  };

  _proto._rotate = function _rotate(c, pivot, angle) {
    var initialAngle = rhumbBearing(pivot, c);
    var finalAngle = initialAngle - angle;
    var distance = this.measureLenBetween(pivot, c);
    c.x = pivot.x;
    c.y = pivot.y;
    return calculateRhumbDestination(c, distance, finalAngle, this.radius);
  };

  return Sphere;
}();

function rhumbBearing(start, end, options) {
  if (options === void 0) {
    options = {};
  }

  var bear360;
  if (options.final) bear360 = calculateRhumbBearing(end, start);else bear360 = calculateRhumbBearing(start, end);
  var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
  return bear180;
}

function calculateRhumbBearing(from, to) {
  var phi1 = toRadian(from.y);
  var phi2 = toRadian(to.y);
  var deltaLambda = toRadian(to.x - from.x);
  if (deltaLambda > Math.PI) deltaLambda -= 2 * Math.PI;
  if (deltaLambda < -Math.PI) deltaLambda += 2 * Math.PI;
  var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var theta = Math.atan2(deltaLambda, deltaPsi);
  return (toDegree(theta) + 360) % 360;
}

function calculateRhumbDestination(origin, distance, bearing, radius) {
  var delta = distance / radius;
  var lambda1 = origin.x * Math.PI / 180;
  var phi1 = toRadian(origin.y);
  var theta = toRadian(bearing);
  var DeltaPhi = delta * Math.cos(theta);
  var phi2 = phi1 + DeltaPhi;
  if (Math.abs(phi2) > Math.PI / 2) phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  var DeltaLambda = delta * Math.sin(theta) / q;
  var lambda2 = lambda1 + DeltaLambda;
  origin.x = (lambda2 * 180 / Math.PI + 540) % 360 - 180;
  origin.y = phi2 * 180 / Math.PI;
  return origin;
}

var WGS84Sphere = extend({
  'measure': 'EPSG:4326',
  sphere: new Sphere(6378137),
  measureLenBetween: function measureLenBetween() {
    return this.sphere.measureLenBetween.apply(this.sphere, arguments);
  },
  measureArea: function measureArea() {
    return this.sphere.measureArea.apply(this.sphere, arguments);
  },
  _locate: function _locate() {
    return this.sphere._locate.apply(this.sphere, arguments);
  },
  locate: function locate() {
    return this.sphere.locate.apply(this.sphere, arguments);
  },
  _rotate: function _rotate() {
    return this.sphere._rotate.apply(this.sphere, arguments);
  },
  rotate: function rotate() {
    return this.sphere.rotate.apply(this.sphere, arguments);
  }
}, Common$1);
var BaiduSphere = extend({
  'measure': 'BAIDU',
  sphere: new Sphere(6370996.81),
  measureLenBetween: function measureLenBetween() {
    return this.sphere.measureLenBetween.apply(this.sphere, arguments);
  },
  measureArea: function measureArea() {
    return this.sphere.measureArea.apply(this.sphere, arguments);
  },
  _locate: function _locate() {
    return this.sphere._locate.apply(this.sphere, arguments);
  },
  locate: function locate() {
    return this.sphere.locate.apply(this.sphere, arguments);
  },
  _rotate: function _rotate() {
    return this.sphere._rotate.apply(this.sphere, arguments);
  },
  rotate: function rotate() {
    return this.sphere.rotate.apply(this.sphere, arguments);
  }
}, Common$1);

var DEFAULT = WGS84Sphere;
var measurers = {};

function registerMeasurer(m) {
  measurers[m.measure] = m;
}

registerMeasurer(Identity);
registerMeasurer(WGS84Sphere);
registerMeasurer(BaiduSphere);
var Measurer = {
  getInstance: function getInstance(name) {
    if (!name) {
      return DEFAULT;
    }

    for (var p in measurers) {
      if (hasOwn(measurers, p)) {
        var mName = measurers[p]['measure'];

        if (!mName) {
          continue;
        }

        if (name.toLowerCase() === mName.toLowerCase()) {
          return measurers[p];
        }
      }
    }

    return null;
  }
};

var index$2 = /*#__PURE__*/Object.freeze({
  Identity: Identity,
  DEFAULT: DEFAULT,
  Measurer: Measurer,
  WGS84Sphere: WGS84Sphere,
  BaiduSphere: BaiduSphere
});

var delta = 1E-7;
var EPSG3857 = extend({}, Common, {
  code: 'EPSG:3857',
  rad: Math.PI / 180,
  metersPerDegree: 6378137 * Math.PI / 180,
  maxLatitude: 85.0511287798,
  project: function project(lnglat, out) {
    var rad = this.rad,
        metersPerDegree = this.metersPerDegree,
        max = this.maxLatitude;
    var lng = lnglat.x,
        lat = Math.max(Math.min(max, lnglat.y), -max);
    var c;

    if (lat === 0) {
      c = 0;
    } else {
      c = Math.log(Math.tan((90 + lat) * rad / 2)) / rad;
    }

    var x = lng * metersPerDegree;
    var y = c * metersPerDegree;

    if (out) {
      out.x = x;
      out.y = y;
      return out;
    }

    return new Coordinate(x, y);
  },
  unproject: function unproject(pLnglat, out) {
    var rad = this.rad;
    var metersPerDegree = this.metersPerDegree;
    var x = pLnglat.x / metersPerDegree;
    var y = pLnglat.y;
    var c;

    if (y === 0) {
      c = 0;
    } else {
      c = y / metersPerDegree;
      c = (2 * Math.atan(Math.exp(c * rad)) - Math.PI / 2) / rad;
    }

    if (Math.abs(Math.abs(x) - 180) < delta) {
      x = sign(x) * 180;
    }

    if (Math.abs(Math.abs(c) - this.maxLatitude) < delta) {
      c = sign(c) * this.maxLatitude;
    }

    var rx = wrap(x, -180, 180);
    var ry = wrap(c, -this.maxLatitude, this.maxLatitude);

    if (out) {
      out.x = rx;
      out.y = ry;
      return out;
    }

    return new Coordinate(rx, ry);
  }
}, WGS84Sphere);

var PROJ4326 = extend({}, Common, {
  code: 'EPSG:4326',
  project: function project(p, out) {
    if (out) {
      out.x = p.x;
      out.y = p.y;
      return out;
    }

    return new Coordinate(p);
  },
  unproject: function unproject(p, out) {
    if (out) {
      out.x = p.x;
      out.y = p.y;
      return out;
    }

    return new Coordinate(p);
  }
}, WGS84Sphere);

var Projection_EPSG4490 = extend({}, PROJ4326, {
  code: 'EPSG:4490'
});

var Projection_Baidu = extend({}, Common, {
  code: 'BAIDU',
  project: function project(p, out) {
    return this.convertLL2MC(p, out);
  },
  unproject: function unproject(p, out) {
    return this.convertMC2LL(p, out);
  }
}, BaiduSphere, {
  EARTHRADIUS: 6370996.81,
  MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
  LLBAND: [75, 60, 45, 30, 15, 0],
  MC2LL: [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]],
  LL2MC: [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]],
  convertMC2LL: function convertMC2LL(cB, out) {
    var cE;

    for (var cD = 0, len = this.MCBAND.length; cD < len; cD++) {
      if (Math.abs(cB.y) >= this.MCBAND[cD]) {
        cE = this.MC2LL[cD];
        break;
      }
    }

    var T = this.convertor(cB, cE, out);
    return T;
  },
  convertLL2MC: function convertLL2MC(T, out) {
    var cD, cC, len;
    T.x = this.getLoop(T.x, -180, 180);
    T.y = this.getRange(T.y, -74, 74);
    var cB = new Coordinate(T.x, T.y);

    for (cC = 0, len = this.LLBAND.length; cC < len; cC++) {
      if (cB.y >= this.LLBAND[cC]) {
        cD = this.LL2MC[cC];
        break;
      }
    }

    if (!cD) {
      for (cC = this.LLBAND.length - 1; cC >= 0; cC--) {
        if (cB.y <= -this.LLBAND[cC]) {
          cD = this.LL2MC[cC];
          break;
        }
      }
    }

    var cE = this.convertor(T, cD, out);
    return cE;
  },
  convertor: function convertor(cC, cD, out) {
    if (!cC || !cD) {
      return null;
    }

    var T = cD[0] + cD[1] * Math.abs(cC.x);
    var cB = Math.abs(cC.y) / cD[9];
    var cE = cD[2] + cD[3] * cB + cD[4] * cB * cB + cD[5] * cB * cB * cB + cD[6] * cB * cB * cB * cB + cD[7] * cB * cB * cB * cB * cB + cD[8] * cB * cB * cB * cB * cB * cB;
    T *= cC.x < 0 ? -1 : 1;
    cE *= cC.y < 0 ? -1 : 1;

    if (out) {
      out.x = T;
      out.y = cE;
      return out;
    }

    return new Coordinate(T, cE);
  },
  toRadians: function toRadians(T) {
    return Math.PI * T / 180;
  },
  toDegrees: function toDegrees(T) {
    return 180 * T / Math.PI;
  },
  getRange: function getRange(cC, cB, T) {
    if (cB != null) {
      cC = Math.max(cC, cB);
    }

    if (T != null) {
      cC = Math.min(cC, T);
    }

    return cC;
  },
  getLoop: function getLoop(cC, cB, T) {
    if (cC === Infinity) {
      return T;
    } else if (cC === -Infinity) {
      return cB;
    }

    while (cC > T) {
      cC -= T - cB;
    }

    while (cC < cB) {
      cC += T - cB;
    }

    return cC;
  }
});

var Projection_IDENTITY = extend({}, Common, {
  code: 'IDENTITY',
  project: function project(p, out) {
    if (out) {
      out.x = p.x;
      out.y = p.y;
      return out;
    }

    return p.copy();
  },
  unproject: function unproject(p, out) {
    if (out) {
      out.x = p.x;
      out.y = p.y;
      return out;
    }

    return p.copy();
  }
}, Identity);

var DEFAULT$1 = EPSG3857;

var projections = /*#__PURE__*/Object.freeze({
  EPSG3857: EPSG3857,
  DEFAULT: DEFAULT$1,
  EPSG4326: PROJ4326,
  EPSG4490: Projection_EPSG4490,
  BAIDU: Projection_Baidu,
  IDENTITY: Projection_IDENTITY,
  Common: Common
});

var Renderable = (function (Base) {
  return function (_Base) {
    _inheritsLoose(_class, _Base);

    function _class() {
      return _Base.apply(this, arguments) || this;
    }

    _class.registerRenderer = function registerRenderer(name, clazz) {
      var proto = this.prototype;
      var parentProto = Object.getPrototypeOf(proto);

      if (!proto._rendererClasses || proto._rendererClasses === parentProto._rendererClasses) {
        proto._rendererClasses = proto._rendererClasses ? Object.create(proto._rendererClasses) : {};
      }

      proto._rendererClasses[name.toLowerCase()] = clazz;
      return this;
    };

    _class.getRendererClass = function getRendererClass(name) {
      var proto = this.prototype;

      if (!proto._rendererClasses) {
        return null;
      }

      return proto._rendererClasses[name.toLowerCase()];
    };

    return _class;
  }(Base);
});

var CanvasRenderer = function (_Class) {
  _inheritsLoose(CanvasRenderer, _Class);

  function CanvasRenderer(layer) {
    var _this;

    _this = _Class.call(this) || this;
    _this.layer = layer;
    _this._painted = false;
    _this._drawTime = 0;

    _this.setToRedraw();

    return _this;
  }

  var _proto = CanvasRenderer.prototype;

  _proto.render = function render(framestamp) {
    this.prepareRender();

    if (!this.getMap() || !this.layer.isVisible()) {
      return;
    }

    if (!this.resources) {
      this.resources = new ResourceCache();
    }

    this.checkAndDraw(this._tryToDraw, framestamp);
  };

  _proto.checkAndDraw = function checkAndDraw(drawFn) {
    var _this2 = this;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (this.checkResources) {
      var resources = this.checkResources();

      if (resources.length > 0) {
        this._loadingResource = true;
        this.loadResources(resources).then(function () {
          _this2._loadingResource = false;

          if (_this2.layer) {
            _this2.layer.fire('resourceload');

            _this2.setToRedraw();
          }
        });
      } else {
        drawFn.call.apply(drawFn, [this].concat(args));
      }
    } else {
      drawFn.call.apply(drawFn, [this].concat(args));
    }
  };

  _proto.testIfNeedRedraw = function testIfNeedRedraw() {
    var map = this.getMap();

    if (this._loadingResource) {
      return false;
    }

    if (this._toRedraw) {
      return true;
    }

    if (map.isInteracting() && !this.drawOnInteracting) {
      return false;
    }

    if (this.needToRedraw()) {
      return true;
    }

    return false;
  };

  _proto.needToRedraw = function needToRedraw() {
    var map = this.getMap();

    if (map.isInteracting() || map.getRenderer().isViewChanged()) {
      return !(!map.getPitch() && map.isMoving() && !map.isZooming() && !map.isRotating() && !this.layer.options['forceRenderOnMoving']);
    }

    return false;
  };

  _proto.onSkipDrawOnInteracting = function onSkipDrawOnInteracting() {};

  _proto.isLoadingResource = function isLoadingResource() {
    return this._loadingResource;
  };

  _proto.isRenderComplete = function isRenderComplete() {
    return !!this._renderComplete;
  };

  _proto.mustRenderOnInteracting = function mustRenderOnInteracting() {
    return !this._painted;
  };

  _proto.setToRedraw = function setToRedraw() {
    this._toRedraw = true;
    return this;
  };

  _proto.setCanvasUpdated = function setCanvasUpdated() {
    this._canvasUpdated = true;
    return this;
  };

  _proto.isCanvasUpdated = function isCanvasUpdated() {
    return !!this._canvasUpdated;
  };

  _proto.remove = function remove() {
    this.onRemove();
    delete this._loadingResource;
    delete this.southWest;
    delete this.canvas;
    delete this.context;
    delete this.canvasExtent2D;
    delete this._extent2D;
    delete this.resources;
    delete this.layer;
  };

  _proto.onRemove = function onRemove() {};

  _proto.onAdd = function onAdd() {};

  _proto.getMap = function getMap() {
    if (!this.layer) {
      return null;
    }

    return this.layer.getMap();
  };

  _proto.getCanvasImage = function getCanvasImage() {
    var map = this.getMap();
    this._canvasUpdated = false;

    if (this._renderZoom !== map.getZoom() || !this.canvas || !this._extent2D) {
      return null;
    }

    if (this.isBlank()) {
      return null;
    }

    if (this.layer.isEmpty && this.layer.isEmpty()) {
      return null;
    }

    var containerPoint = map._pointToContainerPoint(this.southWest)._add(0, -map.height);

    return {
      'image': this.canvas,
      'layer': this.layer,
      'point': containerPoint
    };
  };

  _proto.clear = function clear() {
    this.clearCanvas();
  };

  _proto.isBlank = function isBlank() {
    if (!this._painted) {
      return true;
    }

    return false;
  };

  _proto.show = function show() {
    this.setToRedraw();
  };

  _proto.hide = function hide() {
    this.clear();
    this.setToRedraw();
  };

  _proto.setZIndex = function setZIndex() {
    this.setToRedraw();
  };

  _proto.hitDetect = function hitDetect(point) {
    if (!this.context || this.layer.isEmpty && this.layer.isEmpty() || this.isBlank() || this._errorThrown) {
      return false;
    }

    var map = this.getMap();
    var r = map.getDevicePixelRatio();
    var size = map.getSize();

    if (point.x < 0 || point.x > size['width'] * r || point.y < 0 || point.y > size['height'] * r) {
      return false;
    }

    try {
      var imgData = this.context.getImageData(r * point.x, r * point.y, 1, 1).data;

      if (imgData[3] > 0) {
        return true;
      }
    } catch (error) {
      if (!this._errorThrown) {
        if (console) {
          console.warn('hit detect failed with tainted canvas, some geometries have external resources in another domain:\n', error);
        }

        this._errorThrown = true;
      }

      return false;
    }

    return false;
  };

  _proto.loadResources = function loadResources(resourceUrls) {
    if (!this.resources) {
      this.resources = new ResourceCache();
    }

    var resources = this.resources,
        promises = [];

    if (isArrayHasData(resourceUrls)) {
      var cache = {};

      for (var i = resourceUrls.length - 1; i >= 0; i--) {
        var url = resourceUrls[i];

        if (!url || !url.length || cache[url.join('-')]) {
          continue;
        }

        cache[url.join('-')] = 1;

        if (!resources.isResourceLoaded(url, true)) {
          promises.push(new Promise$1(this._promiseResource(url)));
        }
      }
    }

    return Promise$1.all(promises);
  };

  _proto.prepareRender = function prepareRender() {
    delete this._renderComplete;
    var map = this.getMap();
    this._renderZoom = map.getZoom();
    this.canvasExtent2D = this._extent2D = map._get2DExtent();
    this.southWest = map._containerPointToPoint(new Point(0, map.height));
  };

  _proto.createCanvas = function createCanvas() {
    if (this.canvas) {
      return;
    }

    var map = this.getMap();
    var size = map.getSize();
    var r = map.getDevicePixelRatio(),
        w = r * size.width,
        h = r * size.height;

    if (this.layer._canvas) {
      var canvas = this.layer._canvas;
      canvas.width = w;
      canvas.height = h;

      if (canvas.style) {
        canvas.style.width = size.width + 'px';
        canvas.style.height = size.height + 'px';
      }

      this.canvas = this.layer._canvas;
    } else {
      this.canvas = Canvas.createCanvas(w, h, map.CanvasClass);
    }

    this.onCanvasCreate();
  };

  _proto.onCanvasCreate = function onCanvasCreate() {};

  _proto.createContext = function createContext() {
    if (this.gl && this.gl.canvas === this.canvas || this.context) {
      return;
    }

    this.context = this.canvas.getContext('2d');

    if (!this.context) {
      return;
    }

    if (this.layer.options['globalCompositeOperation']) {
      this.context.globalCompositeOperation = this.layer.options['globalCompositeOperation'];
    }

    var dpr = this.getMap().getDevicePixelRatio();

    if (dpr !== 1) {
      this.context.scale(dpr, dpr);
    }
  };

  _proto.resetCanvasTransform = function resetCanvasTransform() {
    if (!this.context) {
      return;
    }

    var dpr = this.getMap().getDevicePixelRatio();
    this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
  };

  _proto.resizeCanvas = function resizeCanvas(canvasSize) {
    var canvas = this.canvas;

    if (!canvas) {
      return;
    }

    var size = canvasSize || this.getMap().getSize();
    var r = this.getMap().getDevicePixelRatio();

    if (canvas.width === r * size.width && canvas.height === r * size.height) {
      return;
    }

    canvas.height = r * size.height;
    canvas.width = r * size.width;

    if (r !== 1 && this.context) {
      this.context.scale(r, r);
    }

    if (this.layer._canvas && canvas.style) {
      canvas.style.width = size.width + 'px';
      canvas.style.height = size.height + 'px';
    }
  };

  _proto.clearCanvas = function clearCanvas() {
    if (!this.context) {
      return;
    }

    Canvas.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height);
  };

  _proto.prepareCanvas = function prepareCanvas() {
    if (!this.canvas) {
      this.createCanvas();
      this.createContext();
      this.layer.onCanvasCreate();
      this.layer.fire('canvascreate', {
        'context': this.context,
        'gl': this.gl
      });
    } else {
      this.resetCanvasTransform();
      this.clearCanvas();
      this.resizeCanvas();
    }

    delete this._maskExtent;
    var mask = this.layer.getMask();

    if (!mask) {
      this.layer.fire('renderstart', {
        'context': this.context,
        'gl': this.gl
      });
      return null;
    }

    var maskExtent2D = this._maskExtent = mask._getMaskPainter().get2DExtent();

    if (!maskExtent2D.intersects(this._extent2D)) {
      this.layer.fire('renderstart', {
        'context': this.context,
        'gl': this.gl
      });
      return maskExtent2D;
    }

    this.layer.fire('renderstart', {
      'context': this.context,
      'gl': this.gl
    });
    return maskExtent2D;
  };

  _proto.clipCanvas = function clipCanvas(context) {
    var mask = this.layer.getMask();

    if (!mask) {
      return false;
    }

    var old = this.southWest;
    var map = this.getMap();
    this.southWest = map._containerPointToPoint(new Point(0, map.height));
    context.save();
    var dpr = map.getDevicePixelRatio();

    if (dpr !== 1) {
      context.save();
      context.scale(dpr, dpr);
    }

    if (mask.getGeometries) {
      context.isMultiClip = true;
      var masks = mask.getGeometries() || [];
      context.beginPath();
      masks.forEach(function (_mask) {
        var painter = _mask._getMaskPainter();

        painter.paint(null, context);
      });
      context.stroke();
      delete context.isMultiClip;
    } else {
      var painter = mask._getMaskPainter();

      painter.paint(null, context);
    }

    if (dpr !== 1) {
      context.restore();
    }

    context.clip();
    this.southWest = old;
    return true;
  };

  _proto.getViewExtent = function getViewExtent() {
    return {
      'extent': this._extent2D,
      'maskExtent': this._maskExtent,
      'zoom': this._renderZoom,
      'southWest': this.southWest
    };
  };

  _proto.completeRender = function completeRender() {
    if (this.getMap()) {
      this._renderComplete = true;
      this.layer.fire('renderend', {
        'context': this.context,
        'gl': this.gl
      });
      this.setCanvasUpdated();
    }
  };

  _proto.getEvents = function getEvents() {
    return {
      '_zoomstart': this.onZoomStart,
      '_zooming': this.onZooming,
      '_zoomend': this.onZoomEnd,
      '_resize': this.onResize,
      '_movestart': this.onMoveStart,
      '_moving': this.onMoving,
      '_moveend': this.onMoveEnd,
      '_dragrotatestart': this.onDragRotateStart,
      '_dragrotating': this.onDragRotating,
      '_dragrotateend': this.onDragRotateEnd,
      '_spatialreferencechange': this.onSpatialReferenceChange
    };
  };

  _proto.onZoomStart = function onZoomStart() {};

  _proto.onZoomEnd = function onZoomEnd() {
    this.setToRedraw();
  };

  _proto.onZooming = function onZooming() {};

  _proto.onMoveStart = function onMoveStart() {};

  _proto.onMoving = function onMoving() {};

  _proto.onMoveEnd = function onMoveEnd() {
    this.setToRedraw();
  };

  _proto.onResize = function onResize() {
    delete this._extent2D;
    this.resizeCanvas();
    this.setToRedraw();
  };

  _proto.onDragRotateStart = function onDragRotateStart() {};

  _proto.onDragRotating = function onDragRotating() {};

  _proto.onDragRotateEnd = function onDragRotateEnd() {
    this.setToRedraw();
  };

  _proto.onSpatialReferenceChange = function onSpatialReferenceChange() {};

  _proto.getDrawTime = function getDrawTime() {
    return this._drawTime;
  };

  _proto._tryToDraw = function _tryToDraw(framestamp) {
    this._toRedraw = false;

    if (!this.canvas && this.layer.isEmpty && this.layer.isEmpty()) {
      this._renderComplete = true;
      return;
    }

    this._drawAndRecord(framestamp);
  };

  _proto._drawAndRecord = function _drawAndRecord(framestamp) {
    if (!this.getMap()) {
      return;
    }

    var painted = this._painted;
    this._painted = true;
    var t = now();
    this.draw(framestamp);
    t = now() - t;
    this._drawTime = painted ? t : t / 2;

    if (painted && this.layer && this.layer.options['logDrawTime']) {
      console.log(this.layer.getId(), 'frameTimeStamp:', framestamp, 'drawTime:', this._drawTime);
    }
  };

  _proto._promiseResource = function _promiseResource(url) {
    var me = this,
        resources = this.resources,
        crossOrigin = this.layer.options['crossOrigin'];
    return function (resolve) {
      if (resources.isResourceLoaded(url, true)) {
        resolve(url);
        return;
      }

      var img = new Image();

      if (!isNil(crossOrigin)) {
        img['crossOrigin'] = crossOrigin;
      }

      if (isSVG(url[0]) && !IS_NODE) {
        if (url[1]) {
          url[1] *= 2;
        }

        if (url[2]) {
          url[2] *= 2;
        }
      }

      img.onload = function () {
        me._cacheResource(url, img);

        resolve(url);
      };

      img.onabort = function (err) {
        if (console) {
          console.warn('image loading aborted: ' + url[0]);
        }

        if (err) {
          if (console) {
            console.warn(err);
          }
        }

        resolve(url);
      };

      img.onerror = function (err) {
        if (err && typeof console !== 'undefined') {
          console.warn(err);
        }

        resources.markErrorResource(url);
        resolve(url);
      };

      loadImage(img, url);
    };
  };

  _proto._cacheResource = function _cacheResource(url, img) {
    if (!this.layer || !this.resources) {
      return;
    }

    var w = url[1],
        h = url[2];

    if (this.layer.options['cacheSvgOnCanvas'] && isSVG(url[0]) === 1 && (Browser$1.edge || Browser$1.ie)) {
      if (isNil(w)) {
        w = img.width || this.layer.options['defaultIconSize'][0];
      }

      if (isNil(h)) {
        h = img.height || this.layer.options['defaultIconSize'][1];
      }

      var canvas = Canvas.createCanvas(w, h);
      Canvas.image(canvas.getContext('2d'), img, 0, 0, w, h);
      img = canvas;
    }

    this.resources.addResource(url, img);
  };

  return CanvasRenderer;
}(Class);
var ResourceCache = function () {
  function ResourceCache() {
    this.resources = {};
    this._errors = {};
  }

  var _proto2 = ResourceCache.prototype;

  _proto2.addResource = function addResource(url, img) {
    this.resources[url[0]] = {
      image: img,
      width: +url[1],
      height: +url[2]
    };
  };

  _proto2.isResourceLoaded = function isResourceLoaded(url, checkSVG) {
    if (!url) {
      return false;
    }

    var imgUrl = this._getImgUrl(url);

    if (this._errors[imgUrl]) {
      return true;
    }

    var img = this.resources[imgUrl];

    if (!img) {
      return false;
    }

    if (checkSVG && isSVG(url[0]) && (+url[1] > img.width || +url[2] > img.height)) {
      return false;
    }

    return true;
  };

  _proto2.getImage = function getImage(url) {
    var imgUrl = this._getImgUrl(url);

    if (!this.isResourceLoaded(url) || this._errors[imgUrl]) {
      return null;
    }

    return this.resources[imgUrl].image;
  };

  _proto2.markErrorResource = function markErrorResource(url) {
    this._errors[this._getImgUrl(url)] = 1;
  };

  _proto2.merge = function merge(res) {
    if (!res) {
      return this;
    }

    for (var p in res.resources) {
      var img = res.resources[p];
      this.addResource([p, img.width, img.height], img.image);
    }

    return this;
  };

  _proto2.forEach = function forEach(fn) {
    if (!this.resources) {
      return this;
    }

    for (var p in this.resources) {
      if (hasOwn(this.resources, p)) {
        fn(p, this.resources[p]);
      }
    }

    return this;
  };

  _proto2._getImgUrl = function _getImgUrl(url) {
    if (!Array.isArray(url)) {
      return url;
    }

    return url[0];
  };

  return ResourceCache;
}();

function clipLine(points, bounds, round, noCut) {
  var parts = [];
  var k = 0,
      segment;

  for (var j = 0, l = points.length; j < l - 1; j++) {
    segment = clipSegment(points[j], points[j + 1], bounds, j, round, noCut);

    if (!segment) {
      continue;
    }

    parts[k] = parts[k] || [];
    parts[k].push({
      'point': segment[0],
      'index': j
    });

    if (segment[1] !== points[j + 1] || j === l - 2) {
      parts[k].push({
        'point': segment[1],
        'index': j + 1
      });
      k++;
    }
  }

  return parts;
}

var _lastCode;

function clipSegment(a, b, bounds, useLastCode, round, noCut) {
  var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
      codeB = _getBitCode(b, bounds),
      codeOut,
      p,
      newCode;

  _lastCode = codeB;

  while (true) {
    if (!(codeA | codeB)) {
      return [a, b];
    }

    if (codeA & codeB) {
      return false;
    }

    if (noCut) {
      return [a, b];
    }

    codeOut = codeA || codeB;
    p = _getEdgeIntersection(a, b, codeOut, bounds, round);
    newCode = _getBitCode(p, bounds);

    if (codeOut === codeA) {
      a = p;
      codeA = newCode;
    } else {
      b = p;
      codeB = newCode;
    }
  }
}
function clipPolygon(points, bounds, round) {
  var edges = [1, 4, 2, 8];
  var clippedPoints, i, j, k, a, b, len, edge, p;

  for (i = 0, len = points.length; i < len; i++) {
    points[i]._code = _getBitCode(points[i], bounds);
  }

  for (k = 0; k < 4; k++) {
    edge = edges[k];
    clippedPoints = [];

    for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
      a = points[i];
      b = points[j];

      if (!(a._code & edge)) {
        if (b._code & edge) {
          p = _getEdgeIntersection(b, a, edge, bounds, round);
          p._code = _getBitCode(p, bounds);
          clippedPoints.push(p);
        }

        clippedPoints.push(a);
      } else if (!(b._code & edge)) {
        p = _getEdgeIntersection(b, a, edge, bounds, round);
        p._code = _getBitCode(p, bounds);
        clippedPoints.push(p);
      }
    }

    points = clippedPoints;
  }

  return points;
}

function _getEdgeIntersection(a, b, code, bounds, round) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      min = bounds.getMin(),
      max = bounds.getMax();
  var x, y;

  if (code & 8) {
    x = a.x + dx * (max.y - a.y) / dy;
    y = max.y;
  } else if (code & 4) {
    x = a.x + dx * (min.y - a.y) / dy;
    y = min.y;
  } else if (code & 2) {
    x = max.x;
    y = a.y + dy * (max.x - a.x) / dx;
  } else if (code & 1) {
    x = min.x;
    y = a.y + dy * (min.x - a.x) / dx;
  }

  var p = new Point(x, y);

  if (round) {
    p._round();
  }

  return p;
}

function _getBitCode(p, bounds) {
  var code = 0;

  if (p.x < bounds.getMin().x) {
    code |= 1;
  } else if (p.x > bounds.getMax().x) {
    code |= 2;
  }

  if (p.y < bounds.getMin().y) {
    code |= 4;
  } else if (p.y > bounds.getMax().y) {
    code |= 8;
  }

  return code;
}

function withInEllipse(point, center, southeast, tolerance) {
  point = new Point(point);
  var a = Math.abs(southeast.x - center.x),
      b = Math.abs(southeast.y - center.y),
      c = Math.sqrt(Math.abs(a * a - b * b)),
      xfocus = a >= b;
  var f1, f2, d;

  if (xfocus) {
    f1 = new Point(center.x - c, center.y);
    f2 = new Point(center.x + c, center.y);
    d = a * 2;
  } else {
    f1 = new Point(center.x, center.y - c);
    f2 = new Point(center.x, center.y + c);
    d = b * 2;
  }

  return point.distanceTo(f1) + point.distanceTo(f2) <= d + 2 * tolerance;
}

var Symbolizer = function () {
  function Symbolizer() {}

  var _proto = Symbolizer.prototype;

  _proto.getMap = function getMap() {
    return this.geometry.getMap();
  };

  _proto.getPainter = function getPainter() {
    return this.painter;
  };

  _proto.isDynamicSize = function isDynamicSize() {
    return false;
  };

  Symbolizer.testColor = function testColor(prop) {
    if (!prop || !isString(prop)) {
      return false;
    }

    if (COLOR_PROPERTIES.indexOf(prop) >= 0) {
      return true;
    }

    return false;
  };

  return Symbolizer;
}();

var CanvasSymbolizer = function (_Symbolizer) {
  _inheritsLoose(CanvasSymbolizer, _Symbolizer);

  function CanvasSymbolizer() {
    return _Symbolizer.apply(this, arguments) || this;
  }

  var _proto = CanvasSymbolizer.prototype;

  _proto._prepareContext = function _prepareContext(ctx) {
    if (isNumber(this.symbol['opacity'])) {
      if (ctx.globalAlpha !== this.symbol['opacity']) {
        ctx.globalAlpha = this.symbol['opacity'];
      }
    } else if (ctx.globalAlpha !== 1) {
      ctx.globalAlpha = 1;
    }
  };

  _proto.prepareCanvas = function prepareCanvas(ctx, style, resources) {
    Canvas.prepareCanvas(ctx, style, resources, this.getPainter().isHitTesting());
  };

  _proto.remove = function remove() {};

  _proto.setZIndex = function setZIndex() {};

  _proto.show = function show() {};

  _proto.hide = function hide() {};

  _proto._defineStyle = function _defineStyle(style) {
    return function () {
      var _this = this;

      var arr = [],
          prop = {};
      return loadFunctionTypes(style, function () {
        var map = _this.getMap();

        return set$1(arr, map.getZoom(), extend({}, _this.geometry.getProperties(), setProp(prop, map.getBearing(), map.getPitch(), map.getZoom())));
      });
    }.bind(this)();
  };

  return CanvasSymbolizer;
}(Symbolizer);

function set$1(arr, a0, a1) {
  arr[0] = a0;
  arr[1] = a1;
  return arr;
}

function setProp(prop, b, p, z) {
  prop['{bearing}'] = b;
  prop['{pitch}'] = p;
  prop['{zoom}'] = z;
  return prop;
}

var TEMP_POINT0$1 = new Point(0, 0);
var TEMP_POINT1 = new Point(0, 0);

var PointSymbolizer = function (_CanvasSymbolizer) {
  _inheritsLoose(PointSymbolizer, _CanvasSymbolizer);

  function PointSymbolizer(symbol, geometry, painter) {
    var _this;

    _this = _CanvasSymbolizer.call(this) || this;
    _this.symbol = symbol;
    _this.geometry = geometry;
    _this.painter = painter;
    return _this;
  }

  var _proto = PointSymbolizer.prototype;

  _proto.get2DExtent = function get2DExtent() {
    var map = this.getMap();
    var glZoom = map.getGLZoom();
    var extent = new PointExtent();

    var renderPoints = this._getRenderPoints()[0];

    for (var i = renderPoints.length - 1; i >= 0; i--) {
      if (renderPoints[i]) {
        extent._combine(map._pointToPoint(renderPoints[i], glZoom));
      }
    }

    return extent;
  };

  _proto.isDynamicSize = function isDynamicSize() {
    var symbol = this.symbol;
    return isFunctionDefinition(symbol['markerWidth']) || isFunctionDefinition(symbol['markerHeight']) || isFunctionDefinition(symbol['textSize']);
  };

  _proto._rotateExtent = function _rotateExtent(fixedExtent, angle) {
    return fixedExtent.convertTo(function (p) {
      return p._rotate(angle);
    });
  };

  _proto._getRenderPoints = function _getRenderPoints() {
    var painter = this.getPainter();
    var placement = painter.isSpriting() ? 'center' : this.getPlacement();
    return this.getPainter().getRenderPoints(placement);
  };

  _proto._getRenderContainerPoints = function _getRenderContainerPoints(ignoreAltitude) {
    var painter = this.getPainter(),
        points = this._getRenderPoints()[0];

    if (painter.isSpriting()) {
      return points;
    }

    var dxdy = this.getDxDy();

    var cpoints = this.painter._pointContainerPoints(points, dxdy.x, dxdy.y, ignoreAltitude, true, this.getPlacement());

    if (!cpoints || !Array.isArray(cpoints[0])) {
      return cpoints;
    }

    var flat = [];

    for (var i = 0, l = cpoints.length; i < l; i++) {
      for (var ii = 0, ll = cpoints[i].length; ii < ll; ii++) {
        flat.push(cpoints[i][ii]);
      }
    }

    return flat;
  };

  _proto._getRotationAt = function _getRotationAt(i) {
    var r = this.getRotation();

    if (!r) {
      r = 0;
    }

    var rotations = this._getRenderPoints()[1];

    if (!rotations || !rotations[i]) {
      return r;
    }

    var map = this.getMap();
    var p0 = rotations[i][0],
        p1 = rotations[i][1];

    if (map.isTransforming()) {
      var maxZoom = map.getGLZoom();
      p0 = map._pointToContainerPoint(rotations[i][0], maxZoom, 0, TEMP_POINT0$1);
      p1 = map._pointToContainerPoint(rotations[i][1], maxZoom, 0, TEMP_POINT1);
      return r + computeDegree(p0.x, p0.y, p1.x, p1.y);
    } else {
      return r + -computeDegree(p0.x, p0.y, p1.x, p1.y);
    }
  };

  _proto._rotate = function _rotate(ctx, origin, rotation) {
    if (rotation) {
      var dxdy = this.getDxDy();
      var p = origin.sub(dxdy);
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(rotation);
      return this.getDxDy();
    }

    return null;
  };

  return PointSymbolizer;
}(CanvasSymbolizer);

var VectorMarkerSymbolizer = function (_PointSymbolizer) {
  _inheritsLoose(VectorMarkerSymbolizer, _PointSymbolizer);

  VectorMarkerSymbolizer.test = function test(symbol) {
    if (!symbol) {
      return false;
    }

    if (isNil(symbol['markerFile']) && !isNil(symbol['markerType']) && symbol['markerType'] !== 'path') {
      return true;
    }

    return false;
  };

  function VectorMarkerSymbolizer(symbol, geometry, painter) {
    var _this;

    _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
    _this._dynamic = hasFunctionDefinition(symbol);
    _this.style = _this._defineStyle(_this.translate());
    _this.strokeAndFill = _this._defineStyle(VectorMarkerSymbolizer.translateLineAndFill(_this.style));
    var lineWidth = _this.strokeAndFill['lineWidth'];

    if (lineWidth % 2 === 0) {
      _this.padding = 2;
    } else {
      _this.padding = 1.5;
    }

    return _this;
  }

  var _proto = VectorMarkerSymbolizer.prototype;

  _proto.symbolize = function symbolize(ctx, resources) {
    var style = this.style;

    if (!this.painter.isHitTesting() && (style['markerWidth'] === 0 || style['markerHeight'] === 0 || style['polygonOpacity'] === 0 && style['lineOpacity'] === 0)) {
      return;
    }

    var cookedPoints = this._getRenderContainerPoints();

    if (!isArrayHasData(cookedPoints)) {
      return;
    }

    this._prepareContext(ctx);

    if (this.getPainter().isSpriting() || this.geometry.getLayer().getMask() === this.geometry || this._dynamic || this.geometry.getLayer().options['cacheVectorOnCanvas'] === false) {
      this._drawMarkers(ctx, cookedPoints, resources);
    } else {
      this._drawMarkersWithCache(ctx, cookedPoints, resources);
    }
  };

  _proto.getDxDy = function getDxDy() {
    var s = this.style;
    var dx = s['markerDx'],
        dy = s['markerDy'];
    return new Point(dx, dy);
  };

  _proto._drawMarkers = function _drawMarkers(ctx, cookedPoints, resources) {
    var strokeAndFill = this.strokeAndFill;
    var gradient = isGradient(strokeAndFill['lineColor']) || isGradient(strokeAndFill['polygonFill']);

    if (!gradient) {
      this.prepareCanvas(ctx, strokeAndFill, resources);
    }

    for (var i = cookedPoints.length - 1; i >= 0; i--) {
      var point = cookedPoints[i];

      var origin = this._rotate(ctx, point, this._getRotationAt(i));

      if (origin) {
        point = origin;
      }

      this._drawVectorMarker(ctx, point, resources);

      if (origin) {
        ctx.restore();
      }
    }
  };

  _proto._drawMarkersWithCache = function _drawMarkersWithCache(ctx, cookedPoints, resources) {
    var stamp = this._stampSymbol();

    var image = resources.getImage(stamp);

    if (!image) {
      image = this._createMarkerImage(ctx, resources);
      resources.addResource([stamp, image.width, image.height], image);
    }

    var anchor = this._getAnchor(image.width, image.height);

    for (var i = cookedPoints.length - 1; i >= 0; i--) {
      var point = cookedPoints[i];

      var origin = this._rotate(ctx, point, this._getRotationAt(i));

      if (origin) {
        point = origin;
      }

      Canvas.image(ctx, image, point.x + anchor.x, point.y + anchor.y);

      if (origin) {
        ctx.restore();
      }
    }
  };

  _proto._calMarkerSize = function _calMarkerSize() {
    if (!this._size) {
      var lineWidth = this.strokeAndFill['lineWidth'],
          shadow = 2 * (this.symbol['shadowBlur'] || 0),
          w = Math.round(this.style['markerWidth'] + lineWidth + 2 * shadow + this.padding * 2),
          h = Math.round(this.style['markerHeight'] + lineWidth + 2 * shadow + this.padding * 2);

      if (isFunctionDefinition(this.symbol['markerWidth']) || isFunctionDefinition(this.symbol['markerHeight'])) {
        return [w, h];
      }

      this._size = [w, h];
    }

    return this._size;
  };

  _proto._createMarkerImage = function _createMarkerImage(ctx, resources) {
    var canvasClass = ctx.canvas.constructor,
        size = this._calMarkerSize(),
        canvas = Canvas.createCanvas(size[0], size[1], canvasClass),
        point = this._getCacheImageAnchor(size[0], size[1]);

    var context = canvas.getContext('2d');
    var gradient = isGradient(this.strokeAndFill['lineColor']) || isGradient(this.strokeAndFill['polygonFill']);

    if (!gradient) {
      this.prepareCanvas(context, this.strokeAndFill, resources);
    }

    this._drawVectorMarker(context, point, resources);

    return canvas;
  };

  _proto._stampSymbol = function _stampSymbol() {
    if (!this._stamp) {
      this._stamp = [this.style['markerType'], isGradient(this.style['markerFill']) ? getGradientStamp(this.style['markerFill']) : this.style['markerFill'], this.style['markerFillOpacity'], this.style['markerFillPatternFile'], isGradient(this.style['markerLineColor']) ? getGradientStamp(this.style['markerLineColor']) : this.style['markerLineColor'], this.style['markerLineWidth'], this.style['markerLineOpacity'], this.style['markerLineDasharray'] ? this.style['markerLineDasharray'].join(',') : '', this.style['markerLinePatternFile'], this.style['markerWidth'], this.style['markerHeight'], this.style['markerHorizontalAlignment'], this.style['markerVerticalAlignment']].join('_');
    }

    return this._stamp;
  };

  _proto._getAnchor = function _getAnchor(w, h) {
    var shadow = 2 * (this.symbol['shadowBlur'] || 0),
        margin = shadow + this.padding;
    var p = getAlignPoint(new Size(w, h), this.style['markerHorizontalAlignment'], this.style['markerVerticalAlignment']);

    if (p.x !== -w / 2) {
      p.x -= sign(p.x + w / 2) * margin;
    }

    if (p.y !== -h / 2) {
      p.y -= sign(p.y + h / 2) * margin;
    }

    return p;
  };

  _proto._getCacheImageAnchor = function _getCacheImageAnchor(w, h) {
    var shadow = 2 * (this.symbol['shadowBlur'] || 0),
        margin = shadow + this.padding;
    var markerType = this.style['markerType'];

    if (markerType === 'bar' || markerType === 'pie' || markerType === 'pin') {
      return new Point(w / 2, h - margin);
    } else if (markerType === 'rectangle') {
      return new Point(margin, margin);
    } else {
      return new Point(w / 2, h / 2);
    }
  };

  _proto._getGraidentExtent = function _getGraidentExtent(points) {
    var e = new PointExtent(),
        dxdy = this.getDxDy(),
        m = this.getFixedExtent();

    if (Array.isArray(points)) {
      for (var i = points.length - 1; i >= 0; i--) {
        e._combine(points[i]);
      }
    } else {
      e._combine(points);
    }

    e['xmin'] += m['xmin'] - dxdy.x;
    e['ymin'] += m['ymin'] - dxdy.y;
    e['xmax'] += m['xmax'] - dxdy.x;
    e['ymax'] += m['ymax'] - dxdy.y;
    return e;
  };

  _proto._drawVectorMarker = function _drawVectorMarker(ctx, point, resources) {
    var style = this.style,
        strokeAndFill = this.strokeAndFill,
        markerType = style['markerType'].toLowerCase(),
        vectorArray = VectorMarkerSymbolizer._getVectorPoints(markerType, style['markerWidth'], style['markerHeight']),
        lineOpacity = strokeAndFill['lineOpacity'],
        fillOpacity = strokeAndFill['polygonOpacity'];

    var gradient = isGradient(strokeAndFill['lineColor']) || isGradient(strokeAndFill['polygonFill']);

    if (gradient) {
      var gradientExtent;

      if (isGradient(strokeAndFill['lineColor'])) {
        gradientExtent = this._getGraidentExtent(point);
        strokeAndFill['lineGradientExtent'] = gradientExtent.expand(strokeAndFill['lineWidth']);
      }

      if (isGradient(strokeAndFill['polygonFill'])) {
        if (!gradientExtent) {
          gradientExtent = this._getGraidentExtent(point);
        }

        strokeAndFill['polygonGradientExtent'] = gradientExtent;
      }

      this.prepareCanvas(ctx, strokeAndFill, resources);
    }

    var width = style['markerWidth'],
        height = style['markerHeight'],
        hLineWidth = style['markerLineWidth'] / 2;

    if (markerType === 'ellipse') {
      Canvas.ellipse(ctx, point, width / 2, height / 2, height / 2, lineOpacity, fillOpacity);
    } else if (markerType === 'cross' || markerType === 'x') {
      for (var j = vectorArray.length - 1; j >= 0; j--) {
        vectorArray[j]._add(point);
      }

      Canvas.path(ctx, vectorArray.slice(0, 2), lineOpacity);
      Canvas.path(ctx, vectorArray.slice(2, 4), lineOpacity);
    } else if (markerType === 'diamond' || markerType === 'bar' || markerType === 'square' || markerType === 'rectangle' || markerType === 'triangle') {
      if (markerType === 'bar') {
        point = point.add(0, -hLineWidth);
      } else if (markerType === 'rectangle') {
        point = point.add(hLineWidth, hLineWidth);
      }

      for (var _j = vectorArray.length - 1; _j >= 0; _j--) {
        vectorArray[_j]._add(point);
      }

      Canvas.polygon(ctx, vectorArray, lineOpacity, fillOpacity);
    } else if (markerType === 'pin') {
      point = point.add(0, -hLineWidth);

      for (var _j2 = vectorArray.length - 1; _j2 >= 0; _j2--) {
        vectorArray[_j2]._add(point);
      }

      var lineCap = ctx.lineCap;
      ctx.lineCap = 'round';
      Canvas.bezierCurveAndFill(ctx, vectorArray, lineOpacity, fillOpacity);
      ctx.lineCap = lineCap;
    } else if (markerType === 'pie') {
      point = point.add(0, hLineWidth);
      var angle = Math.atan(width / 2 / height) * 180 / Math.PI;
      var _lineCap = ctx.lineCap;
      ctx.lineCap = 'round';
      Canvas.sector(ctx, point, height, [90 - angle, 90 + angle], lineOpacity, fillOpacity);
      ctx.lineCap = _lineCap;
    } else {
      throw new Error('unsupported markerType: ' + markerType);
    }
  };

  _proto.getPlacement = function getPlacement() {
    return this.symbol['markerPlacement'];
  };

  _proto.getRotation = function getRotation() {
    var r = this.style['markerRotation'];

    if (!isNumber(r)) {
      return null;
    }

    return -r * Math.PI / 180;
  };

  _proto.getFixedExtent = function getFixedExtent() {
    var dxdy = this.getDxDy(),
        padding = this.padding * 2;

    var size = this._calMarkerSize().map(function (d) {
      return d - padding;
    });

    var alignPoint = this._getAnchor(size[0], size[1]);

    var result = new PointExtent(dxdy.add(0, 0), dxdy.add(size[0], size[1]));

    result._add(alignPoint);

    var rotation = this.getRotation();

    if (rotation) {
      result = this._rotateExtent(result, rotation);
    }

    return result;
  };

  _proto.translate = function translate() {
    var s = this.symbol;
    var result = {
      'markerType': getValueOrDefault(s['markerType'], 'ellipse'),
      'markerFill': getValueOrDefault(s['markerFill'], '#00f'),
      'markerFillOpacity': getValueOrDefault(s['markerFillOpacity'], 1),
      'markerFillPatternFile': getValueOrDefault(s['markerFillPatternFile'], null),
      'markerLineColor': getValueOrDefault(s['markerLineColor'], '#000'),
      'markerLineWidth': getValueOrDefault(s['markerLineWidth'], 1),
      'markerLineOpacity': getValueOrDefault(s['markerLineOpacity'], 1),
      'markerLineDasharray': getValueOrDefault(s['markerLineDasharray'], []),
      'markerLinePatternFile': getValueOrDefault(s['markerLinePatternFile'], null),
      'markerDx': getValueOrDefault(s['markerDx'], 0),
      'markerDy': getValueOrDefault(s['markerDy'], 0),
      'markerWidth': getValueOrDefault(s['markerWidth'], 10),
      'markerHeight': getValueOrDefault(s['markerHeight'], 10),
      'markerRotation': getValueOrDefault(s['markerRotation'], 0)
    };
    var markerType = result['markerType'];
    var ha, va;

    if (markerType === 'bar' || markerType === 'pie' || markerType === 'pin') {
      ha = 'middle';
      va = 'top';
    } else if (markerType === 'rectangle') {
      ha = 'right';
      va = 'bottom';
    } else {
      ha = 'middle';
      va = 'middle';
    }

    result['markerHorizontalAlignment'] = getValueOrDefault(s['markerHorizontalAlignment'], ha);
    result['markerVerticalAlignment'] = getValueOrDefault(s['markerVerticalAlignment'], va);

    if (isNumber(s['markerOpacity'])) {
      if (isNumber(s['markerFillOpacity'])) {
        result['markerFillOpacity'] *= s['markerOpacity'];
      }

      if (isNumber(s['markerLineOpacity'])) {
        result['markerLineOpacity'] *= s['markerOpacity'];
      }
    }

    return result;
  };

  VectorMarkerSymbolizer.translateLineAndFill = function translateLineAndFill(s) {
    var result = {
      'lineColor': s['markerLineColor'],
      'linePatternFile': s['markerLinePatternFile'],
      'lineWidth': s['markerLineWidth'],
      'lineOpacity': s['markerLineOpacity'],
      'lineDasharray': s['markerLineDasharray'],
      'lineCap': 'butt',
      'lineJoin': 'round',
      'polygonFill': s['markerFill'],
      'polygonPatternFile': s['markerFillPatternFile'],
      'polygonOpacity': s['markerFillOpacity']
    };

    if (result['lineWidth'] === 0) {
      result['lineOpacity'] = 0;
    }

    return result;
  };

  VectorMarkerSymbolizer._getVectorPoints = function _getVectorPoints(markerType, width, height) {
    var hh = height / 2,
        hw = width / 2;
    var left = 0,
        top = 0;
    var v0, v1, v2, v3;

    if (markerType === 'triangle') {
      v0 = new Point(left, top - hh);
      v1 = new Point(left - hw, top + hh);
      v2 = new Point(left + hw, top + hh);
      return [v0, v1, v2];
    } else if (markerType === 'cross') {
      v0 = new Point(left - hw, top);
      v1 = new Point(left + hw, top);
      v2 = new Point(left, top - hh);
      v3 = new Point(left, top + hh);
      return [v0, v1, v2, v3];
    } else if (markerType === 'diamond') {
      v0 = new Point(left - hw, top);
      v1 = new Point(left, top - hh);
      v2 = new Point(left + hw, top);
      v3 = new Point(left, top + hh);
      return [v0, v1, v2, v3];
    } else if (markerType === 'square') {
      v0 = new Point(left - hw, top + hh);
      v1 = new Point(left + hw, top + hh);
      v2 = new Point(left + hw, top - hh);
      v3 = new Point(left - hw, top - hh);
      return [v0, v1, v2, v3];
    } else if (markerType === 'rectangle') {
      v0 = new Point(left, top);
      v1 = v0.add(width, 0);
      v2 = v0.add(width, height);
      v3 = v0.add(0, height);
      return [v0, v1, v2, v3];
    } else if (markerType === 'x') {
      v0 = new Point(left - hw, top + hh);
      v1 = new Point(left + hw, top - hh);
      v2 = new Point(left + hw, top + hh);
      v3 = new Point(left - hw, top - hh);
      return [v0, v1, v2, v3];
    } else if (markerType === 'bar') {
      v0 = new Point(left - hw, top - height);
      v1 = new Point(left + hw, top - height);
      v2 = new Point(left + hw, top);
      v3 = new Point(left - hw, top);
      return [v0, v1, v2, v3];
    } else if (markerType === 'pin') {
      var extWidth = height * Math.atan(hw / hh);
      v0 = new Point(left, top);
      v1 = new Point(left - extWidth, top - height);
      v2 = new Point(left + extWidth, top - height);
      v3 = new Point(left, top);
      return [v0, v1, v2, v3];
    }

    return [];
  };

  return VectorMarkerSymbolizer;
}(PointSymbolizer);

var DebugSymbolizer = function (_PointSymbolizer) {
  _inheritsLoose(DebugSymbolizer, _PointSymbolizer);

  function DebugSymbolizer() {
    return _PointSymbolizer.apply(this, arguments) || this;
  }

  var _proto = DebugSymbolizer.prototype;

  _proto.getPlacement = function getPlacement() {
    return 'point';
  };

  _proto.getDxDy = function getDxDy() {
    return new Point(0, 0);
  };

  _proto.symbolize = function symbolize(ctx) {
    var geometry = this.geometry,
        layer = geometry.getLayer();

    if (!geometry.options['debug'] && layer && !layer.options['debug']) {
      return;
    }

    var map = this.getMap();

    if (!map || map.isZooming()) {
      return;
    }

    var color = layer.options['debugOutline'],
        op = 1;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    var outline = this.getPainter().getContainerExtent().toArray();
    Canvas.polygon(ctx, [outline], op, 0);

    var points = this._getRenderContainerPoints(),
        id = this.geometry.getId(),
        cross = VectorMarkerSymbolizer._getVectorPoints('cross', 10, 10);

    for (var i = 0; i < points.length; i++) {
      var p = points[i];

      if (!isNil(id)) {
        Canvas.fillText(ctx, id, p.add(8, -4), color);
      }

      var c = [];

      for (var ii = 0; ii < cross.length; ii++) {
        c.push(cross[ii].add(p));
      }

      Canvas.path(ctx, c.slice(0, 2), op);
      Canvas.path(ctx, c.slice(2, 4), op);
    }
  };

  return DebugSymbolizer;
}(PointSymbolizer);

var ImageMarkerSymbolizer = function (_PointSymbolizer) {
  _inheritsLoose(ImageMarkerSymbolizer, _PointSymbolizer);

  ImageMarkerSymbolizer.test = function test(symbol) {
    if (!symbol) {
      return false;
    }

    if (!isNil(symbol['markerFile'])) {
      return true;
    }

    return false;
  };

  function ImageMarkerSymbolizer(symbol, geometry, painter) {
    var _this;

    _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
    _this.style = _this._defineStyle(_this.translate());
    return _this;
  }

  var _proto = ImageMarkerSymbolizer.prototype;

  _proto.symbolize = function symbolize(ctx, resources) {
    var style = this.style;

    if (!this.painter.isHitTesting() && (style['markerWidth'] === 0 || style['markerHeight'] === 0 || style['markerOpacity'] === 0)) {
      return;
    }

    var cookedPoints = this._getRenderContainerPoints();

    if (!isArrayHasData(cookedPoints)) {
      return;
    }

    var img = this._getImage(resources);

    if (!img) {
      if (typeof console !== 'undefined') {
        console.warn('no img found for ' + (this.style['markerFile'] || this._url[0]));
      }

      return;
    }

    this._prepareContext(ctx);

    var width = style['markerWidth'];
    var height = style['markerHeight'];

    if (!isNumber(width) || !isNumber(height)) {
      width = img.width;
      height = img.height;
      style['markerWidth'] = width;
      style['markerHeight'] = height;
      var imgURL = [style['markerFile'], style['markerWidth'], style['markerHeight']];

      if (!resources.isResourceLoaded(imgURL)) {
        resources.addResource(imgURL, img);
      }

      var painter = this.getPainter();

      if (!painter.isSpriting()) {
        painter.removeCache();
      }
    }

    var alpha;

    if (this.symbol['markerType'] !== 'path' && isNumber(style['markerOpacity']) && style['markerOpacity'] < 1) {
      alpha = ctx.globalAlpha;
      ctx.globalAlpha *= style['markerOpacity'];
    }

    var alignPoint = getAlignPoint(new Size(width, height), style['markerHorizontalAlignment'], style['markerVerticalAlignment']);

    for (var i = 0, len = cookedPoints.length; i < len; i++) {
      var p = cookedPoints[i];

      var origin = this._rotate(ctx, p, this._getRotationAt(i));

      if (origin) {
        p = origin;
      }

      Canvas.image(ctx, img, p.x + alignPoint.x, p.y + alignPoint.y, width, height);

      if (origin) {
        ctx.restore();
      }
    }

    if (alpha !== undefined) {
      ctx.globalAlpha = alpha;
    }
  };

  _proto._getImage = function _getImage(resources) {
    var img = !resources ? null : resources.getImage([this.style['markerFile'], this.style['markerWidth'], this.style['markerHeight']]);
    return img;
  };

  _proto.getPlacement = function getPlacement() {
    return this.symbol['markerPlacement'];
  };

  _proto.getRotation = function getRotation() {
    var r = this.style['markerRotation'];

    if (!isNumber(r)) {
      return null;
    }

    return -r * Math.PI / 180;
  };

  _proto.getDxDy = function getDxDy() {
    var s = this.style;
    var dx = s['markerDx'],
        dy = s['markerDy'];
    return new Point(dx, dy);
  };

  _proto.getFixedExtent = function getFixedExtent(resources) {
    var style = this.style;
    var url = style['markerFile'],
        img = resources ? resources.getImage(url) : null;
    var width = style['markerWidth'] || (img ? img.width : 0),
        height = style['markerHeight'] || (img ? img.height : 0);
    var dxdy = this.getDxDy();
    var alignPoint = getAlignPoint(new Size(width, height), style['markerHorizontalAlignment'], style['markerVerticalAlignment']);
    var result = new PointExtent(dxdy.add(0, 0), dxdy.add(width, height));

    result._add(alignPoint);

    var rotation = this.getRotation();

    if (rotation) {
      result = this._rotateExtent(result, rotation);
    }

    return result;
  };

  _proto.translate = function translate() {
    var s = this.symbol;
    return {
      'markerFile': s['markerFile'],
      'markerOpacity': getValueOrDefault(s['markerOpacity'], 1),
      'markerWidth': getValueOrDefault(s['markerWidth'], null),
      'markerHeight': getValueOrDefault(s['markerHeight'], null),
      'markerRotation': getValueOrDefault(s['markerRotation'], 0),
      'markerDx': getValueOrDefault(s['markerDx'], 0),
      'markerDy': getValueOrDefault(s['markerDy'], 0),
      'markerHorizontalAlignment': getValueOrDefault(s['markerHorizontalAlignment'], 'middle'),
      'markerVerticalAlignment': getValueOrDefault(s['markerVerticalAlignment'], 'top')
    };
  };

  return ImageMarkerSymbolizer;
}(PointSymbolizer);

var TEMP_COORD0$1 = new Coordinate(0, 0);
var TEMP_COORD1$1 = new Coordinate(0, 0);

var StrokeAndFillSymbolizer = function (_CanvasSymbolizer) {
  _inheritsLoose(StrokeAndFillSymbolizer, _CanvasSymbolizer);

  StrokeAndFillSymbolizer.test = function test(symbol, geometry) {
    if (!symbol) {
      return false;
    }

    if (geometry && geometry.type === 'Point') {
      return false;
    }

    for (var p in symbol) {
      var f = p.slice(0, 4);

      if (f === 'line' || f === 'poly') {
        return true;
      }
    }

    return false;
  };

  function StrokeAndFillSymbolizer(symbol, geometry, painter) {
    var _this;

    _this = _CanvasSymbolizer.call(this) || this;
    _this.symbol = symbol;
    _this.geometry = geometry;
    _this.painter = painter;

    if (geometry.type === 'Point') {
      return _assertThisInitialized(_this);
    }

    _this.style = _this._defineStyle(_this.translate());
    return _this;
  }

  var _proto = StrokeAndFillSymbolizer.prototype;

  _proto.symbolize = function symbolize(ctx, resources) {
    var style = this.style;

    if (style['polygonOpacity'] === 0 && style['lineOpacity'] === 0 && !this.painter.isHitTesting()) {
      return;
    }

    var paintParams = this._getPaintParams();

    if (!paintParams) {
      return;
    }

    this._prepareContext(ctx);

    var isGradient$$1 = isGradient(style['lineColor']),
        isPath = this.geometry.getJSONType() === 'Polygon' || this.geometry.type === 'LineString';

    if (isGradient$$1 && (style['lineColor']['places'] || !isPath)) {
      style['lineGradientExtent'] = this.getPainter().getContainerExtent()._expand(style['lineWidth']);
    }

    if (isGradient(style['polygonFill'])) {
      style['polygonGradientExtent'] = this.getPainter().getContainerExtent();
    }

    var points = paintParams[0],
        isSplitted = this.geometry.getJSONType() === 'Polygon' && points.length > 0 && Array.isArray(points[0][0]) || this.geometry.type === 'LineString' && points.length > 0 && Array.isArray(points[0]);

    if (isSplitted) {
      for (var i = 0; i < points.length; i++) {
        this.prepareCanvas(ctx, style, resources);

        if (isGradient$$1 && isPath && !style['lineColor']['places']) {
          this._createGradient(ctx, points[i], style['lineColor']);
        }

        var params = [ctx, points[i]];

        if (paintParams.length > 1) {
          params.push.apply(params, paintParams.slice(1));
        }

        params.push(style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);

        this.geometry._paintOn.apply(this.geometry, params);
      }
    } else {
      this.prepareCanvas(ctx, style, resources);

      if (isGradient$$1 && isPath && !style['lineColor']['places']) {
        this._createGradient(ctx, points, style['lineColor']);
      }

      var _params = [ctx];

      _params.push.apply(_params, paintParams);

      _params.push(style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);

      this.geometry._paintOn.apply(this.geometry, _params);
    }

    if (ctx.setLineDash && Array.isArray(style['lineDasharray'])) {
      ctx.setLineDash([]);
    }
  };

  _proto.get2DExtent = function get2DExtent() {
    var map = this.getMap();

    var extent = this.geometry._getPrjExtent();

    if (!extent) {
      return null;
    }

    if (!this._extMin || !this._extMax) {
      this._extMin = new Coordinate(0, 0);
      this._extMax = new Coordinate(0, 0);
    }

    this._extMin.x = extent['xmin'];
    this._extMin.y = extent['ymin'];
    this._extMax.x = extent['xmax'];
    this._extMax.y = extent['ymax'];

    var min = map._prjToPoint(this._extMin, undefined, TEMP_COORD0$1),
        max = map._prjToPoint(this._extMax, undefined, TEMP_COORD1$1);

    if (!this._pxExtent) {
      this._pxExtent = new PointExtent(min, max);
    } else {
      this._pxExtent.set(Math.min(min.x, max.x), Math.min(min.y, max.y), Math.max(min.x, max.x), Math.max(min.y, max.y));
    }

    return this._pxExtent;
  };

  _proto.getFixedExtent = function getFixedExtent() {
    var t = this.style['lineWidth'] / 2;
    return new PointExtent(-t, -t, t, t);
  };

  _proto._getPaintParams = function _getPaintParams() {
    return this.getPainter().getPaintParams(this.style['lineDx'], this.style['lineDy']);
  };

  _proto.translate = function translate() {
    var s = this.symbol;
    var result = {
      'lineColor': getValueOrDefault(s['lineColor'], '#000'),
      'lineWidth': getValueOrDefault(s['lineWidth'], 2),
      'lineOpacity': getValueOrDefault(s['lineOpacity'], 1),
      'lineDasharray': getValueOrDefault(s['lineDasharray'], []),
      'lineCap': getValueOrDefault(s['lineCap'], 'butt'),
      'lineJoin': getValueOrDefault(s['lineJoin'], 'miter'),
      'linePatternFile': getValueOrDefault(s['linePatternFile'], null),
      'lineDx': getValueOrDefault(s['lineDx'], 0),
      'lineDy': getValueOrDefault(s['lineDy'], 0),
      'polygonFill': getValueOrDefault(s['polygonFill'], null),
      'polygonOpacity': getValueOrDefault(s['polygonOpacity'], 1),
      'polygonPatternFile': getValueOrDefault(s['polygonPatternFile'], null),
      'polygonPatternDx': getValueOrDefault(s['polygonPatternDx'], 0),
      'polygonPatternDy': getValueOrDefault(s['polygonPatternDy'], 0),
      'linePatternDx': getValueOrDefault(s['linePatternDx'], 0),
      'linePatternDy': getValueOrDefault(s['linePatternDy'], 0)
    };

    if (result['lineWidth'] === 0) {
      result['lineOpacity'] = 0;
    }

    if (this.geometry.type === 'LineString' && !result['polygonFill']) {
      result['polygonFill'] = result['lineColor'];
    }

    return result;
  };

  _proto._createGradient = function _createGradient(ctx, points, lineColor) {
    if (!Array.isArray(points) || !points.length) {
      return;
    }

    var len = points.length;
    var grad = ctx.createLinearGradient(points[0].x, points[0].y, points[len - 1].x, points[len - 1].y);
    lineColor['colorStops'].forEach(function (stop) {
      grad.addColorStop.apply(grad, stop);
    });
    ctx.strokeStyle = grad;
  };

  return StrokeAndFillSymbolizer;
}(CanvasSymbolizer);

var CACHE_KEY = '___text_symbol_cache';

var TextMarkerSymbolizer = function (_PointSymbolizer) {
  _inheritsLoose(TextMarkerSymbolizer, _PointSymbolizer);

  TextMarkerSymbolizer.test = function test(symbol) {
    if (!symbol) {
      return false;
    }

    if (!isNil(symbol['textName'])) {
      return true;
    }

    return false;
  };

  function TextMarkerSymbolizer(symbol, geometry, painter) {
    var _this;

    _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
    _this._dynamic = hasFunctionDefinition(symbol);
    _this.style = _this._defineStyle(_this.translate());

    if (_this.style['textWrapWidth'] === 0) {
      return _assertThisInitialized(_this);
    }

    _this.strokeAndFill = _this._defineStyle(_this.translateLineAndFill(_this.style));
    var textContent = replaceVariable(_this.style['textName'], _this.geometry.getProperties());

    if (!_this._dynamic) {
      _this._cacheKey = genCacheKey(textContent, _this.style);
    }

    _this._descText(textContent);

    return _this;
  }

  var _proto = TextMarkerSymbolizer.prototype;

  _proto.symbolize = function symbolize(ctx, resources) {
    if (!this.painter.isHitTesting() && (this.style['textSize'] === 0 || !this.style['textOpacity'] && (!this.style['textHaloRadius'] || !this.style['textHaloOpacity']) || this.style['textWrapWidth'] === 0)) {
      return;
    }

    var cookedPoints = this._getRenderContainerPoints();

    if (!isArrayHasData(cookedPoints)) {
      return;
    }

    var style = this.style,
        strokeAndFill = this.strokeAndFill;
    var textContent = replaceVariable(this.style['textName'], this.geometry.getProperties());

    this._descText(textContent);

    this._prepareContext(ctx);

    this.prepareCanvas(ctx, strokeAndFill, resources);
    Canvas.prepareCanvasFont(ctx, style);

    for (var i = 0, len = cookedPoints.length; i < len; i++) {
      var p = cookedPoints[i];

      var origin = this._rotate(ctx, p, this._getRotationAt(i));

      if (origin) {
        p = origin;
      }

      Canvas.text(ctx, textContent, p, style, this.textDesc);

      if (origin) {
        ctx.restore();
      }
    }
  };

  _proto.getPlacement = function getPlacement() {
    return this.symbol['textPlacement'];
  };

  _proto.getRotation = function getRotation() {
    var r = this.style['textRotation'];

    if (!isNumber(r)) {
      return null;
    }

    return -r * Math.PI / 180;
  };

  _proto.getDxDy = function getDxDy() {
    var s = this.style;
    return new Point(s['textDx'], s['textDy']);
  };

  _proto.getFixedExtent = function getFixedExtent() {
    var dxdy = this.getDxDy(),
        style = this.style;
    var size = this.textDesc['size'];
    var alignPoint = getAlignPoint(size, style['textHorizontalAlignment'], style['textVerticalAlignment']);
    var alignW = alignPoint.x,
        alignH = alignPoint.y;

    if (style['textHaloRadius']) {
      var r = style['textHaloRadius'];
      size = size.add(r * 2, r * 2);
    }

    var result = new PointExtent(dxdy.add(alignW, alignH), dxdy.add(alignW + size['width'], alignH + size['height']));
    var rotation = this.getRotation();

    if (rotation) {
      result = this._rotateExtent(result, rotation);
    }

    return result;
  };

  _proto.translate = function translate() {
    var s = this.symbol;
    var result = {
      'textName': s['textName'],
      'textFaceName': getValueOrDefault(s['textFaceName'], 'monospace'),
      'textWeight': getValueOrDefault(s['textWeight'], 'normal'),
      'textStyle': getValueOrDefault(s['textStyle'], 'normal'),
      'textSize': getValueOrDefault(s['textSize'], DEFAULT_TEXT_SIZE),
      'textFont': getValueOrDefault(s['textFont'], null),
      'textFill': getValueOrDefault(s['textFill'], '#000'),
      'textOpacity': getValueOrDefault(s['textOpacity'], 1),
      'textHaloFill': getValueOrDefault(s['textHaloFill'], '#ffffff'),
      'textHaloRadius': getValueOrDefault(s['textHaloRadius'], 0),
      'textHaloOpacity': getValueOrDefault(s['textHaloOpacity'], 1),
      'textWrapWidth': getValueOrDefault(s['textWrapWidth'], null),
      'textWrapCharacter': getValueOrDefault(s['textWrapCharacter'], '\n'),
      'textLineSpacing': getValueOrDefault(s['textLineSpacing'], 0),
      'textDx': getValueOrDefault(s['textDx'], 0),
      'textDy': getValueOrDefault(s['textDy'], 0),
      'textHorizontalAlignment': getValueOrDefault(s['textHorizontalAlignment'], 'middle'),
      'textVerticalAlignment': getValueOrDefault(s['textVerticalAlignment'], 'middle'),
      'textAlign': getValueOrDefault(s['textAlign'], 'center'),
      'textRotation': getValueOrDefault(s['textRotation'], 0),
      'textMaxWidth': getValueOrDefault(s['textMaxWidth'], 0),
      'textMaxHeight': getValueOrDefault(s['textMaxHeight'], 0)
    };

    if (result['textMaxWidth'] > 0 && (!result['textWrapWidth'] || result['textWrapWidth'] > result['textMaxWidth'])) {
      if (!result['textWrapWidth']) {
        result['textMaxHeight'] = 1;
      }

      result['textWrapWidth'] = result['textMaxWidth'];
    }

    return result;
  };

  _proto.translateLineAndFill = function translateLineAndFill(s) {
    return {
      'lineColor': s['textHaloRadius'] ? s['textHaloFill'] : s['textFill'],
      'lineWidth': s['textHaloRadius'],
      'lineOpacity': s['textOpacity'],
      'lineDasharray': null,
      'lineCap': 'butt',
      'lineJoin': 'round',
      'polygonFill': s['textFill'],
      'polygonOpacity': s['textOpacity']
    };
  };

  _proto._descText = function _descText(textContent) {
    if (this._dynamic) {
      this.textDesc = this._measureText(textContent);
      return;
    }

    this.textDesc = this._loadFromCache();

    if (!this.textDesc) {
      this.textDesc = this._measureText(textContent);

      this._storeToCache(this.textDesc);
    }
  };

  _proto._measureText = function _measureText(textContent) {
    var maxHeight = this.style['textMaxHeight'];
    var textDesc = splitTextToRow(textContent, this.style);

    if (maxHeight && maxHeight < textDesc.size.height) {
      textDesc.size.height = maxHeight;
    }

    return textDesc;
  };

  _proto._storeToCache = function _storeToCache(textDesc) {
    if (IS_NODE) {
      return;
    }

    if (!this.geometry[CACHE_KEY]) {
      this.geometry[CACHE_KEY] = {};
    }

    this.geometry[CACHE_KEY][this._cacheKey] = {
      'desc': textDesc,
      'active': true
    };
  };

  _proto._loadFromCache = function _loadFromCache() {
    if (!this.geometry[CACHE_KEY]) {
      return null;
    }

    var cache = this.geometry[CACHE_KEY][this._cacheKey];

    if (!cache) {
      return null;
    }

    cache.active = true;
    return cache.desc;
  };

  return TextMarkerSymbolizer;
}(PointSymbolizer);
TextMarkerSymbolizer.CACHE_KEY = CACHE_KEY;

function genCacheKey(textContent, style) {
  var key = [textContent];

  for (var p in style) {
    if (style.hasOwnProperty(p) && p.length > 4 && p.substring(0, 4) === 'text') {
      key.push(p + '=' + style[p]);
    }
  }

  return key.join('-');
}

var VectorPathMarkerSymbolizer = function (_ImageMarkerSymbolize) {
  _inheritsLoose(VectorPathMarkerSymbolizer, _ImageMarkerSymbolize);

  VectorPathMarkerSymbolizer.test = function test(symbol) {
    if (!symbol) {
      return false;
    }

    if (isNil(symbol['markerFile']) && symbol['markerType'] === 'path') {
      return true;
    }

    return false;
  };

  function VectorPathMarkerSymbolizer(symbol, geometry, painter) {
    var _this;

    if (isNil(symbol['markerWidth'])) {
      symbol['markerWidth'] = 80;
    }

    if (isNil(symbol['markerHeight'])) {
      symbol['markerHeight'] = 80;
    }

    _this = _ImageMarkerSymbolize.call(this, symbol, geometry, painter) || this;
    symbol = extend(symbol, _this.translate());

    var style = _this.style = _this._defineStyle(symbol);

    if (Browser$1.gecko) {
      _this._url = [getMarkerPathBase64(style, style['markerWidth'], style['markerHeight']), style['markerWidth'], style['markerHeight']];
    } else {
      _this._url = [getMarkerPathBase64(style), style['markerWidth'], style['markerHeight']];
    }

    return _this;
  }

  var _proto = VectorPathMarkerSymbolizer.prototype;

  _proto._prepareContext = function _prepareContext() {};

  _proto._getImage = function _getImage(resources) {
    var _this2 = this;

    if (resources && resources.isResourceLoaded(this._url)) {
      return resources.getImage(this._url);
    }

    var painter = this.painter;
    var image = new Image();

    image.onload = function () {
      var renderer = painter.getLayer() && painter.getLayer().getRenderer();

      if (renderer) {
        renderer.setToRedraw();
      }
    };

    image.onerror = function (err) {
      if (err && typeof console !== 'undefined') {
        console.warn(err);
      }

      resources.markErrorResource(_this2._url);
    };

    image.src = this._url[0];

    if (resources) {
      resources.addResource(this._url, image);
    }

    return image;
  };

  return VectorPathMarkerSymbolizer;
}(ImageMarkerSymbolizer);

var defaultSymbol = {
  lineWidth: 1,
  polygonFill: '#fff',
  polygonOpacity: 0.5
};

var DrawAltitudeSymbolizer = function (_PointSymbolizer) {
  _inheritsLoose(DrawAltitudeSymbolizer, _PointSymbolizer);

  DrawAltitudeSymbolizer.test = function test(symbol, geometry) {
    var layer = geometry.getLayer();

    if (!layer) {
      return false;
    }

    var type = geometry.getJSONType();
    return type === 'Marker' || type === 'LineString';
  };

  function DrawAltitudeSymbolizer(symbol, geometry, painter) {
    var _this;

    _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
    _this.style = geometry.getLayer().options['drawAltitude'];

    if (!_this.style || !isObject(_this.style)) {
      _this.style = {
        'lineWidth': 2
      };
    }

    if (!_this.style['lineWidth']) {
      _this.style['lineWidth'] = 0;
    }

    _this.dxdy = _this._defineStyle({
      'dx': symbol['textDx'] || symbol['markerDx'],
      'dy': symbol['textDy'] || symbol['markerDy']
    });
    return _this;
  }

  var _proto = DrawAltitudeSymbolizer.prototype;

  _proto.symbolize = function symbolize(ctx) {
    var layer = this.geometry.getLayer();

    if (!layer.options['drawAltitude']) {
      return;
    }

    var properties = this.geometry.getProperties();

    if (!properties || !properties[layer.options['altitudeProperty']]) {
      return;
    }

    var style = this._getStyle();

    this._prepareContext(ctx);

    if (this.geometry.type === 'LineString') {
      var paintParams = this._getPaintParams(style['lineDx'], style['lineDy']);

      if (!paintParams) {
        return;
      }

      var groundPoints = this.getPainter().getPaintParams(style['lineDx'], style['lineDy'], true)[0];

      this._drawLineAltitude(ctx, paintParams[0], groundPoints);
    } else {
      var point = this._getRenderContainerPoints(),
          groundPoint = this._getRenderContainerPoints(true);

      if (!point || point.length === 0) {
        return;
      }

      this._drawMarkerAltitude(ctx, point[0], groundPoint[0]);
    }
  };

  _proto.getDxDy = function getDxDy() {
    var s = this.dxdy;
    return new Point(s['dx'] || 0, s['dy'] || 0);
  };

  _proto.get2DExtent = function get2DExtent() {
    if (this.geometry.type === 'LineString') {
      return StrokeAndFillSymbolizer.prototype.get2DExtent.apply(this);
    } else {
      return _PointSymbolizer.prototype.get2DExtent.call(this);
    }
  };

  _proto.getPlacement = function getPlacement() {
    return 'point';
  };

  _proto._getPaintParams = function _getPaintParams(dx, dy) {
    return this.getPainter().getPaintParams(dx || 0, dy || 0);
  };

  _proto._drawMarkerAltitude = function _drawMarkerAltitude(ctx, point, groundPoint) {
    var style = this._getStyle();

    this.prepareCanvas(ctx, style);
    Canvas.path(ctx, [point, groundPoint], style['lineOpacity'], null, style['lineDasharray']);
  };

  _proto._drawLineAltitude = function _drawLineAltitude(ctx, points, groundPoints) {
    var style = this._getStyle();

    var isSplitted = points.length > 0 && Array.isArray(points[0]);

    if (isSplitted) {
      for (var i = 0; i < points.length; i++) {
        this._drawLine(ctx, points[i], groundPoints[i]);
      }
    } else {
      this._drawLine(ctx, points, groundPoints);
    }

    if (ctx.setLineDash && Array.isArray(style['lineDasharray'])) {
      ctx.setLineDash([]);
    }
  };

  _proto._drawLine = function _drawLine(ctx, points, groundPoints) {
    var style = this._getStyle();

    this.prepareCanvas(ctx, style);

    for (var i = 0, l = points.length - 1; i < l; i++) {
      Canvas.polygon(ctx, [points[i], points[i + 1], groundPoints[i + 1], groundPoints[i]], style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);
    }
  };

  _proto._getStyle = function _getStyle() {
    var style = this.geometry.getLayer().options['drawAltitude'];

    if (!isObject(style)) {
      style = defaultSymbol;
    }

    if (!style['lineWidth']) {
      style['lineWidth'] = 0;
      style['lineOpacity'] = 0;
    }

    return style;
  };

  return DrawAltitudeSymbolizer;
}(PointSymbolizer);



var index$3 = /*#__PURE__*/Object.freeze({
  Symbolizer: Symbolizer,
  CanvasSymbolizer: CanvasSymbolizer,
  DebugSymbolizer: DebugSymbolizer,
  ImageMarkerSymbolizer: ImageMarkerSymbolizer,
  PointSymbolizer: PointSymbolizer,
  StrokeAndFillSymbolizer: StrokeAndFillSymbolizer,
  TextMarkerSymbolizer: TextMarkerSymbolizer,
  VectorMarkerSymbolizer: VectorMarkerSymbolizer,
  VectorPathMarkerSymbolizer: VectorPathMarkerSymbolizer,
  DrawAltitudeSymbolizer: DrawAltitudeSymbolizer
});

var registerSymbolizers = [DrawAltitudeSymbolizer, StrokeAndFillSymbolizer, ImageMarkerSymbolizer, VectorPathMarkerSymbolizer, VectorMarkerSymbolizer, TextMarkerSymbolizer];
var testCanvas;
var TEMP_POINT0$2 = new Point(0, 0);
var TEMP_PAINT_EXTENT = new PointExtent();
var TEMP_EXTENT$1 = new PointExtent();
var TEMP_FIXED_EXTENT = new PointExtent();
var TEMP_CLIP_EXTENT0 = new PointExtent();
var TEMP_CLIP_EXTENT1 = new PointExtent();

var Painter = function (_Class) {
  _inheritsLoose(Painter, _Class);

  function Painter(geometry) {
    var _this;

    _this = _Class.call(this) || this;
    _this.geometry = geometry;
    _this.symbolizers = _this._createSymbolizers();
    _this._altAtGLZoom = _this._getGeometryAltitude();
    return _this;
  }

  var _proto = Painter.prototype;

  _proto.getMap = function getMap() {
    return this.geometry.getMap();
  };

  _proto.getLayer = function getLayer() {
    return this.geometry.getLayer();
  };

  _proto._createSymbolizers = function _createSymbolizers() {
    var geoSymbol = this.getSymbol(),
        symbolizers = [],
        regSymbolizers = registerSymbolizers;
    var symbols = geoSymbol;

    if (!Array.isArray(geoSymbol)) {
      symbols = [geoSymbol];
    }

    for (var ii = symbols.length - 1; ii >= 0; ii--) {
      var symbol = symbols[ii];

      for (var i = regSymbolizers.length - 1; i >= 0; i--) {
        if (regSymbolizers[i].test(symbol, this.geometry)) {
          var symbolizer = new regSymbolizers[i](symbol, this.geometry, this);
          symbolizers.push(symbolizer);

          if (symbolizer instanceof PointSymbolizer) {
            this._hasPoint = true;
          }
        }
      }
    }

    if (!symbolizers.length) {
      if (console) {
        var id = this.geometry.getId();
        console.warn('invalid symbol for geometry(' + (this.geometry ? this.geometry.getType() + (id ? ':' + id : '') : '') + ') to draw : ' + JSON.stringify(geoSymbol));
      }
    }

    this._debugSymbolizer = new DebugSymbolizer(geoSymbol, this.geometry, this);
    return symbolizers;
  };

  _proto.hasPoint = function hasPoint() {
    return !!this._hasPoint;
  };

  _proto.getRenderPoints = function getRenderPoints(placement) {
    if (!this._renderPoints) {
      this._renderPoints = {};
    }

    if (!placement) {
      placement = 'center';
    }

    if (!this._renderPoints[placement]) {
      this._renderPoints[placement] = this.geometry._getRenderPoints(placement);
    }

    return this._renderPoints[placement];
  };

  _proto.getPaintParams = function getPaintParams(dx, dy, ignoreAltitude) {
    var map = this.getMap(),
        geometry = this.geometry,
        res = map.getResolution(),
        pitched = map.getPitch() !== 0,
        rotated = map.getBearing() !== 0;
    var params = this._cachedParams;

    var paintAsPath = geometry._paintAsPath && geometry._paintAsPath();

    if (paintAsPath && this._unsimpledParams && res <= this._unsimpledParams._res) {
      params = this._unsimpledParams;
    } else if (!params || params._res !== map.getResolution() || this._pitched !== pitched && geometry._redrawWhenPitch() || this._rotated !== rotated && geometry._redrawWhenRotate()) {
      params = geometry._getPaintParams();

      if (!params) {
        return null;
      }

      params._res = res;

      if (!geometry._simplified && paintAsPath) {
        if (!this._unsimpledParams) {
          this._unsimpledParams = params;
        }

        if (res > this._unsimpledParams._res) {
          this._unsimpledParams._res = res;
        }
      }

      this._cachedParams = params;
    }

    if (!params) {
      return null;
    }

    this._pitched = pitched;
    this._rotated = rotated;
    var zoomScale = map.getGLScale(),
        tr = [],
        points = params[0];
    var mapExtent = map.getContainerExtent();

    var cPoints = this._pointContainerPoints(points, dx, dy, ignoreAltitude, this._hitPoint && !mapExtent.contains(this._hitPoint));

    if (!cPoints) {
      return null;
    }

    tr.push(cPoints);

    for (var i = 1, l = params.length; i < l; i++) {
      if (isNumber(params[i]) || params[i] instanceof Size) {
        if (isNumber(params[i])) {
          tr.push(params[i] / zoomScale);
        } else {
          tr.push(params[i].multi(1 / zoomScale));
        }
      } else {
        tr.push(params[i]);
      }
    }

    return tr;
  };

  _proto._pointContainerPoints = function _pointContainerPoints(points, dx, dy, ignoreAltitude, disableClip, pointPlacement) {
    if (this._aboveCamera()) {
      return null;
    }

    var map = this.getMap(),
        glZoom = map.getGLZoom(),
        containerOffset = this.containerOffset;
    var cPoints;

    function pointContainerPoint(point, alt) {
      var p = map._pointToContainerPoint(point, glZoom, alt)._sub(containerOffset);

      if (dx || dy) {
        p._add(dx || 0, dy || 0);
      }

      return p;
    }

    var altitude = this.getAltitude();

    if (Array.isArray(points)) {
      var geometry = this.geometry;
      var clipped;

      if (!disableClip && geometry.options['enableClip']) {
        clipped = this._clip(points, altitude);
      } else {
        clipped = {
          points: points,
          altitude: altitude
        };
      }

      var clipPoints = clipped.points;
      altitude = clipped.altitude;

      if (ignoreAltitude) {
        altitude = 0;
      }

      var alt = altitude;
      cPoints = [];

      for (var i = 0, l = clipPoints.length; i < l; i++) {
        var c = clipPoints[i];

        if (Array.isArray(c)) {
          var cring = [];

          for (var ii = 0, ll = c.length; ii < ll; ii++) {
            var cc = c[ii];

            if (Array.isArray(altitude)) {
              if (altitude[i]) {
                alt = altitude[i][ii];
              } else {
                alt = 0;
              }
            }

            cring.push(pointContainerPoint(cc, alt));
          }

          cPoints.push(cring);
        } else {
          if (Array.isArray(altitude)) {
            if (pointPlacement === 'vertex-last') {
              alt = altitude[altitude.length - 1 - i];
            } else if (pointPlacement === 'line') {
              alt = (altitude[i] + altitude[i + 1]) / 2;
            } else {
              alt = altitude[i];
            }
          }

          cPoints.push(pointContainerPoint(c, alt));
        }
      }
    } else if (points instanceof Point) {
      if (ignoreAltitude) {
        altitude = 0;
      }

      cPoints = map._pointToContainerPoint(points, glZoom, altitude)._sub(containerOffset);

      if (dx || dy) {
        cPoints._add(dx, dy);
      }
    }

    return cPoints;
  };

  _proto._clip = function _clip(points, altitude) {
    var map = this.getMap(),
        geometry = this.geometry;
    var lineWidth = this.getSymbol()['lineWidth'];

    if (!isNumber(lineWidth)) {
      lineWidth = 4;
    }

    var extent2D = map._get2DExtent(undefined, TEMP_CLIP_EXTENT0)._expand(lineWidth);

    if (map.getPitch() > 0 && altitude) {
      var c = map.cameraLookAt;
      var pos = map.cameraPosition;
      TEMP_POINT0$2.set(pos.x, pos.y);
      extent2D = extent2D._combine(TEMP_POINT0$2._add(sign(c[0] - pos[0]), sign(c[1] - pos[1])));
    }

    var e = this.get2DExtent(null, TEMP_CLIP_EXTENT1);
    var clipPoints = points;

    if (e.within(extent2D)) {
      return {
        points: clipPoints,
        altitude: altitude
      };
    }

    var glExtent2D = map._get2DExtent(map.getGLZoom(), TEMP_CLIP_EXTENT0)._expand(lineWidth * map._glScale);

    var smoothness = geometry.options['smoothness'];

    if (geometry.getShell && this.geometry.getHoles && !smoothness) {
      if (!Array.isArray(points[0])) {
        clipPoints = clipPolygon(points, glExtent2D);
      } else {
        clipPoints = [];

        for (var i = 0; i < points.length; i++) {
          var part = clipPolygon(points[i], glExtent2D);

          if (part.length) {
            clipPoints.push(part);
          }
        }
      }
    } else if (geometry.getJSONType() === 'LineString' && !smoothness) {
      if (!Array.isArray(points[0])) {
        clipPoints = clipLine(points, glExtent2D, false, !!smoothness);
      } else {
        clipPoints = [];

        for (var _i = 0; _i < points.length; _i++) {
          pushIn(clipPoints, clipLine(points[_i], glExtent2D, false, !!smoothness));
        }
      }

      return this._interpolateSegAlt(clipPoints, points, altitude);
    }

    return {
      points: clipPoints,
      altitude: altitude
    };
  };

  _proto._interpolateSegAlt = function _interpolateSegAlt(clipSegs, orig, altitude) {
    if (!Array.isArray(altitude)) {
      var fn = function fn(cc) {
        return cc.point;
      };

      return {
        points: clipSegs.map(function (c) {
          if (Array.isArray(c)) {
            return c.map(fn);
          }

          return c.point;
        }),
        altitude: altitude
      };
    }

    var segsWithAlt = interpolateAlt(clipSegs, orig, altitude);
    altitude = [];
    var points = segsWithAlt.map(function (p) {
      if (Array.isArray(p)) {
        var alt = [];
        var cp = p.map(function (pp) {
          alt.push(pp.altitude);
          return pp.point;
        });
        altitude.push(alt);
        return cp;
      }

      altitude.push(p.altitude);
      return p.point;
    });
    return {
      points: points,
      altitude: altitude
    };
  };

  _proto.getSymbol = function getSymbol() {
    return this.geometry._getInternalSymbol();
  };

  _proto.paint = function paint(extent, context, offset) {
    if (!this.symbolizers) {
      return;
    }

    var renderer = this.getLayer()._getRenderer();

    if (!renderer || !renderer.context && !context) {
      return;
    }

    if (extent && !extent.intersects(this.get2DExtent(renderer.resources, TEMP_PAINT_EXTENT))) {
      return;
    }

    var map = this.getMap();
    var minAltitude = this.getMinAltitude();
    var frustumAlt = map.getFrustumAltitude();

    if (minAltitude && frustumAlt && frustumAlt < minAltitude) {
      return;
    }

    this.containerOffset = offset || map._pointToContainerPoint(renderer.southWest)._add(0, -map.height);

    this._beforePaint();

    var ctx = context || renderer.context;
    var contexts = [ctx, renderer.resources];

    for (var i = this.symbolizers.length - 1; i >= 0; i--) {
      this._prepareShadow(ctx, this.symbolizers[i].symbol);

      this.symbolizers[i].symbolize.apply(this.symbolizers[i], contexts);
    }

    this._afterPaint();

    this._painted = true;

    this._debugSymbolizer.symbolize.apply(this._debugSymbolizer, contexts);
  };

  _proto.getSprite = function getSprite(resources, canvasClass) {
    if (this.geometry.type !== 'Point') {
      return null;
    }

    this._spriting = true;

    if (!this._sprite && this.symbolizers.length > 0) {
      var extent = new PointExtent();
      this.symbolizers.forEach(function (s) {
        var markerExtent = s.getFixedExtent(resources);

        extent._combine(markerExtent);
      });
      var origin = extent.getMin().multi(-1);
      var clazz = canvasClass || (this.getMap() ? this.getMap().CanvasClass : null);
      var canvas = Canvas.createCanvas(extent.getWidth(), extent.getHeight(), clazz);
      var bak;

      if (this._renderPoints) {
        bak = this._renderPoints;
      }

      var ctx = canvas.getContext('2d');
      var contexts = [ctx, resources];

      for (var i = this.symbolizers.length - 1; i >= 0; i--) {
        var dxdy = this.symbolizers[i].getDxDy();
        this._renderPoints = {
          'center': [[origin.add(dxdy)]]
        };

        this._prepareShadow(ctx, this.symbolizers[i].symbol);

        this.symbolizers[i].symbolize.apply(this.symbolizers[i], contexts);
      }

      if (bak) {
        this._renderPoints = bak;
      }

      this._sprite = {
        'canvas': canvas,
        'offset': extent.getCenter()
      };
    }

    this._spriting = false;
    return this._sprite;
  };

  _proto.isSpriting = function isSpriting() {
    return !!this._spriting;
  };

  _proto.hitTest = function hitTest(cp, tolerance) {
    if (!tolerance || tolerance < 0.5) {
      tolerance = 0.5;
    }

    if (!testCanvas) {
      testCanvas = Canvas.createCanvas(1, 1);
    }

    Canvas.setHitTesting(true);
    testCanvas.width = testCanvas.height = 2 * tolerance;
    var ctx = testCanvas.getContext('2d');
    this._hitPoint = cp.sub(tolerance, tolerance);

    try {
      this.paint(null, ctx, this._hitPoint);
    } catch (e) {
      throw e;
    } finally {
      Canvas.setHitTesting(false);
    }

    delete this._hitPoint;
    var imgData = ctx.getImageData(0, 0, testCanvas.width, testCanvas.height).data;

    for (var i = 3, l = imgData.length; i < l; i += 4) {
      if (imgData[i] > 0) {
        return true;
      }
    }

    return false;
  };

  _proto.isHitTesting = function isHitTesting() {
    return !!this._hitPoint;
  };

  _proto._prepareShadow = function _prepareShadow(ctx, symbol) {
    if (symbol['shadowBlur']) {
      ctx.shadowBlur = this.isHitTesting() ? 0 : symbol['shadowBlur'];
      ctx.shadowColor = symbol['shadowColor'] || '#000';
      ctx.shadowOffsetX = symbol['shadowOffsetX'] || 0;
      ctx.shadowOffsetY = symbol['shadowOffsetY'] || 0;
    } else if (ctx.shadowBlur) {
      ctx.shadowBlur = null;
      ctx.shadowColor = null;
      ctx.shadowOffsetX = null;
      ctx.shadowOffsetY = null;
    }
  };

  _proto._eachSymbolizer = function _eachSymbolizer(fn, context) {
    if (!this.symbolizers) {
      return;
    }

    if (!context) {
      context = this;
    }

    for (var i = this.symbolizers.length - 1; i >= 0; i--) {
      fn.apply(context, [this.symbolizers[i]]);
    }
  };

  _proto.get2DExtent = function get2DExtent(resources, out) {
    this._verifyProjection();

    var map = this.getMap();
    resources = resources || this.getLayer()._getRenderer().resources;
    var zoom = map.getZoom();

    var isDynamicSize = this._isDynamicSize();

    if (!this._extent2D || this._extent2D._zoom !== zoom || !this._fixedExtent) {
      if (this._extent2D && this._extent2D._zoom !== zoom) {
        delete this._extent2D;
      }

      if (this.symbolizers) {
        if (!this._extent2D) {
          this._extent2D = this._computeExtent2D(new PointExtent());
          this._extent2D._zoom = zoom;
        }

        if (!this._fixedExtent) {
          this._fixedExtent = this._computeFixedExtent(resources, new PointExtent());
        }
      }
    }

    if (!this._extent2D) {
      if (isDynamicSize) {
        delete this._fixedExtent;
      }

      return null;
    }

    var _this$_fixedExtent = this._fixedExtent,
        xmin = _this$_fixedExtent.xmin,
        ymin = _this$_fixedExtent.ymin,
        xmax = _this$_fixedExtent.xmax,
        ymax = _this$_fixedExtent.ymax;

    if (isDynamicSize) {
      delete this._fixedExtent;
    }

    TEMP_FIXED_EXTENT.set(xmin, -ymax, xmax, -ymin);

    if (out) {
      out.set(this._extent2D['xmin'], this._extent2D['ymin'], this._extent2D['xmax'], this._extent2D['ymax']);

      out._add(TEMP_FIXED_EXTENT);

      return out;
    }

    return this._extent2D.add(TEMP_FIXED_EXTENT);
  };

  _proto._computeExtent2D = function _computeExtent2D(extent) {
    for (var i = this.symbolizers.length - 1; i >= 0; i--) {
      var symbolizer = this.symbolizers[i];

      extent._combine(symbolizer.get2DExtent());
    }

    return extent;
  };

  _proto._computeFixedExtent = function _computeFixedExtent(resources, extent) {
    for (var i = this.symbolizers.length - 1; i >= 0; i--) {
      var symbolizer = this.symbolizers[i];

      if (symbolizer.getFixedExtent) {
        extent._combine(symbolizer.getFixedExtent(resources));
      }
    }

    return extent;
  };

  _proto._isDynamicSize = function _isDynamicSize() {
    for (var i = this.symbolizers.length - 1; i >= 0; i--) {
      var symbolizer = this.symbolizers[i];

      if (symbolizer.isDynamicSize()) {
        return true;
      }
    }

    return false;
  };

  _proto.getContainerExtent = function getContainerExtent(out) {
    if (this._aboveCamera()) {
      return null;
    }

    this._verifyProjection();

    var map = this.getMap();
    var zoom = map.getZoom();
    var glScale = map._glScale;

    if (!this._extent2D || this._extent2D._zoom !== zoom) {
      this.get2DExtent(null, TEMP_EXTENT$1);
    }

    var altitude = this.getMinAltitude();

    var extent = this._extent2D.convertTo(function (c) {
      return map._pointToContainerPoint(c, zoom, altitude / glScale, TEMP_POINT0$2);
    }, out);

    var maxAltitude = this.getMaxAltitude();

    if (maxAltitude !== altitude) {
      var extent2 = this._extent2D.convertTo(function (c) {
        return map._pointToContainerPoint(c, zoom, maxAltitude / glScale, TEMP_POINT0$2);
      }, TEMP_EXTENT$1);

      extent._combine(extent2);
    }

    var layer = this.geometry.getLayer();

    if (this.geometry.type === 'LineString' && maxAltitude && layer.options['drawAltitude']) {
      var groundExtent = this._extent2D.convertTo(function (c) {
        return map._pointToContainerPoint(c, zoom, 0, TEMP_POINT0$2);
      }, TEMP_EXTENT$1);

      extent._combine(groundExtent);
    }

    if (extent) {
      extent._add(this._fixedExtent || this._computeFixedExtent(null, new PointExtent()));
    }

    var smoothness = this.geometry.options['smoothness'];

    if (smoothness) {
      extent._expand(extent.getWidth() * 0.15);
    }

    return extent;
  };

  _proto._aboveCamera = function _aboveCamera() {
    var altitude = this.getMinAltitude();
    var map = this.getMap();
    var frustumAlt = map.getFrustumAltitude();
    return altitude && frustumAlt && frustumAlt < altitude;
  };

  _proto.getFixedExtent = function getFixedExtent() {
    var map = this.getMap();
    var zoom = map.getZoom();

    if (this._isDynamicSize()) {
      return this._computeFixedExtent(null, new PointExtent());
    }

    if (!this._extent2D || this._extent2D._zoom !== zoom) {
      this.get2DExtent(null, TEMP_FIXED_EXTENT);
    }

    return this._fixedExtent;
  };

  _proto.setZIndex = function setZIndex(change) {
    this._eachSymbolizer(function (symbolizer) {
      symbolizer.setZIndex(change);
    });
  };

  _proto.show = function show() {
    if (!this._painted) {
      var layer = this.getLayer();

      if (!layer.isCanvasRender()) {
        this.paint();
      }
    } else {
      this.removeCache();

      this._eachSymbolizer(function (symbolizer) {
        symbolizer.show();
      });
    }
  };

  _proto.hide = function hide() {
    this._eachSymbolizer(function (symbolizer) {
      symbolizer.hide();
    });
  };

  _proto.repaint = function repaint() {
    this._altAtGLZoom = this._getGeometryAltitude();
    this.removeCache();
    var layer = this.getLayer();

    if (!layer) {
      return;
    }

    var renderer = layer.getRenderer();

    if (!renderer || !renderer.setToRedraw()) {
      return;
    }

    renderer.setToRedraw();
  };

  _proto.refreshSymbol = function refreshSymbol() {
    this.removeCache();

    this._removeSymbolizers();

    this.symbolizers = this._createSymbolizers();
  };

  _proto.remove = function remove() {
    this.removeCache();

    this._removeSymbolizers();
  };

  _proto._removeSymbolizers = function _removeSymbolizers() {
    this._eachSymbolizer(function (symbolizer) {
      delete symbolizer.painter;
      symbolizer.remove();
    });

    delete this.symbolizers;
  };

  _proto.removeCache = function removeCache() {
    delete this._renderPoints;
    delete this._paintParams;
    delete this._sprite;
    delete this._extent2D;
    delete this._fixedExtent;
    delete this._cachedParams;
    delete this._unsimpledParams;

    if (this.geometry) {
      delete this.geometry[TextMarkerSymbolizer.CACHE_KEY];
    }
  };

  _proto.getAltitude = function getAltitude() {
    var propAlt = this.geometry.getAltitude();

    if (propAlt !== this._propAlt) {
      this._altAtGLZoom = this._getGeometryAltitude();
    }

    if (!this._altAtGLZoom) {
      return 0;
    }

    return this._altAtGLZoom;
  };

  _proto.getMinAltitude = function getMinAltitude() {
    if (!this.minAltitude) {
      return 0;
    }

    return this.minAltitude;
  };

  _proto.getMaxAltitude = function getMaxAltitude() {
    if (!this.maxAltitude) {
      return 0;
    }

    return this.maxAltitude;
  };

  _proto._getGeometryAltitude = function _getGeometryAltitude() {
    var _this2 = this;

    var map = this.getMap();

    if (!map) {
      return 0;
    }

    var altitude = this.geometry.getAltitude();
    this._propAlt = altitude;

    if (!altitude) {
      this.minAltitude = this.maxAltitude = 0;
      return 0;
    }

    var center = this.geometry.getCenter();

    if (!center) {
      return 0;
    }

    if (Array.isArray(altitude)) {
      this.minAltitude = Number.MAX_VALUE;
      this.maxAltitude = Number.MIN_VALUE;
      return altitude.map(function (alt) {
        var a = _this2._meterToPoint(center, alt);

        if (a < _this2.minAltitude) {
          _this2.minAltitude = a;
        }

        if (a > _this2.maxAltitude) {
          _this2.maxAltitude = a;
        }

        return a;
      });
    } else {
      this.minAltitude = this.maxAltitude = this._meterToPoint(center, altitude);
      return this.minAltitude;
    }
  };

  _proto._meterToPoint = function _meterToPoint(center, altitude) {
    var map = this.getMap();
    var z = map.getGLZoom();
    return map.distanceToPoint(altitude, 0, z, center).x * sign(altitude);
  };

  _proto._verifyProjection = function _verifyProjection() {
    var projection = this.geometry._getProjection();

    if (this._projCode && this._projCode !== projection.code) {
      this.removeCache();
    }

    this._projCode = projection.code;
  };

  _proto._beforePaint = function _beforePaint() {
    var textcache = this.geometry[TextMarkerSymbolizer.CACHE_KEY];

    if (!textcache) {
      return;
    }

    for (var p in textcache) {
      if (hasOwn(textcache, p)) {
        textcache[p].active = false;
      }
    }
  };

  _proto._afterPaint = function _afterPaint() {
    var textcache = this.geometry[TextMarkerSymbolizer.CACHE_KEY];

    if (!textcache) {
      return;
    }

    for (var p in textcache) {
      if (hasOwn(textcache, p)) {
        if (!textcache[p].active) {
          delete textcache[p];
        }
      }
    }
  };

  return Painter;
}(Class);

function interpolateAlt(points, orig, altitude) {
  if (!Array.isArray(altitude)) {
    return points;
  }

  var parts = [];

  for (var i = 0, l = points.length; i < l; i++) {
    if (Array.isArray(points[i])) {
      parts.push(interpolateAlt(points[i], orig, altitude));
    } else {
      var p = points[i];

      if (!p.point.equals(orig[p.index])) {
        var w0 = void 0,
            w1 = void 0;

        if (p.index === 0) {
          w0 = p.index;
          w1 = p.index + 1;
        } else {
          w0 = p.index - 1;
          w1 = p.index;
        }

        var t0 = p.point.distanceTo(orig[w1]);
        var t = t0 / (t0 + orig[w0].distanceTo(p.point));
        var alt = interpolate(altitude[w0], altitude[w1], 1 - t);
        p.altitude = alt;
        parts.push(p);
      } else {
        p.altitude = altitude[p.index];
        parts.push(p);
      }
    }
  }

  return parts;
}

var TEMP_EXTENT$2 = new PointExtent();

var CollectionPainter = function (_Class) {
  _inheritsLoose(CollectionPainter, _Class);

  function CollectionPainter(geometry, isMask) {
    var _this;

    _this = _Class.call(this) || this;
    _this.geometry = geometry;
    _this.isMask = isMask;
    return _this;
  }

  var _proto = CollectionPainter.prototype;

  _proto._eachPainter = function _eachPainter(fn) {
    var geometries = this.geometry.getGeometries();
    var painter;

    for (var i = 0, len = geometries.length; i < len; i++) {
      painter = this.isMask ? geometries[i]._getMaskPainter() : geometries[i]._getPainter();

      if (!painter) {
        continue;
      }

      if (painter) {
        if (fn.call(this, painter) === false) {
          break;
        }
      }
    }
  };

  _proto.paint = function paint(extent) {
    if (!this.geometry) {
      return;
    }

    this._eachPainter(function (painter) {
      painter.paint(extent);
    });
  };

  _proto.get2DExtent = function get2DExtent(resources, out) {
    if (out) {
      out.set(null, null, null, null);
    }

    var extent = out || new PointExtent();

    this._eachPainter(function (painter) {
      extent = extent._combine(painter.get2DExtent(resources, TEMP_EXTENT$2));
    });

    return extent;
  };

  _proto.getContainerExtent = function getContainerExtent() {
    var extent = new PointExtent();

    this._eachPainter(function (painter) {
      extent = extent.combine(painter.getContainerExtent());
    });

    return extent;
  };

  _proto.remove = function remove() {
    var args = arguments;

    this._eachPainter(function (painter) {
      painter.remove.apply(painter, args);
    });
  };

  _proto.setZIndex = function setZIndex() {
    var args = arguments;

    this._eachPainter(function (painter) {
      painter.setZIndex.apply(painter, args);
    });
  };

  _proto.show = function show() {
    var args = arguments;

    this._eachPainter(function (painter) {
      painter.show.apply(painter, args);
    });
  };

  _proto.hide = function hide() {
    var args = arguments;

    this._eachPainter(function (painter) {
      painter.hide.apply(painter, args);
    });
  };

  _proto.repaint = function repaint() {
    var args = arguments;

    this._eachPainter(function (painter) {
      painter.repaint.apply(painter, args);
    });
  };

  _proto.refreshSymbol = function refreshSymbol() {
    var args = arguments;

    this._eachPainter(function (painter) {
      painter.refreshSymbol.apply(painter, args);
    });
  };

  _proto.hasPoint = function hasPoint() {
    var result = false;

    this._eachPainter(function (painter) {
      if (painter.hasPoint()) {
        result = true;
        return false;
      }

      return true;
    });

    return result;
  };

  _proto.getMinAltitude = function getMinAltitude() {
    var first = true;
    var result = 0;

    this._eachPainter(function (painter) {
      var alt = painter.getMinAltitude();

      if (first || alt < result) {
        first = false;
        result = alt;
      }
    });

    return result;
  };

  _proto.getMaxAltitude = function getMaxAltitude() {
    var result = 0;

    this._eachPainter(function (painter) {
      var alt = painter.getMaxAltitude();

      if (alt > result) {
        result = alt;
      }
    });

    return result;
  };

  return CollectionPainter;
}(Class);

var DefaultSpatialReference = {
  'EPSG:3857': {
    'resolutions': function () {
      var resolutions = [];
      var d = 2 * 6378137 * Math.PI;

      for (var i = 0; i < 21; i++) {
        resolutions[i] = d / (256 * Math.pow(2, i));
      }

      return resolutions;
    }(),
    'fullExtent': {
      'top': 6378137 * Math.PI,
      'left': -6378137 * Math.PI,
      'bottom': -6378137 * Math.PI,
      'right': 6378137 * Math.PI
    }
  },
  'EPSG:4326': {
    'fullExtent': {
      'top': 90,
      'left': -180,
      'bottom': -90,
      'right': 180
    },
    'resolutions': function () {
      var resolutions = [];

      for (var i = 0; i < 20; i++) {
        resolutions[i] = 180 / (Math.pow(2, i) * 128);
      }

      return resolutions;
    }()
  },
  'BAIDU': {
    'resolutions': function () {
      var res = Math.pow(2, 18);
      var resolutions = [];

      for (var i = 0; i < 20; i++) {
        resolutions[i] = res;
        res *= 0.5;
      }

      return resolutions;
    }(),
    'fullExtent': {
      'top': 33554432,
      'left': -33554432,
      'bottom': -33554432,
      'right': 33554432
    }
  },
  'IDENTITY': {
    'resolutions': function () {
      var res = Math.pow(2, 8);
      var resolutions = [];

      for (var i = 0; i < 18; i++) {
        resolutions[i] = res;
        res *= 0.5;
      }

      return resolutions;
    }(),
    'fullExtent': {
      'top': 200000,
      'left': -200000,
      'bottom': -200000,
      'right': 200000
    }
  }
};
DefaultSpatialReference['EPSG:4490'] = DefaultSpatialReference['EPSG:4326'];

var SpatialReference = function () {
  function SpatialReference(options) {
    if (options === void 0) {
      options = {};
    }

    this.options = options;

    this._initSpatialRef();
  }

  SpatialReference.getProjectionInstance = function getProjectionInstance(prjName) {
    if (!prjName) {
      return null;
    }

    if (isObject(prjName)) {
      return prjName;
    }

    prjName = (prjName + '').toLowerCase();

    for (var p in projections) {
      if (hasOwn(projections, p)) {
        var code = projections[p]['code'];

        if (code && code.toLowerCase() === prjName) {
          return projections[p];
        }
      }
    }

    return null;
  };

  SpatialReference.equals = function equals(sp1, sp2) {
    if (!sp1 && !sp2) {
      return true;
    } else if (!sp1 || !sp2) {
      return false;
    }

    if (sp1.projection !== sp2.projection) {
      return false;
    }

    var f1 = sp1.fullExtent,
        f2 = sp2.fullExtent;

    if (f1 && !f2 || !f1 && f2) {
      return false;
    }

    if (f1 && f2) {
      if (f1.top !== f2.top || f1.bottom !== f2.bottom || f1.left !== f2.left || f1.right !== f2.right) {
        return false;
      }
    }

    var r1 = sp1.resolutions,
        r2 = sp2.resolutions;

    if (r1 && r2) {
      if (r1.length !== r2.length) {
        return false;
      }

      for (var i = 0; i < r1.length; i++) {
        if (r1[i] !== r2[i]) {
          return false;
        }
      }
    }

    return true;
  };

  var _proto = SpatialReference.prototype;

  _proto._initSpatialRef = function _initSpatialRef() {
    var projection = this.options['projection'];

    if (projection) {
      projection = SpatialReference.getProjectionInstance(projection);
    } else {
      projection = DEFAULT$1;
    }

    if (!projection) {
      throw new Error('must provide a valid projection in map\'s spatial reference.');
    }

    projection = extend({}, Common, projection);

    if (!projection.measureLength) {
      extend(projection, Measurer.DEFAULT);
    }

    this._projection = projection;
    var defaultSpatialRef,
        resolutions = this.options['resolutions'];

    if (!resolutions) {
      if (projection['code']) {
        defaultSpatialRef = DefaultSpatialReference[projection['code']];

        if (defaultSpatialRef) {
          resolutions = defaultSpatialRef['resolutions'];
          this.isEPSG = projection['code'] !== 'IDENTITY';
        }
      }

      if (!resolutions) {
        throw new Error('must provide valid resolutions in map\'s spatial reference.');
      }
    }

    this._resolutions = resolutions;
    var fullExtent = this.options['fullExtent'];

    if (!fullExtent) {
      if (projection['code']) {
        defaultSpatialRef = DefaultSpatialReference[projection['code']];

        if (defaultSpatialRef) {
          fullExtent = defaultSpatialRef['fullExtent'];
        }
      }

      if (!fullExtent) {
        throw new Error('must provide a valid fullExtent in map\'s spatial reference.');
      }
    }

    if (!isNil(fullExtent['left'])) {
      this._fullExtent = new Extent(new Coordinate(fullExtent['left'], fullExtent['top']), new Coordinate(fullExtent['right'], fullExtent['bottom']));
    } else {
      this._fullExtent = new Extent(fullExtent);
      fullExtent['left'] = fullExtent['xmin'];
      fullExtent['right'] = fullExtent['xmax'];
      fullExtent['top'] = fullExtent['ymax'];
      fullExtent['bottom'] = fullExtent['ymin'];
    }

    if (isNil(fullExtent['top']) || isNil(fullExtent['bottom']) || isNil(fullExtent['left']) || isNil(fullExtent['right'])) {
      throw new Error('must provide valid top/bottom/left/right in fullExtent.');
    }

    extend(this._fullExtent, fullExtent);
    this._projection.fullExtent = fullExtent;
    var a = fullExtent['right'] >= fullExtent['left'] ? 1 : -1,
        b = fullExtent['top'] >= fullExtent['bottom'] ? -1 : 1;
    this._transformation = new Transformation([a, b, 0, 0]);
  };

  _proto.getResolutions = function getResolutions() {
    return this._resolutions || [];
  };

  _proto.getResolution = function getResolution(zoom) {
    var z = zoom | 0;

    if (z < 0) {
      z = 0;
    } else if (z > this._resolutions.length - 1) {
      z = this._resolutions.length - 1;
    }

    var res = this._resolutions[z];

    if (z !== zoom && zoom > 0 && z < this._resolutions.length - 1) {
      var next = this._resolutions[z + 1];
      return res + (next - res) * (zoom - z);
    }

    return res;
  };

  _proto.getProjection = function getProjection() {
    return this._projection;
  };

  _proto.getFullExtent = function getFullExtent() {
    return this._fullExtent;
  };

  _proto.getTransformation = function getTransformation() {
    return this._transformation;
  };

  _proto.getMinZoom = function getMinZoom() {
    for (var i = 0; i < this._resolutions.length; i++) {
      if (!isNil(this._resolutions[i])) {
        return i;
      }
    }

    return 0;
  };

  _proto.getMaxZoom = function getMaxZoom() {
    for (var i = this._resolutions.length - 1; i >= 0; i--) {
      if (!isNil(this._resolutions[i])) {
        return i;
      }
    }

    return this._resolutions.length - 1;
  };

  _proto.getZoomDirection = function getZoomDirection() {
    return sign(this._resolutions[this.getMinZoom()] - this._resolutions[this.getMaxZoom()]);
  };

  _proto.toJSON = function toJSON() {
    if (!this.json) {
      this.json = {
        'resolutions': this._resolutions,
        'fullExtent': {
          'top': this._fullExtent.top,
          'left': this._fullExtent.left,
          'bottom': this._fullExtent.bottom,
          'right': this._fullExtent.right
        },
        'projection': this._projection.code
      };
    }

    return this.json;
  };

  return SpatialReference;
}();

var options = {
  'id': null,
  'visible': true,
  'interactive': true,
  'editable': true,
  'cursor': null,
  'defaultProjection': 'EPSG:4326'
};

var Geometry = function (_JSONAble) {
  _inheritsLoose(Geometry, _JSONAble);

  function Geometry(options) {
    var _this;

    var opts = extend({}, options);
    var symbol = opts['symbol'];
    var properties = opts['properties'];
    var id = opts['id'];
    delete opts['symbol'];
    delete opts['id'];
    delete opts['properties'];
    _this = _JSONAble.call(this, opts) || this;

    if (symbol) {
      _this.setSymbol(symbol);
    }

    if (properties) {
      _this.setProperties(properties);
    }

    if (!isNil(id)) {
      _this.setId(id);
    }

    return _this;
  }

  var _proto = Geometry.prototype;

  _proto.getFirstCoordinate = function getFirstCoordinate() {
    if (this.type === 'GeometryCollection') {
      var geometries = this.getGeometries();

      if (!geometries.length) {
        return null;
      }

      return geometries[0].getFirstCoordinate();
    }

    var coordinates = this.getCoordinates();

    if (!Array.isArray(coordinates)) {
      return coordinates;
    }

    do {
      coordinates = coordinates[0];
    } while (Array.isArray(coordinates) && coordinates.length > 0);

    return coordinates;
  };

  _proto.getLastCoordinate = function getLastCoordinate() {
    if (this.type === 'GeometryCollection') {
      var geometries = this.getGeometries();

      if (!geometries.length) {
        return null;
      }

      return geometries[geometries.length - 1].getLastCoordinate();
    }

    var coordinates = this.getCoordinates();

    if (!Array.isArray(coordinates)) {
      return coordinates;
    }

    do {
      coordinates = coordinates[coordinates.length - 1];
    } while (Array.isArray(coordinates) && coordinates.length > 0);

    return coordinates;
  };

  _proto.addTo = function addTo(layer, fitview) {
    layer.addGeometry(this, fitview);
    return this;
  };

  _proto.getLayer = function getLayer() {
    if (!this._layer) {
      return null;
    }

    return this._layer;
  };

  _proto.getMap = function getMap() {
    if (!this._layer) {
      return null;
    }

    return this._layer.getMap();
  };

  _proto.getId = function getId() {
    return this._id;
  };

  _proto.setId = function setId(id) {
    var oldId = this.getId();
    this._id = id;

    this._fireEvent('idchange', {
      'old': oldId,
      'new': id
    });

    return this;
  };

  _proto.getProperties = function getProperties() {
    if (!this.properties) {
      if (this._getParent()) {
        return this._getParent().getProperties();
      }

      return null;
    }

    return this.properties;
  };

  _proto.setProperties = function setProperties(properties) {
    var old = this.properties;
    this.properties = isObject(properties) ? extend({}, properties) : properties;

    this._repaint();

    this._fireEvent('propertieschange', {
      'old': old,
      'new': properties
    });

    return this;
  };

  _proto.getType = function getType() {
    return this.type;
  };

  _proto.getSymbol = function getSymbol() {
    var s = this._symbol;

    if (s) {
      if (!Array.isArray(s)) {
        return extend({}, s);
      } else {
        return extendSymbol(s);
      }
    }

    return null;
  };

  _proto.setSymbol = function setSymbol(symbol) {
    this._symbol = this._prepareSymbol(symbol);
    this.onSymbolChanged();
    return this;
  };

  _proto.updateSymbol = function updateSymbol(props) {
    if (!props) {
      return this;
    }

    var s = this._getSymbol();

    if (s) {
      s = extendSymbol(s, props);
    } else {
      s = extendSymbol(this._getInternalSymbol(), props);
    }

    this._eventSymbolProperties = props;
    return this.setSymbol(s);
  };

  _proto.getCenter = function getCenter() {
    return this._computeCenter(this._getMeasurer());
  };

  _proto.getExtent = function getExtent() {
    var prjExt = this._getPrjExtent();

    var projection = this._getProjection();

    if (prjExt && projection) {
      var min = projection.unproject(new Coordinate(prjExt['xmin'], prjExt['ymin'])),
          max = projection.unproject(new Coordinate(prjExt['xmax'], prjExt['ymax']));
      return new Extent(min, max, projection);
    } else {
      return this._computeExtent(this._getMeasurer());
    }
  };

  _proto.getContainerExtent = function getContainerExtent(out) {
    var painter = this._getPainter();

    return painter ? painter.getContainerExtent(out) : null;
  };

  _proto.getSize = function getSize() {
    var extent = this.getContainerExtent();
    return extent ? extent.getSize() : null;
  };

  _proto.containsPoint = function containsPoint(containerPoint, t) {
    if (!this.getMap()) {
      throw new Error('The geometry is required to be added on a map to perform "containsPoint".');
    }

    if (containerPoint instanceof Coordinate) {
      containerPoint = this.getMap().coordToContainerPoint(containerPoint);
    }

    return this._containsPoint(containerPoint, t);
  };

  _proto._containsPoint = function _containsPoint(containerPoint, t) {
    var painter = this._getPainter();

    if (!painter) {
      return false;
    }

    if (isNil(t) && this._hitTestTolerance) {
      t = this._hitTestTolerance();
    }

    return painter.hitTest(containerPoint, t);
  };

  _proto.show = function show() {
    this.options['visible'] = true;

    if (this.getMap()) {
      var painter = this._getPainter();

      if (painter) {
        painter.show();
      }

      this._fireEvent('show');
    }

    return this;
  };

  _proto.hide = function hide() {
    this.options['visible'] = false;

    if (this.getMap()) {
      this.onHide();

      var painter = this._getPainter();

      if (painter) {
        painter.hide();
      }

      this._fireEvent('hide');
    }

    return this;
  };

  _proto.isVisible = function isVisible() {
    if (!this.options['visible']) {
      return false;
    }

    var symbol = this._getInternalSymbol();

    if (!symbol) {
      return true;
    }

    if (Array.isArray(symbol)) {
      if (!symbol.length) {
        return true;
      }

      for (var i = 0, l = symbol.length; i < l; i++) {
        if (isNil(symbol[i]['opacity']) || symbol[i]['opacity'] > 0) {
          return true;
        }
      }

      return false;
    } else {
      return isNil(symbol['opacity']) || isNumber(symbol['opacity']) && symbol['opacity'] > 0;
    }
  };

  _proto.getZIndex = function getZIndex() {
    return this.options['zIndex'] || 0;
  };

  _proto.setZIndex = function setZIndex(zIndex) {
    var old = this.options['zIndex'];
    this.options['zIndex'] = zIndex;

    this._fireEvent('zindexchange', {
      'old': old,
      'new': zIndex
    });

    return this;
  };

  _proto.setZIndexSilently = function setZIndexSilently(zIndex) {
    this.options['zIndex'] = zIndex;
    return this;
  };

  _proto.bringToFront = function bringToFront() {
    var layer = this.getLayer();

    if (!layer || !layer.getGeoMaxZIndex) {
      return this;
    }

    var topZ = layer.getGeoMaxZIndex();
    this.setZIndex(topZ + 1);
    return this;
  };

  _proto.bringToBack = function bringToBack() {
    var layer = this.getLayer();

    if (!layer || !layer.getGeoMinZIndex) {
      return this;
    }

    var bottomZ = layer.getGeoMinZIndex();
    this.setZIndex(bottomZ - 1);
    return this;
  };

  _proto.translate = function translate(x, y) {
    if (isNil(x)) {
      return this;
    }

    var offset = new Coordinate(x, y);

    if (offset.x === 0 && offset.y === 0) {
      return this;
    }

    var coordinates = this.getCoordinates();

    if (coordinates) {
      if (Array.isArray(coordinates)) {
        var translated = forEachCoord(coordinates, function (coord) {
          return coord.add(offset);
        });
        this.setCoordinates(translated);
      } else {
        this.setCoordinates(coordinates.add(offset));
      }
    }

    return this;
  };

  _proto.flash = function flash$$1(interval, count, cb, context) {
    return flash.call(this, interval, count, cb, context);
  };

  _proto.copy = function copy() {
    var json = this.toJSON();
    var ret = Geometry.fromJSON(json);
    ret.options['visible'] = true;
    return ret;
  };

  _proto.remove = function remove() {
    var layer = this.getLayer();

    if (!layer) {
      return this;
    }

    this._fireEvent('removestart');

    this._unbind();

    this._fireEvent('removeend');

    this._fireEvent('remove');

    return this;
  };

  _proto.toGeoJSONGeometry = function toGeoJSONGeometry() {
    var gJson = this._exportGeoJSONGeometry();

    return gJson;
  };

  _proto.toGeoJSON = function toGeoJSON(opts) {
    if (!opts) {
      opts = {};
    }

    var feature = {
      'type': 'Feature',
      'geometry': null
    };

    if (isNil(opts['geometry']) || opts['geometry']) {
      var geoJSON = this._exportGeoJSONGeometry();

      feature['geometry'] = geoJSON;
    }

    var id = this.getId();

    if (!isNil(id)) {
      feature['id'] = id;
    }

    var properties;

    if (isNil(opts['properties']) || opts['properties']) {
      properties = this._exportProperties();
    }

    feature['properties'] = properties;
    return feature;
  };

  _proto.toJSON = function toJSON(options) {
    if (!options) {
      options = {};
    }

    var json = this._toJSON(options);

    var other = this._exportGraphicOptions(options);

    extend(json, other);
    return json;
  };

  _proto.getLength = function getLength() {
    return this._computeGeodesicLength(this._getMeasurer());
  };

  _proto.getArea = function getArea() {
    return this._computeGeodesicArea(this._getMeasurer());
  };

  _proto.rotate = function rotate(angle, pivot) {
    if (this.type === 'GeometryCollection') {
      var geometries = this.getGeometries();
      geometries.forEach(function (g) {
        return g.rotate(angle, pivot);
      });
      return this;
    }

    if (!pivot) {
      pivot = this.getCenter();
    } else {
      pivot = new Coordinate(pivot);
    }

    var measurer = this._getMeasurer();

    var coordinates = this.getCoordinates();

    if (!Array.isArray(coordinates)) {
      if (pivot.x !== coordinates.x || pivot.y !== coordinates.y) {
        var c = measurer._rotate(coordinates, pivot, angle);

        this.setCoordinates(c);
      }

      return this;
    }

    forEachCoord(coordinates, function (c) {
      return measurer._rotate(c, pivot, angle);
    });
    this.setCoordinates(coordinates);
    return this;
  };

  _proto._getConnectPoints = function _getConnectPoints() {
    return [this.getCenter()];
  };

  _proto._initOptions = function _initOptions(options) {
    var opts = extend({}, options);
    var symbol = opts['symbol'];
    var properties = opts['properties'];
    var id = opts['id'];
    delete opts['symbol'];
    delete opts['id'];
    delete opts['properties'];
    this.setOptions(opts);

    if (symbol) {
      this.setSymbol(symbol);
    }

    if (properties) {
      this.setProperties(properties);
    }

    if (!isNil(id)) {
      this.setId(id);
    }
  };

  _proto._bindLayer = function _bindLayer(layer) {
    if (this.getLayer()) {
      throw new Error('Geometry cannot be added to two or more layers at the same time.');
    }

    this._layer = layer;

    this._clearCache();
  };

  _proto._prepareSymbol = function _prepareSymbol(symbol) {
    if (Array.isArray(symbol)) {
      var cookedSymbols = [];

      for (var i = 0; i < symbol.length; i++) {
        cookedSymbols.push(convertResourceUrl(this._checkAndCopySymbol(symbol[i])));
      }

      return cookedSymbols;
    } else if (symbol) {
      symbol = this._checkAndCopySymbol(symbol);
      return convertResourceUrl(symbol);
    }

    return null;
  };

  _proto._checkAndCopySymbol = function _checkAndCopySymbol(symbol) {
    var s = {};

    for (var i in symbol) {
      if (NUMERICAL_PROPERTIES[i] && isString(symbol[i])) {
        s[i] = +symbol[i];
      } else {
        s[i] = symbol[i];
      }
    }

    return s;
  };

  _proto._getSymbol = function _getSymbol() {
    return this._symbol;
  };

  _proto._setExternSymbol = function _setExternSymbol(symbol) {
    this._eventSymbolProperties = symbol;
    this._externSymbol = this._prepareSymbol(symbol);
    this.onSymbolChanged();
    return this;
  };

  _proto._getInternalSymbol = function _getInternalSymbol() {
    if (this._symbol) {
      return this._symbol;
    } else if (this._externSymbol) {
      return this._externSymbol;
    } else if (this.options['symbol']) {
      return this.options['symbol'];
    }

    return null;
  };

  _proto._getPrjExtent = function _getPrjExtent() {
    var p = this._getProjection();

    this._verifyProjection();

    if (!this._extent && p) {
      this._extent = this._computePrjExtent(p);
    }

    return this._extent;
  };

  _proto._unbind = function _unbind() {
    var layer = this.getLayer();

    if (!layer) {
      return;
    }

    if (this._animPlayer) {
      this._animPlayer.finish();
    }

    this._clearHandlers();

    this._unbindMenu();

    this._unbindInfoWindow();

    if (this.isEditing()) {
      this.endEdit();
    }

    this._removePainter();

    if (this.onRemove) {
      this.onRemove();
    }

    if (layer.onRemoveGeometry) {
      layer.onRemoveGeometry(this);
    }

    delete this._layer;
    delete this._internalId;
    delete this._extent;
  };

  _proto._getInternalId = function _getInternalId() {
    return this._internalId;
  };

  _proto._setInternalId = function _setInternalId(id) {
    this._internalId = id;
  };

  _proto._getMeasurer = function _getMeasurer() {
    if (this._getProjection()) {
      return this._getProjection();
    }

    return SpatialReference.getProjectionInstance(this.options['defaultProjection']);
  };

  _proto._getProjection = function _getProjection() {
    var map = this.getMap();

    if (map) {
      return map.getProjection();
    }

    return null;
  };

  _proto._verifyProjection = function _verifyProjection() {
    var projection = this._getProjection();

    if (this._projCode && projection && this._projCode !== projection.code) {
      this._clearProjection();
    }

    this._projCode = projection ? projection.code : this._projCode;
  };

  _proto._getExternalResources = function _getExternalResources() {
    var symbol = this._getInternalSymbol();

    return getExternalResources(symbol);
  };

  _proto._getPainter = function _getPainter() {
    var layer = this.getLayer();

    if (!this._painter && layer) {
      if (GEOMETRY_COLLECTION_TYPES.indexOf(this.type) !== -1) {
        if (layer.constructor.getCollectionPainterClass) {
          var clazz = layer.constructor.getCollectionPainterClass();
          this._painter = new clazz(this);
        }
      } else if (layer.constructor.getPainterClass) {
        var _clazz = layer.constructor.getPainterClass();

        this._painter = new _clazz(this);
      }
    }

    return this._painter;
  };

  _proto._getMaskPainter = function _getMaskPainter() {
    if (this._maskPainter) {
      return this._maskPainter;
    }

    this._maskPainter = this.getGeometries && this.getGeometries() ? new CollectionPainter(this, true) : new Painter(this);
    return this._maskPainter;
  };

  _proto._removePainter = function _removePainter() {
    if (this._painter) {
      this._painter.remove();
    }

    delete this._painter;
  };

  _proto._paint = function _paint(extent) {
    if (this._painter) {
      this._painter.paint(extent);
    }
  };

  _proto._clearCache = function _clearCache() {
    delete this._extent;
  };

  _proto._clearProjection = function _clearProjection() {
    delete this._extent;
  };

  _proto._repaint = function _repaint() {
    if (this._painter) {
      this._painter.repaint();
    }
  };

  _proto.onHide = function onHide() {
    this.closeMenu();
    this.closeInfoWindow();
  };

  _proto.onShapeChanged = function onShapeChanged() {
    this._clearCache();

    this._repaint();

    this._fireEvent('shapechange');
  };

  _proto.onPositionChanged = function onPositionChanged() {
    this._clearCache();

    this._repaint();

    this._fireEvent('positionchange');
  };

  _proto.onSymbolChanged = function onSymbolChanged() {
    if (this._painter) {
      this._painter.refreshSymbol();
    }

    var e = {};

    if (this._eventSymbolProperties) {
      e.properties = extend({}, this._eventSymbolProperties);
      delete this._eventSymbolProperties;
    }

    this._fireEvent('symbolchange', e);
  };

  _proto.onConfig = function onConfig(conf) {
    var properties;

    if (conf['properties']) {
      properties = conf['properties'];
      delete conf['properties'];
    }

    var needRepaint = false;

    for (var p in conf) {
      if (conf.hasOwnProperty(p)) {
        var prefix = p.slice(0, 5);

        if (prefix === 'arrow' || prefix === 'smoot') {
          needRepaint = true;
          break;
        }
      }
    }

    if (properties) {
      this.setProperties(properties);

      this._repaint();
    } else if (needRepaint) {
      this._repaint();
    }
  };

  _proto._setParent = function _setParent(geometry) {
    if (geometry) {
      this._parent = geometry;
    }
  };

  _proto._getParent = function _getParent() {
    return this._parent;
  };

  _proto._fireEvent = function _fireEvent(eventName, param) {
    if (this.getLayer() && this.getLayer()._onGeometryEvent) {
      if (!param) {
        param = {};
      }

      param['type'] = eventName;
      param['target'] = this;

      this.getLayer()._onGeometryEvent(param);
    }

    this.fire(eventName, param);
  };

  _proto._toJSON = function _toJSON(options) {
    return {
      'feature': this.toGeoJSON(options)
    };
  };

  _proto._exportGraphicOptions = function _exportGraphicOptions(options) {
    var json = {};

    if (isNil(options['options']) || options['options']) {
      json['options'] = this.config();
    }

    if (isNil(options['symbol']) || options['symbol']) {
      json['symbol'] = this.getSymbol();
    }

    if (isNil(options['infoWindow']) || options['infoWindow']) {
      if (this._infoWinOptions) {
        json['infoWindow'] = this._infoWinOptions;
      }
    }

    return json;
  };

  _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
    var points = this.getCoordinates();
    var coordinates = Coordinate.toNumberArrays(points);
    return {
      'type': this.getType(),
      'coordinates': coordinates
    };
  };

  _proto._exportProperties = function _exportProperties() {
    var properties = null;
    var geoProperties = this.getProperties();

    if (!isNil(geoProperties)) {
      if (isObject(geoProperties)) {
        properties = extend({}, geoProperties);
      } else {
        properties = geoProperties;
      }
    }

    return properties;
  };

  _proto.getAltitude = function getAltitude() {
    var layer = this.getLayer();

    if (!layer) {
      return 0;
    }

    var layerOpts = layer.options,
        properties = this.getProperties();
    var altitude = layerOpts['enableAltitude'] ? properties ? properties[layerOpts['altitudeProperty']] : 0 : 0;
    var layerAltitude = layer.getAltitude ? layer.getAltitude() : 0;

    if (Array.isArray(altitude)) {
      return altitude.map(function (alt) {
        return alt + layerAltitude;
      });
    }

    return altitude + layerAltitude;
  };

  return Geometry;
}(JSONAble(Eventable(Handlerable(Class))));

Geometry.mergeOptions(options);

var options$1 = {
  'attribution': null,
  'minZoom': null,
  'maxZoom': null,
  'visible': true,
  'opacity': 1,
  'globalCompositeOperation': null,
  'renderer': 'canvas',
  'debugOutline': '#0f0',
  'cssFilter': null,
  'forceRenderOnMoving': false,
  'forceRenderOnZooming': false,
  'forceRenderOnRotating': false,
  'hitDetect': function () {
    return !Browser$1.mobile;
  }()
};

var Layer = function (_JSONAble) {
  _inheritsLoose(Layer, _JSONAble);

  function Layer(id, options) {
    var _this;

    var canvas;

    if (options) {
      canvas = options.canvas;
      delete options.canvas;
    }

    _this = _JSONAble.call(this, options) || this;
    _this._canvas = canvas;

    _this.setId(id);

    if (options) {
      _this.setZIndex(options.zIndex);

      if (options.mask) {
        _this.setMask(Geometry.fromJSON(options.mask));
      }
    }

    return _this;
  }

  var _proto = Layer.prototype;

  _proto.load = function load() {
    if (!this.getMap()) {
      return this;
    }

    if (this.onLoad()) {
      this._initRenderer();

      var zIndex = this.getZIndex();

      if (!isNil(zIndex)) {
        this._renderer.setZIndex(zIndex);

        if (!this.isCanvasRender()) {
          this._renderer.render();
        }
      }

      this.onLoadEnd();
    }

    return this;
  };

  _proto.getId = function getId() {
    return this._id;
  };

  _proto.setId = function setId(id) {
    var old = this._id;

    if (!isNil(id)) {
      id = id + '';
    }

    this._id = id;
    this.fire('idchange', {
      'old': old,
      'new': id
    });
    return this;
  };

  _proto.addTo = function addTo(map) {
    map.addLayer(this);
    return this;
  };

  _proto.setZIndex = function setZIndex(zIndex) {
    this._zIndex = zIndex;

    if (isNil(zIndex)) {
      delete this.options['zIndex'];
    } else {
      this.options.zIndex = zIndex;
    }

    if (this.map) {
      this.map._sortLayersByZIndex();
    }

    if (this._renderer) {
      this._renderer.setZIndex(zIndex);
    }

    return this;
  };

  _proto.getZIndex = function getZIndex() {
    return this._zIndex || 0;
  };

  _proto.getMinZoom = function getMinZoom() {
    var map = this.getMap();
    var minZoom = this.options['minZoom'];
    return map ? Math.max(map.getMinZoom(), minZoom || 0) : minZoom;
  };

  _proto.getMaxZoom = function getMaxZoom() {
    var map = this.getMap();
    var maxZoom = this.options['maxZoom'];
    return map ? Math.min(map.getMaxZoom(), isNil(maxZoom) ? Infinity : maxZoom) : maxZoom;
  };

  _proto.getOpacity = function getOpacity() {
    return this.options['opacity'];
  };

  _proto.setOpacity = function setOpacity(op) {
    this.config('opacity', op);
    return this;
  };

  _proto.isCanvasRender = function isCanvasRender() {
    var renderer = this._getRenderer();

    return renderer && renderer instanceof CanvasRenderer;
  };

  _proto.getMap = function getMap() {
    if (this.map) {
      return this.map;
    }

    return null;
  };

  _proto.getProjection = function getProjection() {
    var map = this.getMap();
    return map ? map.getProjection() : null;
  };

  _proto.bringToFront = function bringToFront() {
    var layers = this._getLayerList();

    if (!layers.length) {
      return this;
    }

    var topLayer = layers[layers.length - 1];

    if (layers.length === 1 || topLayer === this) {
      return this;
    }

    var max = topLayer.getZIndex();
    this.setZIndex(max + 1);
    return this;
  };

  _proto.bringToBack = function bringToBack() {
    var layers = this._getLayerList();

    if (!layers.length) {
      return this;
    }

    var bottomLayer = layers[0];

    if (layers.length === 1 || bottomLayer === this) {
      return this;
    }

    var min = bottomLayer.getZIndex();
    this.setZIndex(min - 1);
    return this;
  };

  _proto.show = function show() {
    var _this2 = this;

    if (!this.options['visible']) {
      this.options['visible'] = true;
      var renderer = this.getRenderer();

      if (renderer) {
        renderer.show();
      }

      var map = this.getMap();

      if (renderer && map) {
        map.once('renderend', function () {
          _this2.fire('show');
        });
      } else {
        this.fire('show');
      }
    }

    return this;
  };

  _proto.hide = function hide() {
    var _this3 = this;

    if (this.options['visible']) {
      this.options['visible'] = false;
      var renderer = this.getRenderer();

      if (renderer) {
        renderer.hide();
      }

      var map = this.getMap();

      if (renderer && map) {
        map.once('renderend', function () {
          _this3.fire('hide');
        });
      } else {
        this.fire('hide');
      }
    }

    return this;
  };

  _proto.isVisible = function isVisible() {
    if (isNumber(this.options['opacity']) && this.options['opacity'] <= 0) {
      return false;
    }

    var map = this.getMap();

    if (map) {
      var zoom = map.getZoom();

      if (!isNil(this.options['maxZoom']) && this.options['maxZoom'] < zoom || !isNil(this.options['minZoom']) && this.options['minZoom'] > zoom) {
        return false;
      }
    }

    if (isNil(this.options['visible'])) {
      this.options['visible'] = true;
    }

    return this.options['visible'];
  };

  _proto.remove = function remove() {
    if (this.map) {
      this.map.removeLayer(this);
    }

    return this;
  };

  _proto.getMask = function getMask() {
    return this._mask;
  };

  _proto.setMask = function setMask(mask) {
    if (!(mask.type === 'Point' && mask._isVectorMarker() || mask.type === 'Polygon' || mask.type === 'MultiPolygon')) {
      throw new Error('Mask for a layer must be a marker with vector marker symbol or a Polygon(MultiPolygon).');
    }

    mask._bindLayer(this);

    if (mask.type === 'Point') {
      mask.updateSymbol({
        'markerLineColor': 'rgba(0, 0, 0, 0)',
        'markerFillOpacity': 0
      });
    } else {
      mask.setSymbol({
        'lineColor': 'rgba(0, 0, 0, 0)',
        'polygonOpacity': 0
      });
    }

    this._mask = mask;
    this.options.mask = mask.toJSON();

    if (!this.getMap() || this.getMap().isZooming()) {
      return this;
    }

    var renderer = this._getRenderer();

    if (renderer && renderer.setToRedraw) {
      this._getRenderer().setToRedraw();
    }

    return this;
  };

  _proto.removeMask = function removeMask() {
    delete this._mask;
    delete this.options.mask;

    if (!this.getMap() || this.getMap().isZooming()) {
      return this;
    }

    var renderer = this._getRenderer();

    if (renderer && renderer.setToRedraw) {
      this._getRenderer().setToRedraw();
    }

    return this;
  };

  _proto.onLoad = function onLoad() {
    return true;
  };

  _proto.onLoadEnd = function onLoadEnd() {};

  _proto.isLoaded = function isLoaded() {
    return !!this._loaded;
  };

  _proto.getRenderer = function getRenderer() {
    return this._getRenderer();
  };

  _proto.onConfig = function onConfig(conf) {
    if (isNumber(conf['opacity']) || conf['cssFilter']) {
      var renderer = this.getRenderer();

      if (renderer) {
        renderer.setToRedraw();
      }
    }
  };

  _proto.onAdd = function onAdd() {};

  _proto.onRendererCreate = function onRendererCreate() {};

  _proto.onCanvasCreate = function onCanvasCreate() {};

  _proto.onRemove = function onRemove() {};

  _proto._bindMap = function _bindMap(map, zIndex) {
    if (!map) {
      return;
    }

    this.map = map;

    if (!isNil(zIndex)) {
      this.setZIndex(zIndex);
    }

    this._switchEvents('on', this);

    this.onAdd();
    this.fire('add');
  };

  _proto._initRenderer = function _initRenderer() {
    var renderer = this.options['renderer'];

    if (!this.constructor.getRendererClass) {
      return;
    }

    var clazz = this.constructor.getRendererClass(renderer);

    if (!clazz) {
      throw new Error('Invalid renderer for Layer(' + this.getId() + '):' + renderer);
    }

    this._renderer = new clazz(this);
    this._renderer.layer = this;

    this._renderer.setZIndex(this.getZIndex());

    this._switchEvents('on', this._renderer);

    if (this._renderer.onAdd) {
      this._renderer.onAdd();
    }

    this.onRendererCreate();
    this.fire('renderercreate', {
      'renderer': this._renderer
    });
  };

  _proto._doRemove = function _doRemove() {
    this._loaded = false;
    this.onRemove();

    this._switchEvents('off', this);

    if (this._renderer) {
      this._switchEvents('off', this._renderer);

      this._renderer.remove();

      delete this._renderer;
    }

    delete this.map;
  };

  _proto._switchEvents = function _switchEvents(to, emitter) {
    if (emitter && emitter.getEvents) {
      this.getMap()[to](emitter.getEvents(), emitter);
    }
  };

  _proto._getRenderer = function _getRenderer() {
    return this._renderer;
  };

  _proto._getLayerList = function _getLayerList() {
    if (!this.map) {
      return [];
    }

    return this.map._layers;
  };

  _proto._getMask2DExtent = function _getMask2DExtent() {
    if (!this._mask || !this.getMap()) {
      return null;
    }

    var painter = this._mask._getMaskPainter();

    if (!painter) {
      return null;
    }

    return painter.get2DExtent();
  };

  return Layer;
}(JSONAble(Eventable(Renderable(Class))));

Layer.mergeOptions(options$1);
var fire = Layer.prototype.fire;

Layer.prototype.fire = function (eventType, param) {
  if (eventType === 'layerload') {
    this._loaded = true;
  }

  if (this.map) {
    if (!param) {
      param = {};
    }

    param['type'] = eventType;
    param['target'] = this;

    this.map._onLayerEvent(param);
  }

  return fire.apply(this, arguments);
};

var options$2 = {
  'maxVisualPitch': 70,
  'maxPitch': 80,
  'centerCross': false,
  'zoomInCenter': false,
  'zoomOrigin': null,
  'zoomAnimation': function () {
    return !IS_NODE;
  }(),
  'zoomAnimationDuration': 330,
  'panAnimation': function () {
    return !IS_NODE;
  }(),
  'panAnimationDuration': 600,
  'zoomable': true,
  'enableInfoWindow': true,
  'hitDetect': function () {
    return !Browser$1.mobile;
  }(),
  'hitDetectLimit': 5,
  'fpsOnInteracting': 25,
  'layerCanvasLimitOnInteracting': -1,
  'maxZoom': null,
  'minZoom': null,
  'maxExtent': null,
  'fixCenterOnResize': true,
  'checkSize': true,
  'checkSizeInterval': 1000,
  'renderer': 'canvas',
  'cascadePitches': [10, 60]
};

var Map$1 = function (_Handlerable) {
  _inheritsLoose(Map, _Handlerable);

  function Map(container, options) {
    var _this;

    if (!options) {
      throw new Error('Invalid options when creating map.');
    }

    if (!options['center']) {
      throw new Error('Invalid center when creating map.');
    }

    var opts = extend({}, options);
    var zoom = opts['zoom'];
    delete opts['zoom'];
    var center = new Coordinate(opts['center']);
    delete opts['center'];
    var baseLayer = opts['baseLayer'];
    delete opts['baseLayer'];
    var layers = opts['layers'];
    delete opts['layers'];
    _this = _Handlerable.call(this, opts) || this;
    _this.VERSION = Map.VERSION;
    Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'id', {
      value: UID(),
      writable: false
    });
    _this._loaded = false;

    _this._initContainer(container);

    _this._panels = {};
    _this._baseLayer = null;
    _this._layers = [];
    _this._zoomLevel = zoom;
    _this._center = center;

    _this.setSpatialReference(opts['spatialReference'] || opts['view']);

    _this.setMaxExtent(opts['maxExtent']);

    _this._mapViewPoint = new Point(0, 0);

    _this._initRenderer();

    _this._updateMapSize(_this._getContainerDomSize());

    if (baseLayer) {
      _this.setBaseLayer(baseLayer);
    }

    if (layers) {
      _this.addLayer(layers);
    }

    _this._Load();

    return _this;
  }

  Map.addOnLoadHook = function addOnLoadHook(fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    var onload = typeof fn === 'function' ? fn : function () {
      this[fn].apply(this, args);
    };
    this.prototype._onLoadHooks = this.prototype._onLoadHooks || [];

    this.prototype._onLoadHooks.push(onload);

    return this;
  };

  var _proto = Map.prototype;

  _proto.isLoaded = function isLoaded() {
    return !!this._loaded;
  };

  _proto.getContainer = function getContainer() {
    return this._containerDOM;
  };

  _proto.getSpatialReference = function getSpatialReference() {
    return this._spatialReference;
  };

  _proto.setSpatialReference = function setSpatialReference(ref) {
    var oldRef = this.options['spatialReference'];

    if (this._loaded && SpatialReference.equals(oldRef, ref)) {
      return this;
    }

    this._updateSpatialReference(ref, oldRef);

    return this;
  };

  _proto._updateSpatialReference = function _updateSpatialReference(ref, oldRef) {
    ref = extend({}, ref);
    this._center = this.getCenter();
    this.options['spatialReference'] = ref;
    this._spatialReference = new SpatialReference(ref);

    if (this.options['spatialReference'] && isFunction(this.options['spatialReference']['projection'])) {
      var projection = this._spatialReference.getProjection();

      this.options['spatialReference']['projection'] = projection['code'];
    }

    this._resetMapStatus();

    this._fireEvent('spatialreferencechange', {
      'old': oldRef,
      'new': extend({}, this.options['spatialReference'])
    });

    return this;
  };

  _proto.onConfig = function onConfig(conf) {
    var ref = conf['spatialReference'] || conf['view'];

    if (!isNil(ref)) {
      this._updateSpatialReference(ref, null);
    }

    return this;
  };

  _proto.getProjection = function getProjection() {
    if (!this._spatialReference) {
      return null;
    }

    return this._spatialReference.getProjection();
  };

  _proto.getFullExtent = function getFullExtent() {
    if (!this._spatialReference) {
      return null;
    }

    return this._spatialReference.getFullExtent();
  };

  _proto.setCursor = function setCursor(cursor) {
    delete this._cursor;

    this._trySetCursor(cursor);

    this._cursor = cursor;
    return this;
  };

  _proto.resetCursor = function resetCursor() {
    return this.setCursor(null);
  };

  _proto.getCenter = function getCenter() {
    if (!this._loaded || !this._prjCenter) {
      return this._center;
    }

    var projection = this.getProjection();
    return projection.unproject(this._prjCenter);
  };

  _proto.setCenter = function setCenter(center) {
    if (!center) {
      return this;
    }

    center = new Coordinate(center);
    var projection = this.getProjection();
    var pcenter = projection.project(center);

    if (!this._verifyExtent(pcenter)) {
      return this;
    }

    if (!this._loaded) {
      this._center = center;
      return this;
    }

    this.onMoveStart();

    this._setPrjCenter(pcenter);

    this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
    return this;
  };

  _proto.getSize = function getSize() {
    if (isNil(this.width) || isNil(this.height)) {
      return this._getContainerDomSize();
    }

    return new Size(this.width, this.height);
  };

  _proto.getContainerExtent = function getContainerExtent() {
    var visualHeight = this.height;
    var pitch = this.getPitch(),
        maxVisualPitch = this.options['maxVisualPitch'];

    if (maxVisualPitch && pitch > maxVisualPitch) {
      visualHeight = this._getVisualHeight(maxVisualPitch);
    }

    return new PointExtent(0, this.height - visualHeight, this.width, this.height);
  };

  _proto._getVisualHeight = function _getVisualHeight(visualPitch) {
    visualPitch = visualPitch || 1E-2;
    var pitch = (90 - this.getPitch()) * Math.PI / 180;
    var fov = this.getFov() * Math.PI / 180;
    visualPitch *= Math.PI / 180;
    var cameraToCenter = this.cameraCenterDistance / this.getGLScale();
    var tanB = Math.tan(fov / 2);
    var tanP = Math.tan(visualPitch);
    var visualDistance = cameraToCenter * tanB / (1 / tanP - tanB) / Math.sin(visualPitch);
    var x = cameraToCenter * (Math.sin(pitch) * visualDistance / (cameraToCenter + Math.cos(pitch) * visualDistance));
    return this.height / 2 + x;
  };

  _proto.getExtent = function getExtent() {
    return this._pointToExtent(this._get2DExtent());
  };

  _proto.getProjExtent = function getProjExtent() {
    var extent2D = this._get2DExtent();

    return new Extent(this._pointToPrj(extent2D.getMin()), this._pointToPrj(extent2D.getMax()));
  };

  _proto.getPrjExtent = function getPrjExtent() {
    return this.getProjExtent();
  };

  _proto.getMaxExtent = function getMaxExtent() {
    if (!this.options['maxExtent']) {
      return null;
    }

    return new Extent(this.options['maxExtent'], this.getProjection());
  };

  _proto.setMaxExtent = function setMaxExtent(extent) {
    if (extent) {
      var maxExt = new Extent(extent, this.getProjection());
      this.options['maxExtent'] = maxExt;

      if (!this._verifyExtent(this._getPrjCenter())) {
        this._panTo(this._prjMaxExtent().getCenter());
      }

      var projection = this.getProjection();
      this._prjMaxExtent = maxExt.convertTo(function (c) {
        return projection.project(c);
      });
    } else {
      delete this.options['maxExtent'];
      delete this._prjMaxExtent;
    }

    return this;
  };

  _proto.getZoom = function getZoom() {
    return this._zoomLevel;
  };

  _proto.getZoomForScale = function getZoomForScale(scale, fromZoom, isFraction) {
    var zoom = this.getZoom();

    if (isNil(fromZoom)) {
      fromZoom = zoom;
    }

    if (scale === 1 && fromZoom === zoom) {
      return zoom;
    }

    var res = this._getResolution(fromZoom),
        targetRes = res / scale;

    var scaleZoom = this.getZoomFromRes(targetRes);

    if (isFraction) {
      return scaleZoom;
    } else {
      var delta = 1E-6;
      return this.getSpatialReference().getZoomDirection() < 0 ? Math.ceil(scaleZoom - delta) : Math.floor(scaleZoom + delta);
    }
  };

  _proto.getZoomFromRes = function getZoomFromRes(res) {
    var resolutions = this._getResolutions(),
        minRes = this._getResolution(this.getMinZoom()),
        maxRes = this._getResolution(this.getMaxZoom());

    if (minRes <= maxRes) {
      if (res <= minRes) {
        return this.getMinZoom();
      } else if (res >= maxRes) {
        return this.getMaxZoom();
      }
    } else if (res >= minRes) {
      return this.getMinZoom();
    } else if (res <= maxRes) {
      return this.getMaxZoom();
    }

    var l = resolutions.length;

    for (var i = 0; i < l - 1; i++) {
      if (!resolutions[i]) {
        continue;
      }

      var gap = resolutions[i + 1] - resolutions[i];
      var test = res - resolutions[i];

      if (sign(gap) === sign(test) && Math.abs(gap) >= Math.abs(test)) {
        return i + test / gap;
      }
    }

    return l - 1;
  };

  _proto.setZoom = function setZoom(zoom, options) {
    if (options === void 0) {
      options = {
        'animation': true
      };
    }

    if (isNaN(zoom) || isNil(zoom)) {
      return this;
    }

    zoom = +zoom;

    if (this._loaded && this.options['zoomAnimation'] && options['animation']) {
      this._zoomAnimation(zoom);
    } else {
      this._zoom(zoom);
    }

    return this;
  };

  _proto.getMaxZoom = function getMaxZoom() {
    if (!isNil(this.options['maxZoom'])) {
      return this.options['maxZoom'];
    }

    return this.getMaxNativeZoom();
  };

  _proto.setMaxZoom = function setMaxZoom(maxZoom) {
    var viewMaxZoom = this.getMaxNativeZoom();

    if (maxZoom > viewMaxZoom) {
      maxZoom = viewMaxZoom;
    }

    if (maxZoom !== null && maxZoom < this._zoomLevel) {
      this.setZoom(maxZoom);
      maxZoom = +maxZoom;
    }

    this.options['maxZoom'] = maxZoom;
    return this;
  };

  _proto.getMinZoom = function getMinZoom() {
    if (!isNil(this.options['minZoom'])) {
      return this.options['minZoom'];
    }

    return this._spatialReference.getMinZoom();
  };

  _proto.setMinZoom = function setMinZoom(minZoom) {
    if (minZoom !== null) {
      minZoom = +minZoom;

      var viewMinZoom = this._spatialReference.getMinZoom();

      if (minZoom < viewMinZoom) {
        minZoom = viewMinZoom;
      }

      if (minZoom > this._zoomLevel) {
        this.setZoom(minZoom);
      }
    }

    this.options['minZoom'] = minZoom;
    return this;
  };

  _proto.getMaxNativeZoom = function getMaxNativeZoom() {
    var ref = this.getSpatialReference();

    if (!ref) {
      return null;
    }

    return ref.getMaxZoom();
  };

  _proto.getGLZoom = function getGLZoom() {
    return this.getMaxNativeZoom() / 2;
  };

  _proto.getGLScale = function getGLScale(zoom) {
    if (isNil(zoom)) {
      zoom = this.getZoom();
    }

    return this._getResolution(zoom) / this._getResolution(this.getGLZoom());
  };

  _proto.zoomIn = function zoomIn() {
    return this.setZoom(this.getZoom() + 1);
  };

  _proto.zoomOut = function zoomOut() {
    return this.setZoom(this.getZoom() - 1);
  };

  _proto.isZooming = function isZooming() {
    return !!this._zooming;
  };

  _proto.isInteracting = function isInteracting() {
    return this.isZooming() || this.isMoving() || this.isRotating();
  };

  _proto.setCenterAndZoom = function setCenterAndZoom(center, zoom) {
    if (!isNil(zoom) && this._zoomLevel !== zoom) {
      this.setCenter(center);
      this.setZoom(zoom, {
        animation: false
      });
    } else {
      this.setCenter(center);
    }

    return this;
  };

  _proto.getFitZoom = function getFitZoom(extent, isFraction) {
    var _this2 = this;

    if (!extent || !(extent instanceof Extent)) {
      return this._zoomLevel;
    }

    if (extent['xmin'] === extent['xmax'] && extent['ymin'] === extent['ymax']) {
      return this.getMaxZoom();
    }

    var size = this.getSize();
    var containerExtent = extent.convertTo(function (p) {
      return _this2.coordToContainerPoint(p);
    });
    var w = containerExtent.getWidth(),
        h = containerExtent.getHeight();
    var scaleX = size['width'] / w,
        scaleY = size['height'] / h;
    var scale = this.getSpatialReference().getZoomDirection() < 0 ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);
    var zoom = this.getZoomForScale(scale, null, isFraction);
    return zoom;
  };

  _proto.getView = function getView() {
    return {
      'center': this.getCenter().toArray(),
      'zoom': this.getZoom(),
      'pitch': this.getPitch(),
      'bearing': this.getBearing()
    };
  };

  _proto.setView = function setView(view) {
    if (!view) {
      return this;
    }

    if (view['center']) {
      this.setCenter(view['center']);
    }

    if (view['zoom'] !== null && !isNaN(+view['zoom'])) {
      this.setZoom(+view['zoom'], {
        'animation': false
      });
    }

    if (view['pitch'] !== null && !isNaN(+view['pitch'])) {
      this.setPitch(+view['pitch']);
    }

    if (view['pitch'] !== null && !isNaN(+view['bearing'])) {
      this.setBearing(+view['bearing']);
    }

    return this;
  };

  _proto.getResolution = function getResolution(zoom) {
    return this._getResolution(zoom);
  };

  _proto.getScale = function getScale(zoom) {
    var z = isNil(zoom) ? this.getZoom() : zoom;

    var max = this._getResolution(this.getMaxNativeZoom()),
        res = this._getResolution(z);

    return res / max;
  };

  _proto.fitExtent = function fitExtent(extent, zoomOffset, options, step) {
    if (options === void 0) {
      options = {};
    }

    if (!extent) {
      return this;
    }

    extent = new Extent(extent, this.getProjection());
    var zoom = this.getFitZoom(extent) + (zoomOffset || 0);
    var center = extent.getCenter();
    if (typeof options['animation'] === 'undefined' || options['animation']) return this._animateTo({
      center: center,
      zoom: zoom
    }, {
      'duration': options['duration'] || this.options['zoomAnimationDuration'],
      'easing': options['easing'] || 'out'
    }, step);else return this.setCenterAndZoom(center, zoom);
  };

  _proto.getBaseLayer = function getBaseLayer() {
    return this._baseLayer;
  };

  _proto.setBaseLayer = function setBaseLayer(baseLayer) {
    var isChange = false;

    if (this._baseLayer) {
      isChange = true;

      this._fireEvent('baselayerchangestart');

      this._baseLayer.remove();
    }

    if (!baseLayer) {
      delete this._baseLayer;

      this._fireEvent('baselayerchangeend');

      this._fireEvent('setbaselayer');

      return this;
    }

    this._baseLayer = baseLayer;

    baseLayer._bindMap(this, -1);

    function onbaseLayerload() {
      this._fireEvent('baselayerload');

      if (isChange) {
        isChange = false;

        this._fireEvent('baselayerchangeend');
      }
    }

    this._baseLayer.on('layerload', onbaseLayerload, this);

    if (this._loaded) {
      this._baseLayer.load();
    }

    this._fireEvent('setbaselayer');

    return this;
  };

  _proto.removeBaseLayer = function removeBaseLayer() {
    if (this._baseLayer) {
      this._baseLayer.remove();

      delete this._baseLayer;

      this._fireEvent('baselayerremove');
    }

    return this;
  };

  _proto.getLayers = function getLayers(filter) {
    return this._getLayers(function (layer) {
      if (layer === this._baseLayer || layer.getId().indexOf(INTERNAL_LAYER_PREFIX) >= 0) {
        return false;
      }

      if (filter) {
        return filter(layer);
      }

      return true;
    });
  };

  _proto.getLayer = function getLayer(id) {
    if (!id) {
      return null;
    }

    var layer = this._layerCache ? this._layerCache[id] : null;

    if (layer) {
      return layer;
    }

    var baseLayer = this.getBaseLayer();

    if (baseLayer && baseLayer.getId() === id) {
      return baseLayer;
    }

    return null;
  };

  _proto.addLayer = function addLayer(layers) {
    if (!layers) {
      return this;
    }

    if (!Array.isArray(layers)) {
      layers = Array.prototype.slice.call(arguments, 0);
      return this.addLayer(layers);
    }

    if (!this._layerCache) {
      this._layerCache = {};
    }

    var mapLayers = this._layers;

    for (var i = 0, len = layers.length; i < len; i++) {
      var layer = layers[i];
      var id = layer.getId();

      if (isNil(id)) {
        throw new Error('Invalid id for the layer: ' + id);
      }

      if (layer.getMap() === this) {
        continue;
      }

      if (this._layerCache[id]) {
        throw new Error('Duplicate layer id in the map: ' + id);
      }

      this._layerCache[id] = layer;

      layer._bindMap(this);

      mapLayers.push(layer);

      if (this._loaded) {
        layer.load();
      }
    }

    this._sortLayersByZIndex();

    this._fireEvent('addlayer', {
      'layers': layers
    });

    return this;
  };

  _proto.removeLayer = function removeLayer(layers) {
    if (!layers) {
      return this;
    }

    if (!Array.isArray(layers)) {
      return this.removeLayer([layers]);
    }

    var removed = [];

    for (var i = 0, len = layers.length; i < len; i++) {
      var layer = layers[i];

      if (!(layer instanceof Layer)) {
        layer = this.getLayer(layer);
      }

      if (!layer) {
        continue;
      }

      var map = layer.getMap();

      if (!map || map !== this) {
        continue;
      }

      removed.push(layer);

      this._removeLayer(layer, this._layers);

      if (this._loaded) {
        layer._doRemove();
      }

      var id = layer.getId();

      if (this._layerCache) {
        delete this._layerCache[id];
      }
    }

    if (removed.length > 0) {
      var renderer = this.getRenderer();

      if (renderer) {
        renderer.setLayerCanvasUpdated();
      }

      this.once('frameend', function () {
        removed.forEach(function (layer) {
          layer.fire('remove');
        });
      });
    }

    this._fireEvent('removelayer', {
      'layers': layers
    });

    return this;
  };

  _proto.sortLayers = function sortLayers(layers) {
    if (!layers || !Array.isArray(layers)) {
      return this;
    }

    var layersToOrder = [];
    var minZ = Number.MAX_VALUE;

    for (var i = 0, l = layers.length; i < l; i++) {
      var layer = layers[i];

      if (isString(layers[i])) {
        layer = this.getLayer(layer);
      }

      if (!(layer instanceof Layer) || !layer.getMap() || layer.getMap() !== this) {
        throw new Error('It must be a layer added to this map to order.');
      }

      if (layer.getZIndex() < minZ) {
        minZ = layer.getZIndex();
      }

      layersToOrder.push(layer);
    }

    for (var _i = 0, _l = layersToOrder.length; _i < _l; _i++) {
      layersToOrder[_i].setZIndex(minZ + _i);
    }

    return this;
  };

  _proto.toDataURL = function toDataURL(options) {
    if (!options) {
      options = {};
    }

    var mimeType = options['mimeType'];

    if (!mimeType) {
      mimeType = 'image/png';
    }

    var save = options['save'];

    var renderer = this._getRenderer();

    if (renderer && renderer.toDataURL) {
      var file = options['fileName'];

      if (!file) {
        file = 'export';
      }

      var dataURL = renderer.toDataURL(mimeType);

      if (save && dataURL) {
        var imgURL;

        if (typeof Blob !== 'undefined' && typeof atob !== 'undefined') {
          var blob = b64toBlob(dataURL.replace(/^data:image\/(png|jpeg|jpg);base64,/, ''), mimeType);
          imgURL = URL.createObjectURL(blob);
        } else {
          imgURL = dataURL;
        }

        var dlLink = document.createElement('a');
        dlLink.download = file;
        dlLink.href = imgURL;
        document.body.appendChild(dlLink);
        dlLink.click();
        document.body.removeChild(dlLink);
      }

      return dataURL;
    }

    return null;
  };

  _proto.coordToPoint = function coordToPoint(coordinate, zoom, out) {
    return this.coordinateToPoint(coordinate, zoom, out);
  };

  _proto.pointToCoord = function pointToCoord(point, zoom, out) {
    return this.pointToCoordinate(point, zoom, out);
  };

  _proto.coordToViewPoint = function coordToViewPoint(coordinate, out, altitude) {
    return this.coordinateToViewPoint(coordinate, out, altitude);
  };

  _proto.viewPointToCoord = function viewPointToCoord(viewPoint, out) {
    return this.viewPointToCoordinate(viewPoint, out);
  };

  _proto.coordToContainerPoint = function coordToContainerPoint(coordinate, zoom, out) {
    return this.coordinateToContainerPoint(coordinate, zoom, out);
  };

  _proto.containerPointToCoord = function containerPointToCoord(containerPoint, out) {
    return this.containerPointToCoordinate(containerPoint, out);
  };

  _proto.containerPointToViewPoint = function containerPointToViewPoint(containerPoint, out) {
    if (out) {
      out.set(containerPoint.x, containerPoint.y);
    } else {
      out = containerPoint.copy();
    }

    return out._sub(this.getViewPoint());
  };

  _proto.viewPointToContainerPoint = function viewPointToContainerPoint(viewPoint, out) {
    if (out) {
      out.set(viewPoint.x, viewPoint.y);
    } else {
      out = viewPoint.copy();
    }

    return out._add(this.getViewPoint());
  };

  _proto.checkSize = function checkSize() {
    var justStart = now() - this._initTime < 1500 && this.width === 0 || this.height === 0;

    var watched = this._getContainerDomSize(),
        oldHeight = this.height,
        oldWidth = this.width;

    if (watched['width'] === oldWidth && watched['height'] === oldHeight) {
      return this;
    }

    var center = this.getCenter();

    if (!this.options['fixCenterOnResize']) {
      var vh = this._getVisualHeight(this.getPitch());

      var nwCP = new Point(0, this.height - vh);

      var nwCoord = this._containerPointToPrj(nwCP);

      this._updateMapSize(watched);

      var vhAfter = this._getVisualHeight(this.getPitch());

      var nwCPAfter = new Point(0, this.height - vhAfter);

      this._setPrjCoordAtContainerPoint(nwCoord, nwCPAfter);

      this._mapViewCoord = this._getPrjCenter();
    } else {
      this._updateMapSize(watched);
    }

    var hided = watched['width'] === 0 || watched['height'] === 0 || oldWidth === 0 || oldHeight === 0;

    if (justStart || hided) {
      this._eventSilence = true;
      this.setCenter(center);
      delete this._eventSilence;
    }

    this._fireEvent('resize');

    return this;
  };

  _proto.locate = function locate(coordinate, dx, dy) {
    return this.getProjection()._locate(new Coordinate(coordinate), dx, dy);
  };

  _proto.getMainPanel = function getMainPanel() {
    return this._getRenderer().getMainPanel();
  };

  _proto.getPanels = function getPanels() {
    return this._panels;
  };

  _proto.remove = function remove() {
    var _this3 = this;

    if (this.isRemoved()) {
      return this;
    }

    this._fireEvent('removestart');

    this._removeDomEvents();

    this._clearHandlers();

    this.removeBaseLayer();
    var layers = this.getLayers();

    for (var i = 0; i < layers.length; i++) {
      layers[i].remove();
    }

    if (this._getRenderer()) {
      this._getRenderer().remove();
    }

    if (this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0) {
      Array.prototype.slice.call(this._containerDOM.childNodes, 0).filter(function (node) {
        return node.className === 'maptalks-wrapper';
      }).forEach(function (node) {
        return _this3._containerDOM.removeChild(node);
      });
    }

    delete this._panels;
    delete this._containerDOM;
    delete this.renderer;

    this._fireEvent('removeend');

    this._clearAllListeners();

    return this;
  };

  _proto.isRemoved = function isRemoved() {
    return !this._containerDOM;
  };

  _proto.isMoving = function isMoving() {
    return !!this._moving;
  };

  _proto.onMoveStart = function onMoveStart(param) {
    var prjCenter = this._getPrjCenter();

    if (!this._originCenter || this._verifyExtent(prjCenter)) {
      this._originCenter = prjCenter;
    }

    this._moving = true;

    this._trySetCursor('move');

    this._fireEvent('movestart', this._parseEvent(param ? param['domEvent'] : null, 'movestart'));
  };

  _proto.onMoving = function onMoving(param) {
    this._fireEvent('moving', this._parseEvent(param ? param['domEvent'] : null, 'moving'));
  };

  _proto.onMoveEnd = function onMoveEnd(param) {
    this._moving = false;

    this._trySetCursor('default');

    this._fireEvent('moveend', param && param['domEvent'] ? this._parseEvent(param['domEvent'], 'moveend') : param);

    if (!this._verifyExtent(this._getPrjCenter()) && this._originCenter) {
      var moveTo = this._originCenter;

      this._panTo(moveTo);
    }
  };

  _proto.onDragRotateStart = function onDragRotateStart(param) {
    this._dragRotating = true;

    this._fireEvent('dragrotatestart', this._parseEvent(param ? param['domEvent'] : null, 'dragrotatestart'));
  };

  _proto.onDragRotating = function onDragRotating(param) {
    this._fireEvent('dragrotating', this._parseEvent(param ? param['domEvent'] : null, 'dragrotating'));
  };

  _proto.onDragRotateEnd = function onDragRotateEnd(param) {
    this._dragRotating = false;

    this._fireEvent('dragrotateend', this._parseEvent(param ? param['domEvent'] : null, 'dragrotateend'));
  };

  _proto.isDragRotating = function isDragRotating() {
    return !!this._dragRotating;
  };

  _proto.getRenderer = function getRenderer() {
    return this._getRenderer();
  };

  _proto.getDevicePixelRatio = function getDevicePixelRatio() {
    return this.options['devicePixelRatio'] || Browser$1.devicePixelRatio || 1;
  };

  _proto._initContainer = function _initContainer(container) {
    if (isString(container)) {
      this._containerDOM = document.getElementById(container);

      if (!this._containerDOM) {
        throw new Error('Invalid container when creating map: \'' + container + '\'');
      }
    } else {
      this._containerDOM = container;

      if (IS_NODE) {
        this.CanvasClass = this._containerDOM.constructor;
      }
    }

    if (this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0) {
      if (this._containerDOM.childNodes[0].className === 'maptalks-wrapper') {
        throw new Error('Container is already loaded with another map instance, use map.remove() to clear it.');
      }
    }
  };

  _proto._trySetCursor = function _trySetCursor(cursor) {
    if (!this._cursor && !this._priorityCursor) {
      if (!cursor) {
        cursor = 'default';
      }

      this._setCursorToPanel(cursor);
    }

    return this;
  };

  _proto._setPriorityCursor = function _setPriorityCursor(cursor) {
    if (!cursor) {
      var hasCursor = false;

      if (this._priorityCursor) {
        hasCursor = true;
      }

      delete this._priorityCursor;

      if (hasCursor) {
        this.setCursor(this._cursor);
      }
    } else {
      this._priorityCursor = cursor;

      this._setCursorToPanel(cursor);
    }

    return this;
  };

  _proto._setCursorToPanel = function _setCursorToPanel(cursor) {
    var panel = this.getMainPanel();

    if (panel && panel.style && panel.style.cursor !== cursor) {
      panel.style.cursor = cursor;
    }
  };

  _proto._removeLayer = function _removeLayer(layer, layerList) {
    if (!layer || !layerList) {
      return;
    }

    var index = layerList.indexOf(layer);

    if (index > -1) {
      layerList.splice(index, 1);
    }
  };

  _proto._sortLayersByZIndex = function _sortLayersByZIndex() {
    if (!this._layers) {
      return;
    }

    for (var i = 0, l = this._layers.length; i < l; i++) {
      this._layers[i]._order = i;
    }

    this._layers.sort(function (a, b) {
      var c = a.getZIndex() - b.getZIndex();

      if (c === 0) {
        return a._order - b._order;
      }

      return c;
    });
  };

  _proto._fireEvent = function _fireEvent(eventName, param) {
    if (this._eventSilence) {
      return;
    }

    this.fire('_' + eventName, param);
    this.fire(eventName, param);
  };

  _proto._Load = function _Load() {
    this._resetMapStatus();

    if (this.options['pitch']) {
      this.setPitch(this.options['pitch']);
      delete this.options['pitch'];
    }

    if (this.options['bearing']) {
      this.setBearing(this.options['bearing']);
      delete this.options['bearing'];
    }

    this._loadAllLayers();

    this._getRenderer().onLoad();

    this._loaded = true;

    this._callOnLoadHooks();

    this._initTime = now();
  };

  _proto._initRenderer = function _initRenderer() {
    var renderer = this.options['renderer'];
    var clazz = Map.getRendererClass(renderer);
    this._renderer = new clazz(this);

    this._renderer.load();
  };

  _proto._getRenderer = function _getRenderer() {
    return this._renderer;
  };

  _proto._loadAllLayers = function _loadAllLayers() {
    function loadLayer(layer) {
      if (layer) {
        layer.load();
      }
    }

    if (this._baseLayer) {
      this._baseLayer.load();
    }

    this._eachLayer(loadLayer, this.getLayers());
  };

  _proto._getLayers = function _getLayers(filter) {
    var layers = this._baseLayer ? [this._baseLayer].concat(this._layers) : this._layers;
    var result = [];

    for (var i = 0; i < layers.length; i++) {
      if (!filter || filter.call(this, layers[i])) {
        result.push(layers[i]);
      }
    }

    return result;
  };

  _proto._eachLayer = function _eachLayer(fn) {
    if (arguments.length < 2) {
      return;
    }

    var layerLists = Array.prototype.slice.call(arguments, 1);

    if (layerLists && !Array.isArray(layerLists)) {
      layerLists = [layerLists];
    }

    var layers = [];

    for (var i = 0, len = layerLists.length; i < len; i++) {
      layers = layers.concat(layerLists[i]);
    }

    for (var j = 0, jlen = layers.length; j < jlen; j++) {
      fn.call(fn, layers[j]);
    }
  };

  _proto._onLayerEvent = function _onLayerEvent(param) {
    if (!param) {
      return;
    }

    if (param['type'] === 'idchange') {
      delete this._layerCache[param['old']];
      this._layerCache[param['new']] = param['target'];
    }
  };

  _proto._resetMapStatus = function _resetMapStatus() {
    var maxZoom = this.getMaxZoom(),
        minZoom = this.getMinZoom();

    var viewMaxZoom = this._spatialReference.getMaxZoom(),
        viewMinZoom = this._spatialReference.getMinZoom();

    if (isNil(maxZoom) || maxZoom === -1 || maxZoom > viewMaxZoom) {
      this.setMaxZoom(viewMaxZoom);
    }

    if (isNil(minZoom) || minZoom === -1 || minZoom < viewMinZoom) {
      this.setMinZoom(viewMinZoom);
    }

    maxZoom = this.getMaxZoom();
    minZoom = this.getMinZoom();

    if (maxZoom < minZoom) {
      this.setMaxZoom(minZoom);
    }

    if (isNil(this._zoomLevel) || this._zoomLevel > maxZoom) {
      this._zoomLevel = maxZoom;
    }

    if (this._zoomLevel < minZoom) {
      this._zoomLevel = minZoom;
    }

    delete this._prjCenter;
    var projection = this.getProjection();
    this._prjCenter = projection.project(this._center);

    this._calcMatrices();

    var renderer = this._getRenderer();

    if (renderer) {
      renderer.resetContainer();
    }
  };

  _proto._getContainerDomSize = function _getContainerDomSize() {
    if (!this._containerDOM) {
      return null;
    }

    var containerDOM = this._containerDOM;
    var width, height;

    if (!isNil(containerDOM.width) && !isNil(containerDOM.height)) {
      width = containerDOM.width;
      height = containerDOM.height;
      var dpr = this.getDevicePixelRatio();

      if (dpr !== 1 && containerDOM['layer']) {
        width /= dpr;
        height /= dpr;
      }
    } else if (!isNil(containerDOM.clientWidth) && !isNil(containerDOM.clientHeight)) {
      width = parseInt(containerDOM.clientWidth, 0);
      height = parseInt(containerDOM.clientHeight, 0);
    } else {
      throw new Error('can not get size of container');
    }

    return new Size(width, height);
  };

  _proto._updateMapSize = function _updateMapSize(mSize) {
    this.width = mSize['width'];
    this.height = mSize['height'];

    this._getRenderer().updateMapSize(mSize);

    this._calcMatrices();

    return this;
  };

  _proto._getPrjCenter = function _getPrjCenter() {
    return this._prjCenter;
  };

  _proto._setPrjCenter = function _setPrjCenter(pcenter) {
    this._prjCenter = pcenter;

    if (this.isInteracting() && !this.isMoving()) {
      this._mapViewCoord = pcenter;
    }

    this._calcMatrices();
  };

  _proto._setPrjCoordAtContainerPoint = function _setPrjCoordAtContainerPoint(coordinate, point) {
    if (point.x === this.width / 2 && point.y === this.height / 2) {
      return this;
    }

    var t = this._containerPointToPoint(point)._sub(this._prjToPoint(this._getPrjCenter()));

    var pcenter = this._pointToPrj(this._prjToPoint(coordinate).sub(t));

    this._setPrjCenter(pcenter);

    return this;
  };

  _proto._verifyExtent = function _verifyExtent(prjCenter) {
    if (!prjCenter) {
      return false;
    }

    var maxExt = this._prjMaxExtent;

    if (!maxExt) {
      return true;
    }

    return maxExt.contains(prjCenter);
  };

  _proto._offsetCenterByPixel = function _offsetCenterByPixel(pixel) {
    var pos = new Point(this.width / 2 - pixel.x, this.height / 2 - pixel.y);

    var pCenter = this._containerPointToPrj(pos);

    this._setPrjCenter(pCenter);

    return pCenter;
  };

  _proto.offsetPlatform = function offsetPlatform(offset) {
    if (!offset) {
      return this._mapViewPoint;
    } else {
      this._getRenderer().offsetPlatform(offset);

      this._mapViewCoord = this._getPrjCenter();
      this._mapViewPoint = this._mapViewPoint.add(offset);
      return this;
    }
  };

  _proto.getViewPoint = function getViewPoint() {
    var offset = this._getViewPointFrameOffset();

    var panelOffset = this.offsetPlatform();

    if (offset) {
      panelOffset = panelOffset.add(offset);
    }

    return panelOffset;
  };

  _proto._resetMapViewPoint = function _resetMapViewPoint() {
    this._mapViewPoint = new Point(0, 0);
    this._mapViewCoord = this._getPrjCenter();
  };

  _proto._getResolution = function _getResolution(zoom) {
    if ((zoom === undefined || zoom === this._zoomLevel) && this._mapRes !== undefined) {
      return this._mapRes;
    } else if (zoom === this.getGLZoom() && this._mapGlRes !== undefined) {
      return this._mapGlRes;
    }

    if (isNil(zoom)) {
      zoom = this._zoomLevel;
    }

    return this._spatialReference.getResolution(zoom);
  };

  _proto._getResolutions = function _getResolutions() {
    return this._spatialReference.getResolutions();
  };

  _proto._prjToPoint = function _prjToPoint(pCoord, zoom, out) {
    zoom = isNil(zoom) ? this.getZoom() : zoom;
    return this._spatialReference.getTransformation().transform(pCoord, this._getResolution(zoom), out);
  };

  _proto._pointToPrj = function _pointToPrj(point, zoom, out) {
    zoom = isNil(zoom) ? this.getZoom() : zoom;
    return this._spatialReference.getTransformation().untransform(point, this._getResolution(zoom), out);
  };

  _proto._pointToPoint = function _pointToPoint(point, zoom, out) {
    if (out) {
      out.x = point.x;
      out.y = point.y;
    } else {
      out = point.copy();
    }

    if (!isNil(zoom)) {
      return out._multi(this._getResolution(zoom) / this._getResolution());
    }

    return out;
  };

  _proto._pointToPointAtZoom = function _pointToPointAtZoom(point, zoom, out) {
    if (out) {
      out.x = point.x;
      out.y = point.y;
    } else {
      out = point.copy();
    }

    if (!isNil(zoom)) {
      return out._multi(this._getResolution() / this._getResolution(zoom));
    }

    return out;
  };

  _proto._containerPointToPrj = function _containerPointToPrj(containerPoint, out) {
    return this._pointToPrj(this._containerPointToPoint(containerPoint, undefined, out), undefined, out);
  };

  _proto._callOnLoadHooks = function _callOnLoadHooks() {
    var proto = Map.prototype;

    if (!proto._onLoadHooks) {
      return;
    }

    for (var i = 0, l = proto._onLoadHooks.length; i < l; i++) {
      proto._onLoadHooks[i].call(this);
    }
  };

  return Map;
}(Handlerable(Eventable(Renderable(Class))));

Map$1.include({
  coordinateToPoint: function () {
    var COORD = new Coordinate(0, 0);
    return function (coordinate, zoom, out) {
      var prjCoord = this.getProjection().project(coordinate, COORD);
      return this._prjToPoint(prjCoord, zoom, out);
    };
  }(),
  pointToCoordinate: function () {
    var COORD = new Coordinate(0, 0);
    return function (point, zoom, out) {
      var prjCoord = this._pointToPrj(point, zoom, COORD);

      return this.getProjection().unproject(prjCoord, out);
    };
  }(),
  coordinateToViewPoint: function () {
    var COORD = new Coordinate(0, 0);
    return function (coordinate, out, altitude) {
      return this._prjToViewPoint(this.getProjection().project(coordinate, COORD), out, altitude);
    };
  }(),
  viewPointToCoordinate: function () {
    var COORD = new Coordinate(0, 0);
    return function (viewPoint, out) {
      return this.getProjection().unproject(this._viewPointToPrj(viewPoint, COORD), out);
    };
  }(),
  coordinateToContainerPoint: function () {
    var COORD = new Coordinate(0, 0);
    return function (coordinate, zoom, out) {
      var pCoordinate = this.getProjection().project(coordinate, COORD);
      return this._prjToContainerPoint(pCoordinate, zoom, out);
    };
  }(),
  containerPointToCoordinate: function () {
    var COORD = new Coordinate(0, 0);
    return function (containerPoint, out) {
      var pCoordinate = this._containerPointToPrj(containerPoint, COORD);

      return this.getProjection().unproject(pCoordinate, out);
    };
  }(),
  containerToExtent: function () {
    var POINT0 = new Point(0, 0);
    var POINT1 = new Point(0, 0);
    return function (containerExtent) {
      var extent2D = new PointExtent(this._containerPointToPoint(containerExtent.getMin(POINT0), undefined, POINT0), this._containerPointToPoint(containerExtent.getMax(POINT1), undefined, POINT1));
      return this._pointToExtent(extent2D);
    };
  }(),
  distanceToPixel: function () {
    var POINT0 = new Point(0, 0);
    var POINT1 = new Point(0, 0);
    return function (xDist, yDist, zoom) {
      var projection = this.getProjection();

      if (!projection) {
        return null;
      }

      var scale = this.getScale() / this.getScale(zoom);
      var center = this.getCenter(),
          target = projection.locate(center, xDist, yDist);
      var p0 = this.coordToContainerPoint(center, undefined, POINT0),
          p1 = this.coordToContainerPoint(target, undefined, POINT1);

      p1._sub(p0)._multi(scale)._abs();

      return new Size(p1.x, p1.y);
    };
  }(),
  distanceToPoint: function () {
    var POINT = new Point(0, 0);
    return function (xDist, yDist, zoom, paramCenter) {
      var projection = this.getProjection();

      if (!projection) {
        return null;
      }

      var center = paramCenter || this.getCenter(),
          target = projection.locate(center, xDist, yDist);
      var p0 = this.coordToPoint(center, zoom, POINT),
          p1 = this.coordToPoint(target, zoom);

      p1._sub(p0)._abs();

      return p1;
    };
  }(),
  pixelToDistance: function () {
    var COORD0 = new Coordinate(0, 0);
    var COORD1 = new Coordinate(0, 0);
    return function (width, height) {
      var projection = this.getProjection();

      if (!projection) {
        return null;
      }

      var fullExt = this.getFullExtent();
      var d = fullExt['top'] > fullExt['bottom'] ? -1 : 1;
      var target = COORD0.set(this.width / 2 + width, this.height / 2 + d * height);
      var coord = this.containerPointToCoord(target, COORD1);
      return projection.measureLength(this.getCenter(), coord);
    };
  }(),
  pointToDistance: function () {
    var POINT = new Point(0, 0);
    var COORD = new Coordinate(0, 0);
    return function (dx, dy, zoom) {
      var projection = this.getProjection();

      if (!projection) {
        return null;
      }

      var c = this._prjToPoint(this._getPrjCenter(), zoom, POINT);

      c._add(dx, dy);

      var target = this.pointToCoord(c, zoom, COORD);
      return projection.measureLength(this.getCenter(), target);
    };
  }(),
  locateByPoint: function () {
    var POINT = new Point(0, 0);
    return function (coordinate, px, py) {
      var point = this.coordToContainerPoint(coordinate, undefined, POINT);
      return this.containerPointToCoord(point._add(px, py));
    };
  }(),
  _get2DExtent: function () {
    var POINT = new Point(0, 0);
    return function (zoom, out) {
      var _this4 = this;

      var cached;

      if ((zoom === undefined || zoom === this._zoomLevel) && this._mapExtent2D) {
        cached = this._mapExtent2D;
      } else if (zoom === this.getGLZoom() && this._mapGlExtent2D) {
        cached = this._mapGlExtent2D;
      }

      if (cached) {
        if (out) {
          out.set(cached['xmin'], cached['ymin'], cached['xmax'], cached['ymax']);
          return out;
        }

        return cached.copy();
      }

      var cExtent = this.getContainerExtent();
      return cExtent.convertTo(function (c) {
        return _this4._containerPointToPoint(c, zoom, POINT);
      }, out);
    };
  }(),
  _pointToExtent: function () {
    var COORD0 = new Coordinate(0, 0);
    var COORD1 = new Coordinate(0, 0);
    return function (extent2D) {
      var min2d = extent2D.getMin(),
          max2d = extent2D.getMax();
      var fullExtent = this.getFullExtent();

      var _ref = !fullExtent || fullExtent.left <= fullExtent.right ? [min2d.x, max2d.x] : [max2d.x, min2d.x],
          minx = _ref[0],
          maxx = _ref[1];

      var _ref2 = !fullExtent || fullExtent.top > fullExtent.bottom ? [max2d.y, min2d.y] : [min2d.y, max2d.y],
          miny = _ref2[0],
          maxy = _ref2[1];

      var min = min2d.set(minx, maxy);
      var max = max2d.set(maxx, miny);
      return new Extent(this.pointToCoord(min, undefined, COORD0), this.pointToCoord(max, undefined, COORD1), this.getProjection());
    };
  }(),
  _getViewPointFrameOffset: function () {
    var POINT = new Point(0, 0);
    return function () {
      if (this.isZooming()) {
        return null;
      }

      var pcenter = this._getPrjCenter();

      if (this._mapViewCoord && !this._mapViewCoord.equals(pcenter)) {
        return this._prjToContainerPoint(this._mapViewCoord)._sub(this._prjToContainerPoint(pcenter, undefined, POINT));
      }

      return null;
    };
  }(),
  _viewPointToPrj: function () {
    var POINT = new Point(0, 0);
    return function (viewPoint, out) {
      return this._containerPointToPrj(this.viewPointToContainerPoint(viewPoint, POINT), out);
    };
  }(),
  _prjToContainerPoint: function () {
    var POINT = new Point(0, 0);
    return function (pCoordinate, zoom, out, altitude) {
      return this._pointToContainerPoint(this._prjToPoint(pCoordinate, zoom, POINT), zoom, altitude || 0, out);
    };
  }(),
  _prjToViewPoint: function () {
    var POINT = new Point(0, 0);
    return function (pCoordinate, out, altitude) {
      var containerPoint = this._prjToContainerPoint(pCoordinate, undefined, POINT, altitude);

      return this.containerPointToViewPoint(containerPoint, out);
    };
  }(),
  _viewPointToPoint: function () {
    var POINT = new Point(0, 0);
    return function (viewPoint, zoom, out) {
      return this._containerPointToPoint(this.viewPointToContainerPoint(viewPoint, POINT), zoom, out);
    };
  }(),
  _pointToViewPoint: function () {
    var COORD = new Coordinate(0, 0);
    return function (point, zoom, out) {
      return this._prjToViewPoint(this._pointToPrj(point, zoom, COORD), out);
    };
  }()
});
Map$1.mergeOptions(options$2);

var MapDoubleClickZoomHandler = function (_Handler) {
  _inheritsLoose(MapDoubleClickZoomHandler, _Handler);

  function MapDoubleClickZoomHandler() {
    return _Handler.apply(this, arguments) || this;
  }

  var _proto = MapDoubleClickZoomHandler.prototype;

  _proto.addHooks = function addHooks() {
    if (!this.target) {
      return;
    }

    this.target.on('_dblclick', this._onDoubleClick, this);
  };

  _proto.removeHooks = function removeHooks() {
    if (!this.target) {
      return;
    }

    this.target.off('_dblclick', this._onDoubleClick, this);
  };

  _proto._onDoubleClick = function _onDoubleClick(param) {
    var map = this.target;

    if (map.options['doubleClickZoom']) {
      var oldZoom = map.getZoom(),
          zoom = param['domEvent']['shiftKey'] ? Math.ceil(oldZoom) - 1 : Math.floor(oldZoom) + 1;

      map._zoomAnimation(zoom, param['containerPoint']);
    }
  };

  return MapDoubleClickZoomHandler;
}(Handler$1);

Map$1.mergeOptions({
  'doubleClickZoom': true
});
Map$1.addOnLoadHook('addHandler', 'doubleClickZoom', MapDoubleClickZoomHandler);

var MapDragHandler = function (_Handler) {
  _inheritsLoose(MapDragHandler, _Handler);

  function MapDragHandler() {
    return _Handler.apply(this, arguments) || this;
  }

  var _proto = MapDragHandler.prototype;

  _proto.addHooks = function addHooks() {
    var map = this.target;

    if (!map) {
      return;
    }

    var dom = map._panels.mapWrapper || map._containerDOM;
    this._dragHandler = new DragHandler(dom, {
      'cancelOn': this._cancelOn.bind(this),
      'rightclick': true
    });

    this._dragHandler.on('mousedown', this._onMouseDown, this).on('dragstart', this._onDragStart, this).on('dragging', this._onDragging, this).on('dragend', this._onDragEnd, this).enable();
  };

  _proto.removeHooks = function removeHooks() {
    this._dragHandler.off('mousedown', this._onMouseDown, this).off('dragstart', this._onDragStart, this).off('dragging', this._onDragging, this).off('dragend', this._onDragEnd, this);

    this._dragHandler.remove();

    delete this._dragHandler;
  };

  _proto._cancelOn = function _cancelOn(domEvent) {
    if (this.target.isZooming() || this._ignore(domEvent)) {
      return true;
    }

    return false;
  };

  _proto._ignore = function _ignore(param) {
    if (!param) {
      return false;
    }

    if (param.domEvent) {
      param = param.domEvent;
    }

    return this.target._ignoreEvent(param);
  };

  _proto._onMouseDown = function _onMouseDown(param) {
    delete this.startDragTime;
    delete this._mode;

    if (param.domEvent.button === 2 || param.domEvent.ctrlKey) {
      if (this.target.options['dragRotate'] || this.target.options['dragPitch']) {
        this._mode = 'rotatePitch';
      }
    } else if (this.target.options['dragPan']) {
      this._mode = 'move';
    }

    this.target._stopAnim(this.target._mapAnimPlayer);

    preventDefault(param['domEvent']);
  };

  _proto._onDragStart = function _onDragStart(param) {
    this.startDragTime = now();

    if (this._mode === 'move') {
      this._moveStart(param);
    } else if (this._mode === 'rotatePitch') {
      this._rotateStart(param);
    }
  };

  _proto._onDragging = function _onDragging(param) {
    var map = this.target;

    if (map._isEventOutMap(param['domEvent'])) {
      return;
    }

    if (this._mode === 'move') {
      this._moving(param);
    } else if (this._mode === 'rotatePitch') {
      this._rotating(param);
    }
  };

  _proto._onDragEnd = function _onDragEnd(param) {
    if (this._mode === 'move') {
      this._moveEnd(param);
    } else if (this._mode === 'rotatePitch') {
      this._rotateEnd(param);
    }

    delete this.startDragTime;
    delete this.startBearing;
  };

  _proto._start = function _start(param) {
    this.preX = param['mousePos'].x;
    this.preY = param['mousePos'].y;
    this.startX = this.preX;
    this.startY = this.preY;
  };

  _proto._moveStart = function _moveStart(param) {
    this._start(param);

    var map = this.target;
    map.onMoveStart(param);
    var p = getEventContainerPoint(map._getActualEvent(param.domEvent), map.getContainer());
    this.startPrjCoord = map._containerPointToPrj(p);
  };

  _proto._moving = function _moving(param) {
    if (!this.startDragTime) {
      return;
    }

    var map = this.target;
    var p = getEventContainerPoint(map._getActualEvent(param.domEvent), map.getContainer());

    map._setPrjCoordAtContainerPoint(this.startPrjCoord, p);

    map.onMoving(param);
  };

  _proto._moveEnd = function _moveEnd(param) {
    if (!this.startDragTime) {
      return;
    }

    var map = this.target;
    var t = now() - this.startDragTime;
    var mx = param['mousePos'].x,
        my = param['mousePos'].y;
    var dx = mx - this.startX;
    var dy = my - this.startY;

    this._clear();

    if (map.options['panAnimation'] && !param.interupted && map._verifyExtent(map._getPrjCenter()) && t < 280 && Math.abs(dy) + Math.abs(dx) > 5) {
      t = 5 * t * (Math.abs(dx) + Math.abs(dy)) / 500;
      map.panBy(new Point(dx, dy), {
        'duration': t
      });
    } else {
      map.onMoveEnd(param);
    }
  };

  _proto._rotateStart = function _rotateStart(param) {
    this._start(param);

    delete this._rotateMode;
    this.startBearing = this.target.getBearing();
    this.target.onDragRotateStart(param);
    this._db = 0;
  };

  _proto._rotating = function _rotating(param) {
    var map = this.target;
    var mx = param['mousePos'].x,
        my = param['mousePos'].y;
    var prePitch = map.getPitch(),
        preBearing = map.getBearing();
    var dx = Math.abs(mx - this.preX),
        dy = Math.abs(my - this.preY);

    if (!this._rotateMode) {
      if (map.options['dragRotatePitch']) {
        this._rotateMode = 'rotate_pitch';
      } else if (dx > dy) {
        this._rotateMode = 'rotate';
      } else if (dx < dy) {
        this._rotateMode = 'pitch';
      } else {
        this._rotateMode = 'rotate';
      }
    }

    if (this._rotateMode === 'pitch' && prePitch === 0 && dy < 10) {
      return;
    }

    if (this._rotateMode.indexOf('rotate') >= 0 && map.options['dragRotate']) {
      var db = 0;

      if (map.options['dragPitch'] || dx > dy) {
        db = -0.6 * (this.preX - mx);
      } else if (mx > map.width / 2) {
        db = 0.6 * (this.preY - my);
      } else {
        db = -0.6 * (this.preY - my);
      }

      var bearing = map.getBearing() + db;
      this._db = this._db || 0;
      this._db += db;
      map.setBearing(bearing);
    }

    if (this._rotateMode.indexOf('pitch') >= 0 && map.options['dragPitch']) {
      map.setPitch(map.getPitch() + (this.preY - my) * 0.4);
    }

    this.preX = mx;
    this.preY = my;

    if (map.getBearing() !== preBearing || map.getPitch() !== prePitch) {
      map.onDragRotating(param);
    }
  };

  _proto._rotateEnd = function _rotateEnd(param) {
    var map = this.target;
    var bearing = map.getBearing();

    this._clear();

    var t = now() - this.startDragTime;
    map.onDragRotateEnd(param);

    if (Math.abs(bearing - this.startBearing) > 20 && (this._rotateMode === 'rotate' || this._rotateMode === 'rotate_pitch') && !param.interupted && t < 400) {
      var _bearing = map.getBearing();

      map._animateTo({
        'bearing': _bearing + this._db / 2
      }, {
        'easing': 'out',
        'duration': 800
      });
    }
  };

  _proto._clear = function _clear() {
    delete this.startPrjCoord;
    delete this.preX;
    delete this.preY;
    delete this.startX;
    delete this.startY;
  };

  return MapDragHandler;
}(Handler$1);

Map$1.mergeOptions({
  'draggable': true,
  'dragPan': true,
  'dragRotatePitch': true,
  'dragRotate': true,
  'dragPitch': true
});
Map$1.addOnLoadHook('addHandler', 'draggable', MapDragHandler);

var EVENTS = 'mousedown ' + 'mouseup ' + 'mousemove ' + 'click ' + 'dblclick ' + 'contextmenu ' + 'touchstart ' + 'touchmove ' + 'touchend';

var MapGeometryEventsHandler = function (_Handler) {
  _inheritsLoose(MapGeometryEventsHandler, _Handler);

  function MapGeometryEventsHandler() {
    return _Handler.apply(this, arguments) || this;
  }

  var _proto = MapGeometryEventsHandler.prototype;

  _proto.addHooks = function addHooks() {
    var map = this.target;
    var dom = map._panels.allLayers || map._containerDOM;
    on(dom, EVENTS, this._identifyGeometryEvents, this);
  };

  _proto.removeHooks = function removeHooks() {
    var map = this.target;
    var dom = map._panels.allLayers || map._containerDOM;
    off(dom, EVENTS, this._identifyGeometryEvents, this);
  };

  _proto._identifyGeometryEvents = function _identifyGeometryEvents(domEvent, type) {
    var map = this.target;

    if (map.isInteracting() || map._ignoreEvent(domEvent)) {
      return;
    }

    var layers = map._getLayers(function (layer) {
      if (layer.identify && layer.options['geometryEvents']) {
        return true;
      }

      return false;
    });

    if (!layers.length) {
      return;
    }

    var oneMoreEvent = null;
    var eventType = type || domEvent.type;

    if (eventType === 'mousedown' || eventType === 'touchstart' && domEvent.touches.length === 1) {
      this._mouseDownTime = now();
    } else if ((eventType === 'click' || eventType === 'touchend') && this._mouseDownTime) {
      var downTime = this._mouseDownTime;
      delete this._mouseDownTime;
      var time = now();

      if (time - downTime > 300) {
        if (eventType === 'click') {
          return;
        }
      } else if (eventType === 'touchend') {
        oneMoreEvent = 'click';
      }
    }

    var actual = domEvent.touches && domEvent.touches.length > 0 ? domEvent.touches[0] : domEvent.changedTouches && domEvent.changedTouches.length > 0 ? domEvent.changedTouches[0] : domEvent;

    if (!actual) {
      return;
    }

    var containerPoint = getEventContainerPoint(actual, map._containerDOM),
        coordinate = map.containerPointToCoordinate(containerPoint);

    if (eventType === 'touchstart') {
      preventDefault(domEvent);
    }

    var geometryCursorStyle = null;
    var identifyOptions = {
      'includeInternals': true,
      'filter': function filter(geometry) {
        if (!(geometry instanceof Geometry)) {
          return false;
        }

        var eventToFire = geometry._getEventTypeToFire(domEvent);

        if (eventType === 'mousemove') {
          if (!geometryCursorStyle && geometry.options['cursor']) {
            geometryCursorStyle = geometry.options['cursor'];
          }

          if (!geometry.listens('mousemove') && !geometry.listens('mouseover') && !geometry.listens('mouseenter')) {
            return false;
          }
        } else if (!geometry.listens(eventToFire) && !geometry.listens(oneMoreEvent)) {
          return false;
        }

        return true;
      },
      'count': 1,
      'coordinate': coordinate,
      'onlyVisible': map.options['onlyVisibleGeometryEvents'],
      'layers': layers
    };
    var callback = fireGeometryEvent.bind(this);

    if (eventType === 'mousemove' || eventType === 'touchmove') {
      this._queryIdentifyTimeout = map.getRenderer().callInNextFrame(function () {
        if (map.isInteracting()) {
          return;
        }

        map.identify(identifyOptions, callback);
      });
    } else {
      map.identify(identifyOptions, callback);
    }

    function fireGeometryEvent(geometries) {
      var propagation = true;

      if (eventType === 'mousemove') {
        var geoMap = {};

        if (geometries.length > 0) {
          for (var i = geometries.length - 1; i >= 0; i--) {
            var geo = geometries[i];

            if (!(geo instanceof Geometry)) {
              continue;
            }

            var iid = geo._getInternalId();

            geoMap[iid] = geo;

            geo._onEvent(domEvent);

            if (!this._prevOverGeos || !this._prevOverGeos.geomap[iid]) {
              geo._onEvent(domEvent, 'mouseenter');
            }

            propagation = geo._onEvent(domEvent, 'mouseover');
          }
        }

        map._setPriorityCursor(geometryCursorStyle);

        var oldTargets = this._prevOverGeos && this._prevOverGeos.geos;
        this._prevOverGeos = {
          'geos': geometries,
          'geomap': geoMap
        };

        if (oldTargets && oldTargets.length > 0) {
          for (var _i = oldTargets.length - 1; _i >= 0; _i--) {
            var oldTarget = oldTargets[_i];

            if (!(oldTarget instanceof Geometry)) {
              continue;
            }

            var oldTargetId = oldTargets[_i]._getInternalId();

            if (!geoMap[oldTargetId]) {
              propagation = oldTarget._onEvent(domEvent, 'mouseout');
            }
          }
        }
      } else {
        if (!geometries || !geometries.length) {
          return;
        }

        for (var _i2 = geometries.length - 1; _i2 >= 0; _i2--) {
          if (!(geometries[_i2] instanceof Geometry)) {
            continue;
          }

          propagation = geometries[_i2]._onEvent(domEvent);

          if (oneMoreEvent) {
            geometries[_i2]._onEvent(domEvent, oneMoreEvent);
          }

          break;
        }
      }

      if (propagation === false) {
        stopPropagation(domEvent);
      }
    }
  };

  return MapGeometryEventsHandler;
}(Handler$1);

Map$1.mergeOptions({
  'geometryEvents': true,
  'onlyVisibleGeometryEvents': true
});
Map$1.addOnLoadHook('addHandler', 'geometryEvents', MapGeometryEventsHandler);

var wheelZoomDelta = 4.000244140625;
var defaultZoomRate = 1 / 100;
var wheelZoomRate = 1 / 450;
var maxScalePerFrame = 2;

var MapScrollWheelZoomHandler = function (_Handler) {
  _inheritsLoose(MapScrollWheelZoomHandler, _Handler);

  function MapScrollWheelZoomHandler(target) {
    var _this;

    _this = _Handler.call(this, target) || this;
    _this._thisScrollZoom = _this._scrollZoom.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._wheelZoomRate = wheelZoomRate;
    _this._defaultZoomRate = defaultZoomRate;
    _this._delta = 0;
    return _this;
  }

  var _proto = MapScrollWheelZoomHandler.prototype;

  _proto.addHooks = function addHooks() {
    addDomEvent(this.target._containerDOM, 'wheel', this._onWheelScroll, this);
  };

  _proto.removeHooks = function removeHooks() {
    removeDomEvent(this.target._containerDOM, 'wheel', this._onWheelScroll);
  };

  _proto._onWheelScroll = function _onWheelScroll(evt) {
    preventDefault(evt);
    stopPropagation(evt);
    var map = this.target;

    if (map._ignoreEvent(evt) || !map.options['zoomable']) {
      return false;
    }

    var container = map._containerDOM;

    var origin = map._checkZoomOrigin(getEventContainerPoint(evt, container));

    if (map.options['seamlessZoom']) {
      if (!this._zooming) {
        this._trackPadSuspect = 0;
        this._ensureTrackpad = false;
      }

      return this._seamless(evt, origin);
    } else {
      return this._interval(evt, origin);
    }
  };

  _proto._seamless = function _seamless(evt, origin) {
    var value = evt.deltaMode === window.WheelEvent.DOM_DELTA_LINE ? evt.deltaY * 60 : evt.deltaY;

    if (value % wheelZoomDelta !== 0) {
      if (!this._ensureTrackpad) {
        if (Math.abs(value) < 60) {
          this._trackPadSuspect++;
        } else {
          this._trackPadSuspect = 0;
        }

        if (this._trackPadSuspect >= 2) {
          this._ensureTrackpad = true;
        }
      }

      if (this._ensureTrackpad) {
        value *= 14;
      }
    }

    if (evt.shiftKey && value) value = value / 4;
    this._lastWheelEvent = evt;
    this._delta -= value;

    if (!this._zooming && this._delta) {
      var map = this.target;
      this._zoomOrigin = origin;
      map.onZoomStart(null, origin);
    }

    this._start();
  };

  _proto._start = function _start() {
    if (!this._delta) return;
    this._zooming = true;
    var map = this.target;

    if (!this._active) {
      map.getRenderer().callInNextFrame(this._thisScrollZoom);
      this._active = true;
    }
  };

  _proto._scrollZoom = function _scrollZoom() {
    var _this2 = this;

    this._active = false;

    if (!this._delta) {
      return;
    }

    var zoomRate = Math.abs(this._delta) > wheelZoomDelta ? this._wheelZoomRate : this._defaultZoomRate;
    var scale = maxScalePerFrame / (1 + Math.exp(-Math.abs(this._delta * zoomRate)));

    if (this._delta < 0 && scale !== 0) {
      scale = 1 / scale;
    }

    var map = this.target;
    var zoom = map.getZoom();
    var targetZoom = map.getZoomForScale(scale, zoom, true);
    this._delta = 0;
    map.onZooming(targetZoom, this._zoomOrigin);

    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    this._timeout = setTimeout(function () {
      _this2._zooming = false;
      delete _this2._timeout;
      map.onZoomEnd(map.getZoom(), _this2._zoomOrigin);
    }, 210);
  };

  _proto._interval = function _interval(evt, origin) {
    var _this3 = this;

    var map = this.target;

    if (this._zooming) {
      this._requesting++;
      return false;
    }

    this._requesting = 0;
    var levelValue = (evt.deltaY ? evt.deltaY * -1 : evt.wheelDelta ? evt.wheelDelta : evt.detail) > 0 ? 1 : -1;

    if (evt.detail) {
      levelValue *= -1;
    }

    var zoom = map.getZoom();
    var nextZoom = zoom + levelValue;
    nextZoom = map._checkZoom(levelValue > 0 ? Math.ceil(nextZoom) : Math.floor(nextZoom));

    if (nextZoom === zoom) {
      return false;
    }

    this._zooming = true;

    if (!this._delta) {
      map.onZoomStart(null, origin);
      this._origin = origin;
      this._delta = levelValue;
      this._startZoom = map.getZoom();
    }

    var duration = 90;

    map._animateTo({
      'zoom': nextZoom - this._delta * 1 / 2,
      'around': this._origin
    }, {
      'continueOnViewChanged': true,
      'easing': 'linear',
      'duration': duration,
      'wheelZoom': true
    }, function (frame) {
      if (frame.state.playState !== 'finished') {
        if (frame.state.playState !== 'running') {
          delete _this3._zooming;
          delete _this3._requesting;
        }

        return;
      }

      if (_this3._requesting < 1 || Math.abs(nextZoom - _this3._startZoom) > 2 || nextZoom === map.getMaxZoom() || nextZoom === map.getMinZoom()) {
        map._animateTo({
          'zoom': nextZoom,
          'around': _this3._origin
        }, {
          'continueOnViewChanged': true,
          'duration': 100
        }, function (frame) {
          if (frame.state.playState !== 'running') {
            delete _this3._zooming;
            delete _this3._requesting;
          }
        });

        delete _this3._startZoom;
        delete _this3._origin;
        delete _this3._delta;
        _this3._requesting = 0;
      } else if (!isNil(_this3._requesting)) {
        delete _this3._zooming;

        _this3._onWheelScroll(evt);
      }
    });

    return false;
  };

  return MapScrollWheelZoomHandler;
}(Handler$1);

Map$1.mergeOptions({
  'scrollWheelZoom': true,
  'seamlessZoom': false
});
Map$1.addOnLoadHook('addHandler', 'scrollWheelZoom', MapScrollWheelZoomHandler);

var MapTouchZoomHandler = function (_Handler) {
  _inheritsLoose(MapTouchZoomHandler, _Handler);

  function MapTouchZoomHandler() {
    return _Handler.apply(this, arguments) || this;
  }

  var _proto = MapTouchZoomHandler.prototype;

  _proto.addHooks = function addHooks() {
    addDomEvent(this.target.getContainer(), 'touchstart', this._onTouchStart, this);
  };

  _proto.removeHooks = function removeHooks() {
    removeDomEvent(this.target.getContainer(), 'touchstart', this._onTouchStart);
  };

  _proto._onTouchStart = function _onTouchStart(event) {
    var map = this.target;

    if (!event.touches || event.touches.length < 2) {
      return;
    }

    var container = map.getContainer();
    var p1 = getEventContainerPoint(event.touches[0], container),
        p2 = getEventContainerPoint(event.touches[1], container);
    this.preY = p1.y;
    this._startP1 = p1;
    this._startP2 = p2;
    this._startDist = p1.distanceTo(p2);
    this._startVector = p1.sub(p2);
    this._startZoom = map.getZoom();
    this._startBearing = map.getBearing();
    off(document, 'touchmove', this._onTouchMove, this);
    off(document, 'touchend', this._onTouchEnd, this);
    addDomEvent(document, 'touchmove', this._onTouchMove, this);
    addDomEvent(document, 'touchend', this._onTouchEnd, this);
    preventDefault(event);

    map._fireEvent('touchactstart');
  };

  _proto._onTouchMove = function _onTouchMove(event) {
    var map = this.target;

    if (!event.touches || event.touches.length < 2) {
      return;
    }

    var container = map.getContainer(),
        p1 = getEventContainerPoint(event.touches[0], container),
        p2 = getEventContainerPoint(event.touches[1], container),
        d1 = p1.sub(this._startP1),
        d2 = p2.sub(this._startP2),
        vector = p1.sub(p2),
        scale = p1.distanceTo(p2) / this._startDist,
        bearing = vector.angleWith(this._startVector) * 180 / Math.PI,
        preY = this.preY || p1.y,
        pitch = (preY - p1.y) * 0.4;

    this.preY = p1.y;
    var param = {
      'domEvent': event,
      'mousePos': [p1, p2]
    };

    if (!this.mode) {
      if (map.options['touchRotate'] && Math.abs(bearing) > 8) {
        this.mode = map.options['touchZoomRotate'] ? 'rotate_zoom' : 'rotate';
      } else if (map.options['touchPitch'] && d1.y * d2.y > 0 && Math.abs(d1.y) > 10 && Math.abs(d2.y) > 10) {
        this.mode = 'pitch';
      } else if (map.options['zoomable'] && map.options['touchZoom'] && Math.abs(1 - scale) > 0.15) {
        this.mode = map.options['touchZoomRotate'] && map.options['touchRotate'] ? 'rotate_zoom' : 'zoom';
      }

      this._startTouching(param);
    }

    if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
      this._scale = scale;
      var res = map._getResolution(this._startZoom) / scale;
      var zoom = map.getZoomFromRes(res);
      map.onZooming(zoom, this._Origin);
    }

    if (this.mode === 'rotate' || this.mode === 'rotate_zoom') {
      map.setBearing(this._startBearing + bearing);
      map.onDragRotating(param);
    } else if (this.mode === 'pitch') {
      map.setPitch(map.getPitch() + pitch);
      map.onDragRotating(param);
    }

    map._fireEvent('touchactinging');
  };

  _proto._startTouching = function _startTouching(param) {
    var map = this.target;

    if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
      var size = map.getSize();
      this._Origin = new Point(size['width'] / 2, size['height'] / 2);
      map.onZoomStart(null, this._Origin);
    }

    if (this.mode === 'rotate' || this.mode === 'pitch' || this.mode === 'rotate_zoom') {
      map.onDragRotateStart(param);
    }
  };

  _proto._onTouchEnd = function _onTouchEnd(event) {
    delete this.preY;
    var map = this.target;
    off(document, 'touchmove', this._onTouchMove, this);
    off(document, 'touchend', this._onTouchEnd, this);

    if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
      var scale = this._scale;
      var res = map._getResolution(this._startZoom) / scale;
      var zoom = map.getZoomFromRes(res);
      map.onZoomEnd(zoom, this._Origin);
    }

    if (this.mode === 'pitch' || this.mode === 'rotate' || this.mode === 'rotate_zoom') {
      map.onDragRotateEnd({
        'domEvent': event
      });
    }

    delete this.mode;

    map._fireEvent('touchactend');
  };

  return MapTouchZoomHandler;
}(Handler$1);

Map$1.mergeOptions({
  'touchGesture': true,
  'touchZoom': true,
  'touchPitch': true,
  'touchRotate': true,
  'touchZoomRotate': false
});
Map$1.addOnLoadHook('addHandler', 'touchGesture', MapTouchZoomHandler);

var KEY = '__anim_player';
var Easing = {
  in: function _in(t) {
    return Math.pow(t, 2);
  },
  out: function out(t) {
    return 1 - Easing.in(1 - t);
  },
  inAndOut: function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
  },
  linear: function linear(t) {
    return t;
  },
  upAndDown: function upAndDown(t) {
    if (t < 0.5) {
      return Easing.inAndOut(2 * t);
    } else {
      return 1 - Easing.inAndOut(2 * (t - 0.5));
    }
  }
};

var Frame = function Frame(state, styles) {
  this.state = state;
  this.styles = styles;
};

var Player = function Player(animation, options, onFrame, target) {
  this._animation = animation;
  this.options = options;
  this._onFrame = onFrame;
  this.playState = 'idle';
  this.ready = true;
  this.finished = false;
  this.target = target;
};

var Animation = {
  speed: {
    'slow': 2000,
    'normal': 1000,
    'fast': 500
  },
  _resolveStyles: function _resolveStyles(styles) {
    if (!styles) {
      return null;
    }

    function resolveChild(child) {
      if (!Array.isArray(child)) {
        return Animation._resolveStyles(child);
      }

      var start = [],
          d = [],
          dest = [];

      for (var i = 0; i < child.length; i++) {
        var _styles = Animation._resolveStyles(child[i]);

        if (_styles) {
          start.push(_styles[0]);
          d.push(_styles[1]);
          dest.push(_styles[2]);
        }
      }

      if (!start.length) {
        return null;
      } else {
        return [start, d, dest];
      }
    }

    function resolveVal(val) {
      var values = val;
      var clazz;

      if (!Array.isArray(val)) {
        if (isNumber(val)) {
          values = [0, val];
        } else if (val instanceof Point || val instanceof Coordinate) {
          clazz = val.constructor;
          values = [new clazz(0, 0), val];
        } else {
          values = [val, val];
        }
      }

      var v1 = values[0],
          v2 = values[1];

      if (isNumber(v1) && isNumber(v2)) {
        if (v1 === v2) {
          return null;
        }

        return [v1, v2 - v1, v2];
      } else if (Array.isArray(v1) && isNumber(v1[0]) || v1 instanceof Coordinate || v1 instanceof Point) {
        if (Array.isArray(v1)) {
          v1 = new Coordinate(v1);
          v2 = new Coordinate(v2);
        } else {
          clazz = v1.constructor;
          v1 = new clazz(v1);
          v2 = new clazz(v2);
        }

        if (v1.equals(v2)) {
          return null;
        }

        return [v1, v2.sub(v1), v2];
      } else {
        return [v1, v2, v2];
      }
    }

    function isChild(val) {
      if (!Array.isArray(val) && val.constructor === Object) {
        return true;
      } else if (Array.isArray(val) && val[0].constructor === Object) {
        return true;
      }

      return false;
    }

    var d = {},
        start = {},
        dest = {};

    for (var p in styles) {
      if (styles.hasOwnProperty(p)) {
        var values = styles[p];

        if (!values) {
          continue;
        } else if (Array.isArray(values)) {
          if (isNil(values[0]) || isNil(values[1])) {
            continue;
          }
        }

        var childStyles = void 0;

        if (isChild(values)) {
          childStyles = resolveChild(values);
        } else {
          childStyles = resolveVal(values);
        }

        if (childStyles) {
          start[p] = childStyles[0];
          d[p] = childStyles[1];
          dest[p] = childStyles[2];
        }
      }
    }

    return [start, d, dest];
  },
  framing: function framing(styles, options) {
    if (!options) {
      options = {};
    }

    var easing = options['easing'] ? Easing[options['easing']] : Easing.linear;

    if (!easing) {
      easing = Easing.linear;
    }

    var dStyles, startStyles, destStyles;
    styles = Animation._resolveStyles(styles);

    if (styles) {
      startStyles = styles[0];
      dStyles = styles[1];
      destStyles = styles[2];
    }

    var deltaStyles = function deltaStyles(delta, _startStyles, _dStyles) {
      if (!_startStyles || !_dStyles) {
        return null;
      }

      var result = {};

      for (var p in _dStyles) {
        if (_dStyles.hasOwnProperty(p)) {
          if (_startStyles[p] === destStyles[p]) {
            result[p] = _startStyles[p];
            continue;
          }

          var s = _startStyles[p],
              d = _dStyles[p];

          if (isNumber(d)) {
            result[p] = s + delta * d;
          } else if (Array.isArray(d)) {
            var children = [];

            for (var i = 0; i < d.length; i++) {
              children.push(deltaStyles(delta, s[i], d[i]));
            }

            result[p] = children;
          } else {
            var clazz = d.constructor;

            if (clazz === Object) {
              result[p] = deltaStyles(delta, s, d);
            } else if (s instanceof Point || s instanceof Coordinate) {
              result[p] = s.add(d.multi(delta));
            } else {
              result[p] = d;
            }
          }
        }
      }

      return result;
    };

    return function (elapsed, duration) {
      var state, d;

      if (elapsed < 0) {
        state = {
          'playState': 'idle',
          'delta': 0
        };
        d = startStyles;
      } else if (elapsed < duration) {
        var delta = easing(elapsed / duration);
        state = {
          'playState': 'running',
          'delta': delta
        };
        d = deltaStyles(delta, startStyles, dStyles);
      } else {
        state = {
          'playState': 'finished',
          'delta': 1
        };
        d = destStyles;
      }

      state['startStyles'] = startStyles;
      state['destStyles'] = destStyles;
      state['progress'] = elapsed;
      state['remainingMs'] = duration - elapsed;
      return new Frame(state, d);
    };
  },
  _requestAnimFrame: function _requestAnimFrame(fn) {
    if (!this._frameQueue) {
      this._frameQueue = [];
    }

    this._frameQueue.push(fn);

    this._a();
  },
  _a: function _a() {
    if (!this._animationFrameId) {
      this._animationFrameId = requestAnimFrame(Animation._frameFn);
    }
  },
  _run: function _run() {
    if (this._frameQueue.length) {
      var running = this._frameQueue;
      this._frameQueue = [];

      for (var i = 0, len = running.length; i < len; i++) {
        running[i]();
      }

      if (this._frameQueue.length) {
        this._animationFrameId = requestAnimFrame(Animation._frameFn);
      } else {
        delete this._animationFrameId;
      }
    }
  },
  animate: function animate(styles, options, step, target) {
    if (!options) {
      options = {};
    }

    var animation = Animation.framing(styles, options);
    var player = new Player(animation, options, step, target);
    return player;
  }
};
Animation._frameFn = Animation._run.bind(Animation);
extend(Player.prototype, {
  _prepare: function _prepare() {
    var options = this.options;
    var duration = options['speed'] || options['duration'];

    if (isString(duration)) {
      duration = Animation.speed[duration];

      if (!duration) {
        duration = +duration;
      }
    }

    if (!duration) {
      duration = Animation.speed['normal'];
    }

    this.duration = duration;
    this._framer = options['framer'] || Animation._requestAnimFrame.bind(Animation);
  },
  play: function play() {
    if (this.playState !== 'idle' && this.playState !== 'paused' || this.target && this.target[KEY]) {
      return this;
    }

    if (this.target) {
      this.target[KEY] = 1;
    }

    if (this.playState === 'idle') {
      this.currentTime = 0;

      this._prepare();
    }

    var t = now();

    if (!this.startTime) {
      var options = this.options;
      this.startTime = options['startTime'] ? options['startTime'] : t;
    }

    this._playStartTime = Math.max(t, this.startTime);

    if (this.playState === 'paused') {
      this._playStartTime -= this.currentTime;
    }

    this.playState = 'running';

    this._run();

    return this;
  },
  pause: function pause() {
    if (this.playState === 'paused') {
      return this;
    }

    this.playState = 'paused';

    this._run();

    return this;
  },
  cancel: function cancel() {
    if (this.playState === 'idle') {
      return this;
    }

    this.playState = 'idle';
    this.finished = false;

    this._run();

    return this;
  },
  finish: function finish() {
    if (this.playState === 'finished') {
      return this;
    }

    this.playState = 'finished';
    this.finished = true;

    this._run();

    return this;
  },
  reverse: function reverse() {},
  _run: function _run() {
    var _this = this;

    var onFrame = this._onFrame;
    var t = now();
    var elapsed = t - this._playStartTime;

    if (this.options['repeat'] && elapsed >= this.duration) {
      this._playStartTime = t;
      elapsed = 0;
    }

    if (this.playState !== 'running') {
      if (this.target) {
        delete this.target[KEY];
      }

      if (onFrame) {
        if (this.playState === 'finished') {
          elapsed = this.duration;
        } else if (this.playState === 'idle') {
          elapsed = 0;
        }

        var _frame = this._animation(elapsed, this.duration);

        _frame.state.playState = this.playState;
        onFrame(_frame);
      }

      return;
    }

    var frame = this._animation(elapsed, this.duration);

    this.playState = frame.state['playState'];

    if (this.playState !== 'running' && this.target) {
      delete this.target[KEY];
    }

    if (this.playState === 'idle') {
      if (this.startTime > t) {
        setTimeout(this._run.bind(this), this.startTime - t);
      }
    } else if (this.playState === 'running') {
      this._framer(function () {
        if (_this.playState !== 'running') {
          return;
        }

        _this.currentTime = elapsed;

        if (onFrame) {
          onFrame(frame);
        }

        _this._run();
      });
    } else if (this.playState === 'finished') {
      this.finished = true;

      if (onFrame) {
        onFrame(frame);
      }
    }
  }
});

var Animation$1 = /*#__PURE__*/Object.freeze({
  Animation: Animation,
  Easing: Easing,
  Player: Player,
  Frame: Frame
});

var simplify = createCommonjsModule(function (module) {
  (function () {

    function getSqDist(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return dx * dx + dy * dy;
    }

    function getSqSegDist(p, p1, p2) {
      var x = p1.x,
          y = p1.y,
          dx = p2.x - x,
          dy = p2.y - y;

      if (dx !== 0 || dy !== 0) {
        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
          x = p2.x;
          y = p2.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }

      dx = p.x - x;
      dy = p.y - y;
      return dx * dx + dy * dy;
    }

    function simplifyRadialDist(points, sqTolerance) {
      var prevPoint = points[0],
          newPoints = [prevPoint],
          point;

      for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
          newPoints.push(point);
          prevPoint = point;
        }
      }

      if (prevPoint !== point) newPoints.push(point);
      return newPoints;
    }

    function simplifyDPStep(points, first, last, sqTolerance, simplified) {
      var maxSqDist = sqTolerance,
          index;

      for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
    }

    function simplifyDouglasPeucker(points, sqTolerance) {
      var last = points.length - 1;
      var simplified = [points[0]];
      simplifyDPStep(points, 0, last, sqTolerance, simplified);
      simplified.push(points[last]);
      return simplified;
    }

    function simplify(points, tolerance, highestQuality) {
      if (points.length <= 2) return points;
      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
      points = simplifyDouglasPeucker(points, sqTolerance);
      return points;
    }

    {
      module.exports = simplify;
      module.exports.default = simplify;
    }
  })();
});

var options$3 = {
  'smoothness': 0,
  'enableClip': true,
  'enableSimplify': true,
  'simplifyTolerance': 2,
  'symbol': {
    'lineColor': '#000',
    'lineWidth': 2,
    'lineOpacity': 1,
    'polygonFill': '#fff',
    'polygonOpacity': 1,
    'opacity': 1
  }
};

var Path = function (_Geometry) {
  _inheritsLoose(Path, _Geometry);

  function Path() {
    return _Geometry.apply(this, arguments) || this;
  }

  var _proto = Path.prototype;

  _proto.getOutline = function getOutline() {
    var painter = this._getPainter();

    if (!painter) {
      return null;
    }

    var extent = this.getExtent();
    return new Polygon(extent.toArray(), {
      symbol: {
        'lineWidth': 1,
        'lineColor': '6b707b'
      }
    });
  };

  _proto.animateShow = function animateShow(options, cb) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    if (this._showPlayer) {
      this._showPlayer.finish();
    }

    if (isFunction(options)) {
      options = {};
      cb = options;
    }

    var coordinates = this.getCoordinates();

    if (coordinates.length === 0) {
      return this;
    }

    this._animIdx = 0;
    this._animLenSoFar = 0;
    this.show();
    var isPolygon = !!this.getShell;
    var animCoords = isPolygon ? this.getShell().concat(this.getShell()[0]) : this.getCoordinates();

    var projection = this._getProjection();

    var prjAnimCoords = projection.projectCoords(animCoords);
    this._prjAniShowCenter = this._getPrjExtent().getCenter();
    this._aniShowCenter = projection.unproject(this._prjAniShowCenter);
    var duration = options['duration'] || 1000,
        easing = options['easing'] || 'out';
    this.setCoordinates([]);
    var length = 0;

    for (var i = 1; i < prjAnimCoords.length; i++) {
      length += prjAnimCoords[i].distanceTo(prjAnimCoords[i - 1]);
    }

    var player = this._showPlayer = Animation.animate({
      't': duration
    }, {
      'duration': duration,
      'easing': easing
    }, function (frame) {
      if (!_this.getMap()) {
        if (player.playState !== 'finished') {
          player.finish();

          if (cb) {
            var _coordinates = _this.getCoordinates();

            cb(frame, _coordinates[_coordinates.length - 1]);
          }
        }

        return;
      }

      var currentCoord = _this._drawAnimShowFrame(frame.styles.t, duration, length, animCoords, prjAnimCoords);

      if (frame.state.playState === 'finished') {
        delete _this._showPlayer;
        delete _this._aniShowCenter;
        delete _this._prjAniShowCenter;
        delete _this._animIdx;
        delete _this._animLenSoFar;
        delete _this._animTailRatio;

        _this.setCoordinates(coordinates);
      }

      if (cb) {
        cb(frame, currentCoord);
      }
    }, this);
    player.play();
    return player;
  };

  _proto._drawAnimShowFrame = function _drawAnimShowFrame(t, duration, length, coordinates, prjCoords) {
    if (t === 0) {
      return coordinates[0];
    }

    var projection = this._getProjection();

    var targetLength = t / duration * length;
    var segLen = 0;
    var i, l;

    for (i = this._animIdx, l = prjCoords.length; i < l - 1; i++) {
      segLen = prjCoords[i].distanceTo(prjCoords[i + 1]);

      if (this._animLenSoFar + segLen > targetLength) {
        break;
      }

      this._animLenSoFar += segLen;
    }

    this._animIdx = i;

    if (this._animIdx >= l - 1) {
      this.setCoordinates(coordinates);
      return coordinates[coordinates.length - 1];
    }

    var idx = this._animIdx;
    var p1 = prjCoords[idx],
        p2 = prjCoords[idx + 1],
        span = targetLength - this._animLenSoFar,
        r = span / segLen;
    this._animTailRatio = r;
    var x = p1.x + (p2.x - p1.x) * r,
        y = p1.y + (p2.y - p1.y) * r,
        lastCoord = new Coordinate(x, y);
    var targetCoord = projection.unproject(lastCoord);
    var isPolygon = !!this.getShell;

    if (!isPolygon && this.options['smoothness'] > 0) {
      var animCoords = coordinates.slice(0, this._animIdx + 3);
      this.setCoordinates(animCoords);
      var prjAnimCoords = prjCoords.slice(0, this._animIdx + 3);

      this._setPrjCoordinates(prjAnimCoords);
    } else {
      var _animCoords = coordinates.slice(0, this._animIdx + 1);

      _animCoords.push(targetCoord);

      var _prjAnimCoords = prjCoords.slice(0, this._animIdx + 1);

      _prjAnimCoords.push(lastCoord);

      if (isPolygon) {
        this.setCoordinates([this._aniShowCenter].concat(_animCoords));

        this._setPrjCoordinates([this._prjAniShowCenter].concat(_prjAnimCoords));
      } else {
        this.setCoordinates(_animCoords);

        this._setPrjCoordinates(_prjAnimCoords);
      }
    }

    return targetCoord;
  };

  _proto._getCenterInExtent = function _getCenterInExtent(extent, coordinates, clipFn) {
    var meExtent = this.getExtent();

    if (!extent.intersects(meExtent)) {
      return null;
    }

    var clipped = clipFn(coordinates, extent);

    if (clipped.length === 0) {
      return null;
    }

    var sumx = 0,
        sumy = 0,
        counter = 0;
    clipped.forEach(function (part) {
      if (Array.isArray(part)) {
        part.forEach(function (c) {
          if (c.point) {
            c = c.point;
          }

          sumx += c.x;
          sumy += c.y;
          counter++;
        });
      } else {
        if (part.point) {
          part = part.point;
        }

        sumx += part.x;
        sumy += part.y;
        counter++;
      }
    });

    var c = new Coordinate(sumx, sumy)._multi(1 / counter);

    c.count = counter;
    return c;
  };

  _proto._getPath2DPoints = function _getPath2DPoints(prjCoords, disableSimplify, zoom) {
    if (!isArrayHasData(prjCoords)) {
      return [];
    }

    var map = this.getMap(),
        isSimplify = !disableSimplify && this._shouldSimplify(),
        tolerance = this.options['simplifyTolerance'] * map._getResolution(),
        isMulti = Array.isArray(prjCoords[0]);

    delete this._simplified;

    if (isSimplify && !isMulti) {
      var count = prjCoords.length;
      prjCoords = simplify(prjCoords, tolerance, false);
      this._simplified = prjCoords.length < count;
    }

    if (isNil(zoom)) {
      zoom = map.getZoom();
    }

    return forEachCoord(prjCoords, function (c) {
      return map._prjToPoint(c, zoom);
    });
  };

  _proto._shouldSimplify = function _shouldSimplify() {
    var layer = this.getLayer(),
        properties = this.getProperties();
    var hasAltitude = properties && layer.options['enableAltitude'] && !isNil(properties[layer.options['altitudeProperty']]);
    return layer && layer.options['enableSimplify'] && !hasAltitude && this.options['enableSimplify'] && !this._showPlayer;
  };

  _proto._setPrjCoordinates = function _setPrjCoordinates(prjPoints) {
    this._prjCoords = prjPoints;
    this.onShapeChanged();
  };

  _proto._getPrjCoordinates = function _getPrjCoordinates() {
    this._verifyProjection();

    if (!this._prjCoords && this._getProjection()) {
      this._prjCoords = this._projectCoords(this._coordinates);
    }

    return this._prjCoords;
  };

  _proto._updateCache = function _updateCache() {
    this._clearCache();

    var projection = this._getProjection();

    if (!projection) {
      return;
    }

    if (this._prjCoords) {
      this._coordinates = this._unprojectCoords(this._getPrjCoordinates());
    }
  };

  _proto._clearProjection = function _clearProjection() {
    this._prjCoords = null;

    _Geometry.prototype._clearProjection.call(this);
  };

  _proto._projectCoords = function _projectCoords(points) {
    var projection = this._getProjection();

    if (projection) {
      return projection.projectCoords(points);
    }

    return [];
  };

  _proto._unprojectCoords = function _unprojectCoords(prjPoints) {
    var projection = this._getProjection();

    if (projection) {
      return projection.unprojectCoords(prjPoints);
    }

    return [];
  };

  _proto._computeCenter = function _computeCenter() {
    var ring = this._coordinates;

    if (!isArrayHasData(ring)) {
      return null;
    }

    var sumx = 0,
        sumy = 0,
        counter = 0;
    var size = ring.length;

    for (var i = 0; i < size; i++) {
      if (ring[i]) {
        if (isNumber(ring[i].x) && isNumber(ring[i].y)) {
          sumx += ring[i].x;
          sumy += ring[i].y;
          counter++;
        }
      }
    }

    return new Coordinate(sumx / counter, sumy / counter);
  };

  _proto._computeExtent = function _computeExtent() {
    var shell = this._coordinates;

    if (!isArrayHasData(shell)) {
      return null;
    }

    var rings = [shell];

    if (this.hasHoles && this.hasHoles()) {
      rings.push.apply(rings, this.getHoles());
    }

    return this._coords2Extent(rings, this._getProjection());
  };

  _proto._computePrjExtent = function _computePrjExtent() {
    var coords = [this._getPrjCoordinates()];

    if (this.hasHoles && this.hasHoles()) {
      coords.push.apply(coords, this._getPrjHoles());
    }

    return this._coords2Extent(coords);
  };

  _proto._get2DLength = function _get2DLength() {
    var vertexes = this._getPath2DPoints(this._getPrjCoordinates(), true);

    var len = 0;

    for (var i = 1, l = vertexes.length; i < l; i++) {
      len += vertexes[i].distanceTo(vertexes[i - 1]);
    }

    return len;
  };

  _proto._hitTestTolerance = function _hitTestTolerance() {
    var symbol = this._getInternalSymbol();

    var w;

    if (Array.isArray(symbol)) {
      w = 0;

      for (var i = 0; i < symbol.length; i++) {
        if (isNumber(symbol[i]['lineWidth'])) {
          if (symbol[i]['lineWidth'] > w) {
            w = symbol[i]['lineWidth'];
          }
        }
      }
    } else {
      w = symbol['lineWidth'];
    }

    return isNumber(w) ? w / 2 : 1.5;
  };

  _proto._coords2Extent = function _coords2Extent(coords, proj) {
    var result = new Extent(proj);

    for (var i = 0, l = coords.length; i < l; i++) {
      for (var j = 0, ll = coords[i].length; j < ll; j++) {
        result._combine(coords[i][j]);
      }
    }

    return result;
  };

  return Path;
}(Geometry);

Path.mergeOptions(options$3);

var JSON_TYPE = 'Polygon';

var Polygon = function (_Path) {
  _inheritsLoose(Polygon, _Path);

  function Polygon(coordinates, opts) {
    var _this;

    _this = _Path.call(this, opts) || this;
    _this.type = 'Polygon';

    if (coordinates) {
      _this.setCoordinates(coordinates);
    }

    return _this;
  }

  var _proto = Polygon.prototype;

  _proto.setCoordinates = function setCoordinates(coordinates) {
    if (!coordinates) {
      this._coordinates = null;
      this._holes = null;

      this._projectRings();

      return this;
    }

    var rings = Coordinate.toCoordinates(coordinates);
    var len = rings.length;

    if (!Array.isArray(rings[0])) {
      this._coordinates = this._trimRing(rings);
    } else {
      this._coordinates = this._trimRing(rings[0]);

      if (len > 1) {
        var holes = [];

        for (var i = 1; i < len; i++) {
          if (!rings[i]) {
            continue;
          }

          holes.push(this._trimRing(rings[i]));
        }

        this._holes = holes;
      }
    }

    this._projectRings();

    return this;
  };

  _proto.getCoordinates = function getCoordinates() {
    if (!this._coordinates) {
      return [];
    }

    var holes = this.getHoles();
    var rings = [this._copyAndCloseRing(this._coordinates)];

    for (var i = 0, l = holes.length; i < l; i++) {
      rings.push(this._copyAndCloseRing(holes[i]));
    }

    return rings;
  };

  _proto.getCenterInExtent = function getCenterInExtent(extent) {
    return this._getCenterInExtent(extent, this.getShell(), clipPolygon);
  };

  _proto.getShell = function getShell() {
    return this._coordinates || [];
  };

  _proto.getHoles = function getHoles() {
    return this._holes || [];
  };

  _proto.hasHoles = function hasHoles() {
    return this.getHoles().length > 0;
  };

  _proto._projectRings = function _projectRings() {
    if (!this.getMap()) {
      this.onShapeChanged();
      return;
    }

    this._prjCoords = this._projectCoords(this._coordinates);
    this._prjHoles = this._projectCoords(this._holes);
    this.onShapeChanged();
  };

  _proto._setPrjCoordinates = function _setPrjCoordinates(prjCoords) {
    this._prjCoords = prjCoords;
    this.onShapeChanged();
  };

  _proto._cleanRing = function _cleanRing(ring) {
    for (var i = ring.length - 1; i >= 0; i--) {
      if (!ring[i]) {
        ring.splice(i, 1);
      }
    }
  };

  _proto._checkRing = function _checkRing(ring) {
    this._cleanRing(ring);

    if (!ring || !isArrayHasData(ring)) {
      return false;
    }

    var lastPoint = ring[ring.length - 1];
    var isClose = true;

    if (ring[0].x !== lastPoint.x || ring[0].y !== lastPoint.y) {
      isClose = false;
    }

    return isClose;
  };

  _proto._trimRing = function _trimRing(ring) {
    var isClose = this._checkRing(ring);

    if (isArrayHasData(ring) && isClose) {
      ring.splice(ring.length - 1, 1);
    }

    return ring;
  };

  _proto._copyAndCloseRing = function _copyAndCloseRing(ring) {
    ring = ring.slice(0);

    var isClose = this._checkRing(ring);

    if (isArrayHasData(ring) && !isClose) {
      ring.push(ring[0].copy());
      return ring;
    } else {
      return ring;
    }
  };

  _proto._getPrjShell = function _getPrjShell() {
    if (this.getJSONType() === JSON_TYPE) {
      return this._getPrjCoordinates();
    }

    this._verifyProjection();

    if (this._getProjection() && !this._prjShell) {
      this._prjShell = this._projectCoords(this.getShell());
    }

    return this._prjShell;
  };

  _proto._getPrjHoles = function _getPrjHoles() {
    var projection = this._getProjection();

    this._verifyProjection();

    if (projection && !this._prjHoles) {
      this._prjHoles = this._projectCoords(this.getHoles());
    }

    return this._prjHoles;
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength(measurer) {
    var rings = this.getCoordinates();

    if (!isArrayHasData(rings)) {
      return 0;
    }

    var result = 0;

    for (var i = 0, len = rings.length; i < len; i++) {
      result += measurer.measureLength(rings[i]);
    }

    return result;
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea(measurer) {
    var rings = this.getCoordinates();

    if (!isArrayHasData(rings)) {
      return 0;
    }

    var result = measurer.measureArea(rings[0]);

    for (var i = 1, len = rings.length; i < len; i++) {
      result -= measurer.measureArea(rings[i]);
    }

    return result;
  };

  _proto._updateCache = function _updateCache() {
    _Path.prototype._updateCache.call(this);

    if (this._prjHoles) {
      this._holes = this._unprojectCoords(this._getPrjHoles());
    }
  };

  _proto._clearCache = function _clearCache() {
    delete this._prjShell;
    return _Path.prototype._clearCache.call(this);
  };

  _proto._clearProjection = function _clearProjection() {
    if (this._prjHoles) {
      this._prjHoles = null;
    }

    if (this._prjShell) {
      this._prjShell = null;
    }

    _Path.prototype._clearProjection.call(this);
  };

  return Polygon;
}(Path);

Polygon.registerJSONType(JSON_TYPE);

function CenterMixin (Base) {
  return function (_Base) {
    _inheritsLoose(_class, _Base);

    function _class() {
      return _Base.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.getCoordinates = function getCoordinates() {
      return this._coordinates;
    };

    _proto.setCoordinates = function setCoordinates(coordinates) {
      var center = coordinates instanceof Coordinate ? coordinates : new Coordinate(coordinates);

      if (center.equals(this._coordinates)) {
        return this;
      }

      this._coordinates = center;

      if (!this.getMap()) {
        this.onPositionChanged();
        return this;
      }

      var projection = this._getProjection();

      this._setPrjCoordinates(projection.project(this._coordinates));

      return this;
    };

    _proto._getCenter2DPoint = function _getCenter2DPoint(zoom) {
      var map = this.getMap();

      if (!map) {
        return null;
      }

      var z = isNil(zoom) ? map.getZoom() : map.getGLZoom();

      var pcenter = this._getPrjCoordinates();

      if (!pcenter) {
        return null;
      }

      return map._prjToPoint(pcenter, z);
    };

    _proto._getPrjCoordinates = function _getPrjCoordinates() {
      var projection = this._getProjection();

      this._verifyProjection();

      if (!this._pcenter && projection) {
        if (this._coordinates) {
          this._pcenter = projection.project(this._coordinates);
        }
      }

      return this._pcenter;
    };

    _proto._setPrjCoordinates = function _setPrjCoordinates(pcenter) {
      this._pcenter = pcenter;
      this.onPositionChanged();
    };

    _proto._updateCache = function _updateCache() {
      this._clearCache();

      var projection = this._getProjection();

      if (this._pcenter && projection) {
        this._coordinates = projection.unproject(this._pcenter);
      }
    };

    _proto._clearProjection = function _clearProjection() {
      this._pcenter = null;

      _Base.prototype._clearProjection.call(this);
    };

    _proto._computeCenter = function _computeCenter() {
      return this._coordinates ? this._coordinates.copy() : null;
    };

    return _class;
  }(Base);
}

var options$4 = {
  'symbol': {
    'markerType': 'path',
    'markerPath': [{
      'path': 'M8 23l0 0 0 0 0 0 0 0 0 0c-4,-5 -8,-10 -8,-14 0,-5 4,-9 8,-9l0 0 0 0c4,0 8,4 8,9 0,4 -4,9 -8,14z M3,9 a5,5 0,1,0,0,-0.9Z',
      'fill': '#DE3333'
    }],
    'markerPathWidth': 16,
    'markerPathHeight': 23,
    'markerWidth': 24,
    'markerHeight': 34
  },
  'hitTestForEvent': false
};

var Marker = function (_CenterMixin) {
  _inheritsLoose(Marker, _CenterMixin);

  function Marker(coordinates, opts) {
    var _this;

    _this = _CenterMixin.call(this, opts) || this;
    _this.type = 'Point';

    if (coordinates) {
      _this.setCoordinates(coordinates);
    }

    return _this;
  }

  var _proto = Marker.prototype;

  _proto.getOutline = function getOutline() {
    var painter = this._getPainter();

    if (!painter) {
      return null;
    }

    var coord = this.getCoordinates();
    var extent = painter.getContainerExtent();
    var anchor = this.getMap().coordToContainerPoint(coord);
    return new Marker(coord, {
      'symbol': {
        'markerType': 'square',
        'markerWidth': extent.getWidth(),
        'markerHeight': extent.getHeight(),
        'markerLineWidth': 1,
        'markerLineColor': '6b707b',
        'markerFill': 'rgba(0, 0, 0, 0)',
        'markerDx': extent.xmin - (anchor.x - extent.getWidth() / 2),
        'markerDy': extent.ymin - (anchor.y - extent.getHeight() / 2)
      }
    });
  };

  _proto._isVectorMarker = function _isVectorMarker() {
    var symbol = this._getInternalSymbol();

    if (Array.isArray(symbol)) {
      return false;
    }

    return VectorMarkerSymbolizer.test(symbol);
  };

  _proto._canEdit = function _canEdit() {
    var symbol = this._getInternalSymbol();

    if (Array.isArray(symbol)) {
      return false;
    }

    return VectorMarkerSymbolizer.test(symbol) || VectorPathMarkerSymbolizer.test(symbol) || ImageMarkerSymbolizer.test(symbol);
  };

  _proto._containsPoint = function _containsPoint(point, t) {
    var extent = this.getContainerExtent();

    if (t) {
      extent = extent.expand(t);
    }

    if (extent.contains(point)) {
      if (this.options['hitTestForEvent']) {
        return _CenterMixin.prototype._containsPoint.call(this, point, t);
      } else {
        return true;
      }
    } else {
      return false;
    }
  };

  _proto._computeExtent = function _computeExtent() {
    return computeExtent.call(this, 'getCenter');
  };

  _proto._computePrjExtent = function _computePrjExtent() {
    return computeExtent.call(this, '_getPrjCoordinates');
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength() {
    return 0;
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea() {
    return 0;
  };

  _proto._getSprite = function _getSprite(resources, canvasClass) {
    if (this._getPainter()) {
      return this._getPainter().getSprite(resources, canvasClass);
    }

    return new Painter(this).getSprite(resources, canvasClass);
  };

  return Marker;
}(CenterMixin(Geometry));

Marker.mergeOptions(options$4);
Marker.registerJSONType('Marker');

function computeExtent(fn) {
  var coordinates = this[fn]();

  if (!coordinates) {
    return null;
  }

  return new Extent(coordinates, coordinates, this._getProjection());
}

var options$5 = {
  'arrowStyle': null,
  'arrowPlacement': 'vertex-last'
};

var LineString = function (_Path) {
  _inheritsLoose(LineString, _Path);

  function LineString(coordinates, options) {
    var _this;

    _this = _Path.call(this, options) || this;
    _this.type = 'LineString';

    if (coordinates) {
      _this.setCoordinates(coordinates);
    }

    return _this;
  }

  var _proto = LineString.prototype;

  _proto.setCoordinates = function setCoordinates(coordinates) {
    if (!coordinates) {
      this._coordinates = null;

      this._setPrjCoordinates(null);

      return this;
    }

    this._coordinates = Coordinate.toCoordinates(coordinates);

    if (this.getMap()) {
      this._setPrjCoordinates(this._projectCoords(this._coordinates));
    } else {
      this.onShapeChanged();
    }

    return this;
  };

  _proto.getCoordinates = function getCoordinates() {
    return this._coordinates || [];
  };

  _proto.getCenterInExtent = function getCenterInExtent(extent) {
    return this._getCenterInExtent(extent, this.getCoordinates(), clipLine);
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength(measurer) {
    return measurer.measureLength(this.getCoordinates());
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea() {
    return 0;
  };

  return LineString;
}(Path);

LineString.mergeOptions(options$5);
LineString.registerJSONType('LineString');

var GeometryCollection = function (_Geometry) {
  _inheritsLoose(GeometryCollection, _Geometry);

  function GeometryCollection(geometries, opts) {
    var _this;

    _this = _Geometry.call(this, opts) || this;
    _this.type = 'GeometryCollection';

    _this.setGeometries(geometries);

    return _this;
  }

  var _proto = GeometryCollection.prototype;

  _proto.setGeometries = function setGeometries(_geometries) {
    var geometries = this._checkGeometries(_geometries || []);

    var symbol = this._getSymbol();

    var options = this.config();

    for (var i = geometries.length - 1; i >= 0; i--) {
      geometries[i]._initOptions(options);

      geometries[i]._setParent(this);

      geometries[i]._setEventParent(this);

      if (symbol) {
        geometries[i].setSymbol(symbol);
      }
    }

    this._geometries = geometries;

    if (this.getLayer()) {
      this._bindGeometriesToLayer();

      this.onShapeChanged();
    }

    return this;
  };

  _proto.getGeometries = function getGeometries() {
    return this._geometries || [];
  };

  _proto.forEach = function forEach(fn, context) {
    var geometries = this.getGeometries();

    for (var i = 0, l = geometries.length; i < l; i++) {
      if (!geometries[i]) {
        continue;
      }

      if (!context) {
        fn(geometries[i], i);
      } else {
        fn.call(context, geometries[i], i);
      }
    }

    return this;
  };

  _proto.filter = function filter(fn, context) {
    if (!fn) {
      return new GeometryCollection();
    }

    var selected = [];
    var isFn = isFunction(fn);
    var filter = isFn ? fn : createFilter(fn);
    this.forEach(function (geometry) {
      var g = isFn ? geometry : getFilterFeature(geometry);

      if (context ? filter.call(context, g) : filter(g)) {
        selected.push(geometry);
      }
    }, this);
    return new GeometryCollection(selected);
  };

  _proto.translate = function translate(offset) {
    if (!offset) {
      return this;
    }

    if (this.isEmpty()) {
      return this;
    }

    var args = arguments;
    this.forEach(function (geometry) {
      if (geometry && geometry.translate) {
        geometry.translate.apply(geometry, args);
      }
    });
    return this;
  };

  _proto.isEmpty = function isEmpty$$1() {
    return !isArrayHasData(this.getGeometries());
  };

  _proto.remove = function remove() {
    this.forEach(function (geometry) {
      geometry._unbind();
    });
    return Geometry.prototype.remove.apply(this, arguments);
  };

  _proto.show = function show() {
    this.options['visible'] = true;
    this.forEach(function (geometry) {
      geometry.show();
    });
    return this;
  };

  _proto.hide = function hide() {
    this.options['visible'] = false;
    this.forEach(function (geometry) {
      geometry.hide();
    });
    return this;
  };

  _proto.onConfig = function onConfig(config) {
    this.forEach(function (geometry) {
      geometry.config(config);
    });
  };

  _proto.getSymbol = function getSymbol() {
    var s = _Geometry.prototype.getSymbol.call(this);

    if (!s) {
      var symbols = [];
      var is = false;
      this.forEach(function (g) {
        var symbol = g.getSymbol();

        if (symbol && !is) {
          is = true;
        }

        symbols.push(g.getSymbol());
      });

      if (is) {
        s = {
          'children': symbols
        };
      }
    }

    return s;
  };

  _proto.setSymbol = function setSymbol(s) {
    if (s && s['children']) {
      this._symbol = null;
      this.forEach(function (g, i) {
        g.setSymbol(s['children'][i]);
      });
    } else {
      var symbol = this._prepareSymbol(s);

      this._symbol = symbol;
      this.forEach(function (g) {
        g.setSymbol(symbol);
      });
    }

    this.onSymbolChanged();
    return this;
  };

  _proto._setExternSymbol = function _setExternSymbol(symbol) {
    symbol = this._prepareSymbol(symbol);
    this._externSymbol = symbol;
    this.forEach(function (geometry) {
      geometry._setExternSymbol(symbol);
    });
    this.onSymbolChanged();
    return this;
  };

  _proto._bindLayer = function _bindLayer() {
    _Geometry.prototype._bindLayer.apply(this, arguments);

    this._bindGeometriesToLayer();
  };

  _proto._bindGeometriesToLayer = function _bindGeometriesToLayer() {
    var layer = this.getLayer();
    this.forEach(function (geometry) {
      geometry._bindLayer(layer);
    });
  };

  _proto._checkGeometries = function _checkGeometries(geometries) {
    var invalidGeoError = 'The geometry added to collection is invalid.';

    if (geometries && !Array.isArray(geometries)) {
      if (geometries instanceof Geometry) {
        return [geometries];
      } else {
        throw new Error(invalidGeoError);
      }
    } else {
      for (var i = 0, l = geometries.length; i < l; i++) {
        if (!this._checkGeo(geometries[i])) {
          throw new Error(invalidGeoError + ' Index: ' + i);
        }
      }

      return geometries;
    }
  };

  _proto._checkGeo = function _checkGeo(geo) {
    return geo instanceof Geometry;
  };

  _proto._updateCache = function _updateCache() {
    this._clearCache();

    if (this.isEmpty()) {
      return;
    }

    this.forEach(function (geometry) {
      if (geometry && geometry._updateCache) {
        geometry._updateCache();
      }
    });
  };

  _proto._removePainter = function _removePainter() {
    if (this._painter) {
      this._painter.remove();
    }

    delete this._painter;
    this.forEach(function (geometry) {
      geometry._removePainter();
    });
  };

  _proto._computeCenter = function _computeCenter(projection) {
    if (!projection || this.isEmpty()) {
      return null;
    }

    var sumX = 0,
        sumY = 0,
        counter = 0;
    var geometries = this.getGeometries();

    for (var i = 0, l = geometries.length; i < l; i++) {
      if (!geometries[i]) {
        continue;
      }

      var center = geometries[i]._computeCenter(projection);

      if (center) {
        sumX += center.x;
        sumY += center.y;
        counter++;
      }
    }

    if (counter === 0) {
      return null;
    }

    return new Coordinate(sumX / counter, sumY / counter);
  };

  _proto._containsPoint = function _containsPoint(point, t) {
    if (this.isEmpty()) {
      return false;
    }

    var geometries = this.getGeometries();

    for (var i = 0, l = geometries.length; i < l; i++) {
      if (geometries[i]._containsPoint(point, t)) {
        return true;
      }
    }

    return false;
  };

  _proto._computeExtent = function _computeExtent(projection) {
    return computeExtent$1.call(this, projection, '_computeExtent');
  };

  _proto._computePrjExtent = function _computePrjExtent(projection) {
    return computeExtent$1.call(this, projection, '_computePrjExtent');
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength(projection) {
    if (!projection || this.isEmpty()) {
      return 0;
    }

    var geometries = this.getGeometries();
    var result = 0;

    for (var i = 0, l = geometries.length; i < l; i++) {
      if (!geometries[i]) {
        continue;
      }

      result += geometries[i]._computeGeodesicLength(projection);
    }

    return result;
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea(projection) {
    if (!projection || this.isEmpty()) {
      return 0;
    }

    var geometries = this.getGeometries();
    var result = 0;

    for (var i = 0, l = geometries.length; i < l; i++) {
      if (!geometries[i]) {
        continue;
      }

      result += geometries[i]._computeGeodesicArea(projection);
    }

    return result;
  };

  _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
    var children = [];

    if (!this.isEmpty()) {
      var geometries = this.getGeometries();

      for (var i = 0, l = geometries.length; i < l; i++) {
        if (!geometries[i]) {
          continue;
        }

        children.push(geometries[i]._exportGeoJSONGeometry());
      }
    }

    return {
      'type': 'GeometryCollection',
      'geometries': children
    };
  };

  _proto._clearProjection = function _clearProjection() {
    if (this.isEmpty()) {
      return;
    }

    var geometries = this.getGeometries();

    for (var i = 0, l = geometries.length; i < l; i++) {
      if (!geometries[i]) {
        continue;
      }

      geometries[i]._clearProjection();
    }
  };

  _proto._getConnectPoints = function _getConnectPoints() {
    var extent = this.getExtent();
    var anchors = [new Coordinate(extent.xmin, extent.ymax), new Coordinate(extent.xmax, extent.ymin), new Coordinate(extent.xmin, extent.ymin), new Coordinate(extent.xmax, extent.ymax)];
    return anchors;
  };

  _proto._getExternalResources = function _getExternalResources() {
    if (this.isEmpty()) {
      return [];
    }

    var geometries = this.getGeometries(),
        resources = [];
    var cache = {};
    var symbol, res, key;

    for (var i = 0, l = geometries.length; i < l; i++) {
      if (!geometries[i]) {
        continue;
      }

      symbol = geometries[i]._getInternalSymbol();
      res = getExternalResources(symbol);

      for (var ii = 0, ll = res.length; ii < ll; ii++) {
        key = res[ii].join();

        if (!cache[key]) {
          resources.push(res[ii]);
          cache[key] = 1;
        }
      }
    }

    return resources;
  };

  _proto.startEdit = function startEdit(opts) {
    var _this2 = this;

    if (this.isEmpty()) {
      return this;
    }

    if (!opts) {
      opts = {};
    }

    if (opts['symbol']) {
      this._originalSymbol = this.getSymbol();
      this.setSymbol(opts['symbol']);
    }

    this._draggbleBeforeEdit = this.options['draggable'];
    this.config('draggable', false);
    var geometries = this.getGeometries();

    for (var i = 0, l = geometries.length; i < l; i++) {
      geometries[i].startEdit(opts);
    }

    this._editing = true;
    this.hide();
    setTimeout(function () {
      _this2.fire('editstart');
    }, 1);
    return this;
  };

  _proto.endEdit = function endEdit() {
    if (this.isEmpty()) {
      return this;
    }

    var geometries = this.getGeometries();

    for (var i = 0, l = geometries.length; i < l; i++) {
      geometries[i].endEdit();
    }

    if (this._originalSymbol) {
      this.setSymbol(this._originalSymbol);
      delete this._originalSymbol;
    }

    this._editing = false;
    this.show();
    this.config('draggable', this._draggbleBeforeEdit);
    this.fire('editend');
    return this;
  };

  _proto.isEditing = function isEditing() {
    if (!this._editing) {
      return false;
    }

    return true;
  };

  return GeometryCollection;
}(Geometry);

GeometryCollection.registerJSONType('GeometryCollection');

function computeExtent$1(projection, fn) {
  if (this.isEmpty()) {
    return null;
  }

  var geometries = this.getGeometries();
  var result = null;

  for (var i = 0, l = geometries.length; i < l; i++) {
    var geo = geometries[i];

    if (!geo) {
      continue;
    }

    var geoExtent = geo[fn](projection);

    if (geoExtent) {
      result = geoExtent.combine(result);
    }
  }

  return result;
}

var MultiGeometry = function (_GeometryCollection) {
  _inheritsLoose(MultiGeometry, _GeometryCollection);

  function MultiGeometry(geoType, type, data, options) {
    var _this;

    _this = _GeometryCollection.call(this, null, options) || this;
    _this.GeometryType = geoType;
    _this.type = type;

    _this._initData(data);

    return _this;
  }

  var _proto = MultiGeometry.prototype;

  _proto.getCoordinates = function getCoordinates() {
    var coordinates = [];
    var geometries = this.getGeometries();

    for (var i = 0, l = geometries.length; i < l; i++) {
      var child = geometries[i];
      coordinates.push(child.getShell && child.getJSONType() !== 'Polygon' ? [child.getShell()] : child.getCoordinates());
    }

    return coordinates;
  };

  _proto.setCoordinates = function setCoordinates(coordinates) {
    coordinates = coordinates || [];
    var geometries = [];

    for (var i = 0, l = coordinates.length; i < l; i++) {
      var g = new this.GeometryType(coordinates[i], this.config());
      geometries.push(g);
    }

    this.setGeometries(geometries);
    return this;
  };

  _proto._initData = function _initData(data) {
    data = data || [];

    if (data.length) {
      if (data[0] instanceof this.GeometryType) {
        this.setGeometries(data);
      } else {
        this.setCoordinates(data);
      }
    }
  };

  _proto._checkGeo = function _checkGeo(geo) {
    return geo instanceof this.GeometryType;
  };

  _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
    var points = this.getCoordinates();
    var coordinates = Coordinate.toNumberArrays(points);
    return {
      'type': this.getType(),
      'coordinates': coordinates
    };
  };

  return MultiGeometry;
}(GeometryCollection);

var MultiPoint = function (_MultiGeometry) {
  _inheritsLoose(MultiPoint, _MultiGeometry);

  function MultiPoint(data, opts) {
    return _MultiGeometry.call(this, Marker, 'MultiPoint', data, opts) || this;
  }

  var _proto = MultiPoint.prototype;

  _proto.findClosest = function findClosest(coordinate) {
    if (!coordinate) {
      return null;
    }

    var coords = this.getCoordinates();
    var hit = null;
    var max = Infinity;
    coords.forEach(function (c) {
      var dist = distanceTo(c, coordinate);

      if (dist < max) {
        hit = c;
        max = dist;
      }
    });
    return hit;
  };

  return MultiPoint;
}(MultiGeometry);

MultiPoint.registerJSONType('MultiPoint');

function distanceTo(p0, p1) {
  var x = p1.x - p0.x,
      y = p1.y - p0.y;
  return Math.sqrt(x * x + y * y);
}

var MultiPath = function (_MultiGeometry) {
  _inheritsLoose(MultiPath, _MultiGeometry);

  function MultiPath() {
    return _MultiGeometry.apply(this, arguments) || this;
  }

  var _proto = MultiPath.prototype;

  _proto.getCenterInExtent = function getCenterInExtent(extent) {
    var children = this.getGeometries();
    var sumx = 0,
        sumy = 0,
        counter = 0;
    children.forEach(function (l) {
      var c = l.getCenterInExtent(extent);

      if (c) {
        sumx += c.x * c.count;
        sumy += c.y * c.count;
        counter += c.count;
      }
    });

    if (counter === 0) {
      return null;
    }

    return new Coordinate(sumx, sumy)._multi(1 / counter);
  };

  return MultiPath;
}(MultiGeometry);

var MultiLineString = function (_MultiPath) {
  _inheritsLoose(MultiLineString, _MultiPath);

  function MultiLineString(data, options) {
    return _MultiPath.call(this, LineString, 'MultiLineString', data, options) || this;
  }

  return MultiLineString;
}(MultiPath);

MultiLineString.registerJSONType('MultiLineString');

var MultiPolygon = function (_MultiPath) {
  _inheritsLoose(MultiPolygon, _MultiPath);

  function MultiPolygon(data, opts) {
    return _MultiPath.call(this, Polygon, 'MultiPolygon', data, opts) || this;
  }

  return MultiPolygon;
}(MultiPath);

MultiPolygon.registerJSONType('MultiPolygon');

var types$1 = {
  'Marker': Marker,
  'LineString': LineString,
  'Polygon': Polygon,
  'MultiPoint': MultiPoint,
  'MultiLineString': MultiLineString,
  'MultiPolygon': MultiPolygon
};
var GeoJSON = {
  toGeometry: function toGeometry(geoJSON, foreachFn) {
    if (isString(geoJSON)) {
      geoJSON = parseJSON(geoJSON);
    }

    if (Array.isArray(geoJSON)) {
      var resultGeos = [];

      for (var i = 0, len = geoJSON.length; i < len; i++) {
        var geo = GeoJSON._convert(geoJSON[i], foreachFn);

        if (Array.isArray(geo)) {
          pushIn(resultGeos, geo);
        } else {
          resultGeos.push(geo);
        }
      }

      return resultGeos;
    } else {
      var resultGeo = GeoJSON._convert(geoJSON, foreachFn);

      return resultGeo;
    }
  },
  _convert: function _convert(json, foreachFn) {
    if (!json || isNil(json['type'])) {
      return null;
    }

    var type = json['type'];

    if (type === 'Feature') {
      var g = json['geometry'];

      var geometry = GeoJSON._convert(g);

      if (!geometry) {
        return null;
      }

      geometry.setId(json['id']);
      geometry.setProperties(json['properties']);

      if (foreachFn) {
        foreachFn(geometry);
      }

      return geometry;
    } else if (type === 'FeatureCollection') {
      var features = json['features'];

      if (!features) {
        return null;
      }

      return GeoJSON.toGeometry(features, foreachFn);
    } else if (['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon'].indexOf(type) >= 0) {
      var clazz = type === 'Point' ? 'Marker' : type;
      var result = new types$1[clazz](json['coordinates']);

      if (foreachFn) {
        foreachFn(result);
      }

      return result;
    } else if (type === 'GeometryCollection') {
      var geometries = json['geometries'];

      if (!isArrayHasData(geometries)) {
        var _result2 = new GeometryCollection();

        if (foreachFn) {
          foreachFn(_result2);
        }

        return _result2;
      }

      var mGeos = [];
      var size = geometries.length;

      for (var i = 0; i < size; i++) {
        mGeos.push(GeoJSON._convert(geometries[i]));
      }

      var _result = new GeometryCollection(mGeos);

      if (foreachFn) {
        foreachFn(_result);
      }

      return _result;
    }

    return null;
  }
};

var options$6 = {
  'numberOfShellPoints': 60
};

var Circle = function (_CenterMixin) {
  _inheritsLoose(Circle, _CenterMixin);

  Circle.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var circle = new Circle(json['coordinates'], json['radius'], json['options']);
    circle.setProperties(feature['properties']);
    return circle;
  };

  function Circle(coordinates, radius, opts) {
    var _this;

    _this = _CenterMixin.call(this, null, opts) || this;

    if (coordinates) {
      _this.setCoordinates(coordinates);
    }

    _this._radius = radius;
    return _this;
  }

  var _proto = Circle.prototype;

  _proto.getRadius = function getRadius() {
    return this._radius;
  };

  _proto.setRadius = function setRadius(radius) {
    this._radius = radius;
    this.onShapeChanged();
    return this;
  };

  _proto.getShell = function getShell() {
    var measurer = this._getMeasurer(),
        center = this.getCoordinates(),
        numberOfPoints = this.options['numberOfShellPoints'],
        radius = this.getRadius();

    var shell = [];
    var rad, dx, dy;

    for (var i = 0, len = numberOfPoints - 1; i < len; i++) {
      rad = 360 * i / len * Math.PI / 180;
      dx = radius * Math.cos(rad);
      dy = radius * Math.sin(rad);
      var vertex = measurer.locate(center, dx, dy);
      shell.push(vertex);
    }

    shell.push(shell[0]);
    return shell;
  };

  _proto.getHoles = function getHoles() {
    return [];
  };

  _proto.animateShow = function animateShow() {
    return this.show();
  };

  _proto._containsPoint = function _containsPoint(point, tolerance) {
    var map = this.getMap();

    if (map.getPitch()) {
      return _CenterMixin.prototype._containsPoint.call(this, point, tolerance);
    }

    var center = map._pointToContainerPoint(this._getCenter2DPoint()),
        size = this.getSize(),
        t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
        se = center.add(size.width / 2, size.height / 2);

    return withInEllipse(point, center, se, t);
  };

  _proto._computePrjExtent = function _computePrjExtent(projection) {
    var minmax = this._getMinMax(projection);

    if (!minmax) {
      return null;
    }

    var pcenter = this._getPrjCoordinates();

    var pminmax = minmax.map(function (c) {
      return projection.project(c);
    });
    var leftx = pminmax[0].x - pcenter.x;
    var rightx = pminmax[1].x - pcenter.x;
    var topy = pminmax[2].y - pcenter.y;
    var bottomy = pminmax[3].y - pcenter.y;
    return new Extent(pcenter.add(leftx, topy), pcenter.add(rightx, bottomy));
  };

  _proto._computeExtent = function _computeExtent(measurer) {
    var minmax = this._getMinMax(measurer);

    if (!minmax) {
      return null;
    }

    return new Extent(minmax[0].x, minmax[2].y, minmax[1].x, minmax[3].y, this._getProjection());
  };

  _proto._getMinMax = function _getMinMax(measurer) {
    if (!measurer || !this._coordinates || isNil(this._radius)) {
      return null;
    }

    var radius = this._radius;
    var p1 = measurer.locate(this._coordinates, -radius, 0),
        p2 = measurer.locate(this._coordinates, radius, 0),
        p3 = measurer.locate(this._coordinates, 0, radius),
        p4 = measurer.locate(this._coordinates, 0, -radius);
    return [p1, p2, p3, p4];
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength() {
    if (isNil(this._radius)) {
      return 0;
    }

    return Math.PI * 2 * this._radius;
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea() {
    if (isNil(this._radius)) {
      return 0;
    }

    return Math.PI * Math.pow(this._radius, 2);
  };

  _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
    var coordinates = Coordinate.toNumberArrays([this.getShell()]);
    return {
      'type': 'Polygon',
      'coordinates': coordinates
    };
  };

  _proto._toJSON = function _toJSON(options) {
    var center = this.getCenter();
    var opts = extend({}, options);
    opts.geometry = false;
    var feature = this.toGeoJSON(opts);
    feature['geometry'] = {
      'type': 'Polygon'
    };
    return {
      'feature': feature,
      'subType': 'Circle',
      'coordinates': [center.x, center.y],
      'radius': this.getRadius()
    };
  };

  return Circle;
}(CenterMixin(Polygon));

Circle.mergeOptions(options$6);
Circle.registerJSONType('Circle');

var options$7 = {
  'numberOfShellPoints': 80
};

var Ellipse = function (_CenterMixin) {
  _inheritsLoose(Ellipse, _CenterMixin);

  Ellipse.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var ellipse = new Ellipse(json['coordinates'], json['width'], json['height'], json['options']);
    ellipse.setProperties(feature['properties']);
    return ellipse;
  };

  function Ellipse(coordinates, width, height, opts) {
    var _this;

    _this = _CenterMixin.call(this, null, opts) || this;

    if (coordinates) {
      _this.setCoordinates(coordinates);
    }

    _this.width = width;
    _this.height = height;
    return _this;
  }

  var _proto = Ellipse.prototype;

  _proto.getWidth = function getWidth() {
    return this.width;
  };

  _proto.setWidth = function setWidth(width) {
    this.width = width;
    this.onShapeChanged();
    return this;
  };

  _proto.getHeight = function getHeight() {
    return this.height;
  };

  _proto.setHeight = function setHeight(height) {
    this.height = height;
    this.onShapeChanged();
    return this;
  };

  _proto.getShell = function getShell() {
    var measurer = this._getMeasurer(),
        center = this.getCoordinates(),
        numberOfPoints = this.options['numberOfShellPoints'],
        width = this.getWidth(),
        height = this.getHeight();

    var shell = [];
    var s = Math.pow(width / 2, 2) * Math.pow(height / 2, 2),
        sx = Math.pow(width / 2, 2),
        sy = Math.pow(height / 2, 2);
    var deg, rad, dx, dy;

    for (var i = 0; i < numberOfPoints; i++) {
      deg = 360 * i / numberOfPoints;
      rad = deg * Math.PI / 180;
      dx = Math.sqrt(s / (sx * Math.pow(Math.tan(rad), 2) + sy));
      dy = Math.sqrt(s / (sy * Math.pow(1 / Math.tan(rad), 2) + sx));

      if (deg > 90 && deg < 270) {
        dx *= -1;
      }

      if (deg > 180 && deg < 360) {
        dy *= -1;
      }

      var vertex = measurer.locate(center, dx, dy);
      shell.push(vertex);
    }

    return shell;
  };

  _proto.getHoles = function getHoles() {
    return [];
  };

  _proto.animateShow = function animateShow() {
    return this.show();
  };

  _proto._containsPoint = function _containsPoint(point, tolerance) {
    var map = this.getMap();

    if (map.isTransforming()) {
      return _CenterMixin.prototype._containsPoint.call(this, point, tolerance);
    }

    var projection = map.getProjection();

    var t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
        pps = projection.projectCoords([this._coordinates, map.locate(this._coordinates, this.getWidth() / 2, this.getHeight() / 2)]),
        p0 = map._prjToContainerPoint(pps[0]),
        p1 = map._prjToContainerPoint(pps[1]);

    return withInEllipse(point, p0, p1, t);
  };

  _proto._computePrjExtent = function _computePrjExtent() {
    return Circle.prototype._computePrjExtent.apply(this, arguments);
  };

  _proto._computeExtent = function _computeExtent() {
    return Circle.prototype._computeExtent.apply(this, arguments);
  };

  _proto._getMinMax = function _getMinMax(measurer) {
    if (!measurer || !this._coordinates || isNil(this.width) || isNil(this.height)) {
      return null;
    }

    var width = this.getWidth(),
        height = this.getHeight();
    var p1 = measurer.locate(this._coordinates, -width / 2, 0),
        p2 = measurer.locate(this._coordinates, width / 2, 0),
        p3 = measurer.locate(this._coordinates, 0, -height / 2),
        p4 = measurer.locate(this._coordinates, 0, height / 2);
    return [p1, p2, p3, p4];
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength() {
    if (isNil(this.width) || isNil(this.height)) {
      return 0;
    }

    var longer = this.width > this.height ? this.width : this.height;
    return 2 * Math.PI * longer / 2 - 4 * Math.abs(this.width - this.height);
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea() {
    if (isNil(this.width) || isNil(this.height)) {
      return 0;
    }

    return Math.PI * this.width * this.height / 4;
  };

  _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
    var coordinates = Coordinate.toNumberArrays([this.getShell()]);
    return {
      'type': 'Polygon',
      'coordinates': coordinates
    };
  };

  _proto._toJSON = function _toJSON(options) {
    var opts = extend({}, options);
    var center = this.getCenter();
    opts.geometry = false;
    var feature = this.toGeoJSON(opts);
    feature['geometry'] = {
      'type': 'Polygon'
    };
    return {
      'feature': feature,
      'subType': 'Ellipse',
      'coordinates': [center.x, center.y],
      'width': this.getWidth(),
      'height': this.getHeight()
    };
  };

  return Ellipse;
}(CenterMixin(Polygon));

Ellipse.mergeOptions(options$7);
Ellipse.registerJSONType('Ellipse');

var Rectangle = function (_Polygon) {
  _inheritsLoose(Rectangle, _Polygon);

  Rectangle.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var rect = new Rectangle(json['coordinates'], json['width'], json['height'], json['options']);
    rect.setProperties(feature['properties']);
    return rect;
  };

  function Rectangle(coordinates, width, height, opts) {
    var _this;

    _this = _Polygon.call(this, null, opts) || this;

    if (coordinates) {
      _this.setCoordinates(coordinates);
    }

    _this._width = width;
    _this._height = height;
    return _this;
  }

  var _proto = Rectangle.prototype;

  _proto.getCoordinates = function getCoordinates() {
    return this._coordinates;
  };

  _proto.setCoordinates = function setCoordinates(nw) {
    this._coordinates = nw instanceof Coordinate ? nw : new Coordinate(nw);

    if (!this._coordinates || !this.getMap()) {
      this.onPositionChanged();
      return this;
    }

    var projection = this._getProjection();

    this._setPrjCoordinates(projection.project(this._coordinates));

    return this;
  };

  _proto.getWidth = function getWidth() {
    return this._width;
  };

  _proto.setWidth = function setWidth(width) {
    this._width = width;
    this.onShapeChanged();
    return this;
  };

  _proto.getHeight = function getHeight() {
    return this._height;
  };

  _proto.setHeight = function setHeight(height) {
    this._height = height;
    this.onShapeChanged();
    return this;
  };

  _proto.getShell = function getShell() {
    var measurer = this._getMeasurer();

    var nw = this._coordinates;
    var map = this.getMap();
    var sx = 1,
        sy = -1;

    if (map) {
      var fExt = map.getFullExtent();

      if (fExt['left'] > fExt['right']) {
        sx = -1;
      }

      if (fExt['bottom'] > fExt['top']) {
        sy = 1;
      }
    }

    var points = [];
    points.push(nw);
    points.push(measurer.locate(nw, sx * this._width, 0));
    points.push(measurer.locate(nw, sx * this._width, sy * this._height));
    points.push(measurer.locate(nw, 0, sy * this._height));
    points.push(nw);
    return points;
  };

  _proto.getHoles = function getHoles() {
    return [];
  };

  _proto.animateShow = function animateShow() {
    return this.show();
  };

  _proto._getPrjCoordinates = function _getPrjCoordinates() {
    var projection = this._getProjection();

    this._verifyProjection();

    if (!this._pnw && projection) {
      if (this._coordinates) {
        this._pnw = projection.project(this._coordinates);
      }
    }

    return this._pnw;
  };

  _proto._setPrjCoordinates = function _setPrjCoordinates(pnw) {
    this._pnw = pnw;
    this.onPositionChanged();
  };

  _proto._getPrjShell = function _getPrjShell() {
    var shell = _Polygon.prototype._getPrjShell.call(this);

    var projection = this._getProjection();

    if (!projection.isSphere()) {
      return shell;
    }

    var sphereExtent = projection.getSphereExtent(),
        sx = sphereExtent.sx,
        sy = sphereExtent.sy;

    var circum = this._getProjection().getCircum();

    var nw = shell[0];

    for (var i = 1, l = shell.length; i < l; i++) {
      var p = shell[i];
      var dx = 0,
          dy = 0;

      if (sx * (nw.x - p.x) > 0) {
        dx = circum.x * sx;
      }

      if (sy * (nw.y - p.y) < 0) {
        dy = circum.y * sy;
      }

      shell[i]._add(dx, dy);
    }

    return shell;
  };

  _proto._updateCache = function _updateCache() {
    this._clearCache();

    var projection = this._getProjection();

    if (this._pnw && projection) {
      this._coordinates = projection.unproject(this._pnw);
    }
  };

  _proto._clearProjection = function _clearProjection() {
    this._pnw = null;

    _Polygon.prototype._clearProjection.call(this);
  };

  _proto._computeCenter = function _computeCenter(measurer) {
    return measurer.locate(this._coordinates, this._width / 2, -this._height / 2);
  };

  _proto._containsPoint = function _containsPoint(point, tolerance) {
    var map = this.getMap();

    if (map.isTransforming()) {
      return _Polygon.prototype._containsPoint.call(this, point, tolerance);
    }

    var t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
        r = map._getResolution() * t;

    var extent = this._getPrjExtent().expand(r);

    var p = map._containerPointToPrj(point);

    return extent.contains(p);
  };

  _proto._computePrjExtent = function _computePrjExtent(projection) {
    var se = this._getSouthEast(projection);

    if (!se) {
      return null;
    }

    var prjs = projection.projectCoords([new Coordinate(this._coordinates.x, se.y), new Coordinate(se.x, this._coordinates.y)]);
    return new Extent(prjs[0], prjs[1]);
  };

  _proto._computeExtent = function _computeExtent(measurer) {
    var se = this._getSouthEast(measurer);

    if (!se) {
      return null;
    }

    return new Extent(this._coordinates, se, this._getProjection());
  };

  _proto._getSouthEast = function _getSouthEast(measurer) {
    if (!measurer || !this._coordinates || isNil(this._width) || isNil(this._height)) {
      return null;
    }

    var width = this.getWidth(),
        height = this.getHeight();
    var w = width,
        h = -height;

    if (measurer.fullExtent) {
      var fullExtent = measurer.fullExtent,
          sx = fullExtent.right > fullExtent.left ? 1 : -1,
          sy = fullExtent.top > fullExtent.bottom ? 1 : -1;
      w *= sx;
      h *= sy;
    }

    var se = measurer.locate(this._coordinates, w, h);
    return se;
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength() {
    if (isNil(this._width) || isNil(this._height)) {
      return 0;
    }

    return 2 * (this._width + this._height);
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea() {
    if (isNil(this._width) || isNil(this._height)) {
      return 0;
    }

    return this._width * this._height;
  };

  _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
    var coordinates = Coordinate.toNumberArrays([this.getShell()]);
    return {
      'type': 'Polygon',
      'coordinates': coordinates
    };
  };

  _proto._toJSON = function _toJSON(options) {
    var opts = extend({}, options);
    var nw = this.getCoordinates();
    opts.geometry = false;
    var feature = this.toGeoJSON(opts);
    feature['geometry'] = {
      'type': 'Polygon'
    };
    return {
      'feature': feature,
      'subType': 'Rectangle',
      'coordinates': [nw.x, nw.y],
      'width': this.getWidth(),
      'height': this.getHeight()
    };
  };

  return Rectangle;
}(Polygon);

Rectangle.registerJSONType('Rectangle');

var options$8 = {
  'numberOfShellPoints': 60
};

var Sector = function (_Circle) {
  _inheritsLoose(Sector, _Circle);

  Sector.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var sector = new Sector(json['coordinates'], json['radius'], json['startAngle'], json['endAngle'], json['options']);
    sector.setProperties(feature['properties']);
    return sector;
  };

  function Sector(coordinates, radius, startAngle, endAngle, opts) {
    var _this;

    _this = _Circle.call(this, coordinates, radius, opts) || this;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    return _this;
  }

  var _proto = Sector.prototype;

  _proto.getStartAngle = function getStartAngle() {
    return this.startAngle;
  };

  _proto.setStartAngle = function setStartAngle(startAngle) {
    this.startAngle = startAngle;
    this.onShapeChanged();
    return this;
  };

  _proto.getEndAngle = function getEndAngle() {
    return this.endAngle;
  };

  _proto.setEndAngle = function setEndAngle(endAngle) {
    this.endAngle = endAngle;
    this.onShapeChanged();
    return this;
  };

  _proto.getShell = function getShell() {
    var measurer = this._getMeasurer(),
        center = this.getCoordinates(),
        numberOfPoints = this.options['numberOfShellPoints'] - 2,
        radius = this.getRadius(),
        shell = [center.copy()],
        startAngle = this.getStartAngle(),
        angle = this.getEndAngle() - startAngle;

    var rad, dx, dy;

    for (var i = 0; i < numberOfPoints; i++) {
      rad = (angle * i / (numberOfPoints - 1) + startAngle) * Math.PI / 180;
      dx = radius * Math.cos(rad);
      dy = radius * Math.sin(rad);
      var vertex = measurer.locate(center, dx, dy);
      shell.push(vertex);
    }

    shell.push(center.copy());
    return shell;
  };

  _proto._containsPoint = function _containsPoint(point, tolerance) {
    var map = this.getMap();

    if (map.isTransforming()) {
      return _Circle.prototype._containsPoint.call(this, point, tolerance);
    }

    var center = map._pointToContainerPoint(this._getCenter2DPoint()),
        t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
        size = this.getSize(),
        pc = center,
        pp = point,
        x = pp.x - pc.x,
        y = pc.y - pp.y,
        atan2 = Math.atan2(y, x),
        angle = atan2 < 0 ? (atan2 + 2 * Math.PI) * 360 / (2 * Math.PI) : atan2 * 360 / (2 * Math.PI);

    var sAngle = this.startAngle % 360,
        eAngle = this.endAngle % 360;
    var between = false;

    if (sAngle > eAngle) {
      between = !(angle > eAngle && angle < sAngle);
    } else {
      between = angle >= sAngle && angle <= eAngle;
    }

    return pp.distanceTo(pc) <= size.width / 2 + t && between;
  };

  _proto._computeGeodesicLength = function _computeGeodesicLength() {
    if (isNil(this._radius)) {
      return 0;
    }

    return Math.PI * 2 * this._radius * Math.abs(this.startAngle - this.endAngle) / 360 + 2 * this._radius;
  };

  _proto._computeGeodesicArea = function _computeGeodesicArea() {
    if (isNil(this._radius)) {
      return 0;
    }

    return Math.PI * Math.pow(this._radius, 2) * Math.abs(this.startAngle - this.endAngle) / 360;
  };

  _proto._toJSON = function _toJSON(options) {
    var opts = extend({}, options);
    var center = this.getCenter();
    opts.geometry = false;
    var feature = this.toGeoJSON(opts);
    feature['geometry'] = {
      'type': 'Polygon'
    };
    return {
      'feature': feature,
      'subType': 'Sector',
      'coordinates': [center.x, center.y],
      'radius': this.getRadius(),
      'startAngle': this.getStartAngle(),
      'endAngle': this.getEndAngle()
    };
  };

  return Sector;
}(Circle);

Sector.mergeOptions(options$8);
Sector.registerJSONType('Sector');

var options$9 = {
  'enableSimplify': false,
  'enableClip': false
};

var Curve = function (_LineString) {
  _inheritsLoose(Curve, _LineString);

  function Curve() {
    return _LineString.apply(this, arguments) || this;
  }

  var _proto = Curve.prototype;

  _proto._arc = function _arc(ctx, points, lineOpacity) {
    var degree = this.options['arcDegree'] * Math.PI / 180;

    for (var i = 1, l = points.length; i < l; i++) {
      var c = Canvas._arcBetween(ctx, points[i - 1], points[i], degree);

      var ctrlPoint = [points[i - 1].x + points[i].x - c[0], points[i - 1].y + points[i].y - c[1]];
      points[i - 1].nextCtrlPoint = ctrlPoint;
      points[i].prevCtrlPoint = ctrlPoint;

      Canvas._stroke(ctx, lineOpacity);
    }
  };

  _proto._quadraticCurve = function _quadraticCurve(ctx, points) {
    if (points.length <= 2) {
      Canvas._path(ctx, points);

      return;
    }

    var i, l;

    for (i = 2, l = points.length; i < l; i += 2) {
      ctx.quadraticCurveTo(points[i - 1].x, points[i - 1].y, points[i].x, points[i].y);
    }

    i -= 1;

    if (i < l) {
      for (; i < l; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
    }
  };

  _proto._bezierCurve = function _bezierCurve(ctx, points) {
    if (points.length <= 3) {
      Canvas._path(ctx, points);

      return;
    }

    var i, l;

    for (i = 1, l = points.length; i + 2 < l; i += 3) {
      ctx.bezierCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y);
    }

    if (i < l) {
      for (; i < l; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
    }
  };

  _proto._getCurveArrowPoints = function _getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, step) {
    var l = segments.length;
    var i;

    for (i = step; i < l; i += step) {
      var arrow = this._getArrowShape(segments[i - 1], segments[i], lineWidth, arrowStyle, tolerance);

      if (arrow) {
        arrows.push(arrow);
      }
    }

    i -= step;

    if (i < l - 1) {
      for (i += 1; i < l; i++) {
        var _arrow = this._getArrowShape(segments[i - 1], segments[i], lineWidth, arrowStyle, tolerance);

        if (_arrow) {
          arrows.push(_arrow);
        }
      }
    }
  };

  return Curve;
}(LineString);

Curve.mergeOptions(options$9);

var options$a = {
  'arcDegree': 90
};

var ArcCurve = function (_Curve) {
  _inheritsLoose(ArcCurve, _Curve);

  function ArcCurve() {
    return _Curve.apply(this, arguments) || this;
  }

  var _proto = ArcCurve.prototype;

  _proto._toJSON = function _toJSON(options) {
    return {
      'feature': this.toGeoJSON(options),
      'subType': 'ArcCurve'
    };
  };

  _proto._paintOn = function _paintOn(ctx, points, lineOpacity) {
    ctx.beginPath();

    this._arc(ctx, points, lineOpacity);

    Canvas._stroke(ctx, lineOpacity);

    this._paintArrow(ctx, points, lineOpacity);
  };

  ArcCurve.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var arc = new ArcCurve(feature['geometry']['coordinates'], json['options']);
    arc.setProperties(feature['properties']);
    return arc;
  };

  return ArcCurve;
}(Curve);

ArcCurve.registerJSONType('ArcCurve');
ArcCurve.mergeOptions(options$a);

var CubicBezierCurve = function (_Curve) {
  _inheritsLoose(CubicBezierCurve, _Curve);

  function CubicBezierCurve() {
    return _Curve.apply(this, arguments) || this;
  }

  CubicBezierCurve.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var curve = new CubicBezierCurve(feature['geometry']['coordinates'], json['options']);
    curve.setProperties(feature['properties']);
    return curve;
  };

  var _proto = CubicBezierCurve.prototype;

  _proto._toJSON = function _toJSON(options) {
    return {
      'feature': this.toGeoJSON(options),
      'subType': 'CubicBezierCurve'
    };
  };

  _proto._paintOn = function _paintOn(ctx, points, lineOpacity) {
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);

    this._bezierCurve(ctx, points);

    Canvas._stroke(ctx, lineOpacity);

    this._paintArrow(ctx, points, lineOpacity);
  };

  _proto._getArrowPoints = function _getArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance) {
    return this._getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, 3);
  };

  return CubicBezierCurve;
}(Curve);

CubicBezierCurve.registerJSONType('CubicBezierCurve');

var QuadBezierCurve = function (_Curve) {
  _inheritsLoose(QuadBezierCurve, _Curve);

  function QuadBezierCurve() {
    return _Curve.apply(this, arguments) || this;
  }

  QuadBezierCurve.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var curve = new QuadBezierCurve(feature['geometry']['coordinates'], json['options']);
    curve.setProperties(feature['properties']);
    return curve;
  };

  var _proto = QuadBezierCurve.prototype;

  _proto._toJSON = function _toJSON(options) {
    return {
      'feature': this.toGeoJSON(options),
      'subType': 'QuadBezierCurve'
    };
  };

  _proto._paintOn = function _paintOn(ctx, points, lineOpacity) {
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);

    this._quadraticCurve(ctx, points, lineOpacity);

    Canvas._stroke(ctx, lineOpacity);

    this._paintArrow(ctx, points, lineOpacity);
  };

  _proto._getArrowPoints = function _getArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance) {
    return this._getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, 2);
  };

  return QuadBezierCurve;
}(Curve);

QuadBezierCurve.registerJSONType('QuadBezierCurve');

var defaultSymbol$1 = {
  'textFaceName': 'monospace',
  'textSize': 12,
  'textLineSpacing': 8,
  'textWrapCharacter': '\n',
  'textHorizontalAlignment': 'middle',
  'textVerticalAlignment': 'middle'
};
var defaultBoxSymbol = {
  'markerType': 'square',
  'markerLineColor': '#000',
  'markerLineWidth': 2,
  'markerLineOpacity': 1,
  'markerFill': '#fff',
  'markerOpacity': 1
};

var TextMarker = function (_Marker) {
  _inheritsLoose(TextMarker, _Marker);

  function TextMarker() {
    return _Marker.apply(this, arguments) || this;
  }

  var _proto = TextMarker.prototype;

  _proto.getContent = function getContent() {
    return this._content;
  };

  _proto.setContent = function setContent(content) {
    var old = this._content;
    this._content = escapeSpecialChars(content);

    this._refresh();

    this._fireEvent('contentchange', {
      'old': old,
      'new': content
    });

    return this;
  };

  _proto.onAdd = function onAdd() {
    this._refresh();
  };

  _proto.toJSON = function toJSON() {
    var json = _Marker.prototype.toJSON.call(this);

    delete json['symbol'];
    return json;
  };

  _proto.setSymbol = function setSymbol(symbol) {
    if (this._refreshing || !symbol) {
      return _Marker.prototype.setSymbol.call(this, symbol);
    }

    var s = this._parseSymbol(symbol);

    if (this.setTextStyle) {
      var style = this.getTextStyle() || {};
      style.symbol = s[0];
      this.setTextStyle(style);
    } else if (this.setTextSymbol) {
      this.setTextSymbol(s[0]);
    }

    if (this.setBoxStyle) {
      var _style = this.getBoxStyle() || {};

      _style.symbol = s[1];
      this.setBoxStyle(_style);
    } else if (this.setBoxSymbol) {
      this.setBoxSymbol(s[1]);
    }

    return this;
  };

  _proto._parseSymbol = function _parseSymbol(symbol) {
    var t = {};
    var b = {};

    for (var p in symbol) {
      if (hasOwn(symbol, p)) {
        if (p.indexOf('text') === 0) {
          t[p] = symbol[p];
        } else {
          b[p] = symbol[p];
        }
      }
    }

    return [t, b];
  };

  _proto._getTextSize = function _getTextSize(symbol) {
    return splitTextToRow(this._content, symbol)['size'];
  };

  _proto._getInternalSymbol = function _getInternalSymbol() {
    return this._symbol;
  };

  _proto._getDefaultTextSymbol = function _getDefaultTextSymbol() {
    return extend({}, defaultSymbol$1);
  };

  _proto._getDefaultBoxSymbol = function _getDefaultBoxSymbol() {
    return extend({}, defaultBoxSymbol);
  };

  _proto._getDefaultPadding = function _getDefaultPadding() {
    return [12, 8];
  };

  return TextMarker;
}(Marker);

var options$b = {
  'textStyle': {
    'wrap': true,
    'padding': [12, 8],
    'verticalAlignment': 'middle',
    'horizontalAlignment': 'middle'
  },
  'boxSymbol': null
};

var TextBox = function (_TextMarker) {
  _inheritsLoose(TextBox, _TextMarker);

  function TextBox(content, coordinates, width, height, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _TextMarker.call(this, coordinates, options) || this;
    _this._content = escapeSpecialChars(content);
    _this._width = isNil(width) ? 100 : width;
    _this._height = isNil(height) ? 40 : height;

    if (options.boxSymbol) {
      _this.setBoxSymbol(options.boxSymbol);
    }

    if (options.textStyle) {
      _this.setTextStyle(options.textStyle);
    }

    _this._refresh();

    return _this;
  }

  var _proto = TextBox.prototype;

  _proto.getWidth = function getWidth() {
    return this._width;
  };

  _proto.setWidth = function setWidth(width) {
    this._width = width;

    this._refresh();

    return this;
  };

  _proto.getHeight = function getHeight() {
    return this._height;
  };

  _proto.setHeight = function setHeight(height) {
    this._height = height;

    this._refresh();

    return this;
  };

  _proto.getBoxSymbol = function getBoxSymbol() {
    return extend({}, this.options.boxSymbol);
  };

  _proto.setBoxSymbol = function setBoxSymbol(symbol) {
    this.options.boxSymbol = symbol ? extend({}, symbol) : symbol;

    if (this.getSymbol()) {
      this._refresh();
    }

    return this;
  };

  _proto.getTextStyle = function getTextStyle() {
    if (!this.options.textStyle) {
      return null;
    }

    return extend({}, this.options.textStyle);
  };

  _proto.setTextStyle = function setTextStyle(style) {
    this.options.textStyle = style ? extend({}, style) : style;

    if (this.getSymbol()) {
      this._refresh();
    }

    return this;
  };

  TextBox.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var textBox = new TextBox(json['content'], feature['geometry']['coordinates'], json['width'], json['height'], json['options']);
    textBox.setProperties(feature['properties']);
    textBox.setId(feature['id']);

    if (json['symbol']) {
      textBox.setSymbol(json['symbol']);
    }

    return textBox;
  };

  _proto._toJSON = function _toJSON(options) {
    return {
      'feature': this.toGeoJSON(options),
      'width': this.getWidth(),
      'height': this.getHeight(),
      'subType': 'TextBox',
      'content': this._content
    };
  };

  _proto._refresh = function _refresh() {
    var textStyle = this.getTextStyle() || {},
        padding = textStyle['padding'] || [12, 8],
        maxWidth = this._width - 2 * padding[0],
        maxHeight = this._height - 2 * padding[1];
    var symbol = extend({}, textStyle.symbol || this._getDefaultTextSymbol(), this.options.boxSymbol || this._getDefaultBoxSymbol(), {
      'textName': this._content,
      'markerWidth': this._width,
      'markerHeight': this._height,
      'textHorizontalAlignment': 'middle',
      'textVerticalAlignment': 'middle',
      'textMaxWidth': maxWidth,
      'textMaxHeight': maxHeight
    });

    if (textStyle['wrap'] && !symbol['textWrapWidth']) {
      symbol['textWrapWidth'] = maxWidth;
    }

    var hAlign = textStyle['horizontalAlignment'];
    symbol['textDx'] = symbol['markerDx'] || 0;
    var offsetX = symbol['markerWidth'] / 2 - padding[0];

    if (hAlign === 'left') {
      symbol['textHorizontalAlignment'] = 'right';
      symbol['textDx'] = symbol['textDx'] - offsetX;
    } else if (hAlign === 'right') {
      symbol['textHorizontalAlignment'] = 'left';
      symbol['textDx'] = symbol['textDx'] + offsetX;
    }

    var vAlign = textStyle['verticalAlignment'];
    symbol['textDy'] = symbol['markerDy'] || 0;
    var offsetY = symbol['markerHeight'] / 2 - padding[1];

    if (vAlign === 'top') {
      symbol['textVerticalAlignment'] = 'bottom';
      symbol['textDy'] -= offsetY;
    } else if (vAlign === 'bottom') {
      symbol['textVerticalAlignment'] = 'top';
      symbol['textDy'] += offsetY;
    }

    this._refreshing = true;
    this.updateSymbol(symbol);
    delete this._refreshing;
  };

  return TextBox;
}(TextMarker);

TextBox.mergeOptions(options$b);
TextBox.registerJSONType('TextBox');

var options$c = {
  'boxStyle': null,
  textSymbol: null
};

var Label = function (_TextMarker) {
  _inheritsLoose(Label, _TextMarker);

  function Label(content, coordinates, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _TextMarker.call(this, coordinates, options) || this;

    if (options.textSymbol) {
      _this.setTextSymbol(options.textSymbol);
    }

    if (options.boxStyle) {
      _this.setBoxStyle(options.boxStyle);
    }

    _this._content = escapeSpecialChars(content);

    _this._refresh();

    return _this;
  }

  var _proto = Label.prototype;

  _proto.getBoxStyle = function getBoxStyle() {
    if (!this.options.boxStyle) {
      return null;
    }

    return extend({}, this.options.boxStyle);
  };

  _proto.setBoxStyle = function setBoxStyle(style) {
    this.options.boxStyle = style ? extend({}, style) : style;

    this._refresh();

    return this;
  };

  _proto.getTextSymbol = function getTextSymbol() {
    return extend({}, this._getDefaultTextSymbol(), this.options.textSymbol);
  };

  _proto.setTextSymbol = function setTextSymbol(symbol) {
    this.options.textSymbol = symbol ? extend({}, symbol) : symbol;

    this._refresh();

    return this;
  };

  Label.fromJSON = function fromJSON(json) {
    var feature = json['feature'];
    var label = new Label(json['content'], feature['geometry']['coordinates'], json['options']);
    label.setProperties(feature['properties']);
    label.setId(feature['id']);

    if (json['symbol']) {
      label.setSymbol(json['symbol']);
    }

    return label;
  };

  _proto._canEdit = function _canEdit() {
    return false;
  };

  _proto._toJSON = function _toJSON(options) {
    return {
      'feature': this.toGeoJSON(options),
      'subType': 'Label',
      'content': this._content
    };
  };

  _proto._refresh = function _refresh() {
    var symbol = extend({}, this.getTextSymbol(), {
      'textName': this._content
    });
    var boxStyle = this.getBoxStyle();

    if (boxStyle) {
      extend(symbol, boxStyle.symbol);

      var sizes = this._getBoxSize(symbol),
          textSize = sizes[1],
          padding = boxStyle['padding'] || this._getDefaultPadding();

      var boxSize = sizes[0];
      symbol['markerWidth'] = boxSize['width'];
      symbol['markerHeight'] = boxSize['height'];

      var dx = symbol['textDx'] || 0,
          dy = symbol['textDy'] || 0,
          textAlignPoint = getAlignPoint(textSize, symbol['textHorizontalAlignment'], symbol['textVerticalAlignment'])._add(dx, dy);

      var hAlign = boxStyle['horizontalAlignment'] || 'middle';
      symbol['markerDx'] = textAlignPoint.x;

      if (hAlign === 'left') {
        symbol['markerDx'] += symbol['markerWidth'] / 2 - padding[0];
      } else if (hAlign === 'right') {
        symbol['markerDx'] -= symbol['markerWidth'] / 2 - textSize['width'] - padding[0];
      } else {
        symbol['markerDx'] += textSize['width'] / 2;
      }

      var vAlign = boxStyle['verticalAlignment'] || 'middle';
      symbol['markerDy'] = textAlignPoint.y;

      if (vAlign === 'top') {
        symbol['markerDy'] += symbol['markerHeight'] / 2 - padding[1];
      } else if (vAlign === 'bottom') {
        symbol['markerDy'] -= symbol['markerHeight'] / 2 - textSize['height'] - padding[1];
      } else {
        symbol['markerDy'] += textSize['height'] / 2;
      }
    }

    this._refreshing = true;
    this.updateSymbol(symbol);
    delete this._refreshing;
  };

  _proto._getBoxSize = function _getBoxSize(symbol) {
    if (!symbol['markerType']) {
      symbol['markerType'] = 'square';
    }

    var boxStyle = this.getBoxStyle();

    var size = this._getTextSize(symbol);

    var width, height;

    var padding = boxStyle['padding'] || this._getDefaultPadding();

    width = size['width'] + padding[0] * 2;
    height = size['height'] + padding[1] * 2;

    if (boxStyle['minWidth']) {
      if (!width || width < boxStyle['minWidth']) {
        width = boxStyle['minWidth'];
      }
    }

    if (boxStyle['minHeight']) {
      if (!height || height < boxStyle['minHeight']) {
        height = boxStyle['minHeight'];
      }
    }

    return [new Size(width, height), size];
  };

  return Label;
}(TextMarker);

Label.mergeOptions(options$c);
Label.registerJSONType('Label');

var Connectable = function Connectable(Base) {
  return function (_Base) {
    _inheritsLoose(_class, _Base);

    function _class() {
      return _Base.apply(this, arguments) || this;
    }

    _class._hasConnectors = function _hasConnectors(geometry) {
      return !isNil(geometry.__connectors) && geometry.__connectors.length > 0;
    };

    _class._getConnectors = function _getConnectors(geometry) {
      return geometry.__connectors;
    };

    var _proto = _class.prototype;

    _proto.getConnectSource = function getConnectSource() {
      return this._connSource;
    };

    _proto.setConnectSource = function setConnectSource(src) {
      var target = this._connTarget;
      this.onRemove();
      this._connSource = src;
      this._connTarget = target;
      this.onAdd();
      return this;
    };

    _proto.getConnectTarget = function getConnectTarget() {
      return this._connTarget;
    };

    _proto.setConnectTarget = function setConnectTarget(target) {
      var src = this._connSource;
      this.onRemove();
      this._connSource = src;
      this._connTarget = target;

      this._updateCoordinates();

      this._registerEvents();

      return this;
    };

    _proto._updateCoordinates = function _updateCoordinates() {
      var map = this.getMap();

      if (!map && this._connSource) {
        map = this._connSource.getMap();
      }

      if (!map && this._connTarget) {
        map = this._connTarget.getMap();
      }

      if (!map) {
        return;
      }

      if (!this._connSource || !this._connTarget) {
        return;
      }

      var srcPoints = this._connSource._getConnectPoints();

      var targetPoints = this._connTarget._getConnectPoints();

      var minDist = 0;
      var oldCoordinates = this.getCoordinates();
      var c1, c2;

      for (var i = 0, len = srcPoints.length; i < len; i++) {
        var p1 = srcPoints[i];

        for (var j = 0, length = targetPoints.length; j < length; j++) {
          var p2 = targetPoints[j];
          var dist = map.computeLength(p1, p2);

          if (i === 0 && j === 0) {
            c1 = p1;
            c2 = p2;
            minDist = dist;
          } else if (dist < minDist) {
            c1 = p1;
            c2 = p2;
          }
        }
      }

      if (!isArrayHasData(oldCoordinates) || !oldCoordinates[0].equals(c1) || !oldCoordinates[1].equals(c2)) {
        this.setCoordinates([c1, c2]);
      }
    };

    _proto.onAdd = function onAdd() {
      this._registerEvents();

      this._updateCoordinates();
    };

    _proto.onRemove = function onRemove() {
      if (this._connSource) {
        if (this._connSource.__connectors) {
          removeFromArray(this, this._connSource.__connectors);
        }

        this._connSource.off('dragging positionchange', this._updateCoordinates, this).off('remove', this.onRemove, this);

        this._connSource.off('dragstart mousedown mouseover', this._showConnect, this);

        this._connSource.off('dragend mouseup mouseout', this.hide, this);

        this._connSource.off('show', this._showConnect, this).off('hide', this.hide, this);

        delete this._connSource;
      }

      if (this._connTarget) {
        removeFromArray(this, this._connTarget.__connectors);

        this._connTarget.off('dragging positionchange', this._updateCoordinates, this).off('remove', this.onRemove, this);

        this._connTarget.off('show', this._showConnect, this).off('hide', this.hide, this);

        delete this._connTarget;
      }

      if (!(this._connSource instanceof Geometry) || !(this._connTarget instanceof Geometry)) {
        var map = this.getMap();

        if (map) {
          map.off('movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange', this._updateCoordinates, this);
        }
      }
    };

    _proto._showConnect = function _showConnect() {
      if (!this._connSource || !this._connTarget) {
        return;
      }

      if (this._connSource.isVisible() && this._connTarget.isVisible()) {
        this._updateCoordinates();

        this.show();
      }
    };

    _proto._registerEvents = function _registerEvents() {
      if (!this._connSource || !this._connTarget) {
        return;
      }

      if (!this._connSource.__connectors) {
        this._connSource.__connectors = [];
      }

      if (!this._connTarget.__connectors) {
        this._connTarget.__connectors = [];
      }

      this._connSource.__connectors.push(this);

      this._connTarget.__connectors.push(this);

      this._connSource.on('dragging positionchange', this._updateCoordinates, this).on('remove', this.remove, this);

      this._connTarget.on('dragging positionchange', this._updateCoordinates, this).on('remove', this.remove, this);

      this._connSource.on('show', this._showConnect, this).on('hide', this.hide, this);

      this._connTarget.on('show', this._showConnect, this).on('hide', this.hide, this);

      var trigger = this.options['showOn'];
      this.hide();

      if (trigger === 'moving') {
        this._connSource.on('dragstart', this._showConnect, this).on('dragend', this.hide, this);

        this._connTarget.on('dragstart', this._showConnect, this).on('dragend', this.hide, this);
      } else if (trigger === 'click') {
        this._connSource.on('mousedown', this._showConnect, this).on('mouseup', this.hide, this);

        this._connTarget.on('mousedown', this._showConnect, this).on('mouseup', this.hide, this);
      } else if (trigger === 'mouseover') {
        this._connSource.on('mouseover', this._showConnect, this).on('mouseout', this.hide, this);

        this._connTarget.on('mouseover', this._showConnect, this).on('mouseout', this.hide, this);
      } else {
        this._showConnect();
      }

      if (!(this._connSource instanceof Geometry) || !(this._connTarget instanceof Geometry)) {
        var map = this.getMap();

        if (map) {
          map.on('movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange', this._updateCoordinates, this);
        }
      }
    };

    return _class;
  }(Base);
};

var options$d = {
  showOn: 'always'
};

var ConnectorLine = function (_Connectable) {
  _inheritsLoose(ConnectorLine, _Connectable);

  function ConnectorLine(src, target, options) {
    var _this;

    _this = _Connectable.call(this, null, options) || this;

    if (arguments.length === 1) {
      options = src;
      src = null;
      target = null;
    }

    _this._connSource = src;
    _this._connTarget = target;
    return _this;
  }

  return ConnectorLine;
}(Connectable(LineString));

ConnectorLine.mergeOptions(options$d);
ConnectorLine.registerJSONType('ConnectorLine');

var ArcConnectorLine = function (_Connectable2) {
  _inheritsLoose(ArcConnectorLine, _Connectable2);

  function ArcConnectorLine(src, target, options) {
    var _this2;

    _this2 = _Connectable2.call(this, null, options) || this;

    if (arguments.length === 1) {
      options = src;
      src = null;
      target = null;
    }

    _this2._connSource = src;
    _this2._connTarget = target;
    return _this2;
  }

  return ArcConnectorLine;
}(Connectable(ArcCurve));

ArcConnectorLine.mergeOptions(options$d);
ArcConnectorLine.registerJSONType('ArcConnectorLine');

var options$e = {
  'drawImmediate': false
};

var OverlayLayer = function (_Layer) {
  _inheritsLoose(OverlayLayer, _Layer);

  function OverlayLayer(id, geometries, options) {
    var _this;

    if (geometries && !(geometries instanceof Geometry) && !Array.isArray(geometries) && GEOJSON_TYPES.indexOf(geometries.type) < 0) {
      options = geometries;
      geometries = null;
    }

    _this = _Layer.call(this, id, options) || this;
    _this._maxZIndex = 0;
    _this._minZIndex = 0;

    _this._initCache();

    if (geometries) {
      _this.addGeometry(geometries);
    }

    var style = _this.options['style'];

    if (style) {
      _this.setStyle(style);
    }

    return _this;
  }

  var _proto = OverlayLayer.prototype;

  _proto.getGeometryById = function getGeometryById(id) {
    if (isNil(id) || id === '') {
      return null;
    }

    if (!this._geoMap[id]) {
      return null;
    }

    return this._geoMap[id];
  };

  _proto.getGeometries = function getGeometries(filter, context) {
    if (!filter) {
      return this._geoList.slice(0);
    }

    var result = [];
    var geometry, filtered;

    for (var i = 0, l = this._geoList.length; i < l; i++) {
      geometry = this._geoList[i];

      if (context) {
        filtered = filter.call(context, geometry);
      } else {
        filtered = filter(geometry);
      }

      if (filtered) {
        result.push(geometry);
      }
    }

    return result;
  };

  _proto.getFirstGeometry = function getFirstGeometry() {
    if (!this._geoList.length) {
      return null;
    }

    return this._geoList[0];
  };

  _proto.getLastGeometry = function getLastGeometry() {
    var len = this._geoList.length;

    if (len === 0) {
      return null;
    }

    return this._geoList[len - 1];
  };

  _proto.getCount = function getCount() {
    return this._geoList.length;
  };

  _proto.getExtent = function getExtent() {
    if (this.getCount() === 0) {
      return null;
    }

    var extent = new Extent(this.getProjection());
    this.forEach(function (g) {
      extent._combine(g.getExtent());
    });
    return extent;
  };

  _proto.forEach = function forEach(fn, context) {
    var copyOnWrite = this._geoList.slice(0);

    for (var i = 0, l = copyOnWrite.length; i < l; i++) {
      if (!context) {
        fn(copyOnWrite[i], i);
      } else {
        fn.call(context, copyOnWrite[i], i);
      }
    }

    return this;
  };

  _proto.filter = function filter(fn, context) {
    var selected = [];
    var isFn = isFunction(fn);
    var filter = isFn ? fn : createFilter(fn);
    this.forEach(function (geometry) {
      var g = isFn ? geometry : getFilterFeature(geometry);

      if (context ? filter.call(context, g) : filter(g)) {
        selected.push(geometry);
      }
    }, this);
    return selected;
  };

  _proto.isEmpty = function isEmpty$$1() {
    return !this._geoList.length;
  };

  _proto.addGeometry = function addGeometry(geometries, fitView) {
    if (!geometries) {
      return this;
    }

    if (geometries.type === 'FeatureCollection') {
      return this.addGeometry(GeoJSON.toGeometry(geometries), fitView);
    } else if (!Array.isArray(geometries)) {
      var count = arguments.length;
      var last = arguments[count - 1];
      geometries = Array.prototype.slice.call(arguments, 0, count - 1);
      fitView = last;

      if (last && isObject(last) && ('type' in last || last instanceof Geometry)) {
        geometries.push(last);
        fitView = false;
      }

      return this.addGeometry(geometries, fitView);
    } else if (geometries.length === 0) {
      return this;
    }

    this._initCache();

    var extent;

    if (fitView) {
      extent = new Extent();
    }

    this._toSort = this._maxZIndex > 0;
    var geos = [];

    for (var i = 0, l = geometries.length; i < l; i++) {
      var geo = geometries[i];

      if (!geo) {
        throw new Error('Invalid geometry to add to layer(' + this.getId() + ') at index:' + i);
      }

      if (!(geo instanceof Geometry)) {
        geo = Geometry.fromJSON(geo);

        if (Array.isArray(geo)) {
          for (var ii = 0, ll = geo.length; ii < ll; ii++) {
            this._add(geo[ii], extent, i);

            geos.push(geo[ii]);
          }
        }
      }

      if (!Array.isArray(geo)) {
        this._add(geo, extent, i);

        geos.push(geo);
      }
    }

    var map = this.getMap();

    if (map) {
      this._getRenderer().onGeometryAdd(geos);

      if (extent && !isNil(extent.xmin)) {
        var center = extent.getCenter();
        var z = map.getFitZoom(extent);

        if (isObject(fitView)) {
          var step = isFunction(fitView.step) ? fitView.step : function () {
            return undefined;
          };
          map.animateTo({
            center: center,
            zoom: z
          }, extend({
            duration: map.options.zoomAnimationDuration,
            easing: 'out'
          }, fitView), step);
        } else if (fitView === true) {
          map.setCenterAndZoom(center, z);
        }
      }
    }

    this.fire('addgeo', {
      'geometries': geometries
    });
    return this;
  };

  _proto.getGeoMinZIndex = function getGeoMinZIndex() {
    return this._minZIndex;
  };

  _proto.getGeoMaxZIndex = function getGeoMaxZIndex() {
    return this._maxZIndex;
  };

  _proto._add = function _add(geo, extent, i) {
    if (!this._toSort) {
      this._toSort = geo.getZIndex() !== 0;
    }

    this._updateZIndex(geo.getZIndex());

    var geoId = geo.getId();

    if (!isNil(geoId)) {
      if (!isNil(this._geoMap[geoId])) {
        throw new Error('Duplicate geometry id in layer(' + this.getId() + '):' + geoId + ', at index:' + i);
      }

      this._geoMap[geoId] = geo;
    }

    var internalId = UID();

    geo._setInternalId(internalId);

    this._geoList.push(geo);

    this.onAddGeometry(geo);

    geo._bindLayer(this);

    if (geo.onAdd) {
      geo.onAdd();
    }

    if (extent) {
      extent._combine(geo.getExtent());
    }

    geo._fireEvent('add', {
      'layer': this
    });

    if (this._cookedStyles) {
      this._styleGeometry(geo);
    }
  };

  _proto.removeGeometry = function removeGeometry(geometries) {
    if (!Array.isArray(geometries)) {
      return this.removeGeometry([geometries]);
    }

    for (var i = geometries.length - 1; i >= 0; i--) {
      if (!(geometries[i] instanceof Geometry)) {
        geometries[i] = this.getGeometryById(geometries[i]);
      }

      if (!geometries[i] || this !== geometries[i].getLayer()) continue;
      geometries[i].remove();
    }

    this.fire('removegeo', {
      'geometries': geometries
    });
    return this;
  };

  _proto.clear = function clear() {
    this._clearing = true;
    this.forEach(function (geo) {
      geo.remove();
    });
    this._geoMap = {};
    var old = this._geoList;
    this._geoList = [];

    if (this._getRenderer()) {
      this._getRenderer().onGeometryRemove(old);
    }

    this._clearing = false;
    this.fire('clear');
    return this;
  };

  _proto.onRemoveGeometry = function onRemoveGeometry(geometry) {
    if (!geometry || this._clearing) {
      return;
    }

    if (this !== geometry.getLayer()) {
      return;
    }

    var internalId = geometry._getInternalId();

    if (isNil(internalId)) {
      return;
    }

    var geoId = geometry.getId();

    if (!isNil(geoId)) {
      delete this._geoMap[geoId];
    }

    var idx = this._findInList(geometry);

    if (idx >= 0) {
      this._geoList.splice(idx, 1);
    }

    if (this._getRenderer()) {
      this._getRenderer().onGeometryRemove([geometry]);
    }
  };

  _proto.getStyle = function getStyle() {
    if (!this.options['style']) {
      return null;
    }

    return this.options['style'];
  };

  _proto.setStyle = function setStyle(style) {
    this.options.style = style;
    style = parseStyleRootPath(style);
    this._cookedStyles = compileStyle(style);
    this.forEach(function (geometry) {
      this._styleGeometry(geometry);
    }, this);
    this.fire('setstyle', {
      'style': style
    });
    return this;
  };

  _proto._styleGeometry = function _styleGeometry(geometry) {
    if (!this._cookedStyles) {
      return false;
    }

    var g = getFilterFeature(geometry);

    for (var i = 0, len = this._cookedStyles.length; i < len; i++) {
      if (this._cookedStyles[i]['filter'](g) === true) {
        geometry._setExternSymbol(this._cookedStyles[i]['symbol']);

        return true;
      }
    }

    return false;
  };

  _proto.removeStyle = function removeStyle() {
    if (!this.options.style) {
      return this;
    }

    delete this.options.style;
    delete this._cookedStyles;
    this.forEach(function (geometry) {
      geometry._setExternSymbol(null);
    }, this);
    this.fire('removestyle');
    return this;
  };

  _proto.onAddGeometry = function onAddGeometry(geo) {
    var style = this.getStyle();

    if (style) {
      this._styleGeometry(geo);
    }
  };

  _proto.hide = function hide() {
    for (var i = 0, l = this._geoList.length; i < l; i++) {
      this._geoList[i].onHide();
    }

    return Layer.prototype.hide.call(this);
  };

  _proto._initCache = function _initCache() {
    if (!this._geoList) {
      this._geoList = [];
      this._geoMap = {};
    }
  };

  _proto._updateZIndex = function _updateZIndex() {
    for (var _len = arguments.length, zIndex = new Array(_len), _key = 0; _key < _len; _key++) {
      zIndex[_key] = arguments[_key];
    }

    this._maxZIndex = Math.max(this._maxZIndex, Math.max.apply(Math, zIndex));
    this._minZIndex = Math.min(this._minZIndex, Math.min.apply(Math, zIndex));
  };

  _proto._sortGeometries = function _sortGeometries() {
    var _this2 = this;

    if (!this._toSort) {
      return;
    }

    this._maxZIndex = 0;
    this._minZIndex = 0;

    this._geoList.sort(function (a, b) {
      _this2._updateZIndex(a.getZIndex(), b.getZIndex());

      return _this2._compare(a, b);
    });

    this._toSort = false;
  };

  _proto._compare = function _compare(a, b) {
    if (a.getZIndex() === b.getZIndex()) {
      return a._getInternalId() - b._getInternalId();
    }

    return a.getZIndex() - b.getZIndex();
  };

  _proto._findInList = function _findInList(geo) {
    var len = this._geoList.length;

    if (len === 0) {
      return -1;
    }

    var low = 0,
        high = len - 1,
        middle;

    while (low <= high) {
      middle = Math.floor((low + high) / 2);

      if (this._geoList[middle] === geo) {
        return middle;
      } else if (this._compare(this._geoList[middle], geo) > 0) {
        high = middle - 1;
      } else {
        low = middle + 1;
      }
    }

    return -1;
  };

  _proto._onGeometryEvent = function _onGeometryEvent(param) {
    if (!param || !param['target']) {
      return;
    }

    var type = param['type'];

    if (type === 'idchange') {
      this._onGeometryIdChange(param);
    } else if (type === 'zindexchange') {
      this._onGeometryZIndexChange(param);
    } else if (type === 'positionchange') {
      this._onGeometryPositionChange(param);
    } else if (type === 'shapechange') {
      this._onGeometryShapeChange(param);
    } else if (type === 'symbolchange') {
      this._onGeometrySymbolChange(param);
    } else if (type === 'show') {
      this._onGeometryShow(param);
    } else if (type === 'hide') {
      this._onGeometryHide(param);
    } else if (type === 'propertieschange') {
      this._onGeometryPropertiesChange(param);
    }
  };

  _proto._onGeometryIdChange = function _onGeometryIdChange(param) {
    if (param['new'] === param['old']) {
      if (this._geoMap[param['old']] && this._geoMap[param['old']] === param['target']) {
        return;
      }
    }

    if (!isNil(param['new'])) {
      if (this._geoMap[param['new']]) {
        throw new Error('Duplicate geometry id in layer(' + this.getId() + '):' + param['new']);
      }

      this._geoMap[param['new']] = param['target'];
    }

    if (!isNil(param['old']) && param['new'] !== param['old']) {
      delete this._geoMap[param['old']];
    }
  };

  _proto._onGeometryZIndexChange = function _onGeometryZIndexChange(param) {
    if (param['old'] !== param['new']) {
      this._updateZIndex(param['new']);

      this._toSort = true;

      if (this._getRenderer()) {
        this._getRenderer().onGeometryZIndexChange(param);
      }
    }
  };

  _proto._onGeometryPositionChange = function _onGeometryPositionChange(param) {
    if (this._getRenderer()) {
      this._getRenderer().onGeometryPositionChange(param);
    }
  };

  _proto._onGeometryShapeChange = function _onGeometryShapeChange(param) {
    if (this._getRenderer()) {
      this._getRenderer().onGeometryShapeChange(param);
    }
  };

  _proto._onGeometrySymbolChange = function _onGeometrySymbolChange(param) {
    if (this._getRenderer()) {
      this._getRenderer().onGeometrySymbolChange(param);
    }
  };

  _proto._onGeometryShow = function _onGeometryShow(param) {
    if (this._getRenderer()) {
      this._getRenderer().onGeometryShow(param);
    }
  };

  _proto._onGeometryHide = function _onGeometryHide(param) {
    if (this._getRenderer()) {
      this._getRenderer().onGeometryHide(param);
    }
  };

  _proto._onGeometryPropertiesChange = function _onGeometryPropertiesChange(param) {
    if (this._getRenderer()) {
      this._getRenderer().onGeometryPropertiesChange(param);
    }
  };

  return OverlayLayer;
}(Layer);

OverlayLayer.mergeOptions(options$e);

var TEMP_EXTENT$3 = new PointExtent();
var options$f = {
  'debug': false,
  'enableSimplify': true,
  'geometryEvents': true,
  'defaultIconSize': [20, 20],
  'cacheVectorOnCanvas': true,
  'cacheSvgOnCanvas': Browser$1.gecko,
  'enableAltitude': false,
  'altitudeProperty': 'altitude',
  'drawAltitude': false,
  'altitude': 0
};

var VectorLayer = function (_OverlayLayer) {
  _inheritsLoose(VectorLayer, _OverlayLayer);

  function VectorLayer(id, geometries, options) {
    return _OverlayLayer.call(this, id, geometries, options) || this;
  }

  var _proto = VectorLayer.prototype;

  _proto.onConfig = function onConfig(conf) {
    _OverlayLayer.prototype.onConfig.call(this, conf);

    if (conf['enableAltitude'] || conf['drawAltitude'] || conf['altitudeProperty']) {
      var renderer = this.getRenderer();

      if (renderer && renderer.setToRedraw) {
        renderer.setToRedraw();
      }
    }
  };

  _proto.identify = function identify(coordinate, options) {
    if (options === void 0) {
      options = {};
    }

    var renderer = this.getRenderer();

    if (options['onlyVisible'] && renderer && renderer.identify) {
      return renderer.identify(coordinate, options);
    }

    if (!(coordinate instanceof Coordinate)) {
      coordinate = new Coordinate(coordinate);
    }

    return this._hitGeos(this._geoList, coordinate, options);
  };

  _proto._hitGeos = function _hitGeos(geometries, coordinate, options) {
    if (options === void 0) {
      options = {};
    }

    var filter = options['filter'],
        tolerance = options['tolerance'],
        hits = [];
    var map = this.getMap();
    var point = map.coordToPoint(coordinate);

    var cp = map._pointToContainerPoint(point, undefined, 0, point);

    for (var i = geometries.length - 1; i >= 0; i--) {
      var geo = geometries[i];

      if (!geo || !geo.isVisible() || !geo._getPainter() || !geo.options['interactive']) {
        continue;
      }

      if (!(geo instanceof LineString) || !geo._getArrowStyle() && !(geo instanceof Curve)) {
        var extent = geo.getContainerExtent(TEMP_EXTENT$3);

        if (tolerance) {
          extent = extent._expand(tolerance);
        }

        if (!extent || !extent.contains(cp)) {
          continue;
        }
      }

      if (geo._containsPoint(cp, tolerance) && (!filter || filter(geo))) {
        hits.push(geo);

        if (options['count']) {
          if (hits.length >= options['count']) {
            break;
          }
        }
      }
    }

    return hits;
  };

  _proto.getAltitude = function getAltitude() {
    return this.options['altitude'] || 0;
  };

  _proto.toJSON = function toJSON(options) {
    if (!options) {
      options = {};
    }

    var profile = {
      'type': this.getJSONType(),
      'id': this.getId(),
      'options': this.config()
    };

    if (isNil(options['geometries']) || options['geometries']) {
      var clipExtent;

      if (options['clipExtent']) {
        var map = this.getMap();
        var projection = map ? map.getProjection() : null;
        clipExtent = new Extent(options['clipExtent'], projection);
      }

      var geoJSONs = [];
      var geometries = this.getGeometries();

      for (var i = 0, len = geometries.length; i < len; i++) {
        var geo = geometries[i];
        var geoExt = geo.getExtent();

        if (!geoExt || clipExtent && !clipExtent.intersects(geoExt)) {
          continue;
        }

        var json = geo.toJSON(options['geometries']);
        geoJSONs.push(json);
      }

      profile['geometries'] = geoJSONs;
    }

    return profile;
  };

  VectorLayer.fromJSON = function fromJSON(json) {
    if (!json || json['type'] !== 'VectorLayer') {
      return null;
    }

    var layer = new VectorLayer(json['id'], json['options']);
    var geoJSONs = json['geometries'];
    var geometries = [];

    for (var i = 0; i < geoJSONs.length; i++) {
      var geo = Geometry.fromJSON(geoJSONs[i]);

      if (geo) {
        geometries.push(geo);
      }
    }

    layer.addGeometry(geometries);
    return layer;
  };

  VectorLayer.getPainterClass = function getPainterClass() {
    return Painter;
  };

  VectorLayer.getCollectionPainterClass = function getCollectionPainterClass() {
    return CollectionPainter;
  };

  return VectorLayer;
}(OverlayLayer);

VectorLayer.mergeOptions(options$f);
VectorLayer.registerJSONType('VectorLayer');

var key = '_map_tool';

var MapTool = function (_Eventable) {
  _inheritsLoose(MapTool, _Eventable);

  function MapTool() {
    return _Eventable.apply(this, arguments) || this;
  }

  var _proto = MapTool.prototype;

  _proto.addTo = function addTo(map) {
    if (!map) {
      return this;
    }

    this._map = map;

    if (map[key]) {
      map[key].disable();
    }

    if (this.onAdd) {
      this.onAdd();
    }

    this.enable();
    map[key] = this;

    this._fireEvent('add');

    return this;
  };

  _proto.getMap = function getMap() {
    return this._map;
  };

  _proto.enable = function enable() {
    var map = this._map;

    if (!map || this._enabled) {
      return this;
    }

    this._enabled = true;

    this._switchEvents('off');

    this._registerEvents();

    if (this.onEnable) {
      this.onEnable();
    }

    this._fireEvent('enable');

    return this;
  };

  _proto.disable = function disable() {
    if (!this._enabled || !this._map) {
      return this;
    }

    this._enabled = false;

    this._switchEvents('off');

    if (this.onDisable) {
      this.onDisable();
    }

    this._fireEvent('disable');

    return this;
  };

  _proto.isEnabled = function isEnabled() {
    if (!this._enabled) {
      return false;
    }

    return true;
  };

  _proto.remove = function remove() {
    if (!this._map) {
      return this;
    }

    this.disable();

    if (this._map) {
      delete this._map[key];
      delete this._map;
    }

    this._fireEvent('remove');

    return this;
  };

  _proto._registerEvents = function _registerEvents() {
    this._switchEvents('on');
  };

  _proto._switchEvents = function _switchEvents(to) {
    var events = this.getEvents();

    if (events) {
      this._map[to](events, this);
    }
  };

  _proto._fireEvent = function _fireEvent(eventName, param) {
    if (!param) {
      param = {};
    }

    this.fire(eventName, param);
  };

  return MapTool;
}(Eventable(Class));

var options$g = {
  'symbol': {
    'lineColor': '#000',
    'lineWidth': 2,
    'lineOpacity': 1,
    'polygonFill': '#fff',
    'polygonOpacity': 0.3
  },
  'doubleClickZoom': false,
  'mode': null,
  'once': false,
  'autoPanAtEdge': false,
  'ignoreMouseleave': true
};
var registeredMode = {};

var DrawTool = function (_MapTool) {
  _inheritsLoose(DrawTool, _MapTool);

  DrawTool.registerMode = function registerMode(name, modeAction) {
    registeredMode[name.toLowerCase()] = modeAction;
  };

  DrawTool.getRegisterMode = function getRegisterMode(name) {
    return registeredMode[name.toLowerCase()];
  };

  function DrawTool(options) {
    var _this;

    _this = _MapTool.call(this, options) || this;

    _this._checkMode();

    _this._events = {
      'click': _this._clickHandler,
      'mousemove': _this._mouseMoveHandler,
      'dblclick': _this._doubleClickHandler,
      'mousedown': _this._mouseDownHandler,
      'mouseup': _this._mouseUpHandler
    };
    return _this;
  }

  var _proto = DrawTool.prototype;

  _proto.getMode = function getMode() {
    if (this.options['mode']) {
      return this.options['mode'].toLowerCase();
    }

    return null;
  };

  _proto.setMode = function setMode(mode) {
    if (this._geometry) {
      this._geometry.remove();

      delete this._geometry;
    }

    this._clearStage();

    this._switchEvents('off');

    this.options['mode'] = mode;

    this._checkMode();

    if (this.isEnabled()) {
      this._switchEvents('on');

      this._restoreMapCfg();

      this._saveMapCfg();
    }

    return this;
  };

  _proto.getSymbol = function getSymbol() {
    var symbol = this.options['symbol'];

    if (symbol) {
      return extendSymbol(symbol);
    } else {
      return extendSymbol(this.options['symbol']);
    }
  };

  _proto.setSymbol = function setSymbol(symbol) {
    if (!symbol) {
      return this;
    }

    this.options['symbol'] = symbol;

    if (this._geometry) {
      this._geometry.setSymbol(symbol);
    }

    return this;
  };

  _proto.getCurrentGeometry = function getCurrentGeometry() {
    return this._geometry;
  };

  _proto.onAdd = function onAdd() {
    this._checkMode();
  };

  _proto.onEnable = function onEnable() {
    this._saveMapCfg();

    this._drawToolLayer = this._getDrawLayer();

    this._clearStage();

    this._loadResources();

    if (this.options['autoPanAtEdge']) {
      var map = this.getMap();
      this._mapAutoPanAtEdge = map.options['autoPanAtEdge'];

      if (!this._mapAutoPanAtEdge) {
        map.config({
          autoPanAtEdge: true
        });
      }
    }

    return this;
  };

  _proto.onDisable = function onDisable() {
    var map = this.getMap();

    this._restoreMapCfg();

    this.endDraw();

    if (this._map) {
      map.removeLayer(this._getDrawLayer());

      if (this.options['autoPanAtEdge']) {
        if (!this._mapAutoPanAtEdge) {
          map.config({
            autoPanAtEdge: false
          });
        }
      }
    }

    return this;
  };

  _proto.undo = function undo() {
    var registerMode = this._getRegisterMode();

    var action = registerMode.action;

    if (!this._shouldRecordHistory(action) || !this._historyPointer) {
      return this;
    }

    var coords = this._clickCoords.slice(0, --this._historyPointer);

    registerMode.update(this.getMap().getProjection(), coords, this._geometry);
    return this;
  };

  _proto.redo = function redo() {
    var registerMode = this._getRegisterMode();

    var action = registerMode.action;

    if (!this._shouldRecordHistory(action) || isNil(this._historyPointer) || this._historyPointer === this._clickCoords.length) {
      return this;
    }

    var coords = this._clickCoords.slice(0, ++this._historyPointer);

    registerMode.update(this.getMap().getProjection(), coords, this._geometry);
    return this;
  };

  _proto._shouldRecordHistory = function _shouldRecordHistory(actions) {
    return Array.isArray(actions) && actions[0] === 'click' && actions[1] === 'mousemove' && actions[2] === 'dblclick';
  };

  _proto._checkMode = function _checkMode() {
    this._getRegisterMode();
  };

  _proto._saveMapCfg = function _saveMapCfg() {
    var map = this.getMap();
    this._mapDoubleClickZoom = map.options['doubleClickZoom'];
    map.config({
      'doubleClickZoom': this.options['doubleClickZoom']
    });

    var actions = this._getRegisterMode()['action'];

    if (actions.indexOf('mousedown') > -1) {
      var _map = this.getMap();

      this._mapDraggable = _map.options['draggable'];

      _map.config({
        'draggable': false
      });
    }
  };

  _proto._restoreMapCfg = function _restoreMapCfg() {
    var map = this.getMap();
    map.config({
      'doubleClickZoom': this._mapDoubleClickZoom
    });

    if (!isNil(this._mapDraggable)) {
      map.config('draggable', this._mapDraggable);
    }

    delete this._mapDraggable;
    delete this._mapDoubleClickZoom;
  };

  _proto._loadResources = function _loadResources() {
    var symbol = this.getSymbol();
    var resources = getExternalResources(symbol);

    if (resources.length > 0) {
      this._drawToolLayer._getRenderer().loadResources(resources);
    }
  };

  _proto._getProjection = function _getProjection() {
    return this._map.getProjection();
  };

  _proto._getRegisterMode = function _getRegisterMode() {
    var mode = this.getMode();
    var registerMode = DrawTool.getRegisterMode(mode);

    if (!registerMode) {
      throw new Error(mode + ' is not a valid mode of DrawTool.');
    }

    return registerMode;
  };

  _proto.getEvents = function getEvents() {
    var action = this._getRegisterMode()['action'];

    var _events = {};

    if (Array.isArray(action)) {
      for (var i = 0; i < action.length; i++) {
        _events[action[i]] = this._events[action[i]];
      }

      return _events;
    }

    return null;
  };

  _proto._mouseDownHandler = function _mouseDownHandler(event) {
    this._createGeometry(event);
  };

  _proto._mouseUpHandler = function _mouseUpHandler(event) {
    this.endDraw(event);
  };

  _proto._clickHandler = function _clickHandler(event) {
    var registerMode = this._getRegisterMode();

    if (!this._geometry) {
      this._createGeometry(event);
    } else {
      var prjCoord = this.getMap()._pointToPrj(event['point2d']);

      if (!isNil(this._historyPointer)) {
        this._clickCoords = this._clickCoords.slice(0, this._historyPointer);
      }

      this._clickCoords.push(prjCoord);

      this._historyPointer = this._clickCoords.length;
      event.drawTool = this;
      registerMode['update'](this.getMap().getProjection(), this._clickCoords, this._geometry, event);

      this._fireEvent('drawvertex', event);

      if (registerMode['clickLimit'] && registerMode['clickLimit'] === this._historyPointer) {
        this.endDraw(event);
      }
    }
  };

  _proto._createGeometry = function _createGeometry(event) {
    var mode = this.getMode();

    var registerMode = this._getRegisterMode();

    var prjCoord = this.getMap()._pointToPrj(event['point2d']);

    var symbol = this.getSymbol();

    if (!this._geometry) {
      this._clickCoords = [prjCoord];
      event.drawTool = this;
      this._geometry = registerMode['create'](this.getMap().getProjection(), this._clickCoords, event);

      if (symbol && mode !== 'point') {
        this._geometry.setSymbol(symbol);
      } else if (this.options.hasOwnProperty('symbol')) {
        this._geometry.setSymbol(this.options['symbol']);
      }

      this._addGeometryToStage(this._geometry);

      this._fireEvent('drawstart', event);
    }

    if (mode === 'point') {
      this.endDraw(event);
    }
  };

  _proto._mouseMoveHandler = function _mouseMoveHandler(event) {
    var map = this.getMap();

    if (!this._geometry || !map || map.isInteracting()) {
      return;
    }

    var containerPoint = this._getMouseContainerPoint(event);

    if (!this._isValidContainerPoint(containerPoint)) {
      return;
    }

    var prjCoord = this.getMap()._pointToPrj(event['point2d']);

    var projection = map.getProjection();
    event.drawTool = this;

    var registerMode = this._getRegisterMode();

    if (this._shouldRecordHistory(registerMode.action)) {
      var path = this._clickCoords.slice(0, this._historyPointer);

      if (path && path.length > 0 && prjCoord.equals(path[path.length - 1])) {
        return;
      }

      registerMode['update'](projection, path.concat([prjCoord]), this._geometry, event);
    } else {
      registerMode['update'](projection, prjCoord, this._geometry, event);
    }

    this._fireEvent('mousemove', event);
  };

  _proto._doubleClickHandler = function _doubleClickHandler(event) {
    if (!this._geometry) {
      return;
    }

    var containerPoint = this._getMouseContainerPoint(event);

    if (!this._isValidContainerPoint(containerPoint)) {
      return;
    }

    var registerMode = this._getRegisterMode();

    var clickCoords = this._clickCoords;

    if (clickCoords.length < 2) {
      return;
    }

    var projection = this.getMap().getProjection();
    var path = [clickCoords[0]];

    for (var i = 1, len = clickCoords.length; i < len; i++) {
      if (clickCoords[i].x !== clickCoords[i - 1].x || clickCoords[i].y !== clickCoords[i - 1].y) {
        path.push(clickCoords[i]);
      }
    }

    if (path.length < 2 || this._geometry && this._geometry instanceof Polygon && path.length < 3) {
      return;
    }

    event.drawTool = this;
    registerMode['update'](projection, path, this._geometry, event);
    this.endDraw(event);
  };

  _proto._addGeometryToStage = function _addGeometryToStage(geometry) {
    var drawLayer = this._getDrawLayer();

    drawLayer.addGeometry(geometry);
  };

  _proto.endDraw = function endDraw(param) {
    if (!this._geometry || this._ending) {
      return this;
    }

    this._ending = true;
    var geometry = this._geometry;

    this._clearStage();

    param = param || {};
    this._geometry = geometry;

    this._fireEvent('drawend', param);

    delete this._geometry;

    if (this.options['once']) {
      this.disable();
    }

    delete this._ending;
    delete this._historyPointer;
    return this;
  };

  _proto._clearStage = function _clearStage() {
    this._getDrawLayer().clear();

    delete this._geometry;
    delete this._clickCoords;
  };

  _proto._getMouseContainerPoint = function _getMouseContainerPoint(event) {
    var action = this._getRegisterMode()['action'];

    if (action === 'mousedown') {
      stopPropagation(event['domEvent']);
    }

    return event['containerPoint'];
  };

  _proto._isValidContainerPoint = function _isValidContainerPoint(containerPoint) {
    var mapSize = this._map.getSize();

    var w = mapSize['width'],
        h = mapSize['height'];

    if (containerPoint.x < 0 || containerPoint.y < 0) {
      return false;
    } else if (containerPoint.x > w || containerPoint.y > h) {
      return false;
    }

    return true;
  };

  _proto._getDrawLayer = function _getDrawLayer() {
    var drawLayerId = INTERNAL_LAYER_PREFIX + 'drawtool';

    var drawToolLayer = this._map.getLayer(drawLayerId);

    if (!drawToolLayer) {
      drawToolLayer = new VectorLayer(drawLayerId, {
        'enableSimplify': false
      });

      this._map.addLayer(drawToolLayer);
    }

    return drawToolLayer;
  };

  _proto._fireEvent = function _fireEvent(eventName, param) {
    if (!param) {
      param = {};
    }

    if (this._geometry) {
      param['geometry'] = this._getRegisterMode()['generate'](this._geometry, {
        drawTool: this
      });
    }

    MapTool.prototype._fireEvent.call(this, eventName, param);
  };

  return DrawTool;
}(MapTool);

DrawTool.mergeOptions(options$g);

var MapBoxZoomHander = function (_Handler) {
  _inheritsLoose(MapBoxZoomHander, _Handler);

  function MapBoxZoomHander(target) {
    var _this;

    _this = _Handler.call(this, target) || this;
    _this.drawTool = new DrawTool({
      'mode': 'boxZoom',
      'ignoreMouseleave': false
    });
    return _this;
  }

  var _proto = MapBoxZoomHander.prototype;

  _proto.addHooks = function addHooks() {
    this.target.on('_mousedown', this._onMouseDown, this);
  };

  _proto.removeHooks = function removeHooks() {
    this.target.off('_mousedown', this._onMouseDown, this);

    if (this.drawTool.isEnabled()) {
      this.drawTool.remove();
    }
  };

  _proto._onMouseDown = function _onMouseDown(param) {
    if (!this.target.options['boxZoom']) {
      return;
    }

    if (param.domEvent.shiftKey) {
      this.drawTool.setSymbol(this.target.options['boxZoomSymbol']).on('drawend', this._boxZoom, this).addTo(this.target);
    }
  };

  _proto._boxZoom = function _boxZoom(param) {
    var map = this.target;
    this.drawTool.remove();
    var geometry = param.geometry,
        center = geometry.getCenter(),
        symbol = geometry.getSymbol(),
        w = symbol.markerWidth,
        h = symbol.markerHeight;
    var extent = new Extent(center, map.locateByPoint(center, w, h), map.getProjection());
    var zoom = map.getFitZoom(extent);

    map._animateTo({
      center: extent.getCenter(),
      zoom: zoom
    });
  };

  return MapBoxZoomHander;
}(Handler$1);

Map$1.mergeOptions({
  'boxZoom': true,
  'boxZoomSymbol': {
    'markerType': 'rectangle',
    'markerLineWidth': 3,
    'markerLineColor': '#1bbc9b',
    'markerLineDasharray': [10, 5],
    'markerFillOpacity': 0.1,
    'markerFill': '#1bbc9b',
    'markerWidth': 1,
    'markerHeight': 1
  }
});
Map$1.addOnLoadHook('addHandler', 'boxZoom', MapBoxZoomHander);

var PANOFFSET = 30;

var MapAutoPanAtEdgeHandler = function (_Handler) {
  _inheritsLoose(MapAutoPanAtEdgeHandler, _Handler);

  function MapAutoPanAtEdgeHandler() {
    return _Handler.apply(this, arguments) || this;
  }

  var _proto = MapAutoPanAtEdgeHandler.prototype;

  _proto.addHooks = function addHooks() {
    if (!this.target) {
      return;
    }

    this.target.on('_mousemove', this._onMouseMove, this);
  };

  _proto.removeHooks = function removeHooks() {
    if (!this.target) {
      return;
    }

    this.target.off('_mousemove', this._onMouseMove, this);
  };

  _proto._onMouseMove = function _onMouseMove(event) {
    var map = this.target;

    if (map.options['autoPanAtEdge']) {
      var containerPoint = event.containerPoint;
      var containerExtent = map.getContainerExtent();

      if (containerExtent) {
        var x = containerPoint.x,
            y = containerPoint.y;
        var xmax = containerExtent.xmax,
            ymax = containerExtent.ymax;
        var p;

        if (x < PANOFFSET) {
          p = [Math.abs(x - PANOFFSET), 0];
        }

        if (y < PANOFFSET) {
          p = [0, Math.abs(y - PANOFFSET)];
        }

        if (x + PANOFFSET > xmax) {
          p = [-Math.abs(x + PANOFFSET - xmax), 0];
        }

        if (y + PANOFFSET > ymax) {
          p = [0, -Math.abs(y + PANOFFSET - ymax)];
        }

        if (p) {
          map.panBy(p, {
            duration: 1
          });
        }
      }
    }
  };

  return MapAutoPanAtEdgeHandler;
}(Handler$1);

Map$1.mergeOptions({
  'autoPanAtEdge': false
});
Map$1.addOnLoadHook('addHandler', 'autoPanAtEdge', MapAutoPanAtEdgeHandler);

Map$1.include({
  animateTo: function animateTo(view, options, step) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    if (isFunction(options)) {
      step = options;
      options = {};
    }

    var projection = this.getProjection(),
        currView = this.getView(),
        props = {};
    var empty = true;

    for (var p in view) {
      if (hasOwn(view, p) && !isNil(view[p]) && (p === 'prjCenter' || !isNil(currView[p]))) {
        empty = false;

        if (p === 'center') {
          var from = new Coordinate(currView[p]).toFixed(7),
              to = new Coordinate(view[p]).toFixed(7);

          if (!from.equals(to)) {
            props['center'] = [from, to];
          }
        } else if (p === 'prjCenter') {
          var _from = new Coordinate(this._getPrjCenter());

          var _to = new Coordinate(view[p]);

          if (!_from.equals(_to)) {
            props['prjCenter'] = [_from, _to];
          }
        } else if (currView[p] !== view[p] && p !== 'around') {
          props[p] = [currView[p], view[p]];
        }
      }
    }

    if (empty) {
      return null;
    }

    if (this._animPlayer) {
      if (this._isInternalAnimation) {
        if (this._animPlayer.playState === 'running') {
          this._animPlayer.pause();

          this._prevAnimPlayer = this._animPlayer;
        }
      } else {
        delete this._prevAnimPlayer;

        this._stopAnim(this._animPlayer);
      }
    }

    var zoomOrigin = view['around'] || new Point(this.width / 2, this.height / 2);

    var renderer = this._getRenderer(),
        framer = function framer(fn) {
      renderer.callInNextFrame(fn);
    };

    var player = this._animPlayer = Animation.animate(props, {
      'easing': options['easing'] || 'out',
      'duration': options['duration'] || this.options['zoomAnimationDuration'],
      'framer': framer
    }, function (frame) {
      if (_this.isRemoved()) {
        player.finish();
        return;
      }

      if (player.playState === 'running') {
        if (frame.styles['center']) {
          var center = frame.styles['center'];

          _this._setPrjCenter(projection.project(center));

          _this.onMoving(_this._parseEventFromCoord(_this.getCenter()));
        } else if (frame.styles['prjCenter']) {
          var _center = frame.styles['prjCenter'];

          _this._setPrjCenter(_center);

          _this.onMoving(_this._parseEventFromCoord(_this.getCenter()));
        }

        if (!isNil(frame.styles['zoom'])) {
          _this.onZooming(frame.styles['zoom'], zoomOrigin);
        }

        if (!isNil(frame.styles['pitch'])) {
          _this.setPitch(frame.styles['pitch']);
        }

        if (!isNil(frame.styles['bearing'])) {
          _this.setBearing(frame.styles['bearing']);
        }

        _this._fireEvent('animating');
      } else if (player.playState !== 'paused' || player === _this._mapAnimPlayer) {
        if (!player._interupted) {
          if (props['center']) {
            _this._setPrjCenter(projection.project(props['center'][1]));
          } else if (props['prjCenter']) {
            _this._setPrjCenter(props['prjCenter'][1]);
          }

          if (!isNil(props['pitch'])) {
            _this.setPitch(props['pitch'][1]);
          }

          if (!isNil(props['bearing'])) {
            _this.setBearing(props['bearing'][1]);
          }
        }

        _this._endAnim(player, props, zoomOrigin, options);
      }

      if (step) {
        step(frame);
      }
    }, this);

    this._startAnim(props, zoomOrigin);

    return player;
  },
  _animateTo: function _animateTo(view, options, step) {
    if (options === void 0) {
      options = {};
    }

    if (this._mapAnimPlayer) {
      this._stopAnim(this._mapAnimPlayer);
    }

    this._isInternalAnimation = true;
    this._mapAnimPlayer = this.animateTo(view, options, step);
    delete this._isInternalAnimation;
    return this._mapAnimPlayer;
  },
  isAnimating: function isAnimating() {
    return !!this._animPlayer;
  },
  isRotating: function isRotating() {
    return this.isDragRotating() || !!this._animRotating;
  },
  _endAnim: function _endAnim(player, props, zoomOrigin, options) {
    delete this._animRotating;
    var evtType = player._interupted ? 'animateinterrupted' : 'animateend';

    if (player === this._animPlayer) {
      delete this._animPlayer;
    }

    if (player === this._mapAnimPlayer) {
      delete this._mapAnimPlayer;
    }

    if (props['center']) {
      var endCoord;

      if (player._interupted) {
        endCoord = this.getCenter();
      } else {
        endCoord = props['center'][1];
      }

      this.onMoveEnd(this._parseEventFromCoord(endCoord));
    } else if (props['prjCenter']) {
      var _endCoord;

      if (player._interupted) {
        _endCoord = this._getPrjCenter();
      } else {
        _endCoord = props['prjCenter'][1];
      }

      var event = this._parseEventFromCoord(this.getProjection().unproject(_endCoord));

      event['point2d'] = this._prjToPoint(_endCoord);
      this.onMoveEnd(event);
    }

    if (!isNil(props['zoom'])) {
      if (player._interupted) {
        this.onZoomEnd(this.getZoom(), zoomOrigin);
      } else if (!options['wheelZoom']) {
        this.onZoomEnd(props['zoom'][1], zoomOrigin);
      } else {
        this.onZooming(props['zoom'][1], zoomOrigin);
      }
    }

    if (evtType) {
      this._fireEvent(evtType);
    }

    if (!isNil(props['pitch']) && !this.getPitch()) {
      this.getRenderer().setToRedraw();
    }

    this._resumePrev(player);
  },
  _startAnim: function _startAnim(props, zoomOrigin) {
    if (!this._animPlayer) {
      return;
    }

    if (props['center']) {
      this.onMoveStart();
    }

    if (props['zoom'] && !this.isZooming()) {
      this.onZoomStart(props['zoom'][1], zoomOrigin);
    }

    if (props['pitch'] || props['bearing']) {
      this._animRotating = true;
    }

    this._fireEvent('animatestart');

    this._animPlayer.play();
  },
  _stopAnim: function _stopAnim(player) {
    if (!player) {
      return;
    }

    delete this._animRotating;

    if (player.playState !== 'finished') {
      player._interupted = true;
      player.cancel();
    }

    if (player === this._animPlayer) {
      delete this._animPlayer;
    }

    if (player === this._mapAnimPlayer) {
      delete this._mapAnimPlayer;
    }
  },
  _resumePrev: function _resumePrev(player) {
    if (!this._prevAnimPlayer) {
      return;
    }

    var prevPlayer = this._prevAnimPlayer;

    if (prevPlayer.playState !== 'paused') {
      delete this._prevAnimPlayer;
    }

    if (player !== prevPlayer) {
      this._animPlayer = prevPlayer;
      prevPlayer.play();
    }
  }
});

var events = 'mousedown ' + 'mouseup ' + 'mouseover ' + 'mouseout ' + 'mouseenter ' + 'mouseleave ' + 'mousemove ' + 'click ' + 'dblclick ' + 'contextmenu ' + 'keypress ' + 'touchstart ' + 'touchmove ' + 'touchend ';
Map$1.include({
  _registerDomEvents: function _registerDomEvents() {
    var dom = this._panels.mapWrapper || this._containerDOM;
    addDomEvent(dom, events, this._handleDOMEvent, this);
  },
  _removeDomEvents: function _removeDomEvents() {
    var dom = this._panels.mapWrapper || this._containerDOM;
    removeDomEvent(dom, events, this._handleDOMEvent, this);
  },
  _handleDOMEvent: function _handleDOMEvent(e) {
    var type = e.type;

    if (type === 'contextmenu') {
      preventDefault(e);
    }

    if (this._ignoreEvent(e)) {
      return;
    }

    var mimicClick = false;

    if (type === 'mousedown' || type === 'touchstart' && e.touches.length === 1) {
      this._mouseDownTime = now();
    } else if (type === 'click' || type === 'touchend' || type === 'contextmenu') {
      if (!this._mouseDownTime) {
        return;
      } else {
        var downTime = this._mouseDownTime;
        delete this._mouseDownTime;
        var time = now();

        if (time - downTime > 300) {
          if (type === 'click' || type === 'contextmenu') {
            return;
          }
        } else if (type === 'touchend') {
          mimicClick = true;
        }
      }
    }

    this._fireDOMEvent(this, e, type);

    if (mimicClick) {
      if (this._clickTime && now() - this._clickTime <= 300) {
        delete this._clickTime;

        this._fireDOMEvent(this, e, 'dblclick');
      } else {
        this._clickTime = now();

        this._fireDOMEvent(this, e, 'click');
      }
    }
  },
  _ignoreEvent: function _ignoreEvent(domEvent) {
    if (!domEvent || !this._panels.control) {
      return false;
    }

    if (this._isEventOutMap(domEvent)) {
      return true;
    }

    var target = domEvent.srcElement || domEvent.target;
    var preTarget;

    if (target) {
      while (target && target !== this._containerDOM) {
        if (target.className && target.className.indexOf && (target.className.indexOf('maptalks-control') >= 0 || target.className.indexOf('maptalks-ui') >= 0 && !preTarget['eventsPropagation'])) {
          return true;
        }

        preTarget = target;
        target = target.parentNode;
      }
    }

    return false;
  },
  _isEventOutMap: function _isEventOutMap(domEvent) {
    if (this.getPitch() > this.options['maxVisualPitch']) {
      var actualEvent = this._getActualEvent(domEvent);

      var eventPos = getEventContainerPoint(actualEvent, this._containerDOM);

      if (!this.getContainerExtent().contains(eventPos)) {
        return true;
      }
    }

    return false;
  },
  _parseEvent: function _parseEvent(e, type) {
    if (!e) {
      return null;
    }

    var eventParam = {
      'domEvent': e
    };

    if (type !== 'keypress') {
      var actual = this._getActualEvent(e);

      if (actual) {
        var containerPoint = getEventContainerPoint(actual, this._containerDOM);
        eventParam = extend(eventParam, {
          'coordinate': this.containerPointToCoord(containerPoint),
          'containerPoint': containerPoint,
          'viewPoint': this.containerPointToViewPoint(containerPoint),
          'point2d': this._containerPointToPoint(containerPoint)
        });
      }
    }

    return eventParam;
  },
  _parseEventFromCoord: function _parseEventFromCoord(coord) {
    var containerPoint = this.coordToContainerPoint(coord),
        viewPoint = this.containerPointToViewPoint(containerPoint);
    var e = {
      'coordinate': coord,
      'containerPoint': containerPoint,
      'viewPoint': viewPoint,
      'point2d': this.coordToPoint(coord)
    };
    return e;
  },
  _getActualEvent: function _getActualEvent(e) {
    return e.touches && e.touches.length > 0 ? e.touches[0] : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;
  },
  _fireDOMEvent: function _fireDOMEvent(target, e, type) {
    if (this.isRemoved()) {
      return;
    }

    var eventParam = this._parseEvent(e, type);

    this._fireEvent(type, eventParam);
  }
});
Map$1.addOnLoadHook('_registerDomEvents');

Map$1.include({
  isFullScreen: function isFullScreen() {
    return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
  },
  requestFullScreen: function requestFullScreen(dom) {
    this._fireEvent('fullscreenstart');

    this._requestFullScreen(dom || this._containerDOM);

    this._fireEvent('fullscreenend');

    return this;
  },
  cancelFullScreen: function cancelFullScreen() {
    this._cancelFullScreen();

    this._fireEvent('cancelfullscreen');

    return this;
  },
  _requestFullScreen: function _requestFullScreen(dom) {
    if (dom.requestFullscreen) {
      dom.requestFullscreen();
    } else if (dom.mozRequestFullScreen) {
      dom.mozRequestFullScreen();
    } else if (dom.webkitRequestFullScreen) {
      dom.webkitRequestFullScreen();
    } else if (dom.msRequestFullScreen) {
      dom.msRequestFullScreen();
    } else {
      var features = 'fullscreen=1,status=no,resizable=yes,top=0,left=0,scrollbars=no,' + 'titlebar=no,menubar=no,location=no,toolbar=no,z-look=yes,' + 'width=' + (screen.availWidth - 8) + ',height=' + (screen.availHeight - 45);
      var newWin = window.open(location.href, '_blank', features);

      if (newWin !== null) {
        window.opener = null;
        window.close();
      }
    }
  },
  _cancelFullScreen: function _cancelFullScreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitCancelFullScreen) {
      document.webkitCancelFullScreen();
    } else {
      var features = 'fullscreen=no,status=yes,resizable=yes,scrollbars=no,' + 'titlebar=no,menubar=yes,location=yes,toolbar=yes,z-look=yes';
      var newWin = window.open(location.href, '_blank', features);

      if (newWin !== null) {
        window.opener = null;
        window.close();
      }
    }
  }
});

Map$1.include({
  panTo: function panTo(coordinate, options, step) {
    if (options === void 0) {
      options = {};
    }

    if (!coordinate) {
      return this;
    }

    if (isFunction(options)) {
      step = options;
      options = {};
    }

    coordinate = new Coordinate(coordinate);

    if (typeof options['animation'] === 'undefined' || options['animation']) {
      var prjCoord = this.getProjection().project(coordinate);
      return this._panAnimation(prjCoord, options['duration'], step);
    } else {
      this.setCenter(coordinate);
    }

    return this;
  },
  _panTo: function _panTo(prjCoord, options) {
    if (options === void 0) {
      options = {};
    }

    if (typeof options['animation'] === 'undefined' || options['animation']) {
      return this._panAnimation(prjCoord, options['duration']);
    } else {
      this.onMoveStart();

      this._setPrjCenter(prjCoord);

      this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
      return this;
    }
  },
  panBy: function panBy(offset, options, step) {
    if (options === void 0) {
      options = {};
    }

    if (!offset) {
      return this;
    }

    if (isFunction(options)) {
      step = options;
      options = {};
    }

    offset = new Point(offset);
    var containerExtent = this.getContainerExtent();
    var ymin = containerExtent.ymin;

    if (ymin > 0 && offset.y > 30) {
      var y = offset.y;
      offset.y = 30;
      offset.x = offset.x * 30 / y;
      console.warn('offset is limited to panBy when pitch is above maxPitch');
    }

    this.onMoveStart();

    if (typeof options['animation'] === 'undefined' || options['animation']) {
      offset = offset.multi(-1);

      var target = this._containerPointToPrj(new Point(this.width / 2 + offset.x, this.height / 2 + offset.y));

      this._panAnimation(target, options['duration'], step);
    } else {
      this._offsetCenterByPixel(offset);

      this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
    }

    return this;
  },
  _panAnimation: function _panAnimation(target, t, cb) {
    return this._animateTo({
      'prjCenter': target
    }, {
      'duration': t || this.options['panAnimationDuration']
    }, cb);
  }
});

Geometry.fromJSON = function (json) {
  if (Array.isArray(json)) {
    var result = [];

    for (var i = 0, len = json.length; i < len; i++) {
      var c = Geometry.fromJSON(json[i]);

      if (Array.isArray(json)) {
        result = result.concat(c);
      } else {
        result.push(c);
      }
    }

    return result;
  }

  if (json && !json['feature']) {
    return GeoJSON.toGeometry(json);
  }

  var geometry;

  if (json['subType']) {
    geometry = Geometry.getJSONClass(json['subType']).fromJSON(json);

    if (!isNil(json['feature']['id'])) {
      geometry.setId(json['feature']['id']);
    }
  } else {
    geometry = GeoJSON.toGeometry(json['feature']);

    if (json['options']) {
      geometry.config(json['options']);
    }
  }

  if (json['symbol']) {
    geometry.setSymbol(json['symbol']);
  }

  if (json['infoWindow']) {
    geometry.setInfoWindow(json['infoWindow']);
  }

  return geometry;
};

Layer.fromJSON = function (layerJSON) {
  if (!layerJSON) {
    return null;
  }

  var layerType = layerJSON['type'];
  var clazz = Layer.getJSONClass(layerType);

  if (!clazz || !clazz.fromJSON) {
    throw new Error('unsupported layer type:' + layerType);
  }

  return clazz.fromJSON(layerJSON);
};

Map$1.include({
  'JSON_VERSION': '1.0',
  toJSON: function toJSON(options) {
    if (!options) {
      options = {};
    }

    var json = {
      'jsonVersion': this['JSON_VERSION'],
      'version': this.VERSION,
      'extent': this.getExtent().toJSON()
    };
    json['options'] = this.config();
    json['options']['center'] = this.getCenter();
    json['options']['zoom'] = this.getZoom();
    json['options']['bearing'] = this.getBearing();
    json['options']['pitch'] = this.getPitch();
    var baseLayer = this.getBaseLayer();

    if ((isNil(options['baseLayer']) || options['baseLayer']) && baseLayer) {
      json['baseLayer'] = baseLayer.toJSON(options['baseLayer']);
    }

    var extraLayerOptions = {};

    if (options['clipExtent']) {
      if (options['clipExtent'] === true) {
        extraLayerOptions['clipExtent'] = this.getExtent();
      } else {
        extraLayerOptions['clipExtent'] = options['clipExtent'];
      }
    }

    var layersJSON = [];

    if (isNil(options['layers']) || options['layers'] && !Array.isArray(options['layers'])) {
      var layers = this.getLayers();

      for (var i = 0, len = layers.length; i < len; i++) {
        if (!layers[i].toJSON) {
          continue;
        }

        var opts = extend({}, isObject(options['layers']) ? options['layers'] : {}, extraLayerOptions);
        layersJSON.push(layers[i].toJSON(opts));
      }

      json['layers'] = layersJSON;
    } else if (isArrayHasData(options['layers'])) {
      var _layers = options['layers'];

      for (var _i = 0; _i < _layers.length; _i++) {
        var exportOption = _layers[_i];
        var layer = this.getLayer(exportOption['id']);

        if (!layer.toJSON) {
          continue;
        }

        var _opts = extend({}, exportOption['options'], extraLayerOptions);

        layersJSON.push(layer.toJSON(_opts));
      }

      json['layers'] = layersJSON;
    } else {
      json['layers'] = [];
    }

    return json;
  }
});

Map$1.fromJSON = function (container, profile, options) {
  if (!container || !profile) {
    return null;
  }

  if (!options) {
    options = {};
  }

  var map = new Map$1(container, profile['options']);

  if (isNil(options['baseLayer']) || options['baseLayer']) {
    var baseLayer = Layer.fromJSON(profile['baseLayer']);

    if (baseLayer) {
      map.setBaseLayer(baseLayer);
    }
  }

  if (isNil(options['layers']) || options['layers']) {
    var layers = [];
    var layerJSONs = profile['layers'];

    for (var i = 0; i < layerJSONs.length; i++) {
      var layer = Layer.fromJSON(layerJSONs[i]);
      layers.push(layer);
    }

    map.addLayer(layers);
  }

  return map;
};

Map$1.include({
  computeLength: function computeLength(coord1, coord2) {
    if (!this.getProjection()) {
      return null;
    }

    var p1 = new Coordinate(coord1),
        p2 = new Coordinate(coord2);

    if (p1.equals(p2)) {
      return 0;
    }

    return this.getProjection().measureLength(p1, p2);
  },
  computeGeometryLength: function computeGeometryLength(geometry) {
    return geometry._computeGeodesicLength(this.getProjection());
  },
  computeGeometryArea: function computeGeometryArea(geometry) {
    return geometry._computeGeodesicArea(this.getProjection());
  },
  identify: function identify(opts, callback) {
    if (!opts) {
      return this;
    }

    var reqLayers = opts['layers'];

    if (!isArrayHasData(reqLayers)) {
      return this;
    }

    var layers = [];

    for (var i = 0, len = reqLayers.length; i < len; i++) {
      if (isString(reqLayers[i])) {
        layers.push(this.getLayer(reqLayers[i]));
      } else {
        layers.push(reqLayers[i]);
      }
    }

    var coordinate = new Coordinate(opts['coordinate']);
    var options = extend({}, opts);
    var hits = [];

    for (var _i = layers.length - 1; _i >= 0; _i--) {
      if (opts['count'] && hits.length >= opts['count']) {
        break;
      }

      var layer = layers[_i];

      if (!layer || !layer.getMap() || !opts['includeInvisible'] && !layer.isVisible() || !opts['includeInternals'] && layer.getId().indexOf(INTERNAL_LAYER_PREFIX) >= 0) {
        continue;
      }

      var layerHits = layer.identify(coordinate, options);

      if (layerHits) {
        if (Array.isArray(layerHits)) {
          pushIn(hits, layerHits);
        } else {
          hits.push(layerHits);
        }
      }
    }

    callback.call(this, hits);
    return this;
  }
});

Map$1.include({
  _zoom: function _zoom(nextZoom, origin) {
    if (!this.options['zoomable'] || this.isZooming()) {
      return;
    }

    origin = this._checkZoomOrigin(origin);
    nextZoom = this._checkZoom(nextZoom);
    this.onZoomStart(nextZoom, origin);
    this._frameZoom = this.getZoom();
    this.onZoomEnd(nextZoom, origin);
  },
  _zoomAnimation: function _zoomAnimation(nextZoom, origin, startScale) {
    if (!this.options['zoomable'] || this.isZooming()) {
      return;
    }

    nextZoom = this._checkZoom(nextZoom);

    if (this.getZoom() === nextZoom) {
      return;
    }

    origin = this._checkZoomOrigin(origin);

    this._startZoomAnim(nextZoom, origin, startScale);
  },
  _checkZoomOrigin: function _checkZoomOrigin(origin) {
    if (!origin || this.options['zoomInCenter']) {
      origin = new Point(this.width / 2, this.height / 2);
    }

    if (this.options['zoomOrigin']) {
      origin = new Point(this.options['zoomOrigin']);
    }

    return origin;
  },
  _startZoomAnim: function _startZoomAnim(nextZoom, origin, startScale) {
    if (isNil(startScale)) {
      startScale = 1;
    }

    var endScale = this._getResolution(this._startZoomVal) / this._getResolution(nextZoom);

    var duration = this.options['zoomAnimationDuration'] * Math.abs(endScale - startScale) / Math.abs(endScale - 1);
    this._frameZoom = this._startZoomVal;

    this._animateTo({
      'zoom': nextZoom,
      'around': origin
    }, {
      'continueOnViewChanged': true,
      'duration': duration
    });
  },
  onZoomStart: function onZoomStart(nextZoom, origin) {
    if (!this.options['zoomable'] || this.isZooming()) {
      return;
    }

    if (this._mapAnimPlayer) {
      this._stopAnim(this._mapAnimPlayer);
    }

    this._zooming = true;
    this._startZoomVal = this.getZoom();
    this._startZoomCoord = this._containerPointToPrj(origin);

    this._fireEvent('zoomstart', {
      'from': this._startZoomVal,
      'to': nextZoom
    });
  },
  onZooming: function onZooming(nextZoom, origin, startScale) {
    if (!this.options['zoomable']) {
      return;
    }

    var frameZoom = this._frameZoom;

    if (frameZoom === nextZoom) {
      return;
    }

    if (isNil(startScale)) {
      startScale = 1;
    }

    this._zoomTo(nextZoom, origin);

    var res = this.getResolution(nextZoom),
        fromRes = this.getResolution(this._startZoomVal),
        scale = fromRes / res / startScale,
        startPoint = this._prjToContainerPoint(this._startZoomCoord, this._startZoomVal);

    var offset = this.getViewPoint();

    if (!this.isRotating() && !startPoint.equals(origin) && scale !== 1) {
      var pitch = this.getPitch();

      var originOffset = startPoint._sub(origin)._multi(1 / (1 - scale));

      if (pitch) {
        originOffset.y /= Math.cos(pitch * Math.PI / 180);
      }

      origin = origin.add(originOffset);
    }

    var matrix = {
      'view': [scale, 0, 0, scale, (origin.x - offset.x) * (1 - scale), (origin.y - offset.y) * (1 - scale)]
    };
    var dpr = this.getDevicePixelRatio();

    if (dpr !== 1) {
      origin = origin.multi(dpr);
    }

    matrix['container'] = [scale, 0, 0, scale, origin.x * (1 - scale), origin.y * (1 - scale)];

    this._fireEvent('zooming', {
      'from': this._startZoomVal,
      'to': nextZoom,
      'origin': origin,
      'matrix': matrix
    });

    this._frameZoom = nextZoom;
  },
  onZoomEnd: function onZoomEnd(nextZoom, origin) {
    if (!this.options['zoomable']) {
      return;
    }

    var startZoomVal = this._startZoomVal;

    this._zoomTo(nextZoom, origin);

    this._zooming = false;

    this._getRenderer().onZoomEnd();

    this._fireEvent('zoomend', {
      'from': startZoomVal,
      'to': nextZoom
    });

    if (!this._verifyExtent(this._getPrjCenter())) {
      this._panTo(this._prjMaxExtent.getCenter());
    }
  },
  _zoomTo: function _zoomTo(nextZoom, origin) {
    this._zoomLevel = nextZoom;

    this._calcMatrices();

    if (origin) {
      this._setPrjCoordAtContainerPoint(this._startZoomCoord, origin);
    }
  },
  _checkZoom: function _checkZoom(nextZoom) {
    var maxZoom = this.getMaxZoom(),
        minZoom = this.getMinZoom();

    if (nextZoom < minZoom) {
      nextZoom = minZoom;
    }

    if (nextZoom > maxZoom) {
      nextZoom = maxZoom;
    }

    return nextZoom;
  }
});

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = 2 * far * near * nf;
  out[15] = 0;
  return out;
}
function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2],
      a00,
      a01,
      a02,
      a03,
      a10,
      a11,
      a12,
      a13,
      a20,
      a21,
      a22,
      a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad),
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];

  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad),
      a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];

  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11],
      a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11],
      a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15],
      b00 = a00 * a11 - a01 * a10,
      b01 = a00 * a12 - a02 * a10,
      b02 = a00 * a13 - a03 * a10,
      b03 = a01 * a12 - a02 * a11,
      b04 = a01 * a13 - a03 * a11,
      b05 = a02 * a13 - a03 * a12,
      b06 = a20 * a31 - a21 * a30,
      b07 = a20 * a32 - a22 * a30,
      b08 = a20 * a33 - a23 * a30,
      b09 = a21 * a32 - a22 * a31,
      b10 = a21 * a33 - a23 * a31,
      b11 = a22 * a33 - a23 * a32,
      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

function set$2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function scale$1(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot ? Math.hypot(x, y, z) : hypot(x, y, z);
}
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

function hypot() {
  var y = 0;
  var i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
}

function applyMatrix(out, v, e) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
  out[0] = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
  out[1] = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
  out[2] = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
  return out;
}
function matrixToQuaternion(out, te) {
  var m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10],
      trace = m11 + m22 + m33;
  var s;

  if (trace > 0) {
    s = 0.5 / Math.sqrt(trace + 1.0);
    out.w = 0.25 / s;
    out.x = (m32 - m23) * s;
    out.y = (m13 - m31) * s;
    out.z = (m21 - m12) * s;
  } else if (m11 > m22 && m11 > m33) {
    s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
    out.w = (m32 - m23) / s;
    out.x = 0.25 * s;
    out.y = (m12 + m21) / s;
    out.z = (m13 + m31) / s;
  } else if (m22 > m33) {
    s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
    out.w = (m13 - m31) / s;
    out.x = (m12 + m21) / s;
    out.y = 0.25 * s;
    out.z = (m23 + m32) / s;
  } else {
    s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
    out.w = (m21 - m12) / s;
    out.x = (m13 + m31) / s;
    out.y = (m23 + m32) / s;
    out.z = 0.25 * s;
  }

  return this;
}
function quaternionToMatrix(out, q) {
  var te = out;
  var x = q.x,
      y = q.y,
      z = q.z,
      w = q.w;
  var x2 = x + x,
      y2 = y + y,
      z2 = z + z;
  var xx = x * x2,
      xy = x * y2,
      xz = x * z2;
  var yy = y * y2,
      yz = y * z2,
      zz = z * z2;
  var wx = w * x2,
      wy = w * y2,
      wz = w * z2;
  te[0] = 1 - (yy + zz);
  te[4] = xy - wz;
  te[8] = xz + wy;
  te[1] = xy + wz;
  te[5] = 1 - (xx + zz);
  te[9] = yz - wx;
  te[2] = xz - wy;
  te[6] = yz + wx;
  te[10] = 1 - (xx + yy);
  te[3] = 0;
  te[7] = 0;
  te[11] = 0;
  te[12] = 0;
  te[13] = 0;
  te[14] = 0;
  te[15] = 1;
  return te;
}
function setPosition(out, v) {
  var te = out;
  te[12] = v[0];
  te[13] = v[1];
  te[14] = v[2];
  return out;
}
function lookAt(te, eye, target, up) {
  var x = [0, 0, 0];
  var y = [0, 0, 0];
  var z = [0, 0, 0];
  subtract(z, eye, target);

  if (length(z) === 0) {
    z[2] = 1;
  }

  normalize(z, z);
  cross(x, up, z);

  if (length(z) === 0) {
    if (Math.abs(up[2]) === 1) {
      z[0] += 0.0001;
    } else {
      z[2] += 0.0001;
    }

    normalize(z, z);
    cross(x, up, z);
  }

  normalize(x, x);
  cross(y, z, x);
  te[0] = x[0];
  te[4] = y[0];
  te[8] = z[0];
  te[1] = x[1];
  te[5] = y[1];
  te[9] = z[1];
  te[2] = x[2];
  te[6] = y[2];
  te[10] = z[2];
  return te;
}

var RADIAN$1 = Math.PI / 180;
var DEFAULT_FOV = 0.6435011087932844;
var TEMP_COORD = new Coordinate(0, 0);
Map$1.include({
  getFov: function getFov() {
    if (!this._fov) {
      this._fov = DEFAULT_FOV;
    }

    return this._fov / RADIAN$1;
  },
  setFov: function setFov(fov) {
    if (this.isZooming()) {
      return this;
    }

    fov = Math.max(0.01, Math.min(60, fov));
    if (this._fov === fov) return this;
    var from = this.getFov();
    this._fov = fov * RADIAN$1;

    this._calcMatrices();

    this._renderLayers();

    this._fireEvent('fovchange', {
      'from': from,
      'to': this.getFov()
    });

    return this;
  },
  getBearing: function getBearing() {
    if (!this._angle) {
      return 0;
    }

    return -this._angle / RADIAN$1;
  },
  setBearing: function setBearing(bearing) {
    if (Browser$1.ie9) {
      throw new Error('map can\'t rotate in IE9.');
    }

    var b = -wrap(bearing, -180, 180) * RADIAN$1;
    if (this._angle === b) return this;
    var from = this.getBearing();

    this._fireEvent('rotatestart', {
      'from': from,
      'to': b
    });

    this._angle = b;

    this._calcMatrices();

    this._renderLayers();

    this._fireEvent('rotate', {
      'from': from,
      'to': b
    });

    this._fireEvent('rotateend', {
      'from': from,
      'to': b
    });

    return this;
  },
  getPitch: function getPitch() {
    if (!this._pitch) {
      return 0;
    }

    return this._pitch / Math.PI * 180;
  },
  setPitch: function setPitch(pitch) {
    if (Browser$1.ie9) {
      throw new Error('map can\'t tilt in IE9.');
    }

    var p = clamp(pitch, 0, this.options['maxPitch']) * RADIAN$1;
    if (this._pitch === p) return this;
    var from = this.getPitch();

    this._fireEvent('pitchstart', {
      'from': from,
      'to': p
    });

    this._pitch = p;

    this._calcMatrices();

    this._renderLayers();

    this._fireEvent('pitch', {
      'from': from,
      'to': p
    });

    this._fireEvent('pitchend', {
      'from': from,
      'to': p
    });

    return this;
  },
  isTransforming: function isTransforming() {
    return !!(this._pitch || this._angle);
  },
  getFrustumAltitude: function getFrustumAltitude() {
    return this._frustumAltitude;
  },
  _calcFrustumAltitude: function _calcFrustumAltitude() {
    var pitch = 90 - this.getPitch();
    var fov = this.getFov() / 2;
    var cameraAlt = this.cameraPosition ? this.cameraPosition[2] : 0;

    if (fov <= pitch) {
      return cameraAlt;
    }

    fov = Math.PI * fov / 180;
    var d1 = new Point(this.cameraPosition).distanceTo(new Point(this.cameraLookAt)),
        d2 = cameraAlt * Math.tan(fov * 2);
    var d = Math.tan(fov) * (d1 + d2);
    return cameraAlt + d;
  },
  _pointToContainerPoint: function () {
    var a = [0, 0, 0];
    return function (point, zoom, altitude, out) {
      if (altitude === void 0) {
        altitude = 0;
      }

      point = this._pointToPoint(point, zoom, out);

      if (this.isTransforming() || altitude) {
        altitude *= this._getResolution(zoom) / this._getResolution();
        var _scale = this._glScale;
        set$2(a, point.x * _scale, point.y * _scale, altitude * _scale);

        var t = this._projIfBehindCamera(a, this.cameraPosition, this.cameraForward);

        applyMatrix(t, t, this.projViewMatrix);
        var w2 = this.width / 2,
            h2 = this.height / 2;
        t[0] = t[0] * w2 + w2;
        t[1] = -(t[1] * h2) + h2;

        if (out) {
          out.x = t[0];
          out.y = t[1];
          return out;
        }

        return new Point(t[0], t[1]);
      } else {
        var centerPoint = this._prjToPoint(this._getPrjCenter(), undefined, TEMP_COORD);

        if (out) {
          out.x = point.x;
          out.y = point.y;
        } else {
          out = point;
        }

        out._sub(centerPoint.x, centerPoint.y);

        out.set(out.x, -out.y);
        return out._add(this.width / 2, this.height / 2);
      }
    };
  }(),
  _projIfBehindCamera: function () {
    var vectorFromCam = new Array(3);
    var proj = new Array(3);
    var sub = new Array(3);
    return function (position, cameraPos, camForward) {
      subtract(vectorFromCam, position, cameraPos);
      var camNormDot = dot(camForward, vectorFromCam);

      if (camNormDot <= 0) {
        scale$1(proj, camForward, camNormDot * 1.01);
        add(position, cameraPos, subtract(sub, vectorFromCam, proj));
      }

      return position;
    };
  }(),
  _containerPointToPoint: function () {
    var cp = [0, 0, 0],
        coord0 = [0, 0, 0, 1],
        coord1 = [0, 0, 0, 1];
    return function (p, zoom, out) {
      if (this.isTransforming()) {
        var w2 = this.width / 2 || 1,
            h2 = this.height / 2 || 1;
        set$2(cp, (p.x - w2) / w2, (h2 - p.y) / h2, 0);
        set$2(coord0, cp[0], cp[1], 0);
        set$2(coord1, cp[0], cp[1], 1);
        coord0[3] = coord1[3] = 1;
        applyMatrix(coord0, coord0, this.projViewMatrixInverse);
        applyMatrix(coord1, coord1, this.projViewMatrixInverse);
        var x0 = coord0[0];
        var x1 = coord1[0];
        var y0 = coord0[1];
        var y1 = coord1[1];
        var z0 = coord0[2];
        var z1 = coord1[2];
        var t = z0 === z1 ? 0 : (0 - z0) / (z1 - z0);

        var _x = interpolate(x0, x1, t);

        var _y = interpolate(y0, y1, t);

        if (out) {
          out.x = _x;
          out.y = _y;
        } else {
          out = new Point(_x, _y);
        }

        out._multi(1 / this._glScale);

        return zoom === undefined || this.getZoom() === zoom ? out : this._pointToPointAtZoom(out, zoom, out);
      }

      var centerPoint = this._prjToPoint(this._getPrjCenter(), zoom, out),
          scale$$1 = zoom !== undefined ? this._getResolution() / this._getResolution(zoom) : 1;

      var x = scale$$1 * (p.x - this.width / 2),
          y = scale$$1 * (p.y - this.height / 2);
      return centerPoint._add(x, -y);
    };
  }(),
  _calcMatrices: function () {
    var m0 = createMat4(),
        m1 = createMat4();
    return function () {
      delete this._mapRes;
      delete this._mapGlRes;
      delete this._mapExtent2D;
      delete this._mapGlExtent2D;
      var size = this.getSize();
      var w = size.width || 1,
          h = size.height || 1;
      this._glScale = this.getGLScale();
      var pitch = this.getPitch() * Math.PI / 180;

      var worldMatrix = this._getCameraWorldMatrix();

      var fov = this.getFov() * Math.PI / 180;

      var farZ = this._getCameraFar(fov, this.getPitch());

      this.cameraFar = farZ;
      this.cameraNear = Math.max(this._glScale * this.getResolution(this.getGLZoom()) * Math.cos(pitch), 0.1);
      var projMatrix = this.projMatrix || createMat4();
      perspective(projMatrix, fov, w / h, this.cameraNear, farZ);
      this.projMatrix = projMatrix;
      this.viewMatrix = invert(m0, worldMatrix);
      this.projViewMatrix = multiply(this.projViewMatrix || createMat4(), projMatrix, this.viewMatrix);

      this._calcCascadeMatrixes();

      this.projViewMatrixInverse = multiply(this.projViewMatrixInverse || createMat4(), worldMatrix, invert(m1, projMatrix));
      this.domCssMatrix = this._calcDomMatrix();
      this._frustumAltitude = this._calcFrustumAltitude();
      this._mapRes = this._getResolution();
      this._mapGlRes = this._getResolution(this.getGLZoom());
      this._mapExtent2D = this._get2DExtent();
      this._mapGlExtent2D = this._get2DExtent(this.getGLZoom());
    };
  }(),
  _getCameraFar: function _getCameraFar(fov, pitch) {
    var cameraCenterDistance = this.cameraCenterDistance = distance(this.cameraPosition, this.cameraLookAt);
    var farZ = cameraCenterDistance;

    if (pitch > 0) {
      pitch = pitch * Math.PI / 180;
      var y;

      if (2 / Math.PI - pitch <= fov / 2) {
        y = 4 * cameraCenterDistance;
      } else {
        var tanFov = Math.tan(fov / 2);
        var tanP = Math.tan(pitch);
        y = cameraCenterDistance * tanFov / (1 / tanP - tanFov);
      }

      farZ += y;
    }

    return farZ + 1.0;
  },
  _calcCascadeMatrixes: function () {
    var projMatrix = createMat4();

    function cal(curPitch, pitch, out) {
      var w = this.width;
      var h = this.height;
      var fov = this.getFov() * Math.PI / 180;

      var farZ = this._getCameraFar(fov, pitch);

      var cameraCenterDistance = this.cameraCenterDistance;
      farZ = cameraCenterDistance + (farZ - cameraCenterDistance) / Math.cos((90 - pitch) * Math.PI / 180) * Math.cos((90 - curPitch) * Math.PI / 180);
      perspective(projMatrix, fov, w / h, 0.1, farZ);
      var viewMatrix = this.viewMatrix;
      return multiply(out, projMatrix, viewMatrix);
    }

    return function () {
      var pitch = this.getPitch();
      var cascadePitch0 = this.options['cascadePitches'][0];
      var cascadePitch1 = this.options['cascadePitches'][1];
      var projViewMatrix0 = this.cascadeFrustumMatrix0 = this.cascadeFrustumMatrix0 || createMat4();
      var projViewMatrix1 = this.cascadeFrustumMatrix1 = this.cascadeFrustumMatrix1 || createMat4();

      if (pitch > cascadePitch0) {
        cal.call(this, pitch, cascadePitch0, projViewMatrix0);
      } else {
        copy(this.cascadeFrustumMatrix0, this.projViewMatrix);
      }

      if (pitch > cascadePitch1) {
        cal.call(this, pitch, cascadePitch1, projViewMatrix1);
      } else {
        copy(this.cascadeFrustumMatrix1, this.cascadeFrustumMatrix0);
      }
    };
  }(),
  _calcDomMatrix: function () {
    var m = createMat4(),
        m1 = createMat4(),
        minusY = [1, -1, 1],
        arr = [0, 0, 0];
    return function () {
      var width = this.width || 1;
      var height = this.height || 1;
      var cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * height;
      scale(m, this.projMatrix, minusY);
      translate(m, m, set$2(arr, 0, 0, -cameraToCenterDistance));

      if (this._pitch) {
        rotateX(m, m, this._pitch);
      }

      if (this._angle) {
        rotateZ(m, m, this._angle);
      }

      identity(m1);
      scale(m1, m1, set$2(arr, width / 2, -height / 2, 1));
      return multiply(this.domCssMatrix || createMat4(), m1, m);
    };
  }(),
  _getCameraWorldMatrix: function () {
    var q = {};
    return function () {
      var targetZ = this.getGLZoom();
      var size = this.getSize(),
          scale$$1 = this.getGLScale();

      var center2D = this._prjToPoint(this._prjCenter, targetZ);

      this.cameraLookAt = set$2(this.cameraLookAt || [0, 0, 0], center2D.x, center2D.y, 0);
      var pitch = this.getPitch() * RADIAN$1;
      var bearing = this.getBearing() * RADIAN$1;

      var ratio = this._getFovRatio();

      var z = scale$$1 * (size.height || 1) / 2 / ratio;
      var cz = z * Math.cos(pitch);
      var dist = Math.sin(pitch) * z;
      var cx = center2D.x - dist * Math.sin(bearing);
      var cy = center2D.y - dist * Math.cos(bearing);
      this.cameraPosition = set$2(this.cameraPosition || [0, 0, 0], cx, cy, cz);
      var d = dist || 1;
      var up = this.cameraUp = set$2(this.cameraUp || [0, 0, 0], Math.sin(bearing) * d, Math.cos(bearing) * d, 0);
      var m = this.cameraWorldMatrix = this.cameraWorldMatrix || createMat4();
      lookAt(m, this.cameraPosition, this.cameraLookAt, up);
      var cameraForward = this.cameraForward || [0, 0, 0];
      subtract(cameraForward, this.cameraLookAt, this.cameraPosition);
      this.cameraForward = normalize(cameraForward, cameraForward);
      matrixToQuaternion(q, m);
      quaternionToMatrix(m, q);
      setPosition(m, this.cameraPosition);
      return m;
    };
  }(),
  _getFovRatio: function _getFovRatio() {
    var fov = this.getFov();
    return Math.tan(fov / 2 * RADIAN$1);
  },
  _renderLayers: function _renderLayers() {
    if (this.isInteracting()) {
      return;
    }

    var layers = this._getLayers();

    layers.forEach(function (layer) {
      if (!layer) {
        return;
      }

      var renderer = layer._getRenderer();

      if (renderer && renderer.setToRedraw) {
        renderer.setToRedraw();
      }
    });
  }
});

function createMat4() {
  return identity(new Array(16));
}

Map$1.include({
  _onViewChange: function _onViewChange(view) {
    if (!this._viewHistory) {
      this._viewHistory = [];
      this._viewHistoryPointer = 0;
    }

    var old = this._getCurrentView();

    for (var i = this._viewHistory.length - 1; i >= 0; i--) {
      if (equalMapView(view, this._viewHistory[i])) {
        this._viewHistoryPointer = i;

        this._fireViewChange(old, view);

        return;
      }
    }

    if (this._viewHistoryPointer < this._viewHistory.length - 1) {
      this._viewHistory.splice(this._viewHistoryPointer + 1);
    }

    this._viewHistory.push(view);

    var count = this.options['viewHistoryCount'];

    if (count > 0 && this._viewHistory.length > count) {
      this._viewHistory.splice(0, this._viewHistory.length - count);
    }

    this._viewHistoryPointer = this._viewHistory.length - 1;

    this._fireViewChange(old, view);
  },
  zoomToPreviousView: function zoomToPreviousView(options) {
    if (options === void 0) {
      options = {};
    }

    if (!this.hasPreviousView()) {
      return null;
    }

    var view = this._viewHistory[--this._viewHistoryPointer];

    this._zoomToView(view, options);

    return view;
  },
  hasPreviousView: function hasPreviousView() {
    if (!this._viewHistory || this._viewHistoryPointer === 0) {
      return false;
    }

    return true;
  },
  zoomToNextView: function zoomToNextView(options) {
    if (options === void 0) {
      options = {};
    }

    if (!this.hasNextView()) {
      return null;
    }

    var view = this._viewHistory[++this._viewHistoryPointer];

    this._zoomToView(view, options);

    return view;
  },
  hasNextView: function hasNextView() {
    if (!this._viewHistory || this._viewHistoryPointer === this._viewHistory.length - 1) {
      return false;
    }

    return true;
  },
  _zoomToView: function _zoomToView(view, options) {
    var _this = this;

    var old = this.getView();

    if (options['animation']) {
      this._animateTo(view, {
        'duration': options['duration']
      }, function (frame) {
        if (frame.state.playState === 'finished') {
          _this._fireViewChange(old, view);
        }
      });
    } else {
      this.setView(view);

      this._fireViewChange(old, view);
    }
  },
  getViewHistory: function getViewHistory() {
    return this._viewHistory;
  },
  _fireViewChange: function _fireViewChange(old, view) {
    this._fireEvent('viewchange', {
      'old': old,
      'new': view
    });
  },
  _getCurrentView: function _getCurrentView() {
    if (!this._viewHistory) {
      return null;
    }

    return this._viewHistory[this._viewHistoryPointer];
  }
});
Map$1.mergeOptions({
  'viewHistory': true,
  'viewHistoryCount': 10
});

var options$h = {
  'mode': 'LineString',
  'language': 'zh-CN',
  'metric': true,
  'imperial': false,
  'symbol': {
    'lineColor': '#000',
    'lineWidth': 3,
    'lineOpacity': 1
  },
  'vertexSymbol': {
    'markerType': 'ellipse',
    'markerFill': '#fff',
    'markerLineColor': '#000',
    'markerLineWidth': 3,
    'markerWidth': 11,
    'markerHeight': 11
  },
  'labelOptions': {
    'textSymbol': {
      'textFaceName': 'monospace',
      'textLineSpacing': 1,
      'textHorizontalAlignment': 'right',
      'textDx': 15
    },
    'boxStyle': {
      'padding': [6, 2],
      'symbol': {
        'markerType': 'square',
        'markerFill': '#fff',
        'markerFillOpacity': 0.9,
        'markerLineColor': '#b4b3b3'
      }
    }
  },
  'clearButtonSymbol': [{
    'markerType': 'square',
    'markerFill': '#fff',
    'markerLineColor': '#b4b3b3',
    'markerLineWidth': 2,
    'markerWidth': 15,
    'markerHeight': 15,
    'markerDx': 20
  }, {
    'markerType': 'x',
    'markerWidth': 10,
    'markerHeight': 10,
    'markerDx': 20
  }]
};

var DistanceTool = function (_DrawTool) {
  _inheritsLoose(DistanceTool, _DrawTool);

  function DistanceTool(options) {
    var _this;

    _this = _DrawTool.call(this, options) || this;

    _this.on('enable', _this._afterEnable, _assertThisInitialized(_assertThisInitialized(_this))).on('disable', _this._afterDisable, _assertThisInitialized(_assertThisInitialized(_this)));

    _this._measureLayers = [];
    return _this;
  }

  var _proto = DistanceTool.prototype;

  _proto.clear = function clear() {
    if (isArrayHasData(this._measureLayers)) {
      for (var i = 0; i < this._measureLayers.length; i++) {
        this._measureLayers[i].remove();
      }
    }

    delete this._lastMeasure;
    delete this._lastVertex;
    this._measureLayers = [];
    return this;
  };

  _proto.getMeasureLayers = function getMeasureLayers() {
    return this._measureLayers;
  };

  _proto.getLastMeasure = function getLastMeasure() {
    if (!this._lastMeasure) {
      return 0;
    }

    return this._lastMeasure;
  };

  _proto.undo = function undo() {
    _DrawTool.prototype.undo.call(this);

    var pointer = this._historyPointer;

    if (pointer !== this._vertexes.length) {
      for (var i = pointer; i < this._vertexes.length; i++) {
        if (this._vertexes[i].label) {
          this._vertexes[i].label.remove();
        }

        this._vertexes[i].marker.remove();
      }
    }

    return this;
  };

  _proto.redo = function redo() {
    _DrawTool.prototype.redo.call(this);

    var i = this._historyPointer - 1;

    if (this._vertexes[i]) {
      if (!this._vertexes[i].marker.getLayer()) {
        if (this._vertexes[i].label) {
          this._vertexes[i].label.addTo(this._measureMarkerLayer);
        }

        this._vertexes[i].marker.addTo(this._measureMarkerLayer);
      }
    }

    return this;
  };

  _proto._measure = function _measure(toMeasure) {
    var map = this.getMap();
    var length;

    if (toMeasure instanceof Geometry) {
      length = map.computeGeometryLength(toMeasure);
    } else if (Array.isArray(toMeasure)) {
      length = map.getProjection().measureLength(toMeasure);
    }

    this._lastMeasure = length;
    var units;

    if (this.options['language'] === 'zh-CN') {
      units = [' 米', ' 公里', ' 英尺', ' 英里'];
    } else {
      units = [' m', ' km', ' feet', ' mile'];
    }

    var content = '';

    if (this.options['metric']) {
      content += length < 1000 ? length.toFixed(0) + units[0] : (length / 1000).toFixed(2) + units[1];
    }

    if (this.options['imperial']) {
      length *= 3.2808399;

      if (content.length > 0) {
        content += '\n';
      }

      content += length < 5280 ? length.toFixed(0) + units[2] : (length / 5280).toFixed(2) + units[3];
    }

    return content;
  };

  _proto._registerMeasureEvents = function _registerMeasureEvents() {
    this.on('drawstart', this._msOnDrawStart, this).on('drawvertex', this._msOnDrawVertex, this).on('mousemove', this._msOnMouseMove, this).on('drawend', this._msOnDrawEnd, this);
  };

  _proto._afterEnable = function _afterEnable() {
    this._registerMeasureEvents();
  };

  _proto._afterDisable = function _afterDisable() {
    this.off('drawstart', this._msOnDrawStart, this).off('drawvertex', this._msOnDrawVertex, this).off('mousemove', this._msOnMouseMove, this).off('drawend', this._msOnDrawEnd, this);
  };

  _proto._msOnDrawStart = function _msOnDrawStart(param) {
    var map = this.getMap();

    var prjCoord = map._pointToPrj(param['point2d']);

    var uid = UID();
    var layerId = 'distancetool_' + uid;
    var markerLayerId = 'distancetool_markers_' + uid;

    if (!map.getLayer(layerId)) {
      this._measureLineLayer = new VectorLayer(layerId).addTo(map);
      this._measureMarkerLayer = new VectorLayer(markerLayerId).addTo(map);
    } else {
      this._measureLineLayer = map.getLayer(layerId);
      this._measureMarkerLayer = map.getLayer(markerLayerId);
    }

    this._measureLayers.push(this._measureLineLayer);

    this._measureLayers.push(this._measureMarkerLayer);

    var marker = new Marker(param['coordinate'], {
      'symbol': this.options['vertexSymbol']
    });

    marker._setPrjCoordinates(prjCoord);

    var content = this.options['language'] === 'zh-CN' ? '起点' : 'start';
    var startLabel = new Label(content, param['coordinate'], this.options['labelOptions']);

    startLabel._setPrjCoordinates(prjCoord);

    this._lastVertex = startLabel;

    this._addVertexMarker(marker, startLabel);
  };

  _proto._msOnMouseMove = function _msOnMouseMove(param) {
    var ms = this._measure(this._msGetCoordsToMeasure(param));

    if (!this._tailMarker) {
      var symbol = extendSymbol(this.options['vertexSymbol']);
      symbol['markerWidth'] /= 2;
      symbol['markerHeight'] /= 2;
      this._tailMarker = new Marker(param['coordinate'], {
        'symbol': symbol
      }).addTo(this._measureMarkerLayer);
      this._tailLabel = new Label(ms, param['coordinate'], this.options['labelOptions']).addTo(this._measureMarkerLayer);
    }

    var prjCoords = this._geometry._getPrjCoordinates();

    var lastCoord = prjCoords[prjCoords.length - 1];

    this._tailMarker.setCoordinates(param['coordinate']);

    this._tailMarker._setPrjCoordinates(lastCoord);

    this._tailLabel.setContent(ms);

    this._tailLabel.setCoordinates(param['coordinate']);

    this._tailLabel._setPrjCoordinates(lastCoord);
  };

  _proto._msGetCoordsToMeasure = function _msGetCoordsToMeasure(param) {
    return param['geometry'].getCoordinates().concat([param['coordinate']]);
  };

  _proto._msOnDrawVertex = function _msOnDrawVertex(param) {
    var prjCoords = this._geometry._getPrjCoordinates();

    var lastCoord = prjCoords[prjCoords.length - 1];
    var geometry = param['geometry'];
    var marker = new Marker(param['coordinate'], {
      'symbol': this.options['vertexSymbol']
    });

    var length = this._measure(geometry);

    var vertexLabel = new Label(length, param['coordinate'], this.options['labelOptions']);

    this._addVertexMarker(marker, vertexLabel);

    vertexLabel._setPrjCoordinates(lastCoord);

    marker._setPrjCoordinates(lastCoord);

    this._lastVertex = vertexLabel;
  };

  _proto._addVertexMarker = function _addVertexMarker(marker, vertexLabel) {
    if (!this._vertexes) {
      this._vertexes = [];
    }

    this._vertexes.push({
      label: vertexLabel,
      marker: marker
    });

    if (this._historyPointer !== undefined) {
      this._vertexes.length = this._historyPointer;
    }

    this._measureMarkerLayer.addGeometry(marker);

    if (vertexLabel) {
      this._measureMarkerLayer.addGeometry(vertexLabel);
    }
  };

  _proto._msOnDrawEnd = function _msOnDrawEnd(param) {
    this._clearTailMarker();

    var size = this._lastVertex.getSize();

    if (!size) {
      size = new Size(10, 10);
    }

    this._addClearMarker(this._lastVertex.getCoordinates(), this._lastVertex._getPrjCoordinates(), size['width']);

    var geo = param['geometry'].copy();

    geo._setPrjCoordinates(param['geometry']._getPrjCoordinates());

    geo.addTo(this._measureLineLayer);
    this._lastMeasure = geo.getLength();
  };

  _proto._addClearMarker = function _addClearMarker(coordinates, prjCoord, dx) {
    var symbol = this.options['clearButtonSymbol'];
    var dxSymbol = {
      'markerDx': (symbol['markerDx'] || 0) + dx,
      'textDx': (symbol['textDx'] || 0) + dx
    };

    if (Array.isArray(symbol)) {
      dxSymbol = symbol.map(function (s) {
        if (s) {
          return {
            'markerDx': (s['markerDx'] || 0) + dx,
            'textDx': (s['textDx'] || 0) + dx
          };
        }

        return null;
      });
    }

    symbol = extendSymbol(symbol, dxSymbol);
    var endMarker = new Marker(coordinates, {
      'symbol': symbol
    });
    var measureLineLayer = this._measureLineLayer,
        measureMarkerLayer = this._measureMarkerLayer;
    endMarker.on('click', function () {
      measureLineLayer.remove();
      measureMarkerLayer.remove();
      return false;
    }, this);
    endMarker.addTo(this._measureMarkerLayer);

    endMarker._setPrjCoordinates(prjCoord);
  };

  _proto._clearTailMarker = function _clearTailMarker() {
    if (this._tailMarker) {
      this._tailMarker.remove();

      delete this._tailMarker;
    }

    if (this._tailLabel) {
      this._tailLabel.remove();

      delete this._tailLabel;
    }
  };

  return DistanceTool;
}(DrawTool);

DistanceTool.mergeOptions(options$h);

var options$i = {
  'mode': 'Polygon',
  'symbol': {
    'lineColor': '#000000',
    'lineWidth': 2,
    'lineOpacity': 1,
    'lineDasharray': '',
    'polygonFill': '#ffffff',
    'polygonOpacity': 0.5
  }
};

var AreaTool = function (_DistanceTool) {
  _inheritsLoose(AreaTool, _DistanceTool);

  function AreaTool(options) {
    var _this;

    _this = _DistanceTool.call(this, options) || this;

    _this.on('enable', _this._afterEnable, _assertThisInitialized(_assertThisInitialized(_this))).on('disable', _this._afterDisable, _assertThisInitialized(_assertThisInitialized(_this)));

    _this._measureLayers = [];
    return _this;
  }

  var _proto = AreaTool.prototype;

  _proto._measure = function _measure(toMeasure) {
    var map = this.getMap();
    var area;

    if (toMeasure instanceof Geometry) {
      area = map.computeGeometryArea(toMeasure);
    } else if (Array.isArray(toMeasure)) {
      area = map.getProjection().measureArea(toMeasure);
    }

    this._lastMeasure = area;
    var units;

    if (this.options['language'] === 'zh-CN') {
      units = [' 平方米', ' 平方公里', ' 平方英尺', ' 平方英里'];
    } else {
      units = [' sq.m', ' sq.km', ' sq.ft', ' sq.mi'];
    }

    var content = '';

    if (this.options['metric']) {
      content += area < 1E6 ? area.toFixed(0) + units[0] : (area / 1E6).toFixed(2) + units[1];
    }

    if (this.options['imperial']) {
      area *= 3.2808399;

      if (content.length > 0) {
        content += '\n';
      }

      var sqmi = 5280 * 5280;
      content += area < sqmi ? area.toFixed(0) + units[2] : (area / sqmi).toFixed(2) + units[3];
    }

    return content;
  };

  _proto._msGetCoordsToMeasure = function _msGetCoordsToMeasure(param) {
    return param['geometry'].getShell().concat([param['coordinate']]);
  };

  _proto._msOnDrawVertex = function _msOnDrawVertex(param) {
    var prjCoord = this.getMap()._pointToPrj(param['point2d']);

    var vertexMarker = new Marker(param['coordinate'], {
      'symbol': this.options['vertexSymbol']
    });

    vertexMarker._setPrjCoordinates(prjCoord);

    this._measure(param['geometry']);

    this._lastVertex = vertexMarker;

    this._addVertexMarker(vertexMarker);
  };

  _proto._msOnDrawEnd = function _msOnDrawEnd(param) {
    this._clearTailMarker();

    var prjCoord = this.getMap()._pointToPrj(param['point2d']);

    var ms = this._measure(param['geometry']);

    var endLabel = new Label(ms, param['coordinate'], this.options['labelOptions']).addTo(this._measureMarkerLayer);

    endLabel._setPrjCoordinates(prjCoord);

    var size = endLabel.getSize();

    if (!size) {
      size = new Size(10, 10);
    }

    this._addClearMarker(param['coordinate'], prjCoord, size['width']);

    var geo = param['geometry'].copy();

    geo._setPrjCoordinates(param['geometry']._getPrjCoordinates());

    geo.addTo(this._measureLineLayer);
    this._lastMeasure = geo.getArea();
  };

  return AreaTool;
}(DistanceTool);

AreaTool.mergeOptions(options$i);

var circleHooks = {
  'create': function create(projection, prjCoord) {
    var center = projection.unproject(prjCoord[0]);
    var circle = new Circle(center, 0);

    circle._setPrjCoordinates(prjCoord[0]);

    return circle;
  },
  'update': function update(projection, prjPath, geometry) {
    var map = geometry.getMap();
    var prjCoord = Array.isArray(prjPath) ? prjPath[prjPath.length - 1] : prjPath;
    var nextCoord = projection.unproject(prjCoord);
    var radius = map.computeLength(geometry.getCenter(), nextCoord);
    geometry.setRadius(radius);
  },
  'generate': function generate(geometry) {
    return geometry;
  }
};
DrawTool.registerMode('circle', extend({
  'clickLimit': 2,
  'action': ['click', 'mousemove', 'click']
}, circleHooks));
DrawTool.registerMode('freeHandCircle', extend({
  'action': ['mousedown', 'mousemove', 'mouseup']
}, circleHooks));
var ellipseHooks = {
  'create': function create(projection, prjCoord) {
    var center = projection.unproject(prjCoord[0]);
    var ellipse = new Ellipse(center, 0, 0);

    ellipse._setPrjCoordinates(prjCoord[0]);

    return ellipse;
  },
  'update': function update(projection, prjPath, geometry) {
    var map = geometry.getMap();
    var center = geometry.getCenter();
    var prjCoord = Array.isArray(prjPath) ? prjPath[prjPath.length - 1] : prjPath;
    var nextCoord = projection.unproject(prjCoord);
    var rx = map.computeLength(center, new Coordinate({
      x: nextCoord.x,
      y: center.y
    }));
    var ry = map.computeLength(center, new Coordinate({
      x: center.x,
      y: nextCoord.y
    }));
    geometry.setWidth(rx * 2);
    geometry.setHeight(ry * 2);
  },
  'generate': function generate(geometry) {
    return geometry;
  }
};
DrawTool.registerMode('ellipse', extend({
  'clickLimit': 2,
  'action': ['click', 'mousemove', 'click']
}, ellipseHooks));
DrawTool.registerMode('freeHandEllipse', extend({
  'action': ['mousedown', 'mousemove', 'mouseup']
}, ellipseHooks));
var rectangleHooks = {
  'create': function create(projection, prjCoords) {
    var rect = new Polygon([]);
    rect._firstClick = prjCoords[0];
    return rect;
  },
  'update': function update(projection, prjCoords, geometry, param) {
    var map = geometry.getMap();
    var containerPoint = param['containerPoint'];

    var firstClick = map._prjToContainerPoint(geometry._firstClick);

    var ring = [[firstClick.x, firstClick.y], [containerPoint.x, firstClick.y], [containerPoint.x, containerPoint.y], [firstClick.x, containerPoint.y]];
    geometry.setCoordinates(ring.map(function (c) {
      return map.containerPointToCoord(new Point(c));
    }));

    geometry._setPrjCoordinates(ring.map(function (c) {
      return map._containerPointToPrj(new Point(c));
    }));
  },
  'generate': function generate(geometry) {
    return geometry;
  }
};
DrawTool.registerMode('rectangle', extend({
  'clickLimit': 2,
  'action': ['click', 'mousemove', 'click']
}, rectangleHooks));
DrawTool.registerMode('freeHandRectangle', extend({
  'action': ['mousedown', 'mousemove', 'mouseup']
}, rectangleHooks));
DrawTool.registerMode('point', {
  'clickLimit': 1,
  'action': ['click'],
  'create': function create(projection, prjCoord) {
    var center = projection.unproject(prjCoord[0]);
    var marker = new Marker(center);

    marker._setPrjCoordinates(prjCoord[0]);

    return marker;
  },
  'generate': function generate(geometry) {
    return geometry;
  }
});
var polygonHooks = {
  'create': function create(projection, prjPath) {
    var path = prjPath.map(function (c) {
      return projection.unproject(c);
    });
    var line = new LineString(path);

    line._setPrjCoordinates(prjPath);

    return line;
  },
  'update': function update(projection, path, geometry) {
    var symbol = geometry.getSymbol();
    var prjCoords;

    if (Array.isArray(path)) {
      prjCoords = path;
    } else {
      prjCoords = geometry._getPrjCoordinates();
      prjCoords.push(path);
    }

    var coordinates = prjCoords.map(function (c) {
      return projection.unproject(c);
    });
    geometry.setCoordinates(coordinates);

    geometry._setPrjCoordinates(prjCoords);

    var layer = geometry.getLayer();

    if (layer) {
      var polygon = layer.getGeometryById('polygon');

      if (!polygon && prjCoords.length >= 3) {
        polygon = new Polygon([coordinates], {
          'id': 'polygon'
        });

        if (symbol) {
          var pSymbol = extendSymbol(symbol, {
            'lineOpacity': 0
          });
          polygon.setSymbol(pSymbol);
        }

        polygon.addTo(layer);
      }

      if (polygon) {
        polygon._setPrjCoordinates(prjCoords);
      }
    }
  },
  'generate': function generate(geometry) {
    var polygon = new Polygon(geometry.getCoordinates(), {
      'symbol': geometry.getSymbol()
    });

    polygon._setPrjCoordinates(geometry._getPrjCoordinates());

    polygon._projCode = geometry._projCode;
    return polygon;
  }
};
DrawTool.registerMode('polygon', extend({
  'action': ['click', 'mousemove', 'dblclick']
}, polygonHooks));
DrawTool.registerMode('freeHandPolygon', extend({
  'action': ['mousedown', 'mousemove', 'mouseup']
}, polygonHooks));
var lineStringHooks = {
  'create': function create(projection, prjPath) {
    var path = prjPath.map(function (c) {
      return projection.unproject(c);
    });
    var line = new LineString(path);

    line._setPrjCoordinates(prjPath);

    return line;
  },
  'update': function update(projection, prjPath, geometry) {
    var prjCoords;

    if (Array.isArray(prjPath)) {
      prjCoords = prjPath;
    } else {
      prjCoords = geometry._getPrjCoordinates();
      prjCoords.push(prjPath);
    }

    var path = prjCoords.map(function (c) {
      return projection.unproject(c);
    });
    geometry.setCoordinates(path);

    geometry._setPrjCoordinates(prjCoords);
  },
  'generate': function generate(geometry) {
    return geometry;
  }
};
DrawTool.registerMode('linestring', extend({
  'action': ['click', 'mousemove', 'dblclick']
}, lineStringHooks));
DrawTool.registerMode('freeHandLinestring', extend({
  'action': ['mousedown', 'mousemove', 'mouseup']
}, lineStringHooks));
DrawTool.registerMode('arccurve', {
  'action': ['click', 'mousemove', 'dblclick'],
  'create': function create(projection, prjPath) {
    var path = prjPath.map(function (c) {
      return projection.unproject(c);
    });
    var arc = new ArcCurve(path);

    arc._setPrjCoordinates(prjPath);

    return arc;
  },
  'update': lineStringHooks.update,
  'generate': function generate(geometry) {
    return geometry;
  }
});
DrawTool.registerMode('quadbeziercurve', {
  'action': ['click', 'mousemove', 'dblclick'],
  'create': function create(projection, prjPath) {
    var path = prjPath.map(function (c) {
      return projection.unproject(c);
    });
    var curve = new QuadBezierCurve(path);

    curve._setPrjCoordinates(prjPath);

    return curve;
  },
  'update': lineStringHooks.update,
  'generate': function generate(geometry) {
    return geometry;
  }
});
DrawTool.registerMode('cubicbeziercurve', {
  'action': ['click', 'mousemove', 'dblclick'],
  'create': function create(projection, prjPath) {
    var path = prjPath.map(function (c) {
      return projection.unproject(c);
    });
    var curve = new CubicBezierCurve(path);

    curve._setPrjCoordinates(prjPath);

    return curve;
  },
  'update': lineStringHooks.update,
  'generate': function generate(geometry) {
    return geometry;
  }
});
DrawTool.registerMode('boxZoom', {
  'action': ['mousedown', 'mousemove', 'mouseup'],
  'create': function create(projection, prjCoord) {
    prjCoord = prjCoord[0];
    var center = projection.unproject(prjCoord);
    var marker = new Marker(center);
    marker._firstClick = prjCoord;
    return marker;
  },
  'update': function update(projection, prjCoord, geometry, param) {
    var map = geometry.getMap();

    var p1 = map._prjToContainerPoint(geometry._firstClick),
        p2 = param['containerPoint'];

    prjCoord = map._containerPointToPrj(new Coordinate(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y)));
    var center = projection.unproject(prjCoord);

    geometry.setCoordinates(center)._setPrjCoordinates(prjCoord);

    geometry.updateSymbol({
      markerWidth: Math.abs(p1.x - p2.x),
      markerHeight: Math.abs(p1.y - p2.y)
    });
  },
  'generate': function generate(geometry) {
    return geometry;
  }
});

function parse(arcConf) {
  var tileInfo = arcConf['tileInfo'],
      tileSize = [tileInfo['cols'], tileInfo['rows']],
      resolutions = [],
      lods = tileInfo['lods'];

  for (var i = 0, len = lods.length; i < len; i++) {
    resolutions.push(lods[i]['resolution']);
  }

  var fullExtent = arcConf['fullExtent'],
      origin = tileInfo['origin'],
      tileSystem = [1, -1, origin['x'], origin['y']];
  delete fullExtent['spatialReference'];
  return {
    'spatialReference': {
      'resolutions': resolutions,
      'fullExtent': fullExtent
    },
    'tileSystem': tileSystem,
    'tileSize': tileSize
  };
}

SpatialReference.loadArcgis = function (url, cb, options) {
  if (options === void 0) {
    options = {
      'jsonp': true
    };
  }

  if (isString(url) && url.substring(0, 1) !== '{') {
    Ajax.getJSON(url, function (err, json) {
      if (err) {
        cb(err);
        return;
      }

      var spatialRef = parse(json);
      cb(null, spatialRef);
    }, options);
  } else {
    if (isString(url)) {
      url = parseJSON(url);
    }

    var spatialRef = parse(url);
    cb(null, spatialRef);
  }

  return this;
};

function getProjection(projection) {
  var prj = projection.indexOf('EPSG') > -1 ? projection : 'EPSG:' + projection;
  prj = strReplace(prj, [['4490', '4326'], ['102100', '3857'], ['900913', '3857']]);
  return prj;
}

function strReplace(str, repArray) {
  if (repArray === void 0) {
    repArray = [];
  }

  repArray.forEach(function (rep) {
    var template = rep[0],
        value = rep[1];
    str = str.replace(template, value);
  });
  return str;
}

function parseWMTSXML(str, requestUrl, options) {
  var parser = new DOMParser();
  var xmlDoc = parser.parseFromString(str, 'text/xml');
  var content = xmlDoc.querySelectorAll('Contents')[0];

  if (!content) {
    return [];
  }

  var layers = content.getElementsByTagName('Layer');

  if (!layers.length) {
    return [];
  }

  var TileMatrixSets = [];

  for (var i = 0, len = content.childNodes.length; i < len; i++) {
    if (content.childNodes[i].nodeName === 'TileMatrixSet') {
      TileMatrixSets.push(content.childNodes[i]);
    }
  }

  if (!TileMatrixSets.length) {
    return [];
  }

  var result = [];

  for (var _i = 0, _len = layers.length; _i < _len; _i++) {
    var layer = layers[_i];
    var style = layer.querySelectorAll('Style')[0];

    if (style) {
      style = style.getElementsByTagName('ows:Identifier')[0];

      if (style) {
        style = style.textContent;
      }
    }

    var layerName = layer.getElementsByTagName('ows:Identifier')[0];

    if (layerName) {
      layerName = layerName.textContent;
    }

    var resourceURL = layer.querySelectorAll('ResourceURL')[0];
    var url = '';

    if (resourceURL) {
      url = resourceURL.attributes.template.value;
    }

    var _parseTileMatrixSet = parseTileMatrixSet(TileMatrixSets, _i, options),
        resolutions = _parseTileMatrixSet.resolutions,
        tileSize = _parseTileMatrixSet.tileSize,
        tileSystem = _parseTileMatrixSet.tileSystem,
        projection = _parseTileMatrixSet.projection,
        TileMatrixSet = _parseTileMatrixSet.TileMatrixSet;

    if (!url.length) {
      url = requestUrl.substr(0, requestUrl.lastIndexOf('?'));
      url += '?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER={LAYER}&STYLE={Style}&TILEMATRIXSET={TileMatrixSet}&FORMAT=tiles&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}';
    }

    var urlTemplate = strReplace(url, [['{LAYER}', layerName], ['{Layer}', layerName], ['{layer}', layerName], ['{STYLE}', style], ['{Style}', style], ['{style}', style], ['{TileMatrixSet}', TileMatrixSet], ['{TileMatrix}', '{z}'], ['{TileRow}', '{y}'], ['{TileCol}', '{x}']]);
    result.push({
      tileSize: tileSize,
      tileSystem: tileSystem,
      spatialReference: {
        resolutions: resolutions,
        projection: projection
      },
      urlTemplate: urlTemplate,
      info: {
        layerName: layerName,
        TileMatrixSet: TileMatrixSet,
        style: style,
        tileSize: tileSize,
        tileSystem: tileSystem,
        resolutions: resolutions,
        projection: projection,
        urlTemplate: urlTemplate
      }
    });
  }

  return result;
}

function parseTileMatrixSet(TileMatrixSets, index, options) {
  if (options === void 0) {
    options = {};
  }

  var TileMatrixSet = TileMatrixSets[index];
  var TileMatrixs = TileMatrixSet.getElementsByTagName('TileMatrix');
  var resolutions = [],
      tileSystem = [],
      tileSize = [];
  var projection, tset;

  if (!projection) {
    var supportedCRS = TileMatrixSet.getElementsByTagName('ows:SupportedCRS')[0];

    if (supportedCRS) {
      projection = supportedCRS.textContent;
      projection = projection.split('EPSG')[1];

      while (projection.indexOf(':') > -1) {
        projection = projection.replace(':', '');
      }

      projection = getProjection(projection);
    }
  }

  if (!tset) {
    tset = TileMatrixSet.getElementsByTagName('ows:Identifier')[0];

    if (tset) {
      tset = tset.textContent;
    }
  }

  var transformValue = 0.0002645833333333333;

  if (options.isArcgis) {
    transformValue = 0.00028;
  }

  if (projection && projection.indexOf('4326') > -1) {
    transformValue = 2.3767925226029154e-9;

    if (options.isArcgis) {
      transformValue = 2.518101729011901e-9;
    }
  }

  var minLevel = Infinity;

  for (var _index = 0; _index < TileMatrixs.length; _index++) {
    var TileMatrix = TileMatrixs[_index];
    var level = TileMatrix.getElementsByTagName('ows:Identifier')[0].textContent;
    level = parseInt(level);
    minLevel = Math.min(minLevel, level);
    var ScaleDenominator = TileMatrix.getElementsByTagName('ScaleDenominator')[0].textContent;
    var TopLeftCorner = TileMatrix.getElementsByTagName('TopLeftCorner')[0].textContent;
    var TileWidth = TileMatrix.getElementsByTagName('TileWidth')[0].textContent;
    var TileHeight = TileMatrix.getElementsByTagName('TileHeight')[0].textContent;

    if (tileSize.length === 0) {
      tileSize.push(parseInt(TileWidth), parseInt(TileHeight));
    }

    if (tileSystem.length === 0) {
      var _TopLeftCorner$split$ = TopLeftCorner.split(' ').filter(function (s) {
        return s !== '';
      }).map(function (v) {
        return parseFloat(v);
      }),
          x = _TopLeftCorner$split$[0],
          y = _TopLeftCorner$split$[1];

      if (x > 0) {
        tileSystem.push(1, -1, y, x);
      } else {
        tileSystem.push(1, -1, x, y);
      }
    }

    var res = parseFloat(ScaleDenominator) * transformValue;
    resolutions.push(res);
  }

  if (minLevel > 0) {
    var _res = resolutions[0];

    for (var i = minLevel - 1; i >= 0; i--) {
      _res = _res * 2;
      resolutions.splice(0, 0, _res);
    }
  }

  return {
    resolutions: resolutions,
    tileSize: tileSize,
    tileSystem: tileSystem,
    projection: projection,
    TileMatrixSet: tset
  };
}

SpatialReference.loadWMTS = function (url, cb, options) {
  if (options === void 0) {
    options = {
      'jsonp': true
    };
  }

  if (isString(url)) {
    Ajax.get(url, function (err, xml) {
      if (err) {
        cb(err);
        return;
      }

      var layers = parseWMTSXML(xml, url, options);
      cb(null, layers);
    }, options);
  }

  return this;
};

var options$j = {
  'eventsPropagation': false,
  'eventsToStop': null,
  'dx': 0,
  'dy': 0,
  'autoPan': false,
  'autoPanDuration': 600,
  'single': true,
  'animation': 'scale',
  'animationOnHide': true,
  'animationDuration': 500,
  'pitchWithMap': false,
  'rotateWithMap': false
};

var UIComponent = function (_Eventable) {
  _inheritsLoose(UIComponent, _Eventable);

  function UIComponent(options) {
    return _Eventable.call(this, options) || this;
  }

  var _proto = UIComponent.prototype;

  _proto.addTo = function addTo(owner) {
    this._owner = owner;

    this._switchEvents('on');

    if (this.onAdd) {
      this.onAdd();
    }

    this.fire('add');
    return this;
  };

  _proto.getMap = function getMap() {
    if (!this._owner) {
      return null;
    }

    if (this._owner.getBaseLayer) {
      return this._owner;
    }

    return this._owner.getMap();
  };

  _proto.show = function show(coordinate) {
    var map = this.getMap();

    if (!map) {
      return this;
    }

    if (!this._mapEventsOn) {
      this._switchMapEvents('on');
    }

    coordinate = coordinate || this._coordinate || this._owner.getCenter();
    var visible = this.isVisible();
    this.fire('showstart');

    var container = this._getUIContainer();

    this._coordinate = coordinate;

    this._removePrevDOM();

    var dom = this.__uiDOM = this.buildOn(map);
    dom['eventsPropagation'] = this.options['eventsPropagation'];

    if (!dom) {
      this.fire('showend');
      return this;
    }

    this._measureSize(dom);

    if (this._singleton()) {
      map[this._uiDomKey()] = dom;
    }

    this._setPosition();

    dom.style[TRANSITION] = null;
    container.appendChild(dom);

    var anim = this._getAnimation();

    if (visible) {
      anim.ok = false;
    }

    if (anim.ok) {
      if (anim.fade) {
        dom.style.opacity = 0;
      }

      if (anim.scale) {
        if (this.getTransformOrigin) {
          var origin = this.getTransformOrigin();
          dom.style[TRANSFORMORIGIN] = origin;
        }

        dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(0)';
      }
    }

    dom.style.display = '';

    if (this.options['eventsToStop']) {
      on(dom, this.options['eventsToStop'], stopPropagation);
    }

    if (this.options['autoPan']) {
      this._autoPan();
    }

    var transition = anim.transition;

    if (anim.ok && transition) {
      dom.offsetHeight;

      if (transition) {
        dom.style[TRANSITION] = transition;
      }

      if (anim.fade) {
        dom.style.opacity = 1;
      }

      if (anim.scale) {
        dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(1)';
      }
    }

    this.fire('showend');
    return this;
  };

  _proto.hide = function hide() {
    var _this = this;

    if (!this.getDOM() || !this.getMap()) {
      return this;
    }

    var anim = this._getAnimation(),
        dom = this.getDOM();

    if (!this.options['animationOnHide']) {
      anim.ok = false;
    }

    if (!anim.ok) {
      dom.style.display = 'none';
      this.fire('hide');
    } else {
      dom.offsetHeight;
      dom.style[TRANSITION] = anim.transition;
      setTimeout(function () {
        dom.style.display = 'none';

        _this.fire('hide');
      }, this.options['animationDuration']);
    }

    if (anim.fade) {
      dom.style.opacity = 0;
    }

    if (anim.scale) {
      dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(0)';
    }

    return this;
  };

  _proto.isVisible = function isVisible() {
    var dom = this.getDOM();
    return this.getMap() && dom && dom.parentNode && dom.style.display !== 'none';
  };

  _proto.remove = function remove() {
    delete this._mapEventsOn;

    if (!this._owner) {
      return this;
    }

    this.hide();

    this._switchEvents('off');

    if (this.onRemove) {
      this.onRemove();
    }

    if (!this._singleton() && this.__uiDOM) {
      this._removePrevDOM();
    }

    delete this._owner;
    this.fire('remove');
    return this;
  };

  _proto.getSize = function getSize() {
    if (this._size) {
      return this._size.copy();
    } else {
      return null;
    }
  };

  _proto.getOwner = function getOwner() {
    return this._owner;
  };

  _proto.getDOM = function getDOM() {
    return this.__uiDOM;
  };

  _proto.getPosition = function getPosition() {
    if (!this.getMap()) {
      return null;
    }

    var p = this._getViewPoint()._round();

    if (this.getOffset) {
      var o = this.getOffset()._round();

      if (o) {
        p._add(o);
      }
    }

    return p;
  };

  _proto._getAnimation = function _getAnimation() {
    var anim = {
      'fade': false,
      'scale': false
    };
    var animations = this.options['animation'] ? this.options['animation'].split(',') : [];

    for (var i = 0; i < animations.length; i++) {
      var trimed = trim(animations[i]);

      if (trimed === 'fade') {
        anim.fade = true;
      } else if (trimed === 'scale') {
        anim.scale = true;
      }
    }

    var transition = null;

    if (anim.fade) {
      transition = 'opacity ' + this.options['animationDuration'] + 'ms';
    }

    if (anim.scale) {
      transition = transition ? transition + ',' : '';
      transition += TRANSFORM + ' ' + this.options['animationDuration'] + 'ms';
    }

    anim.transition = transition;
    anim.ok = transition !== null;
    return anim;
  };

  _proto._getViewPoint = function _getViewPoint() {
    var alt = 0;

    if (this._owner && this._owner.getAltitude) {
      var altitude = this._owner.getAltitude();

      if (altitude > 0) {
        alt = this._meterToPoint(this._coordinate, altitude);
      }
    }

    return this.getMap().coordToViewPoint(this._coordinate, undefined, alt)._add(this.options['dx'], this.options['dy']);
  };

  _proto._meterToPoint = function _meterToPoint(center, altitude) {
    var map = this.getMap();
    return map.distanceToPoint(altitude, 0, undefined, center).x * sign(altitude);
  };

  _proto._autoPan = function _autoPan() {
    var map = this.getMap(),
        dom = this.getDOM();

    if (map.isMoving()) {
      return;
    }

    var point = this._pos;
    var mapSize = map.getSize(),
        mapWidth = mapSize['width'],
        mapHeight = mapSize['height'];
    var containerPoint = map.viewPointToContainerPoint(point);
    var clientWidth = parseInt(dom.clientWidth),
        clientHeight = parseInt(dom.clientHeight);
    var left = 0,
        top = 0;

    if (containerPoint.x < 0) {
      left = -(containerPoint.x - clientWidth / 2);
    } else if (containerPoint.x + clientWidth - 35 > mapWidth) {
      left = mapWidth - (containerPoint.x + clientWidth * 3 / 2);
    }

    if (containerPoint.y - clientHeight < 0) {
      top = -(containerPoint.y - clientHeight) + 50;
    } else if (containerPoint.y > mapHeight) {
      top = mapHeight - containerPoint.y - clientHeight - 30;
    }

    if (top !== 0 || left !== 0) {
      map.panBy(new Point(left, top), {
        'duration': this.options['autoPanDuration']
      });
    }
  };

  _proto._measureSize = function _measureSize(dom) {
    var container = this._getUIContainer();

    dom.style.position = 'absolute';
    dom.style.left = -99999 + 'px';
    var anchor = dom.style.bottom ? 'bottom' : 'top';
    dom.style[anchor] = -99999 + 'px';
    dom.style.display = '';
    container.appendChild(dom);
    this._size = new Size(dom.clientWidth, dom.clientHeight);
    dom.style.display = 'none';
    dom.style.left = '0px';
    dom.style[anchor] = '0px';
    return this._size;
  };

  _proto._removePrevDOM = function _removePrevDOM() {
    if (this.onDomRemove) {
      this.onDomRemove();
    }

    var eventsToStop = this.options['eventsToStop'];

    if (this._singleton()) {
      var map = this.getMap(),
          key = this._uiDomKey();

      if (map[key]) {
        if (eventsToStop) {
          off(map[key], eventsToStop, stopPropagation);
        }

        removeDomNode(map[key]);
        delete map[key];
      }

      delete this.__uiDOM;
    } else if (this.__uiDOM) {
      if (eventsToStop) {
        off(this.__uiDOM, eventsToStop, stopPropagation);
      }

      removeDomNode(this.__uiDOM);
      delete this.__uiDOM;
    }
  };

  _proto._uiDomKey = function _uiDomKey() {
    return '__ui_' + this._getClassName();
  };

  _proto._singleton = function _singleton() {
    return this.options['single'];
  };

  _proto._getUIContainer = function _getUIContainer() {
    return this.getMap()._panels['ui'];
  };

  _proto._getClassName = function _getClassName() {
    return 'UIComponent';
  };

  _proto._switchMapEvents = function _switchMapEvents(to) {
    var map = this.getMap();

    if (!map) {
      return;
    }

    this._mapEventsOn = to === 'on';

    var events = this._getDefaultEvents();

    if (this.getEvents) {
      extend(events, this.getEvents());
    }

    if (events) {
      for (var p in events) {
        if (events.hasOwnProperty(p)) {
          map[to](p, events[p], this);
        }
      }
    }
  };

  _proto._switchEvents = function _switchEvents(to) {
    this._switchMapEvents(to);

    var ownerEvents = this._getOwnerEvents();

    if (this._owner) {
      for (var p in ownerEvents) {
        if (ownerEvents.hasOwnProperty(p)) {
          this._owner[to](p, ownerEvents[p], this);
        }
      }
    }
  };

  _proto._getDefaultEvents = function _getDefaultEvents() {
    return {
      'zooming rotate pitch': this.onEvent,
      'zoomend': this.onZoomEnd,
      'moving': this.onMoving,
      'resize': this.onResize
    };
  };

  _proto._getOwnerEvents = function _getOwnerEvents() {
    var events = {};

    if (this._owner && this._owner instanceof Geometry) {
      events.positionchange = this.onGeometryPositionChange;
    }

    if (this.getOwnerEvents) {
      extend(events, this.getOwnerEvents());
    }

    return events;
  };

  _proto.onGeometryPositionChange = function onGeometryPositionChange(param) {
    if (this._owner && this.isVisible()) {
      this.show(param['target'].getCenter());
    }
  };

  _proto.onMoving = function onMoving() {
    if (this.isVisible() && this.getMap().isTransforming()) {
      this._updatePosition();
    }
  };

  _proto.onEvent = function onEvent() {
    if (this.isVisible()) {
      this._updatePosition();
    }
  };

  _proto.onZoomEnd = function onZoomEnd() {
    if (this.isVisible()) {
      this._setPosition();
    }
  };

  _proto.onResize = function onResize() {
    if (this.isVisible()) {
      this._setPosition();
    }
  };

  _proto._updatePosition = function _updatePosition() {
    var renderer = this.getMap()._getRenderer();

    renderer.callInNextFrame(this._setPosition.bind(this));
  };

  _proto._setPosition = function _setPosition() {
    var dom = this.getDOM();
    if (!dom) return;
    dom.style[TRANSITION] = null;
    var p = this.getPosition();
    this._pos = p;
    dom.style[TRANSFORM] = this._toCSSTranslate(p) + ' scale(1)';
  };

  _proto._toCSSTranslate = function _toCSSTranslate(p) {
    if (!p) {
      return '';
    }

    if (Browser$1.any3d) {
      var map = this.getMap(),
          bearing = map ? map.getBearing() : 0,
          pitch = map ? map.getPitch() : 0;
      var r = '';

      if (this.options['pitchWithMap'] && pitch) {
        r += " rotateX(" + Math.round(pitch) + "deg)";
      }

      if (this.options['rotateWithMap'] && bearing) {
        r += " rotateZ(" + Math.round(-bearing) + "deg)";
      }

      return 'translate3d(' + p.x + 'px,' + p.y + 'px, 0px)' + r;
    } else {
      return 'translate(' + p.x + 'px,' + p.y + 'px)';
    }
  };

  UIComponent.isSupport = function isSupport(owner) {
    if (owner && isFunction(owner.on) && isFunction(owner.off) && isFunction(owner.getCenter)) {
      return true;
    }

    return false;
  };

  return UIComponent;
}(Eventable(Class));

UIComponent.mergeOptions(options$j);

var options$k = {
  'containerClass': null,
  'eventsPropagation': true,
  'draggable': false,
  'single': false,
  'content': null
};
var domEvents = 'mousedown ' + 'mouseup ' + 'mouseenter ' + 'mouseover ' + 'mouseout ' + 'mousemove ' + 'click ' + 'dblclick ' + 'contextmenu ' + 'keypress ' + 'touchstart ' + 'touchmove ' + 'touchend';

var UIMarker = function (_Handlerable) {
  _inheritsLoose(UIMarker, _Handlerable);

  function UIMarker(coordinate, options) {
    var _this;

    _this = _Handlerable.call(this, options) || this;
    _this._markerCoord = new Coordinate(coordinate);
    return _this;
  }

  var _proto = UIMarker.prototype;

  _proto._getClassName = function _getClassName() {
    return 'UIMarker';
  };

  _proto.setCoordinates = function setCoordinates(coordinates) {
    this._markerCoord = coordinates;
    this.fire('positionchange');

    if (this.isVisible()) {
      this._coordinate = this._markerCoord;

      this._setPosition();
    }

    return this;
  };

  _proto.getCoordinates = function getCoordinates() {
    return this._markerCoord;
  };

  _proto.setContent = function setContent(content) {
    var old = this.options['content'];
    this.options['content'] = content;
    this.fire('contentchange', {
      'old': old,
      'new': content
    });

    if (this.isVisible()) {
      this.show();
    }

    return this;
  };

  _proto.getContent = function getContent() {
    return this.options['content'];
  };

  _proto.onAdd = function onAdd() {
    this.show();
  };

  _proto.show = function show() {
    return _Handlerable.prototype.show.call(this, this._markerCoord);
  };

  _proto.flash = function flash$$1(interval, count, cb, context) {
    return flash.call(this, interval, count, cb, context);
  };

  _proto.buildOn = function buildOn() {
    var dom;

    if (isString(this.options['content'])) {
      dom = createEl('div');
      dom.innerHTML = this.options['content'];
    } else {
      dom = this.options['content'];
    }

    if (this.options['containerClass']) {
      dom.className = this.options['containerClass'];
    }

    this._registerDOMEvents(dom);

    return dom;
  };

  _proto.getOffset = function getOffset() {
    var size = this.getSize();
    return new Point(-size.width / 2, -size.height / 2);
  };

  _proto.getTransformOrigin = function getTransformOrigin() {
    return 'center center';
  };

  _proto.onDomRemove = function onDomRemove() {
    var dom = this.getDOM();

    this._removeDOMEvents(dom);
  };

  _proto.isDragging = function isDragging() {
    if (this['draggable']) {
      return this['draggable'].isDragging();
    }

    return false;
  };

  _proto._registerDOMEvents = function _registerDOMEvents(dom) {
    on(dom, domEvents, this._onDomEvents, this);
  };

  _proto._onDomEvents = function _onDomEvents(e) {
    var event = this.getMap()._parseEvent(e, e.type);

    this.fire(e.type, event);
  };

  _proto._removeDOMEvents = function _removeDOMEvents(dom) {
    off(dom, domEvents, this._onDomEvents, this);
  };

  _proto._getConnectPoints = function _getConnectPoints() {
    var map = this.getMap();
    var containerPoint = map.coordToContainerPoint(this.getCoordinates());
    var size = this.getSize(),
        width = size.width,
        height = size.height;
    var anchors = [map.containerPointToCoordinate(containerPoint.add(-width / 2, 0)), map.containerPointToCoordinate(containerPoint.add(width / 2, 0)), map.containerPointToCoordinate(containerPoint.add(0, height / 2)), map.containerPointToCoordinate(containerPoint.add(0, -height / 2))];
    return anchors;
  };

  return UIMarker;
}(Handlerable(UIComponent));

UIMarker.mergeOptions(options$k);
var EVENTS$1 = Browser$1.touch ? 'touchstart mousedown' : 'mousedown';

var UIMarkerDragHandler = function (_Handler) {
  _inheritsLoose(UIMarkerDragHandler, _Handler);

  function UIMarkerDragHandler(target) {
    return _Handler.call(this, target) || this;
  }

  var _proto2 = UIMarkerDragHandler.prototype;

  _proto2.addHooks = function addHooks() {
    this.target.on(EVENTS$1, this._startDrag, this);
  };

  _proto2.removeHooks = function removeHooks() {
    this.target.off(EVENTS$1, this._startDrag, this);
  };

  _proto2._startDrag = function _startDrag(param) {
    var domEvent = param['domEvent'];

    if (domEvent.touches && domEvent.touches.length > 1 || domEvent.button === 2) {
      return;
    }

    if (this.isDragging()) {
      return;
    }

    this.target.on('click', this._endDrag, this);
    this._lastCoord = param['coordinate'];
    this._lastPoint = param['containerPoint'];

    this._prepareDragHandler();

    this._dragHandler.onMouseDown(param['domEvent']);

    this.target.fire('dragstart', param);
  };

  _proto2._prepareDragHandler = function _prepareDragHandler() {
    this._dragHandler = new DragHandler(this.target.getDOM(), {
      'cancelOn': this._cancelOn.bind(this),
      'ignoreMouseleave': true
    });

    this._dragHandler.on('mousedown', this._onMouseDown, this);

    this._dragHandler.on('dragging', this._dragging, this);

    this._dragHandler.on('mouseup', this._endDrag, this);

    this._dragHandler.enable();
  };

  _proto2._cancelOn = function _cancelOn(domEvent) {
    var target = domEvent.srcElement || domEvent.target,
        tagName = target.tagName.toLowerCase();

    if (tagName === 'button' || tagName === 'input' || tagName === 'select' || tagName === 'option' || tagName === 'textarea') {
      return true;
    }

    return false;
  };

  _proto2._onMouseDown = function _onMouseDown(param) {
    stopPropagation(param['domEvent']);
  };

  _proto2._dragging = function _dragging(param) {
    var target = this.target,
        map = target.getMap(),
        eventParam = map._parseEvent(param['domEvent']),
        domEvent = eventParam['domEvent'];

    if (domEvent.touches && domEvent.touches.length > 1) {
      return;
    }

    if (!this._isDragging) {
      this._isDragging = true;
      return;
    }

    var coord = eventParam['coordinate'],
        point = eventParam['containerPoint'];

    if (!this._lastCoord) {
      this._lastCoord = coord;
    }

    if (!this._lastPoint) {
      this._lastPoint = point;
    }

    var coordOffset = coord.sub(this._lastCoord),
        pointOffset = point.sub(this._lastPoint);
    this._lastCoord = coord;
    this._lastPoint = point;
    this.target.setCoordinates(this.target.getCoordinates().add(coordOffset));
    eventParam['coordOffset'] = coordOffset;
    eventParam['pointOffset'] = pointOffset;
    target.fire('dragging', eventParam);
  };

  _proto2._endDrag = function _endDrag(param) {
    var target = this.target,
        map = target.getMap();

    if (this._dragHandler) {
      target.off('click', this._endDrag, this);

      this._dragHandler.disable();

      delete this._dragHandler;
    }

    delete this._lastCoord;
    delete this._lastPoint;
    this._isDragging = false;

    if (!map) {
      return;
    }

    var eventParam = map._parseEvent(param['domEvent']);

    target.fire('dragend', eventParam);
  };

  _proto2.isDragging = function isDragging() {
    if (!this._isDragging) {
      return false;
    }

    return true;
  };

  return UIMarkerDragHandler;
}(Handler$1);

UIMarker.addInitHook('addHandler', 'draggable', UIMarkerDragHandler);

var options$l = {
  'containerClass': 'maptalks-msgBox',
  'autoPan': true,
  'autoCloseOn': null,
  'autoOpenOn': 'click',
  'width': 300,
  'minHeight': 120,
  'custom': false,
  'title': null,
  'content': null
};

var InfoWindow = function (_UIComponent) {
  _inheritsLoose(InfoWindow, _UIComponent);

  function InfoWindow() {
    return _UIComponent.apply(this, arguments) || this;
  }

  var _proto = InfoWindow.prototype;

  _proto._getClassName = function _getClassName() {
    return 'InfoWindow';
  };

  _proto.addTo = function addTo(owner) {
    if (owner instanceof Geometry) {
      if (owner.getInfoWindow() && owner.getInfoWindow() !== this) {
        owner.removeInfoWindow();
      }

      owner._infoWindow = this;
    }

    return _UIComponent.prototype.addTo.call(this, owner);
  };

  _proto.setContent = function setContent(content) {
    var old = this.options['content'];
    this.options['content'] = content;
    this.fire('contentchange', {
      'old': old,
      'new': content
    });

    if (this.isVisible()) {
      this.show(this._coordinate);
    }

    return this;
  };

  _proto.getContent = function getContent() {
    return this.options['content'];
  };

  _proto.setTitle = function setTitle(title) {
    var old = title;
    this.options['title'] = title;
    this.fire('contentchange', {
      'old': old,
      'new': title
    });

    if (this.isVisible()) {
      this.show(this._coordinate);
    }

    return this;
  };

  _proto.getTitle = function getTitle() {
    return this.options['title'];
  };

  _proto.buildOn = function buildOn() {
    if (this.options['custom']) {
      if (isString(this.options['content'])) {
        var _dom = createEl('div');

        _dom.innerHTML = this.options['content'];
        return _dom;
      } else {
        return this.options['content'];
      }
    }

    var dom = createEl('div');

    if (this.options['containerClass']) {
      dom.className = this.options['containerClass'];
    }

    dom.style.width = this._getWindowWidth() + 'px';
    dom.style.bottom = '0px';
    var content = '<em class="maptalks-ico"></em>';

    if (this.options['title']) {
      content += '<h2>' + this.options['title'] + '</h2>';
    }

    content += '<a href="javascript:void(0);" class="maptalks-close"></a><div class="maptalks-msgContent"></div>';
    dom.innerHTML = content;
    var msgContent = dom.querySelector('.maptalks-msgContent');

    if (isString(this.options['content'])) {
      msgContent.innerHTML = this.options['content'];
    } else {
      msgContent.appendChild(this.options['content']);
    }

    this._onCloseBtnClick = this.hide.bind(this);
    var closeBtn = dom.querySelector('.maptalks-close');
    addDomEvent(closeBtn, 'click touchend', this._onCloseBtnClick);
    return dom;
  };

  _proto.getTransformOrigin = function getTransformOrigin() {
    var size = this.getSize();
    return size.width / 2 + 'px bottom';
  };

  _proto.getOffset = function getOffset() {
    var size = this.getSize();
    var o = new Point(-size['width'] / 2, 0);

    if (!this.options['custom']) {
      o._sub(4, 12);
    } else {
      o._sub(0, size['height']);
    }

    var owner = this.getOwner();

    if (owner instanceof Marker || owner instanceof MultiPoint) {
      var painter, markerSize;

      if (owner instanceof Marker) {
        painter = owner._getPainter();
        markerSize = owner.getSize();
      } else {
        var children = owner.getGeometries();

        if (!children || !children.length) {
          return o;
        }

        painter = children[0]._getPainter();
        markerSize = children[0].getSize();
      }

      if (painter) {
        var fixExtent = painter.getFixedExtent();

        o._add(fixExtent.xmax - markerSize.width / 2, fixExtent.ymin);
      } else {
        o._add(0, -markerSize.height);
      }
    }

    return o;
  };

  _proto.show = function show(coordinate) {
    if (!this.getMap()) {
      return this;
    }

    if (!this.getMap().options['enableInfoWindow']) {
      return this;
    }

    return _UIComponent.prototype.show.call(this, coordinate);
  };

  _proto.getEvents = function getEvents() {
    if (!this.options['autoCloseOn']) {
      return null;
    }

    var events = {};
    events[this.options['autoCloseOn']] = this.hide;
    return events;
  };

  _proto.getOwnerEvents = function getOwnerEvents() {
    var owner = this.getOwner();

    if (!this.options['autoOpenOn'] || !owner) {
      return null;
    }

    var events = {};
    events[this.options['autoOpenOn']] = this._onAutoOpen;
    return events;
  };

  _proto.onRemove = function onRemove() {
    this.onDomRemove();
  };

  _proto.onDomRemove = function onDomRemove() {
    if (this._onCloseBtnClick) {
      var dom = this.getDOM();
      var closeBtn = dom.childNodes[2];
      removeDomEvent(closeBtn, 'click touchend', this._onCloseBtnClick);
      delete this._onCloseBtnClick;
    }
  };

  _proto._onAutoOpen = function _onAutoOpen(e) {
    var _this = this;

    var owner = this.getOwner();
    setTimeout(function () {
      if (owner instanceof Marker || owner instanceof UIComponent) {
        _this.show(owner.getCoordinates());
      } else if (owner instanceof MultiPoint) {
        _this.show(owner.findClosest(e.coordinate));
      } else if (owner instanceof LineString || owner instanceof MultiLineString) {
        if (_this.getMap().getScale() >= 8) {
          e.coordinate = _this._rectifyMouseCoordinte(owner, e.coordinate);
        }

        _this.show(e.coordinate);
      } else {
        _this.show(e.coordinate);
      }
    }, 1);
  };

  _proto._rectifyMouseCoordinte = function _rectifyMouseCoordinte(owner, mouseCoordinate) {
    var _this2 = this;

    if (owner instanceof LineString) {
      return this._rectifyLineStringMouseCoordinate(owner, mouseCoordinate).coordinate;
    } else if (owner instanceof MultiLineString) {
      return owner.getGeometries().map(function (lineString) {
        return _this2._rectifyLineStringMouseCoordinate(lineString, mouseCoordinate);
      }).sort(function (a, b) {
        return a.dis - b.dis;
      })[0].coordinate;
    }

    return mouseCoordinate;
  };

  _proto._rectifyLineStringMouseCoordinate = function _rectifyLineStringMouseCoordinate(lineString, mouseCoordinate) {
    var _this3 = this;

    var pts = lineString.getCoordinates().map(function (coordinate) {
      return _this3.getMap().coordToContainerPoint(coordinate);
    });
    var mousePt = this.getMap().coordToContainerPoint(mouseCoordinate);
    var minDis = Infinity,
        coordinateIndex = -1;

    for (var i = 0, len = pts.length; i < len; i++) {
      var pt = pts[i];
      var dis = mousePt.distanceTo(pt);

      if (dis < minDis) {
        minDis = dis;
        coordinateIndex = i;
      }
    }

    var filterPts = [];

    if (coordinateIndex === 0) {
      filterPts.push(pts[0], pts[1]);
    } else if (coordinateIndex === pts.length - 1) {
      filterPts.push(pts[coordinateIndex - 1], pts[coordinateIndex]);
    } else {
      filterPts.push(pts[coordinateIndex - 1], pts[coordinateIndex], pts[coordinateIndex + 1]);
    }

    var xys = [];

    var _this$getMap$getSize = this.getMap().getSize(),
        width = _this$getMap$getSize.width,
        height = _this$getMap$getSize.height;

    for (var _i = 0, _len = filterPts.length - 1; _i < _len; _i++) {
      var pt1 = filterPts[_i],
          pt2 = filterPts[_i + 1];

      if (pt1.x === pt2.x) {
        var miny = Math.max(0, Math.min(pt1.y, pt2.y));
        var maxy = Math.min(height, Math.max(pt1.y, pt2.y));

        for (var y = miny; y <= maxy; y++) {
          xys.push(new Point(pt1.x, y));
        }
      } else {
        var k = (pt2.y - pt1.y) / (pt2.x - pt1.x);
        var minx = Math.max(0, Math.min(pt1.x, pt2.x));
        var maxx = Math.min(width, Math.max(pt1.x, pt2.x));

        for (var x = minx; x <= maxx; x++) {
          var _y = k * (x - pt1.x) + pt1.y;

          xys.push(new Point(x, _y));
        }
      }
    }

    var minPtDis = Infinity,
        ptIndex = -1;

    for (var _i2 = 0, _len2 = xys.length; _i2 < _len2; _i2++) {
      var _pt = xys[_i2];

      var _dis = mousePt.distanceTo(_pt);

      if (_dis < minPtDis) {
        minPtDis = _dis;
        ptIndex = _i2;
      }
    }

    return {
      dis: minPtDis,
      coordinate: ptIndex < 0 ? mouseCoordinate : this.getMap().containerPointToCoord(xys[ptIndex])
    };
  };

  _proto._getWindowWidth = function _getWindowWidth() {
    var defaultWidth = 300;
    var width = this.options['width'];

    if (!width) {
      width = defaultWidth;
    }

    return width;
  };

  return InfoWindow;
}(UIComponent);

InfoWindow.mergeOptions(options$l);

var options$m = {
  'width': 0,
  'height': 0,
  'animation': 'fade',
  'containerClass': 'maptalks-tooltip',
  'showTimeout': 400
};

var ToolTip = function (_UIComponent) {
  _inheritsLoose(ToolTip, _UIComponent);

  var _proto = ToolTip.prototype;

  _proto._getClassName = function _getClassName() {
    return 'ToolTip';
  };

  function ToolTip(content, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _UIComponent.call(this, options) || this;
    _this._content = content;
    return _this;
  }

  _proto.addTo = function addTo(owner) {
    if (ToolTip.isSupport(owner)) {
      owner.on('mousemove', this.onMouseMove, this);
      owner.on('mouseout', this.onMouseOut, this);
      return _UIComponent.prototype.addTo.call(this, owner);
    } else {
      throw new Error('Invalid geometry or UIMarker the tooltip is added to.');
    }
  };

  _proto.setStyle = function setStyle$$1(cssName) {
    this.options.containerClass = cssName;
    return this;
  };

  _proto.getStyle = function getStyle() {
    return this.options.containerClass;
  };

  _proto.getContent = function getContent() {
    return this._content;
  };

  _proto.buildOn = function buildOn() {
    var dom = createEl('div');
    var options = this.options || {};

    if (options.height) {
      dom.style.height = options.height + 'px';
    }

    if (options.width) {
      dom.style.width = options.width + 'px';
    }

    var cssName = options.containerClass || options.cssName;

    if (!cssName && options.height) {
      dom.style.lineHeight = options.height + 'px';
    }

    dom.innerHTML = "<div class=\"" + cssName + "\">" + this._content + "</div>";
    return dom;
  };

  _proto.onMouseOut = function onMouseOut() {
    clearTimeout(this._timeout);

    if (this.isVisible()) {
      this._removePrevDOM();
    }
  };

  _proto.onMouseMove = function onMouseMove(e) {
    var _this2 = this;

    clearTimeout(this._timeout);
    var map = this.getMap();

    if (!map) {
      return;
    }

    var coord = map.locateByPoint(e.coordinate, -5, 25);

    if (this.options['showTimeout'] === 0) {
      this.show(coord);
    } else {
      this._timeout = setTimeout(function () {
        if (map) {
          _this2.show(coord);
        }
      }, this.options['showTimeout']);
    }
  };

  _proto.onRemove = function onRemove() {
    clearTimeout(this._timeout);

    if (this._owner) {
      this._owner.off('mouseover', this.onMouseOver, this);

      this._owner.off('mouseout', this.onMouseOut, this);
    }
  };

  _proto._getViewPoint = function _getViewPoint() {
    return this.getMap().coordToViewPoint(this._coordinate, undefined, 0)._add(this.options['dx'], this.options['dy']);
  };

  return ToolTip;
}(UIComponent);

ToolTip.mergeOptions(options$m);

var defaultOptions = {
  'containerClass': 'maptalks-menu',
  'animation': null,
  'animationDelay': 10,
  'animationOnHide': false,
  'autoPan': false,
  'width': 160,
  'maxHeight': 0,
  'custom': false,
  'items': []
};

var Menu = function (_UIComponent) {
  _inheritsLoose(Menu, _UIComponent);

  function Menu(options) {
    return _UIComponent.call(this, options) || this;
  }

  var _proto = Menu.prototype;

  _proto._getClassName = function _getClassName() {
    return 'Menu';
  };

  _proto.addTo = function addTo(owner) {
    if (owner._menu && owner._menu !== this) {
      owner.removeMenu();
    }

    owner._menu = this;
    return UIComponent.prototype.addTo.apply(this, arguments);
  };

  _proto.setItems = function setItems(items) {
    this.options['items'] = items;
    return this;
  };

  _proto.getItems = function getItems() {
    return this.options['items'] || [];
  };

  _proto.buildOn = function buildOn() {
    if (this.options['custom']) {
      if (isString(this.options['items'])) {
        var container = createEl('div');
        container.innerHTML = this.options['items'];
        return container;
      } else {
        return this.options['items'];
      }
    } else {
      var dom = createEl('div');

      if (this.options['containerClass']) {
        addClass(dom, this.options['containerClass']);
      }

      dom.style.width = this._getMenuWidth() + 'px';

      var menuItems = this._createMenuItemDom();

      dom.appendChild(menuItems);
      on(dom, 'contextmenu', preventDefault);
      return dom;
    }
  };

  _proto.getOffset = function getOffset() {
    if (!this.getMap()) {
      return null;
    }

    var mapSize = this.getMap().getSize(),
        p = this.getMap().viewPointToContainerPoint(this._getViewPoint()),
        size = this.getSize();
    var dx = 0,
        dy = 0;

    if (p.x + size['width'] > mapSize['width']) {
      dx = -size['width'];
    }

    if (p.y + size['height'] > mapSize['height']) {
      dy = -size['height'];
    }

    return new Point(dx, dy);
  };

  _proto.getTransformOrigin = function getTransformOrigin() {
    var p = this.getOffset()._multi(-1);

    return p.x + 'px ' + p.y + 'px';
  };

  _proto.getEvents = function getEvents() {
    return {
      '_zoomstart _zoomend _movestart _dblclick _click': this._removePrevDOM
    };
  };

  _proto._createMenuItemDom = function _createMenuItemDom() {
    var me = this;
    var map = this.getMap();
    var ul = createEl('ul');
    addClass(ul, 'maptalks-menu-items');
    var items = this.getItems();

    function onMenuClick(index) {
      return function (e) {
        var param = map._parseEvent(e, 'click');

        param['target'] = me;
        param['owner'] = me._owner;
        param['index'] = index;

        var result = this._callback(param);

        if (result === false) {
          return;
        }

        me.hide();
      };
    }

    var item, itemDOM;

    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];

      if (item === '-' || item === '_') {
        itemDOM = createEl('li');
        addClass(itemDOM, 'maptalks-menu-splitter');
      } else {
        itemDOM = createEl('li');
        var itemTitle = item['item'];

        if (isFunction(itemTitle)) {
          itemTitle = itemTitle({
            'owner': this._owner,
            'index': i
          });
        }

        itemDOM.innerHTML = itemTitle;
        itemDOM._callback = item['click'];
        on(itemDOM, 'click', onMenuClick(i));
      }

      ul.appendChild(itemDOM);
    }

    var maxHeight = this.options['maxHeight'] || 0;

    if (maxHeight > 0) {
      setStyle(ul, 'max-height: ' + maxHeight + 'px; overflow-y: auto;');
    }

    return ul;
  };

  _proto._getMenuWidth = function _getMenuWidth() {
    var defaultWidth = 160;
    var width = this.options['width'] || defaultWidth;
    return width;
  };

  return Menu;
}(UIComponent);

Menu.mergeOptions(defaultOptions);

var Menuable = {
  setMenu: function setMenu(options) {
    this._menuOptions = options;

    if (this._menu) {
      this._menu.setOptions(options);
    } else {
      this.on('contextmenu', this._defaultOpenMenu, this);
    }

    return this;
  },
  openMenu: function openMenu(coordinate) {
    var map = this instanceof Map$1 ? this : this.getMap();

    if (!coordinate) {
      coordinate = this.getCenter();
    }

    if (!this._menu) {
      if (this._menuOptions && map) {
        this._bindMenu(this._menuOptions);

        this._menu.show(coordinate);
      }
    } else {
      this._menu.show(coordinate);
    }

    return this;
  },
  setMenuItems: function setMenuItems(items) {
    if (!this._menuOptions) {
      this._menuOptions = {};
    }

    if (Array.isArray(items)) {
      this._menuOptions['custom'] = false;
    }

    this._menuOptions['items'] = items;
    this.setMenu(this._menuOptions);
    return this;
  },
  getMenuItems: function getMenuItems() {
    if (this._menu) {
      return this._menu.getItems();
    } else if (this._menuOptions) {
      return this._menuOptions['items'] || [];
    }

    return [];
  },
  closeMenu: function closeMenu() {
    if (this._menu) {
      this._menu.hide();
    }

    return this;
  },
  removeMenu: function removeMenu() {
    this.off('contextmenu', this._defaultOpenMenu, this);

    this._unbindMenu();

    delete this._menuOptions;
    return this;
  },
  _bindMenu: function _bindMenu(options) {
    this._menu = new Menu(options);

    this._menu.addTo(this);

    return this;
  },
  _unbindMenu: function _unbindMenu() {
    if (this._menu) {
      this.closeMenu();

      this._menu.remove();

      delete this._menu;
    }

    return this;
  },
  _defaultOpenMenu: function _defaultOpenMenu(param) {
    if (this.listens('contextmenu') > 1) {
      return true;
    } else {
      this.openMenu(param['coordinate']);
      return false;
    }
  }
};
Map$1.include(Menuable);
Geometry.include(Menuable);



var index$4 = /*#__PURE__*/Object.freeze({
  UIComponent: UIComponent,
  UIMarker: UIMarker,
  InfoWindow: InfoWindow,
  ToolTip: ToolTip,
  Menuable: Menuable,
  Menu: Menu
});

var Control = function (_Eventable) {
  _inheritsLoose(Control, _Eventable);

  function Control(options) {
    if (options && options['position'] && !isString(options['position'])) {
      options['position'] = extend({}, options['position']);
    }

    return _Eventable.call(this, options) || this;
  }

  var _proto = Control.prototype;

  _proto.addTo = function addTo(map) {
    this.remove();

    if (!map.options['control']) {
      return this;
    }

    this._map = map;
    var controlContainer = map._panels.control;
    this.__ctrlContainer = createEl('div');
    setStyle(this.__ctrlContainer, 'position:absolute;overflow:visible;');
    this.update();
    controlContainer.appendChild(this.__ctrlContainer);

    if (this.onAdd) {
      this.onAdd();
    }

    this.fire('add', {
      'dom': controlContainer
    });
    return this;
  };

  _proto.update = function update() {
    this.__ctrlContainer.innerHTML = '';
    this._controlDom = this.buildOn(this.getMap());

    if (this._controlDom) {
      this._updatePosition();

      this.__ctrlContainer.appendChild(this._controlDom);
    }

    return this;
  };

  _proto.getMap = function getMap() {
    return this._map;
  };

  _proto.getPosition = function getPosition() {
    return extend({}, this._parse(this.options['position']));
  };

  _proto.setPosition = function setPosition(position) {
    if (isString(position)) {
      this.options['position'] = position;
    } else {
      this.options['position'] = extend({}, position);
    }

    this._updatePosition();

    return this;
  };

  _proto.getContainerPoint = function getContainerPoint() {
    var position = this.getPosition();
    var size = this.getMap().getSize();
    var x, y;

    if (!isNil(position['left'])) {
      x = parseInt(position['left']);
    } else if (!isNil(position['right'])) {
      x = size['width'] - parseInt(position['right']);
    }

    if (!isNil(position['top'])) {
      y = parseInt(position['top']);
    } else if (!isNil(position['bottom'])) {
      y = size['height'] - parseInt(position['bottom']);
    }

    return new Point(x, y);
  };

  _proto.getContainer = function getContainer() {
    return this.__ctrlContainer;
  };

  _proto.getDOM = function getDOM() {
    return this._controlDom;
  };

  _proto.show = function show() {
    this.__ctrlContainer.style.display = '';
    return this;
  };

  _proto.hide = function hide() {
    this.__ctrlContainer.style.display = 'none';
    return this;
  };

  _proto.isVisible = function isVisible() {
    return this.__ctrlContainer && this.__ctrlContainer.style.display === '';
  };

  _proto.remove = function remove() {
    if (!this._map) {
      return this;
    }

    removeDomNode(this.__ctrlContainer);

    if (this.onRemove) {
      this.onRemove();
    }

    delete this._map;
    delete this.__ctrlContainer;
    delete this._controlDom;
    this.fire('remove');
    return this;
  };

  _proto._parse = function _parse(position) {
    var p = position;

    if (isString(position)) {
      p = Control['positions'][p];
    }

    return p;
  };

  _proto._updatePosition = function _updatePosition() {
    var position = this.getPosition();

    if (!position) {
      position = {
        'top': 20,
        'left': 20
      };
    }

    for (var p in position) {
      if (position.hasOwnProperty(p)) {
        position[p] = parseInt(position[p]);
        this.__ctrlContainer.style[p] = position[p] + 'px';
      }
    }

    this.fire('positionchange', {
      'position': extend({}, position)
    });
  };

  return Control;
}(Eventable(Class));

Control.positions = {
  'top-left': {
    'top': 20,
    'left': 20
  },
  'top-right': {
    'top': 20,
    'right': 20
  },
  'bottom-left': {
    'bottom': 20,
    'left': 20
  },
  'bottom-right': {
    'bottom': 20,
    'right': 20
  }
};
Map$1.mergeOptions({
  'control': true
});
Map$1.include({
  addControl: function addControl(control) {
    if (this._containerDOM.getContext) {
      return this;
    }

    control.addTo(this);
    return this;
  },
  removeControl: function removeControl(control) {
    if (!control || control.getMap() !== this) {
      return this;
    }

    control.remove();
    return this;
  }
});

var options$n = {
  'position': {
    'bottom': 0,
    'left': 0
  },
  'content': '<a href="http://maptalks.org" target="_blank">maptalks</a>'
};
var layerEvents = 'addlayer removelayer setbaselayer baselayerremove';

var Attribution = function (_Control) {
  _inheritsLoose(Attribution, _Control);

  function Attribution() {
    return _Control.apply(this, arguments) || this;
  }

  var _proto = Attribution.prototype;

  _proto.buildOn = function buildOn() {
    this._attributionContainer = createEl('div');
    this._attributionContainer.className = 'maptalks-attribution';

    this._update();

    return this._attributionContainer;
  };

  _proto.onAdd = function onAdd() {
    this.getMap().on(layerEvents, this._update, this);
  };

  _proto.onRemove = function onRemove() {
    this.getMap().off(layerEvents, this._update, this);
  };

  _proto._update = function _update() {
    var map = this.getMap();

    if (!map) {
      return;
    }

    var attributions = map._getLayers(function (layer) {
      return layer.options['attribution'];
    }).reverse().map(function (layer) {
      return layer.options['attribution'];
    });

    var content = this.options['content'] + (attributions.length > 0 ? ' - ' + attributions.join(', ') : '');
    this._attributionContainer.innerHTML = '<span style="padding:0px 4px">' + content + '</span>';
  };

  return Attribution;
}(Control);

Attribution.mergeOptions(options$n);
Map$1.mergeOptions({
  'attribution': true
});
Map$1.addOnLoadHook(function () {
  var a = this.options['attribution'] || this.options['attributionControl'];

  if (a) {
    this.attributionControl = new Attribution(a);
    this.addControl(this.attributionControl);
  }
});

var options$o = {
  'position': 'top-right',
  'baseTitle': 'Base Layers',
  'overlayTitle': 'Layers',
  'excludeLayers': [],
  'containerClass': 'maptalks-layer-switcher'
};

var LayerSwitcher = function (_Control) {
  _inheritsLoose(LayerSwitcher, _Control);

  function LayerSwitcher() {
    return _Control.apply(this, arguments) || this;
  }

  var _proto = LayerSwitcher.prototype;

  _proto.buildOn = function buildOn() {
    var container = this.container = createEl('div', this.options['containerClass']),
        panel = this.panel = createEl('div', 'panel'),
        button = this.button = createEl('button');
    container.appendChild(button);
    container.appendChild(panel);
    return container;
  };

  _proto.onAdd = function onAdd() {
    on(this.button, 'mouseover', this._show, this);
    on(this.panel, 'mouseleave', this._hide, this);
    on(this.getMap(), 'click', this._hide, this);
  };

  _proto.onRemove = function onRemove() {
    if (this.panel) {
      off(this.button, 'mouseover', this._show, this);
      off(this.panel, 'mouseleave', this._hide, this);
      off(this.getMap(), 'click', this._hide, this);
      removeDomNode(this.panel);
      removeDomNode(this.button);
      delete this.panel;
      delete this.button;
      delete this.container;
    }
  };

  _proto._show = function _show() {
    if (!hasClass(this.container, 'shown')) {
      addClass(this.container, 'shown');

      this._createPanel();
    }
  };

  _proto._hide = function _hide(e) {
    if (!this.panel.contains(e.toElement || e.relatedTarget)) {
      setClass(this.container, this.options['containerClass']);
    }
  };

  _proto._createPanel = function _createPanel() {
    this.panel.innerHTML = '';
    var ul = createEl('ul');
    this.panel.appendChild(ul);

    this._renderLayers(this.getMap(), ul);
  };

  _proto._renderLayers = function _renderLayers(map, elm) {
    var base = map.getBaseLayer(),
        layers = map.getLayers(),
        len = layers.length;

    if (base) {
      var baseLayers = base.layers || [base],
          li = createEl('li', 'group'),
          ul = createEl('ul'),
          label = createEl('label');
      label.innerHTML = this.options['baseTitle'];
      li.appendChild(label);

      for (var i = 0, _len = baseLayers.length; i < _len; i++) {
        var layer = baseLayers[i];

        if (this._isExcluded(layer)) {
          ul.appendChild(this._renderLayer(baseLayers[i], true));
          li.appendChild(ul);
          elm.appendChild(li);
        }
      }
    }

    if (len) {
      var _li = createEl('li', 'group'),
          _ul = createEl('ul'),
          _label = createEl('label');

      _label.innerHTML = this.options['overlayTitle'];

      _li.appendChild(_label);

      for (var _i = 0; _i < len; _i++) {
        var _layer = layers[_i];

        if (this._isExcluded(_layer)) {
          _ul.appendChild(this._renderLayer(_layer));
        }
      }

      _li.appendChild(_ul);

      elm.appendChild(_li);
    }
  };

  _proto._isExcluded = function _isExcluded(layer) {
    var id = layer.getId(),
        excludeLayers = this.options['excludeLayers'];
    return !(excludeLayers.length && excludeLayers.indexOf(id) >= 0);
  };

  _proto._renderLayer = function _renderLayer(layer, isBase) {
    var _this = this;

    var li = createEl('li', 'layer'),
        label = createEl('label'),
        input = createEl('input'),
        map = this.getMap();
    var visible = layer.options['visible'];
    layer.options['visible'] = true;
    var enabled = layer.isVisible();
    layer.options['visible'] = visible;
    li.className = 'layer';

    if (isBase) {
      input.type = 'radio';
      input.name = 'base';
    } else {
      input.type = 'checkbox';
    }

    input.checked = visible && enabled;

    if (!enabled) {
      input.setAttribute('disabled', 'disabled');
    }

    input.onchange = function (e) {
      if (e.target.type === 'radio') {
        var baseLayer = map.getBaseLayer(),
            baseLayers = baseLayer.layers;

        if (baseLayers) {
          for (var i = 0, len = baseLayers.length; i < len; i++) {
            var _baseLayer = baseLayers[i];

            _baseLayer[_baseLayer === layer ? 'show' : 'hide']();
          }
        } else if (!baseLayer.isVisible()) {
          baseLayer.show();
        }

        map._fireEvent('setbaselayer');
      } else {
        layer[e.target.checked ? 'show' : 'hide']();
      }

      _this.fire('layerchange', {
        target: layer
      });
    };

    li.appendChild(input);
    label.innerHTML = layer.getId();
    li.appendChild(label);
    return li;
  };

  return LayerSwitcher;
}(Control);

LayerSwitcher.mergeOptions(options$o);
Map$1.mergeOptions({
  'layerSwitcherControl': false
});
Map$1.addOnLoadHook(function () {
  if (this.options['layerSwitcherControl']) {
    this.layerSwitcherControl = new LayerSwitcher(this.options['layerSwitcherControl']);
    this.addControl(this.layerSwitcherControl);
  }
});

var options$p = {
  'level': 4,
  'position': {
    'right': 1,
    'bottom': 1
  },
  'size': [300, 200],
  'maximize': true,
  'symbol': {
    'lineWidth': 3,
    'lineColor': '#1bbc9b',
    'polygonFill': '#1bbc9b',
    'polygonOpacity': 0.4
  },
  'containerClass': 'maptalks-overview',
  'buttonClass': 'maptalks-overview-button'
};

var Overview = function (_Control) {
  _inheritsLoose(Overview, _Control);

  function Overview() {
    return _Control.apply(this, arguments) || this;
  }

  var _proto = Overview.prototype;

  _proto.buildOn = function buildOn() {
    var size = this.options['size'];

    if (!this.options['maximize']) {
      size = [0, 0];
    }

    var container = createEl('div');
    var mapContainer = this.mapContainer = createEl('div');
    mapContainer.style.width = size[0] + 'px';
    mapContainer.style.height = size[1] + 'px';
    mapContainer.className = this.options['containerClass'];
    var button = this.button = createEl('div');
    button.className = this.options['buttonClass'];
    container.appendChild(mapContainer);
    container.appendChild(button);
    return container;
  };

  _proto.onAdd = function onAdd() {
    if (this.options['maximize']) {
      this._createOverview();
    }

    this.getMap().on('resize moving zooming rotate dragrotating viewchange', this._update, this).on('setbaselayer', this._updateBaseLayer, this).on('spatialreferencechange', this._updateSpatialReference, this);
    on(this.button, 'click', this._onButtonClick, this);

    this._updateButtonText();
  };

  _proto.onRemove = function onRemove() {
    this.getMap().off('resize moving zooming rotate dragrotating viewchange', this._update, this).off('setbaselayer', this._updateBaseLayer, this).off('spatialreferencechange', this._updateSpatialReference, this);

    if (this._overview) {
      this._overview.remove();

      delete this._overview;
      delete this._perspective;
    }

    off(this.button, 'click', this._onButtonClick, this);
  };

  _proto.maxmize = function maxmize() {
    var size = this.options['size'];
    var dom = this.mapContainer;
    dom.style.width = size[0] + 'px';
    dom.style.height = size[1] + 'px';

    this._createOverview();

    return this;
  };

  _proto.minimize = function minimize() {
    if (this._overview) {
      this._overview.remove();
    }

    delete this._overview;
    delete this._perspective;
    var dom = this.mapContainer;
    dom.style.width = 0 + 'px';
    dom.style.height = 0 + 'px';
    return this;
  };

  _proto.getOverviewMap = function getOverviewMap() {
    return this._overview;
  };

  _proto._onButtonClick = function _onButtonClick() {
    if (!this._overview) {
      this.maxmize();
    } else {
      this.minimize();
    }

    this._updateButtonText();
  };

  _proto._updateButtonText = function _updateButtonText() {
    if (this._overview) {
      this.button.innerHTML = '-';
    } else {
      this.button.innerHTML = '+';
    }
  };

  _proto._createOverview = function _createOverview() {
    var map = this.getMap(),
        dom = this.mapContainer;
    var options = map.config();
    extend(options, {
      'center': map.getCenter(),
      'zoom': this._getOverviewZoom(),
      'zoomAnimationDuration': 150,
      'pitch': 0,
      'bearing': 0,
      'scrollWheelZoom': false,
      'checkSize': false,
      'doubleClickZoom': false,
      'touchZoom': false,
      'control': false,
      'draggable': false,
      'maxExtent': null
    });
    this._overview = new Map$1(dom, options);

    this._updateBaseLayer();

    this._perspective = new Polygon(this._getPerspectiveCoords(), {
      'draggable': true,
      'cursor': 'move',
      'symbol': this.options['symbol']
    }).on('dragend', this._onDragEnd, this);
    new VectorLayer('perspective_layer', this._perspective).addTo(this._overview);
    this.fire('load');
  };

  _proto._getOverviewZoom = function _getOverviewZoom() {
    var map = this.getMap(),
        zoom = map.getZoom(),
        minZoom = map.getMinZoom(),
        level = this.options['level'];

    if (level > 0) {
      for (var i = level; i > 0; i--) {
        if (zoom - i >= minZoom) {
          return zoom - i;
        }
      }
    } else {
      for (var _i = level; _i < 0; _i++) {
        if (zoom - _i >= minZoom) {
          return zoom - _i;
        }
      }
    }

    return zoom;
  };

  _proto._onDragEnd = function _onDragEnd() {
    var center = this._perspective.getCenter();

    this._overview.setCenter(center);

    this.getMap().panTo(center);
  };

  _proto._getPerspectiveCoords = function _getPerspectiveCoords() {
    var map = this.getMap();
    return map.getContainerExtent().toArray().map(function (c) {
      return map.containerPointToCoordinate(c);
    });
  };

  _proto._update = function _update() {
    if (!this._overview) {
      return;
    }

    computeDomPosition(this._overview._containerDOM);

    var coords = this._getPerspectiveCoords();

    this._perspective.setCoordinates(coords);

    this._overview.setCenterAndZoom(this.getMap().getCenter(), this._getOverviewZoom());
  };

  _proto._updateSpatialReference = function _updateSpatialReference() {
    if (!this._overview) {
      return;
    }

    var map = this.getMap();
    var spatialRef = map.options['spatialReference'];

    this._overview.setSpatialReference(spatialRef);
  };

  _proto._updateBaseLayer = function _updateBaseLayer() {
    if (!this._overview) {
      return;
    }

    var map = this.getMap(),
        baseLayer = map.getBaseLayer();

    if (!baseLayer) {
      this._overview.setBaseLayer(null);

      return;
    }

    var layers = baseLayer.layers;
    var showIndex = 0;

    if (layers) {
      for (var i = 0, l = layers.length; i < l; i++) {
        var _layer = layers[i];

        if (_layer.isVisible()) {
          showIndex = i;
          break;
        }
      }
    }

    var json = baseLayer.toJSON();
    var options = null;

    if (layers) {
      options = json.layers[showIndex].options;
      options.visible = true;
    } else {
      options = json.options;
    }

    this._overview.setMinZoom(options.minZoom || null).setMaxZoom(options.maxZoom || null);

    delete options.minZoom;
    delete options.maxZoom;
    delete json.options.canvas;
    json.options.visible = true;
    json.options.renderer = 'canvas';
    var layer = Layer.fromJSON(json);

    for (var p in baseLayer) {
      if (isFunction(baseLayer[p]) && baseLayer.hasOwnProperty(p) && baseLayer[p] !== baseLayer.constructor.prototype[p]) {
        layer[p] = baseLayer[p];
      }
    }

    this._overview.setBaseLayer(layer);
  };

  return Overview;
}(Control);

Overview.mergeOptions(options$p);
Map$1.mergeOptions({
  'overviewControl': false
});
Map$1.addOnLoadHook(function () {
  if (this.options['overviewControl']) {
    this.overviewControl = new Overview(this.options['overviewControl']);
    this.addControl(this.overviewControl);
  }
});

var options$q = {
  'position': 'top-right',
  'draggable': true,
  'custom': false,
  'content': '',
  'closeButton': true
};

var Panel = function (_Control) {
  _inheritsLoose(Panel, _Control);

  function Panel() {
    return _Control.apply(this, arguments) || this;
  }

  var _proto = Panel.prototype;

  _proto.buildOn = function buildOn() {
    var dom;

    if (this.options['custom']) {
      if (isString(this.options['content'])) {
        dom = createEl('div');
        dom.innerHTML = this.options['content'];
      } else {
        dom = this.options['content'];
      }
    } else {
      dom = createEl('div', 'maptalks-panel');

      if (this.options['closeButton']) {
        var closeButton = createEl('a', 'maptalks-close');
        closeButton.href = 'javascript:;';

        closeButton.onclick = function () {
          dom.style.display = 'none';
        };

        dom.appendChild(closeButton);
      }

      var panelContent = createEl('div', 'maptalks-panel-content');
      panelContent.innerHTML = this.options['content'];
      dom.appendChild(panelContent);
    }

    this.draggable = new DragHandler(dom, {
      'cancelOn': this._cancelOn.bind(this),
      'ignoreMouseleave': true
    });
    this.draggable.on('dragstart', this._onDragStart, this).on('dragging', this._onDragging, this).on('dragend', this._onDragEnd, this);

    if (this.options['draggable']) {
      this.draggable.enable();
    }

    return dom;
  };

  _proto.update = function update() {
    if (this.draggable) {
      this.draggable.disable();
      delete this.draggable;
    }

    return Control.prototype.update.call(this);
  };

  _proto.setContent = function setContent(content) {
    var old = this.options['content'];
    this.options['content'] = content;
    this.fire('contentchange', {
      'old': old,
      'new': content
    });

    if (this.isVisible()) {
      this.update();
    }

    return this;
  };

  _proto.getContent = function getContent() {
    return this.options['content'];
  };

  _proto._cancelOn = function _cancelOn(domEvent) {
    var target = domEvent.srcElement || domEvent.target,
        tagName = target.tagName.toLowerCase();

    if (tagName === 'button' || tagName === 'input' || tagName === 'select' || tagName === 'option' || tagName === 'textarea') {
      return true;
    }

    return false;
  };

  _proto._onDragStart = function _onDragStart(param) {
    this._startPos = param['mousePos'];
    this._startPosition = extend({}, this.getPosition());
    this.fire('dragstart', param);
  };

  _proto._onDragging = function _onDragging(param) {
    var pos = param['mousePos'];
    var offset = pos.sub(this._startPos);
    var startPosition = this._startPosition;
    var position = this.getPosition();

    if (!isNil(position['top'])) {
      position['top'] = parseInt(startPosition['top']) + offset.y;
    }

    if (!isNil(position['bottom'])) {
      position['bottom'] = parseInt(startPosition['bottom']) - offset.y;
    }

    if (!isNil(position['left'])) {
      position['left'] = parseInt(startPosition['left']) + offset.x;
    }

    if (!isNil(position['right'])) {
      position['right'] = parseInt(startPosition['right']) - offset.x;
    }

    this.setPosition(position);
    this.fire('dragging', param);
  };

  _proto._onDragEnd = function _onDragEnd(param) {
    delete this._startPos;
    delete this._startPosition;
    this.fire('dragend', param);
  };

  _proto._getConnectPoints = function _getConnectPoints() {
    var map = this.getMap();
    var containerPoint = this.getContainerPoint();
    var dom = this.getDOM(),
        width = parseInt(dom.clientWidth),
        height = parseInt(dom.clientHeight);
    var anchors = [map.containerPointToCoordinate(containerPoint.add(width / 2, 0)), map.containerPointToCoordinate(containerPoint.add(width, height / 2)), map.containerPointToCoordinate(containerPoint.add(width / 2, height)), map.containerPointToCoordinate(containerPoint.add(0, height / 2))];
    return anchors;
  };

  return Panel;
}(Control);

Panel.mergeOptions(options$q);

var options$r = {
  'position': 'bottom-left',
  'maxWidth': 100,
  'metric': true,
  'imperial': false,
  'containerClass': null
};

var Scale = function (_Control) {
  _inheritsLoose(Scale, _Control);

  function Scale() {
    return _Control.apply(this, arguments) || this;
  }

  var _proto = Scale.prototype;

  _proto.buildOn = function buildOn(map) {
    this._map = map;
    this._scaleContainer = createEl('div', this.options['containerClass']);

    this._addScales();

    map.on('zoomend', this._update, this);

    if (this._map._loaded) {
      this._update();
    }

    return this._scaleContainer;
  };

  _proto.onRemove = function onRemove() {
    this.getMap().off('zoomend', this._update, this);
  };

  _proto._addScales = function _addScales() {
    var css = 'border: 2px solid #000000;border-top: none;line-height: 1.1;padding: 0px;' + 'color: #000000;font-size: 11px;text-align:center;white-space: nowrap;overflow: hidden' + ';-moz-box-sizing: content-box;box-sizing: content-box;background: #fff; background: rgba(255, 255, 255, 0);';

    if (this.options['metric']) {
      this._mScale = createElOn('div', this.options['containerClass'] ? null : css, this._scaleContainer);
    }

    if (this.options['imperial']) {
      this._iScale = createElOn('div', this.options['containerClass'] ? null : css, this._scaleContainer);
    }
  };

  _proto._update = function _update() {
    var map = this._map;
    var maxMeters = map.pixelToDistance(this.options['maxWidth'], 0);

    this._updateScales(maxMeters);
  };

  _proto._updateScales = function _updateScales(maxMeters) {
    if (this.options['metric'] && maxMeters) {
      this._updateMetric(maxMeters);
    }

    if (this.options['imperial'] && maxMeters) {
      this._updateImperial(maxMeters);
    }
  };

  _proto._updateMetric = function _updateMetric(maxMeters) {
    var meters = this._getRoundNum(maxMeters),
        label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

    this._updateScale(this._mScale, label, meters / maxMeters);
  };

  _proto._updateImperial = function _updateImperial(maxMeters) {
    var maxFeet = maxMeters * 3.2808399;
    var maxMiles, miles, feet;

    if (maxFeet > 5280) {
      maxMiles = maxFeet / 5280;
      miles = this._getRoundNum(maxMiles);

      this._updateScale(this._iScale, miles + ' mile', miles / maxMiles);
    } else {
      feet = this._getRoundNum(maxFeet);

      this._updateScale(this._iScale, feet + ' feet', feet / maxFeet);
    }
  };

  _proto._updateScale = function _updateScale(scale, text, ratio) {
    scale['style']['width'] = Math.round(this.options['maxWidth'] * ratio) + 'px';
    scale['innerHTML'] = text;
  };

  _proto._getRoundNum = function _getRoundNum(num) {
    var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
    var d = num / pow10;
    d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
    return pow10 * d;
  };

  return Scale;
}(Control);

Scale.mergeOptions(options$r);
Map$1.mergeOptions({
  'scaleControl': false
});
Map$1.addOnLoadHook(function () {
  if (this.options['scaleControl']) {
    this.scaleControl = new Scale(this.options['scaleControl']);
    this.addControl(this.scaleControl);
  }
});

var options$s = {
  'height': 28,
  'vertical': false,
  'position': 'top-right',
  'reverseMenu': false,
  'items': {}
};

var Toolbar = function (_Control) {
  _inheritsLoose(Toolbar, _Control);

  function Toolbar() {
    return _Control.apply(this, arguments) || this;
  }

  var _proto = Toolbar.prototype;

  _proto.buildOn = function buildOn(map) {
    this._map = map;
    var dom = createEl('div');
    var ul = createEl('ul', 'maptalks-toolbar-hx');
    dom.appendChild(ul);

    if (this.options['vertical']) {
      addClass(dom, 'maptalks-toolbar-vertical');
    } else {
      addClass(dom, 'maptalks-toolbar-horizonal');
    }

    var me = this;

    function onButtonClick(fn, index, childIndex, targetDom) {
      var item = me._getItems()[index];

      return function (e) {
        stopPropagation(e);
        return fn({
          'target': item,
          'index': index,
          'childIndex': childIndex,
          'dom': targetDom
        });
      };
    }

    var items = this.options['items'];

    if (isArrayHasData(items)) {
      for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
        var li = createEl('li');

        if (this.options['height'] !== 28) {
          li.style.lineHeight = this.options['height'] + 'px';
        }

        li.style.height = this.options['height'] + 'px';
        li.style.cursor = 'pointer';

        if (isHTML(item['item'])) {
          li.style.textAlign = 'center';
          var itemSize = measureDom('div', item['item']);
          li.innerHTML = '<div style="margin-top:' + (this.options['height'] - itemSize['height']) / 2 + 'px;">' + item['item'] + '</div>';
        } else {
          li.innerHTML = item['item'];
        }

        if (item['click']) {
          on(li, 'click', onButtonClick(item['click'], i, null, li));
        }

        if (isArrayHasData(item['children'])) {
          var dropMenu = this._createDropMenu(i);

          li.appendChild(dropMenu);
          li._menu = dropMenu;
          on(li, 'mouseover', function () {
            this._menu.style.display = '';
          });
          on(li, 'mouseout', function () {
            this._menu.style.display = 'none';
          });
        }

        ul.appendChild(li);
      }
    }

    return dom;
  };

  _proto._createDropMenu = function _createDropMenu(index) {
    var me = this;

    function onButtonClick(fn, index, childIndex) {
      var item = me._getItems()[index]['children'][childIndex];

      return function (e) {
        stopPropagation(e);
        return fn({
          'target': item,
          'index': index,
          'childIndex': childIndex
        });
      };
    }

    var menuDom = createEl('div', 'maptalks-dropMenu'),
        items = this._getItems(),
        len = items.length,
        menuUL = createEl('ul'),
        children = items[index]['children'];

    if (index === len - 1 && children) {
      menuDom.style.cssText = 'right: 0px;';
      menuUL.style.cssText = 'right: 0px;position: absolute;';

      if (this.options['reverseMenu']) {
        menuUL.style.bottom = 0;
      }
    }

    menuDom.appendChild(createEl('em', 'maptalks-ico'));
    var liWidth = 0;

    for (var i = 0, l = children.length; i < l; i++) {
      var size = stringLength(children[i]['item'], '12px');

      if (size.width > liWidth) {
        liWidth = size.width;
      }
    }

    for (var _i = 0, _l = children.length; _i < _l; _i++) {
      var child = children[_i];
      var li = createEl('li');
      li.innerHTML = '<a href="javascript:;">' + child['item'] + '</a>';
      li.style.cursor = 'pointer';
      li.style.width = liWidth + 24 + 'px';
      on(li.childNodes[0], 'click', onButtonClick(child['click'], index, _i));
      menuUL.appendChild(li);
    }

    if (this.options['vertical']) {
      var width = liWidth < 95 ? 95 : liWidth;

      if (this.options['reverseMenu']) {
        menuDom.style.right = -(width + 10 * 2) + 'px';
      } else {
        menuDom.style.left = -(width + 10 * 2) + 'px';
      }
    } else if (this.options['reverseMenu']) {
      menuDom.style.bottom = '28px';
    } else {
      menuDom.style.top = '28px';
    }

    menuDom.appendChild(menuUL);
    menuDom.style.display = 'none';
    return menuDom;
  };

  _proto._getItems = function _getItems() {
    return this.options['items'] || [];
  };

  return Toolbar;
}(Control);

Toolbar.mergeOptions(options$s);

var options$t = {
  'position': 'top-left',
  'slider': true,
  'zoomLevel': true,
  'seamless': false
};
var UNIT = 10;

var Zoom = function (_Control) {
  _inheritsLoose(Zoom, _Control);

  function Zoom() {
    return _Control.apply(this, arguments) || this;
  }

  var _proto = Zoom.prototype;

  _proto.buildOn = function buildOn(map) {
    var options = this.options;
    var dom = createEl('div', 'maptalks-zoom');

    if (options['zoomLevel']) {
      var levelDOM = createEl('span', 'maptalks-zoom-zoomlevel');
      dom.appendChild(levelDOM);
      this._levelDOM = levelDOM;
    }

    var zoomDOM = createEl('div', 'maptalks-zoom-slider');
    var zoomInButton = createEl('a', 'maptalks-zoom-zoomin');
    zoomInButton.href = 'javascript:;';
    zoomInButton.innerHTML = '+';
    zoomDOM.appendChild(zoomInButton);
    this._zoomInButton = zoomInButton;

    if (options['slider']) {
      var box = createEl('div', 'maptalks-zoom-slider-box');
      var ruler = createEl('div', 'maptalks-zoom-slider-ruler');
      var reading = createEl('span', 'maptalks-zoom-slider-reading');
      var dot = createEl('span', 'maptalks-zoom-slider-dot');
      ruler.appendChild(reading);
      box.appendChild(ruler);
      box.appendChild(dot);
      zoomDOM.appendChild(box);
      this._sliderBox = box;
      this._sliderRuler = ruler;
      this._sliderReading = reading;
      this._sliderDot = dot;
    }

    var zoomOutButton = createEl('a', 'maptalks-zoom-zoomout');
    zoomOutButton.href = 'javascript:;';
    zoomOutButton.innerHTML = '-';
    zoomDOM.appendChild(zoomOutButton);
    this._zoomOutButton = zoomOutButton;
    dom.appendChild(zoomDOM);
    map.on('_zoomend _zooming _zoomstart _spatialreferencechange', this._update, this);

    this._update();

    this._registerDomEvents();

    return dom;
  };

  _proto.onRemove = function onRemove() {
    this.getMap().off('_zoomend _zooming _zoomstart _spatialreferencechange', this._update, this);

    if (this._zoomInButton) {
      off(this._zoomInButton, 'click', this._onZoomInClick, this);
    }

    if (this._zoomOutButton) {
      off(this._zoomOutButton, 'click', this._onZoomOutClick, this);
    }

    if (this._sliderRuler) {
      off(this._sliderRuler, 'click', this._onClickRuler, this);
      this.dotDragger.disable();
      delete this.dotDragger;
    }
  };

  _proto._update = function _update() {
    var map = this.getMap();

    if (this._sliderBox) {
      var totalRange = (map.getMaxZoom() - map.getMinZoom()) * UNIT;
      this._sliderBox.style.height = totalRange + 16 + 'px';
      this._sliderRuler.style.height = totalRange + 8 + 'px';
      this._sliderRuler.style.cursor = 'pointer';
      var zoomRange = (map.getMaxZoom() - map.getZoom()) * UNIT;
      this._sliderReading.style.height = (map.getZoom() - map.getMinZoom() + 1) * UNIT + 'px';
      this._sliderDot.style.top = zoomRange + 'px';
    }

    this._updateText();
  };

  _proto._updateText = function _updateText() {
    if (this._levelDOM) {
      var map = this.getMap();
      var zoom = map.getZoom();

      if (!isInteger(zoom)) {
        zoom = Math.floor(zoom * 10) / 10;
      }

      this._levelDOM.innerHTML = zoom;
    }
  };

  _proto._registerDomEvents = function _registerDomEvents() {
    if (this._zoomInButton) {
      on(this._zoomInButton, 'click', this._onZoomInClick, this);
    }

    if (this._zoomOutButton) {
      on(this._zoomOutButton, 'click', this._onZoomOutClick, this);
    }

    if (this._sliderRuler) {
      on(this._sliderRuler, 'click', this._onClickRuler, this);
      this.dotDragger = new DragHandler(this._sliderDot, {
        'ignoreMouseleave': true
      });
      this.dotDragger.on('dragstart', this._onDotDragstart, this).on('dragging dragend', this._onDotDrag, this).enable();
    }
  };

  _proto._onZoomInClick = function _onZoomInClick(e) {
    preventDefault(e);
    this.getMap().zoomIn();
  };

  _proto._onZoomOutClick = function _onZoomOutClick(e) {
    preventDefault(e);
    this.getMap().zoomOut();
  };

  _proto._onClickRuler = function _onClickRuler(e) {
    preventDefault(e);
    var map = this.getMap(),
        point = getEventContainerPoint(e, this._sliderRuler),
        h = point.y;
    var maxZoom = map.getMaxZoom(),
        zoom = Math.floor(maxZoom - h / UNIT);
    map.setZoom(zoom);
  };

  _proto._onDotDragstart = function _onDotDragstart(e) {
    preventDefault(e.domEvent);

    var map = this.getMap(),
        origin = map.getSize().toPoint()._multi(1 / 2);

    map.onZoomStart(map.getZoom(), origin);
  };

  _proto._onDotDrag = function _onDotDrag(e) {
    preventDefault(e.domEvent);

    var map = this.getMap(),
        origin = map.getSize().toPoint()._multi(1 / 2),
        point = getEventContainerPoint(e.domEvent, this._sliderRuler),
        maxZoom = map.getMaxZoom(),
        minZoom = map.getMinZoom();

    var top = point.y,
        z = maxZoom - top / UNIT;

    if (maxZoom < z) {
      z = maxZoom;
      top = 0;
    } else if (minZoom > z) {
      z = minZoom;
      top = (maxZoom - minZoom) * UNIT;
    }

    if (e.type === 'dragging') {
      map.onZooming(z, origin, 1);
    } else if (e.type === 'dragend') {
      if (this.options['seamless']) {
        map.onZoomEnd(z, origin);
      } else {
        map.onZoomEnd(Math.round(z), origin);
      }
    }

    this._sliderDot.style.top = top + 'px';
    this._sliderReading.style.height = (map.getZoom() - minZoom + 1) * UNIT + 'px';

    this._updateText();
  };

  return Zoom;
}(Control);

Zoom.mergeOptions(options$t);
Map$1.mergeOptions({
  'zoomControl': false
});
Map$1.addOnLoadHook(function () {
  if (this.options['zoomControl']) {
    this.zoomControl = new Zoom(this.options['zoomControl']);
    this.addControl(this.zoomControl);
  }
});



var index$5 = /*#__PURE__*/Object.freeze({
  Control: Control,
  Attribution: Attribution,
  LayerSwitcher: LayerSwitcher,
  Overview: Overview,
  Panel: Panel,
  Scale: Scale,
  Toolbar: Toolbar,
  Zoom: Zoom
});

var TileSystem = function () {
  function TileSystem(sx, sy, ox, oy) {
    if (Array.isArray(sx)) {
      this.scale = {
        x: sx[0],
        y: sx[1]
      };
      this.origin = {
        x: sx[2],
        y: sx[3]
      };
    } else {
      this.scale = {
        x: sx,
        y: sy
      };
      this.origin = {
        x: ox,
        y: oy
      };
    }
  }

  TileSystem.getDefault = function getDefault(projection) {
    if (projection['code'].toLowerCase() === 'baidu') {
      return 'baidu';
    } else if (projection['code'].toLowerCase() === 'EPSG:4326'.toLowerCase()) {
      return 'tms-global-geodetic';
    } else if (projection['code'].toLowerCase() === 'identity') {
      return [1, -1, 0, 0];
    } else {
      return 'web-mercator';
    }
  };

  return TileSystem;
}();

var semiCircum = 6378137 * Math.PI;
extend(TileSystem, {
  'web-mercator': new TileSystem([1, -1, -semiCircum, semiCircum]),
  'tms-global-mercator': new TileSystem([1, 1, -semiCircum, -semiCircum]),
  'tms-global-geodetic': new TileSystem([1, 1, -180, -90]),
  'baidu': new TileSystem([1, 1, 0, 0])
});

var TileConfig = function () {
  function TileConfig(map, tileSystem, fullExtent, tileSize) {
    this.map = map;
    this.tileSize = tileSize;
    this.fullExtent = fullExtent;
    this.prepareTileInfo(tileSystem, fullExtent);
    this._xScale = fullExtent['right'] >= fullExtent['left'] ? 1 : -1;
    this._yScale = fullExtent['top'] >= fullExtent['bottom'] ? 1 : -1;
    this._pointOrigin = map._prjToPoint(new Point(this.tileSystem['origin']), map.getGLZoom());
    this._glRes = map.getResolution(map.getGLZoom());
  }

  var _proto = TileConfig.prototype;

  _proto.prepareTileInfo = function prepareTileInfo(tileSystem, fullExtent) {
    if (isString(tileSystem)) {
      tileSystem = TileSystem[tileSystem.toLowerCase()];
    } else if (Array.isArray(tileSystem)) {
      tileSystem = new TileSystem(tileSystem);
    }

    if (!tileSystem) {
      throw new Error('Invalid TileSystem');
    }

    this.tileSystem = tileSystem;
    var a = fullExtent['right'] > fullExtent['left'] ? 1 : -1,
        b = fullExtent['top'] > fullExtent['bottom'] ? -1 : 1,
        c = tileSystem['origin']['x'],
        d = tileSystem['origin']['y'];
    this.transformation = new Transformation([a, b, c, d]);
  };

  _proto._getTileNum = function _getTileNum(point, res) {
    var tileSystem = this.tileSystem,
        tileSize = this['tileSize'],
        delta = 1E-7;
    var tileX = Math.floor(delta * tileSystem['scale']['x'] + point.x / (tileSize['width'] * res));
    var tileY = Math.ceil(delta * tileSystem['scale']['y'] + point.y / (tileSize['height'] * res));
    return {
      'x': tileSystem['scale']['x'] * tileX,
      'y': tileSystem['scale']['y'] * tileY
    };
  };

  _proto.getTileIndex = function getTileIndex(pCoord, res, repeatWorld) {
    var tileSystem = this.tileSystem;
    var point = this.transformation.transform(pCoord, 1);

    var tileIndex = this._getTileNum(point, res);

    if (tileSystem['scale']['x'] < 0) {
      tileIndex['x'] -= 1;
    }

    if (tileSystem['scale']['y'] > 0) {
      tileIndex['y'] -= 1;
    }

    return this.getNeighorTileIndex(tileIndex['x'], tileIndex['y'], 0, 0, res, repeatWorld);
  };

  _proto.getNeighorTileIndex = function getNeighorTileIndex(tileX, tileY, offsetX, offsetY, res, repeatWorld) {
    var tileSystem = this.tileSystem;
    var x = tileX + tileSystem['scale']['x'] * offsetX;
    var y = tileY - tileSystem['scale']['y'] * offsetY;
    var out = false;
    var idx = x;
    var idy = y;

    var ext = this._getTileFullIndex(res);

    if (repeatWorld) {
      if (repeatWorld === true || repeatWorld === 'x') {
        if (ext['xmax'] === ext['xmin']) {
          x = ext['xmin'];
        } else if (x < ext['xmin']) {
          x = ext['xmax'] - (ext['xmin'] - x) % (ext['xmax'] - ext['xmin']);

          if (x === ext['xmax']) {
            x = ext['xmin'];
          }
        } else if (x >= ext['xmax']) {
          x = ext['xmin'] + (x - ext['xmin']) % (ext['xmax'] - ext['xmin']);
        }
      }

      if (repeatWorld === true || repeatWorld === 'y') {
        if (ext['ymax'] === ext['ymin']) {
          y = ext['ymin'];
        } else if (y >= ext['ymax']) {
          y = ext['ymin'] + (y - ext['ymin']) % (ext['ymax'] - ext['ymin']);
        } else if (y < ext['ymin']) {
          y = ext['ymax'] - (ext['ymin'] - y) % (ext['ymax'] - ext['ymin']);

          if (y === ext['ymax']) {
            y = ext['ymin'];
          }
        }
      }
    }

    if (x < ext['xmin'] || x > ext['xmax'] || y > ext['ymax'] || y < ext['ymin']) {
      out = true;
    }

    return {
      'x': x,
      'y': y,
      'idx': idx,
      'idy': idy,
      out: out
    };
  };

  _proto._getTileFullIndex = function _getTileFullIndex(res) {
    if (!this._tileFullIndex) {
      this._tileFullIndex = {};
    }

    if (this._tileFullIndex[res]) {
      return this._tileFullIndex[res];
    }

    var ext = this.fullExtent;
    var transformation = this.transformation;

    var nwIndex = this._getTileNum(transformation.transform(new Coordinate(ext['left'], ext['top']), 1), res);

    var seIndex = this._getTileNum(transformation.transform(new Coordinate(ext['right'], ext['bottom']), 1), res);

    var tileSystem = this.tileSystem;

    if (tileSystem['scale']['x'] < 0) {
      nwIndex.x -= 1;
      seIndex.x -= 1;
    }

    if (tileSystem['scale']['y'] > 0) {
      nwIndex.y -= 1;
      seIndex.y -= 1;
    }

    this._tileFullIndex[res] = new Extent(nwIndex, seIndex);
    return this._tileFullIndex[res];
  };

  _proto.getTilePrjNW = function getTilePrjNW(tileX, tileY, res) {
    var tileSystem = this.tileSystem;
    var tileSize = this['tileSize'];
    var y = tileSystem['origin']['y'] + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 1 : 0)) * res * tileSize['height'];
    var x = tileSystem['origin']['x'] + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 0 : 1)) * res * tileSize['width'];
    return new Coordinate(x, y);
  };

  _proto.getTilePointNW = function getTilePointNW(tileX, tileY, res) {
    var scale = this._glRes / res;
    var tileSystem = this.tileSystem;
    var tileSize = this['tileSize'];
    var y = this._pointOrigin.y * scale + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 1 : 0)) * tileSize['height'];
    var x = this._pointOrigin.x * scale + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 0 : 1)) * tileSize['width'];
    return new Point(x, y);
  };

  _proto.getTilePrjSE = function getTilePrjSE(tileX, tileY, res) {
    var tileSystem = this.tileSystem;
    var tileSize = this['tileSize'];
    var y = tileSystem['origin']['y'] + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 0 : 1)) * res * tileSize['height'];
    var x = tileSystem['origin']['x'] + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 1 : 0)) * res * tileSize['width'];
    return new Coordinate(x, y);
  };

  _proto.getTilePointSE = function getTilePointSE(tileX, tileY, res) {
    var scale = this._glRes / res;
    var tileSystem = this.tileSystem;
    var tileSize = this['tileSize'];
    var y = this._pointOrigin.y * scale + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 0 : 1)) * tileSize['height'];
    var x = this._pointOrigin.x * scale + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 1 : 0)) * tileSize['width'];
    return new Point(x, y);
  };

  _proto.getTilePrjExtent = function getTilePrjExtent(tileX, tileY, res) {
    var nw = this.getTilePrjNW(tileX, tileY, res),
        se = this.getTilePrjSE(tileX, tileY, res);
    return new Extent(nw, se);
  };

  return TileConfig;
}();

var planes = [];

for (var i = 0; i < 6; i++) {
  planes[i] = [];
}
var p = [];
function intersectsBox(matrix, box, mask) {
  setPlanes(matrix);

  for (var i = 0; i < 6; i++) {
    if (mask && mask.charAt(i) === '0') {
      continue;
    }

    var plane = planes[i];
    p[0] = plane[0] > 0 ? box[1][0] : box[0][0];
    p[1] = plane[1] > 0 ? box[1][1] : box[0][1];
    p[2] = plane[2] > 0 ? box[1][2] : box[0][2];

    if (distanceToPoint(plane, p) < 0) {
      return false;
    }
  }

  return true;
}

function setPlanes(m) {
  var me = m;
  var me0 = me[0],
      me1 = me[1],
      me2 = me[2],
      me3 = me[3];
  var me4 = me[4],
      me5 = me[5],
      me6 = me[6],
      me7 = me[7];
  var me8 = me[8],
      me9 = me[9],
      me10 = me[10],
      me11 = me[11];
  var me12 = me[12],
      me13 = me[13],
      me14 = me[14],
      me15 = me[15];
  setComponents(planes[0], me3 - me0, me7 - me4, me11 - me8, me15 - me12);
  setComponents(planes[1], me3 + me0, me7 + me4, me11 + me8, me15 + me12);
  setComponents(planes[2], me3 + me1, me7 + me5, me11 + me9, me15 + me13);
  setComponents(planes[3], me3 - me1, me7 - me5, me11 - me9, me15 - me13);
  setComponents(planes[4], me3 - me2, me7 - me6, me11 - me10, me15 - me14);
  setComponents(planes[5], me3 + me2, me7 + me6, me11 + me10, me15 + me14);
}

function setComponents(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  var length = distance$1(out);
  out[0] /= length;
  out[1] /= length;
  out[2] /= length;
  out[3] /= length;
  return out;
}

function distanceToPoint(plane, p) {
  return plane[0] * p[0] + plane[1] * p[1] + plane[2] * p[2] + plane[3];
}

function distance$1(v3) {
  return Math.sqrt(v3[0] * v3[0] + v3[1] * v3[1] + v3[2] * v3[2]);
}

var isSetAvailable = typeof Set !== 'undefined';

var TileHashset = function () {
  function TileHashset() {
    this._table = isSetAvailable ? new Set() : {};
  }

  var _proto = TileHashset.prototype;

  _proto.add = function add$$1(key) {
    if (isSetAvailable) {
      this._table.add(key);
    } else {
      this._table[key] = true;
    }
  };

  _proto.has = function has(key) {
    if (isSetAvailable) {
      return this._table.has(key);
    } else {
      return this._table[key];
    }
  };

  _proto.reset = function reset() {
    if (isSetAvailable) {
      this._table.clear();
    } else {
      this._table = {};
    }
  };

  return TileHashset;
}();

var options$u = {
  'urlTemplate': null,
  'subdomains': null,
  'repeatWorld': true,
  'background': true,
  'backgroundZoomDiff': 6,
  'loadingLimitOnInteracting': 3,
  'tileRetryCount': 0,
  'placeholder': false,
  'crossOrigin': null,
  'tileSize': [256, 256],
  'offset': [0, 0],
  'tileSystem': null,
  'fadeAnimation': !IS_NODE,
  'debug': false,
  'spatialReference': null,
  'maxCacheSize': 256,
  'renderer': function () {
    return Browser$1.webgl ? 'gl' : 'canvas';
  }(),
  'clipByPitch': true,
  'maxAvailableZoom': null,
  'cascadeTiles': true,
  'zoomOffset': 0
};
var URL_PATTERN$1 = /\{ *([\w_]+) *\}/g;
var TEMP_POINT = new Point(0, 0);
var TEMP_POINT0$3 = new Point(0, 0);
var TEMP_POINT1$1 = new Point(0, 0);
var TEMP_POINT2 = new Point(0, 0);
var TEMP_POINT3 = new Point(0, 0);
var TEMP_POINT4 = new Point(0, 0);
var TEMP_POINT5 = new Point(0, 0);
var TEMP_POINT6 = new Point(0, 0);
var TILE_BOX = [[0, 0, 0], [0, 0, 0]];
var ARR3 = [];

var TileLayer = function (_Layer) {
  _inheritsLoose(TileLayer, _Layer);

  function TileLayer() {
    return _Layer.apply(this, arguments) || this;
  }

  TileLayer.fromJSON = function fromJSON(layerJSON) {
    if (!layerJSON || layerJSON['type'] !== 'TileLayer') {
      return null;
    }

    return new TileLayer(layerJSON['id'], layerJSON['options']);
  };

  var _proto2 = TileLayer.prototype;

  _proto2.getTileSize = function getTileSize() {
    var size = this.options['tileSize'];

    if (isNumber(size)) {
      size = [size, size];
    }

    return new Size(size);
  };

  _proto2.getTiles = function getTiles(z, parentLayer) {
    var map = this.getMap();
    var pitch = map.getPitch();
    var parentRenderer = parentLayer && parentLayer.getRenderer();
    var mapExtent = map.getContainerExtent();
    var tileGrids = [];
    var count = 0;
    var minZoom = this.getMinZoom();
    var cascadePitch0 = map.options['cascadePitches'][0];
    var cascadePitch1 = map.options['cascadePitches'][1];
    var visualHeight1 = Math.floor(map._getVisualHeight(cascadePitch1));
    var tileZoom = isNil(z) ? this._getTileZoom(map.getZoom()) : z;
    this._visitedTiles = new TileHashset();
    this._coordCache = {};

    if (!isNil(z) || !this.options['cascadeTiles'] || pitch <= cascadePitch0 || !isNil(minZoom) && tileZoom <= minZoom) {
      var containerExtent = pitch <= cascadePitch1 ? mapExtent : new PointExtent(0, map.height - visualHeight1, map.width, map.height);

      var _currentTiles = this._getTiles(tileZoom, containerExtent, 2, parentRenderer);

      if (_currentTiles) {
        count += _currentTiles.tiles.length;
        tileGrids.push(_currentTiles);
      }

      return {
        tileGrids: tileGrids,
        count: count
      };
    }

    var visualHeight0 = Math.floor(map._getVisualHeight(cascadePitch0));
    var extent0 = new PointExtent(0, map.height - visualHeight0, map.width, map.height);

    var currentTiles = this._getTiles(tileZoom, extent0, 0, parentRenderer);

    count += currentTiles ? currentTiles.tiles.length : 0;
    tileGrids.push(currentTiles);
    var cascadeHeight = extent0.ymin;
    var d = map.getSpatialReference().getZoomDirection();
    var cascadeLevels = d;
    var cascadeTiles1;

    if (pitch > cascadePitch1) {
      if (tileZoom - cascadeLevels <= minZoom) {
        cascadeLevels = 0;
      }

      var extent1 = new PointExtent(0, map.height - visualHeight1, map.width, cascadeHeight);
      cascadeTiles1 = this._getTiles(tileZoom - cascadeLevels, extent1, 1, parentRenderer);
      count += cascadeTiles1 ? cascadeTiles1.tiles.length : 0;
      cascadeHeight = extent1.ymin;
      cascadeLevels += 4 * d;
    }

    var cascadeTiles2;

    if (tileZoom - cascadeLevels >= minZoom) {
      var extent2 = new PointExtent(0, mapExtent.ymin, map.width, cascadeHeight);
      cascadeTiles2 = this._getTiles(tileZoom - cascadeLevels, extent2, 2, parentRenderer);
      count += cascadeTiles2 ? cascadeTiles2.tiles.length : 0;
      tileGrids.push(cascadeTiles2);
    }

    if (cascadeTiles1 && cascadeTiles2) {
      tileGrids[1] = cascadeTiles2;
      tileGrids[2] = cascadeTiles1;
    }

    return {
      tileGrids: tileGrids,
      count: count
    };
  };

  _proto2.getTileUrl = function getTileUrl(x, y, z) {
    var urlTemplate = this.options['urlTemplate'];
    var domain = '';

    if (this.options['subdomains']) {
      var subdomains = this.options['subdomains'];

      if (isArrayHasData(subdomains)) {
        var length$$1 = subdomains.length;
        var s = (x + y) % length$$1;

        if (s < 0) {
          s = 0;
        }

        domain = subdomains[s];
      }
    }

    if (isFunction(urlTemplate)) {
      return urlTemplate(x, y, z, domain);
    }

    var data = {
      'x': x,
      'y': y,
      'z': z,
      's': domain
    };
    return urlTemplate.replace(URL_PATTERN$1, function (str, key) {
      var value = data[key];

      if (value === undefined) {
        throw new Error('No value provided for variable ' + str);
      } else if (typeof value === 'function') {
        value = value(data);
      }

      return value;
    });
  };

  _proto2.clear = function clear() {
    if (this._renderer) {
      this._renderer.clear();
    }

    this.fire('clear');
    return this;
  };

  _proto2.toJSON = function toJSON() {
    var profile = {
      'type': this.getJSONType(),
      'id': this.getId(),
      'options': this.config()
    };
    return profile;
  };

  _proto2.getSpatialReference = function getSpatialReference() {
    var map = this.getMap();

    if (map && (!this.options['spatialReference'] || SpatialReference.equals(this.options['spatialReference'], map.options['spatialReference']))) {
      return map.getSpatialReference();
    }

    this._sr = this._sr || new SpatialReference(this.options['spatialReference']);

    if (this._srMinZoom === undefined) {
      this._srMinZoom = this._sr.getMinZoom();
      this._srMaxZoom = this._sr.getMaxZoom();
    }

    return this._sr;
  };

  _proto2.getMinZoom = function getMinZoom() {
    var sr = this.getSpatialReference();

    if (sr !== this.getMap().getSpatialReference()) {
      return Math.max(_Layer.prototype.getMinZoom.call(this), this._srMinZoom);
    }

    return _Layer.prototype.getMinZoom.call(this);
  };

  _proto2.getMaxZoom = function getMaxZoom() {
    var sr = this.getSpatialReference();

    if (sr !== this.getMap().getSpatialReference()) {
      return Math.min(_Layer.prototype.getMaxZoom.call(this), this._srMaxZoom);
    }

    return _Layer.prototype.getMaxZoom.call(this);
  };

  _proto2._getTileZoom = function _getTileZoom(zoom) {
    if (!isInteger(zoom)) {
      zoom = Math.round(zoom);
    }

    var maxZoom = this.options['maxAvailableZoom'];

    if (!isNil(maxZoom) && zoom > maxZoom) {
      zoom = maxZoom;
    }

    return zoom;
  };

  _proto2._getTiles = function _getTiles(tileZoom, containerExtent, cascadeLevel, parentRenderer) {
    var _this = this;

    var map = this.getMap();
    var z = tileZoom;
    var frustumMatrix = map.projViewMatrix;

    if (cascadeLevel < 2) {
      if (cascadeLevel === 0) {
        z -= 1;
      }

      frustumMatrix = cascadeLevel === 0 ? map.cascadeFrustumMatrix0 : cascadeLevel === 1 ? map.cascadeFrustumMatrix1 : map.projViewMatrix;
    }

    var zoom = z + this.options['zoomOffset'];

    var offset = this._getTileOffset(zoom),
        hasOffset = offset[0] || offset[1];

    var emptyGrid = {
      'zoom': z,
      'extent': null,
      'offset': offset,
      'tiles': []
    };

    if (zoom < 0) {
      return emptyGrid;
    }

    var minZoom = this.getMinZoom(),
        maxZoom = this.getMaxZoom();

    if (!map || !this.isVisible() || !map.width || !map.height) {
      return emptyGrid;
    }

    if (!isNil(minZoom) && z < minZoom || !isNil(maxZoom) && z > maxZoom) {
      return emptyGrid;
    }

    var tileConfig = this._getTileConfig();

    if (!tileConfig) {
      return emptyGrid;
    }

    var sr = this.getSpatialReference();
    var mapSR = map.getSpatialReference();
    var res = sr.getResolution(zoom);
    var glScale = map.getGLScale(z);
    var repeatWorld = sr === mapSR && this.options['repeatWorld'];
    var extent2d = containerExtent.convertTo(function (c) {
      var result;

      if (c.y > 0 && c.y < map.height) {
        var key = (c.x === 0 ? 0 : 1) + c.y;

        if (!_this._coordCache[key]) {
          _this._coordCache[key] = map._containerPointToPoint(c);
        }

        result = _this._coordCache[key];
      }

      result = map._containerPointToPoint(c, undefined, TEMP_POINT);
      return result;
    });

    extent2d._add(offset);

    var maskExtent = this._getMask2DExtent();

    if (maskExtent) {
      var intersection = maskExtent.intersection(extent2d);

      if (!intersection) {
        return emptyGrid;
      }

      containerExtent = intersection.convertTo(function (c) {
        return map._pointToContainerPoint(c, undefined, 0, TEMP_POINT);
      });
    }

    var prjCenter = map._containerPointToPrj(containerExtent.getCenter(), TEMP_POINT0$3);

    var centerPoint = map._prjToPoint(prjCenter, undefined, TEMP_POINT1$1);

    var c;

    if (hasOffset) {
      c = this._project(map._pointToPrj(centerPoint._add(offset), undefined, TEMP_POINT1$1), TEMP_POINT1$1);
    } else {
      c = this._project(prjCenter, TEMP_POINT1$1);
    }

    TEMP_POINT2.x = extent2d.xmin;
    TEMP_POINT2.y = extent2d.ymax;
    TEMP_POINT3.x = extent2d.xmax;
    TEMP_POINT3.y = extent2d.ymin;

    var pmin = this._project(map._pointToPrj(TEMP_POINT2, undefined, TEMP_POINT2), TEMP_POINT2);

    var pmax = this._project(map._pointToPrj(TEMP_POINT3, undefined, TEMP_POINT3), TEMP_POINT3);

    var centerTile = tileConfig.getTileIndex(c, res, repeatWorld);
    var ltTile = tileConfig.getTileIndex(pmin, res, repeatWorld);
    var rbTile = tileConfig.getTileIndex(pmax, res, repeatWorld);
    var top = Math.ceil(Math.abs(centerTile.idy - ltTile.idy)),
        left = Math.ceil(Math.abs(centerTile.idx - ltTile.idx)),
        bottom = Math.ceil(Math.abs(centerTile.idy - rbTile.idy)),
        right = Math.ceil(Math.abs(centerTile.idx - rbTile.idx));
    var allCount = (top + bottom + 1) * (left + right + 1);
    var tileSize = this.getTileSize();

    var renderer = this.getRenderer() || parentRenderer,
        scale = this._getTileConfig().tileSystem.scale;

    var tiles = [],
        extent = new PointExtent();

    for (var i = -top; i <= bottom; i++) {
      var j = -left;
      var leftVisitEnd = -Infinity;
      var rightVisitEnd = false;

      while (j >= leftVisitEnd && j <= right) {
        var idx = tileConfig.getNeighorTileIndex(centerTile.idx, centerTile.idy, j, i, res, repeatWorld);

        if (leftVisitEnd === -Infinity) {
          j++;
        } else {
          j--;
        }

        var tileId = this._getTileId(idx.idx, idx.idy, z);

        if (idx.out || this._visitedTiles && this._visitedTiles.has(tileId)) {
          continue;
        }

        var tileInfo = renderer && renderer.isTileCachedOrLoading(tileId);

        if (tileInfo) {
          tileInfo = tileInfo.info;
        }

        var p = void 0;

        if (tileInfo) {
          var _tileInfo = tileInfo,
              point0 = _tileInfo.point0;
          p = tileInfo.point.set(point0.x, point0.y);
        } else if (!this._hasOwnSR) {
          p = tileConfig.getTilePointNW(idx.x, idx.y, res);
        } else {
          var pnw = tileConfig.getTilePrjNW(idx.x, idx.y, res);
          p = map._prjToPoint(this._unproject(pnw, TEMP_POINT3), z);
        }

        var width = void 0,
            height = void 0;

        if (sr === mapSR) {
          width = tileSize.width;
          height = tileSize.height;
        } else {
          var pp = void 0;

          if (!this._hasOwnSR) {
            pp = tileConfig.getTilePointSE(idx.x, idx.y, res);
          } else {
            var pse = tileConfig.getTilePrjSE(idx.x, idx.y, res);
            pp = map._prjToPoint(this._unproject(pse, TEMP_POINT3), z, TEMP_POINT3);
          }

          width = Math.ceil(Math.abs(pp.x - p.x));
          height = Math.ceil(Math.abs(pp.y - p.y));
        }

        var dx = scale.x * (idx.idx - idx.x) * width,
            dy = scale.y * (idx.idy - idx.y) * height;

        if (dx || dy) {
          p._add(dx, dy);
        }

        if (hasOffset) {
          p._sub(offset);
        }

        var tileExtent = tileInfo && tileInfo.extent2d || new PointExtent(p.x, p.y, p.x + width, p.y - height);

        if (allCount <= 4 || rightVisitEnd || this._isTileInExtent(frustumMatrix, tileExtent, glScale)) {
          if (this._visitedTiles && cascadeLevel === 0) {
            this._visitedTiles.add(tileId);
          }

          if (cascadeLevel === 0) {
            this._splitTiles(frustumMatrix, tiles, renderer, idx, z + 1, tileExtent, offset, dx, dy);

            extent._combine(tileExtent);
          } else {
            if (!tileInfo) {
              tileInfo = {
                'point0': p.add(offset)._sub(dx, dy),
                'point': p,
                'z': z,
                'x': idx.x,
                'y': idx.y,
                'extent2d': tileExtent,
                'mask': cascadeLevel,
                'size': [width, height],
                'id': tileId,
                'dupKey': tileId,
                'layer': this.getId(),
                'url': this.getTileUrl(idx.x, idx.y, zoom)
              };
            }

            if (hasOffset) {
              tileExtent.set(p.x, p.y, p.x + width, p.y - height);
              tileInfo.point = p._add(offset);

              tileExtent._add(offset);
            }

            tiles.push(tileInfo);

            extent._combine(tileExtent);
          }

          if (leftVisitEnd === -Infinity) {
            leftVisitEnd = j;
            j = right;
          } else if (!rightVisitEnd) {
            rightVisitEnd = true;
          }
        }
      }
    }

    if (tiles.length) {
      var center = map._containerPointToPoint(containerExtent.getCenter(), z, TEMP_POINT)._add(offset);

      tiles.sort(function (a, b) {
        return a.point.distanceTo(center) - b.point.distanceTo(center);
      });
    }

    return {
      'offset': offset,
      'zoom': tileZoom,
      'extent': extent,
      'tiles': tiles
    };
  };

  _proto2._splitTiles = function _splitTiles(frustumMatrix, tiles, renderer, tileIdx, z, tileExtent, offset, dx, dy) {
    var yOrder = this._getTileConfig().tileSystem.scale.y;

    var glScale = this.getMap().getGLScale(z);
    var corner = TEMP_POINT4.set(tileExtent.xmin * 2, yOrder < 0 ? tileExtent.ymax * 2 : tileExtent.ymin * 2);

    var corner0 = TEMP_POINT5.set(tileExtent.xmin, yOrder < 0 ? tileExtent.ymax : tileExtent.ymin)._add(offset)._sub(dx, dy)._multi(2);

    var w = tileExtent.getWidth();
    var h = tileExtent.getHeight();
    var idx = tileIdx.idx * 2;
    var idy = tileIdx.idy * 2;
    var x = tileIdx.x * 2;
    var y = tileIdx.y * 2;

    var tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 0, 0, w, h, corner, corner0, offset, glScale);

    if (tile) tiles.push(tile);
    tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 0, 1, w, h, corner, corner0, offset, glScale);
    if (tile) tiles.push(tile);
    tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 1, 0, w, h, corner, corner0, offset, glScale);
    if (tile) tiles.push(tile);
    tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 1, 1, w, h, corner, corner0, offset, glScale);
    if (tile) tiles.push(tile);
  };

  _proto2._checkAndAddTile = function _checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, i, j, w, h, corner, corner0, offset, glScale) {
    var tileId = this._getTileId(idx + i, idy + j, z);

    if (this._visitedTiles && this._visitedTiles.has(tileId)) {
      return null;
    }

    var yOrder = this._getTileConfig().tileSystem.scale.y;

    var childExtent = new PointExtent(corner.x + i * w, corner.y + yOrder * j * h, corner.x + (i + 1) * w, corner.y + yOrder * (j + 1) * h);

    if (!this._isSplittedTileInExtent(frustumMatrix, childExtent, glScale)) {
      return null;
    }

    var hasOffset = offset[0] || offset[1];
    var tileInfo = renderer && renderer.isTileCachedOrLoading(tileId);

    if (!tileInfo) {
      tileInfo = {
        'point0': corner0.add(i * w, Math.max(yOrder * j * h, yOrder * (j + 1) * h)),
        'point': new Point(childExtent.xmin, childExtent.ymax),
        'z': z,
        'x': x + i,
        'y': y + j,
        'extent2d': childExtent,
        'size': [w, h],
        'id': tileId,
        'dupKey': tileId,
        'layer': this.getId(),
        'url': this.getTileUrl(x + i, y + j, z + this.options['zoomOffset'])
      };
    } else {
      tileInfo = tileInfo.info;
    }

    if (hasOffset) {
      tileInfo.extent2d = childExtent;

      tileInfo.extent2d._add(offset);

      tileInfo.point.set(childExtent.xmin, childExtent.ymax)._add(offset);
    }

    return tileInfo;
  };

  _proto2._getTileOffset = function _getTileOffset(z) {
    var map = this.getMap();

    var scale = map._getResolution() / map._getResolution(z);

    var offset = this.options['offset'];

    if (isFunction(offset)) {
      offset = offset(this);
    }

    offset[0] *= scale;
    offset[1] *= scale;
    return offset;
  };

  _proto2._getTileId = function _getTileId(x, y, zoom, id) {
    return (id || this.getId()) + "_" + y + "_" + x + "_" + zoom;
  };

  _proto2._project = function _project(pcoord, out) {
    if (this._hasOwnSR) {
      var map = this.getMap();
      var mapProjection = map.getProjection();
      var projection = this.getSpatialReference().getProjection();
      return projection.project(mapProjection.unproject(pcoord, out), out);
    } else {
      return pcoord;
    }
  };

  _proto2._unproject = function _unproject(pcoord, out) {
    if (this._hasOwnSR) {
      var map = this.getMap();
      var sr = this.getSpatialReference();
      var mapProjection = map.getProjection();
      var projection = sr.getProjection();
      return mapProjection.project(projection.unproject(pcoord, out), out);
    } else {
      return pcoord;
    }
  };

  _proto2._initTileConfig = function _initTileConfig() {
    var map = this.getMap(),
        tileSize = this.getTileSize();
    var sr = this.getSpatialReference();
    var projection = sr.getProjection(),
        fullExtent = sr.getFullExtent();
    this._defaultTileConfig = new TileConfig(map, TileSystem.getDefault(projection), fullExtent, tileSize);

    if (this.options['tileSystem']) {
      this._tileConfig = new TileConfig(map, this.options['tileSystem'], fullExtent, tileSize);
    }

    if (map && !this._tileConfig && map.getSpatialReference() === sr && map.getBaseLayer() && map.getBaseLayer() !== this && map.getBaseLayer()._getTileConfig) {
      var base = map.getBaseLayer()._getTileConfig();

      this._tileConfig = new TileConfig(map, base.tileSystem, base.fullExtent, tileSize);
    }

    this._hasOwnSR = sr !== map.getSpatialReference();
  };

  _proto2._getTileConfig = function _getTileConfig() {
    if (!this._defaultTileConfig) {
      this._initTileConfig();
    }

    return this._tileConfig || this._defaultTileConfig;
  };

  _proto2._bindMap = function _bindMap(map) {
    var baseLayer = map.getBaseLayer();

    if (baseLayer === this) {
      if (!baseLayer.options.hasOwnProperty('forceRenderOnMoving')) {
        this.config({
          'forceRenderOnMoving': true
        });
      }
    }

    return _Layer.prototype._bindMap.apply(this, arguments);
  };

  _proto2._isTileInExtent = function _isTileInExtent(frustumMatrix, tileExtent, glScale) {
    var map = this.getMap();
    var matrix;

    if (frustumMatrix !== map.projViewMatrix) {
      var tileCenter = tileExtent.getCenter(TEMP_POINT6)._multi(glScale);

      set$2(ARR3, tileCenter.x, tileCenter.y, 0);
      var ndc = transformMat4(ARR3, ARR3, map.projViewMatrix);
      matrix = ndc[1] < 0 ? map.projViewMatrix : frustumMatrix;
    } else {
      matrix = map.projViewMatrix;
    }

    TILE_BOX[0][0] = tileExtent.xmin * glScale;
    TILE_BOX[0][1] = tileExtent.ymin * glScale;
    TILE_BOX[1][0] = tileExtent.xmax * glScale;
    TILE_BOX[1][1] = tileExtent.ymax * glScale;
    return intersectsBox(matrix, TILE_BOX);
  };

  _proto2._isSplittedTileInExtent = function _isSplittedTileInExtent(frustumMatrix, tileExtent, glScale) {
    var map = this.getMap();
    TILE_BOX[0][0] = tileExtent.xmin * glScale;
    TILE_BOX[0][1] = tileExtent.ymin * glScale;
    TILE_BOX[1][0] = tileExtent.xmax * glScale;
    TILE_BOX[1][1] = tileExtent.ymax * glScale;
    return intersectsBox(map.projViewMatrix, TILE_BOX);
  };

  _proto2.getEvents = function getEvents() {
    return {
      'spatialreferencechange': this._onSpatialReferenceChange
    };
  };

  _proto2._onSpatialReferenceChange = function _onSpatialReferenceChange() {
    delete this._tileConfig;
    delete this._defaultTileConfig;
    delete this._sr;
    var renderer = this.getRenderer();

    if (renderer) {
      renderer.clear();
    }
  };

  return TileLayer;
}(Layer);

TileLayer.registerJSONType('TileLayer');
TileLayer.mergeOptions(options$u);

var GroupTileLayer = function (_TileLayer) {
  _inheritsLoose(GroupTileLayer, _TileLayer);

  GroupTileLayer.fromJSON = function fromJSON(layerJSON) {
    if (!layerJSON || layerJSON['type'] !== 'GroupTileLayer') {
      return null;
    }

    var layers = layerJSON['layers'].map(function (json) {
      return Layer.fromJSON(json);
    });
    return new GroupTileLayer(layerJSON['id'], layers, layerJSON['options']);
  };

  function GroupTileLayer(id, layers, options) {
    var _this;

    _this = _TileLayer.call(this, id, options) || this;
    _this.layers = layers || [];

    _this._checkChildren();

    _this.layerMap = {};
    _this._groupChildren = [];
    return _this;
  }

  var _proto = GroupTileLayer.prototype;

  _proto.getLayers = function getLayers() {
    return this.layers;
  };

  _proto.toJSON = function toJSON() {
    var profile = {
      'type': this.getJSONType(),
      'id': this.getId(),
      'layers': this.layers.map(function (layer) {
        return layer.toJSON();
      }),
      'options': this.config()
    };
    return profile;
  };

  _proto.getTiles = function getTiles(z) {
    var layers = this.layers;
    var tiles = [];
    var count = 0;

    for (var i = 0, l = layers.length; i < l; i++) {
      var layer = layers[i];

      if (!layer.options['visible']) {
        continue;
      }

      var childGrid = layer.getTiles(z, this);

      if (!childGrid || childGrid.count === 0) {
        continue;
      }

      count += childGrid.count;
      pushIn(tiles, childGrid.tileGrids);
    }

    return {
      count: count,
      tileGrids: tiles
    };
  };

  _proto.onAdd = function onAdd() {
    var _this2 = this;

    var map = this.getMap();
    this.layers.forEach(function (layer) {
      _this2.layerMap[layer.getId()] = layer;

      if (layer.getChildLayer) {
        _this2._groupChildren.push(layer);
      }

      layer._bindMap(map);

      layer.on('show hide', _this2._onLayerShowHide, _this2);
    });

    _TileLayer.prototype.onAdd.call(this);
  };

  _proto.onRemove = function onRemove() {
    var _this3 = this;

    this.layers.forEach(function (layer) {
      layer._doRemove();

      layer.off('show hide', _this3._onLayerShowHide, _this3);
    });
    this.layerMap = {};
    this._groupChildren = [];

    _TileLayer.prototype.onRemove.call(this);
  };

  _proto.getChildLayer = function getChildLayer(id) {
    var layer = this.layerMap[id];

    if (layer) {
      return layer;
    }

    for (var i = 0; i < this._groupChildren.length; i++) {
      var child = this._groupChildren[i].getChildLayer(id);

      if (child) {
        return child;
      }
    }

    return null;
  };

  _proto._onLayerShowHide = function _onLayerShowHide() {
    var renderer = this.getRenderer();

    if (renderer) {
      renderer.setToRedraw();
    }
  };

  _proto.isVisible = function isVisible() {
    if (!_TileLayer.prototype.isVisible.call(this)) {
      return false;
    }

    var children = this.layers;

    for (var i = 0, l = children.length; i < l; i++) {
      if (children[i].isVisible()) {
        return true;
      }
    }

    return false;
  };

  _proto._checkChildren = function _checkChildren() {
    var _this4 = this;

    var ids = {};
    this.layers.forEach(function (layer) {
      var layerId = layer.getId();

      if (ids[layerId]) {
        throw new Error("Duplicate child layer id (" + layerId + ") in the GroupTileLayer (" + _this4.getId() + ")");
      } else {
        ids[layerId] = 1;
      }
    });
  };

  return GroupTileLayer;
}(TileLayer);

GroupTileLayer.registerJSONType('GroupTileLayer');

var options$v = {
  crs: null,
  uppercase: false,
  detectRetina: false
};
var defaultWmsParams = {
  service: 'WMS',
  request: 'GetMap',
  layers: '',
  styles: '',
  format: 'image/jpeg',
  transparent: false,
  version: '1.1.1'
};

var WMSTileLayer = function (_TileLayer) {
  _inheritsLoose(WMSTileLayer, _TileLayer);

  function WMSTileLayer(id, options) {
    var _this;

    _this = _TileLayer.call(this, id) || this;
    var wmsParams = extend({}, defaultWmsParams);

    for (var p in options) {
      if (!(p in _this.options)) {
        wmsParams[p] = options[p];
      }
    }

    _this.setOptions(options);

    _this.setZIndex(options.zIndex);

    var tileSize = _this.getTileSize();

    wmsParams.width = tileSize.width;
    wmsParams.height = tileSize.height;
    _this.wmsParams = wmsParams;
    _this._wmsVersion = parseFloat(wmsParams.version);
    return _this;
  }

  var _proto = WMSTileLayer.prototype;

  _proto.onAdd = function onAdd() {
    var dpr = this.getMap().getDevicePixelRatio();
    var r = options$v.detectRetina ? dpr : 1;
    this.wmsParams.width *= r;
    this.wmsParams.height *= r;
    var crs = this.options.crs || this.getMap().getProjection().code;
    var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
    this.wmsParams[projectionKey] = crs;

    _TileLayer.prototype.onAdd.call(this);
  };

  _proto.getTileUrl = function getTileUrl(x, y, z) {
    var res = this.getSpatialReference().getResolution(z),
        tileConfig = this._getTileConfig(),
        tileExtent = tileConfig.getTilePrjExtent(x, y, res);

    var max = tileExtent.getMax(),
        min = tileExtent.getMin();
    var bbox = (this._wmsVersion >= 1.3 && this.wmsParams.crs === 'EPSG:4326' ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(',');

    var url = _TileLayer.prototype.getTileUrl.call(this, x, y, z);

    return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
  };

  _proto.toJSON = function toJSON() {
    return {
      'type': 'WMSTileLayer',
      'id': this.getId(),
      'options': this.config()
    };
  };

  WMSTileLayer.fromJSON = function fromJSON(layerJSON) {
    if (!layerJSON || layerJSON['type'] !== 'WMSTileLayer') {
      return null;
    }

    return new WMSTileLayer(layerJSON['id'], layerJSON['options']);
  };

  return WMSTileLayer;
}(TileLayer);

WMSTileLayer.registerJSONType('WMSTileLayer');
WMSTileLayer.mergeOptions(options$v);
function getParamString(obj, existingUrl, uppercase) {
  var params = [];

  for (var i in obj) {
    params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
  }

  return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
}

var CanvasTileLayer = function (_TileLayer) {
  _inheritsLoose(CanvasTileLayer, _TileLayer);

  function CanvasTileLayer(id, options) {
    var _this;

    _this = _TileLayer.call(this, id, options) || this;

    if (!_this.options.hasOwnProperty('forceRenderOnMoving')) {
      _this.options['forceRenderOnMoving'] = false;
    }

    return _this;
  }

  var _proto = CanvasTileLayer.prototype;

  _proto.drawTile = function drawTile() {};

  _proto.toJSON = function toJSON() {
    return {
      'type': 'CanvasTileLayer',
      'id': this.getId(),
      'options': this.config()
    };
  };

  CanvasTileLayer.fromJSON = function fromJSON(layerJSON) {
    if (!layerJSON || layerJSON['type'] !== 'CanvasTileLayer') {
      return null;
    }

    return new CanvasTileLayer(layerJSON['id'], layerJSON['options']);
  };

  return CanvasTileLayer;
}(TileLayer);

CanvasTileLayer.registerJSONType('CanvasTileLayer');

function createGLContext(canvas, options) {
  var attributes = {
    'alpha': true,
    'stencil': true,
    'preserveDrawingBuffer': true,
    'antialias': false
  };
  var names = ['webgl', 'experimental-webgl'];
  var context = null;

  for (var i = 0; i < names.length; ++i) {
    try {
      context = canvas.getContext(names[i], options || attributes);
    } catch (e) {}

    if (context) {
      break;
    }
  }

  return context;
}
function compileShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (!compiled) {
    var error = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw new Error('Failed to compile shader: ' + error);
  }

  return shader;
}
function createProgram(gl, vert, frag) {
  var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vert);
  var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, frag);

  if (!vertexShader || !fragmentShader) {
    return null;
  }

  var program = gl.createProgram();

  if (!program) {
    return null;
  }

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  return {
    program: program,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader
  };
}
function enableVertexAttrib(gl, program, attributes) {
  if (Array.isArray(attributes[0])) {
    var FSIZE = Float32Array.BYTES_PER_ELEMENT;
    var STRIDE = 0;

    for (var i = 0; i < attributes.length; i++) {
      STRIDE += attributes[i][1] || 0;
    }

    var offset = 0;

    for (var _i = 0; _i < attributes.length; _i++) {
      var attr = gl.getAttribLocation(program, attributes[_i][0]);

      if (attr < 0) {
        throw new Error('Failed to get the storage location of ' + attributes[_i][0]);
      }

      gl.vertexAttribPointer(attr, attributes[_i][1], gl[attributes[_i][2] || 'FLOAT'], false, FSIZE * STRIDE, FSIZE * offset);
      offset += attributes[_i][1] || 0;
      gl.enableVertexAttribArray(attr);
    }
  } else {
    var _attr = gl.getAttribLocation(program, attributes[0]);

    gl.vertexAttribPointer(_attr, attributes[1], gl[attributes[2] || 'FLOAT'], false, 0, 0);
    gl.enableVertexAttribArray(_attr);
  }
}

var shaders = {
  'vertexShader': "\n        attribute vec2 a_position;\n\n        attribute vec2 a_texCoord;\n\n        uniform mat4 u_matrix;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            gl_Position = u_matrix * vec4(a_position, 0., 1.);\n\n            v_texCoord = a_texCoord;\n        }\n    ",
  'fragmentShader': "\n        precision mediump float;\n\n        uniform sampler2D u_image;\n\n        uniform float u_opacity;\n        uniform float u_debug_line;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            if (u_debug_line == 1.) {\n                gl_FragColor = vec4(0., 1., 0., 1.);\n            } else {\n                gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n            }\n        }\n    "
};
var v2 = [0, 0],
    v3 = [0, 0, 0],
    arr16 = new Array(16);
var DEBUG_POINT = new Point(20, 20);

var ImageGLRenderable = function ImageGLRenderable(Base) {
  var renderable = function (_Base) {
    _inheritsLoose(renderable, _Base);

    function renderable() {
      return _Base.apply(this, arguments) || this;
    }

    var _proto = renderable.prototype;

    _proto.drawGLImage = function drawGLImage(image, x, y, w, h, scale$$1, opacity, debug) {
      if (this.gl.program !== this.program) {
        this.useProgram(this.program);
      }

      var gl = this.gl;
      this.loadTexture(image);
      v3[0] = x || 0;
      v3[1] = y || 0;
      var uMatrix = identity(arr16);
      translate(uMatrix, uMatrix, v3);
      scale(uMatrix, uMatrix, [scale$$1, scale$$1, 1]);
      multiply(uMatrix, this.getMap().projViewMatrix, uMatrix);
      gl.uniformMatrix4fv(this.program['u_matrix'], false, uMatrix);
      gl.uniform1f(this.program['u_opacity'], opacity);
      gl.uniform1f(this.program['u_debug_line'], 0);
      var glBuffer = image.glBuffer;

      if (glBuffer && (glBuffer.width !== w || glBuffer.height !== h)) {
        this.saveImageBuffer(glBuffer);
        delete image.glBuffer;
      }

      if (!image.glBuffer) {
        image.glBuffer = this.bufferTileData(0, 0, w, h);
      } else {
        gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
      }

      v2[0] = 'a_position';
      v2[1] = 2;
      v2[2] = image.glBuffer.type;
      this.enableVertexAttrib(v2);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      if (debug) {
        this.drawDebug(uMatrix, v2, 0, 0, w, h, debug);
      }
    };

    _proto.drawDebug = function drawDebug(uMatrix, attrib, x, y, w, h, debugInfo) {
      var gl = this.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, this._debugBuffer);
      this.enableVertexAttrib(['a_position', 2, 'FLOAT']);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x, y, x + w, y, x + w, y - h, x, y - h, x, y]), gl.DYNAMIC_DRAW);
      gl.uniformMatrix4fv(this.program['u_matrix'], false, uMatrix);
      gl.uniform1f(this.program['u_debug_line'], 1);
      gl.drawArrays(gl.LINE_STRIP, 0, 5);
      var canvas = this._debugInfoCanvas;

      if (!canvas) {
        var dpr = this.getMap().getDevicePixelRatio() > 1 ? 2 : 1;
        canvas = this._debugInfoCanvas = document.createElement('canvas');
        canvas.width = 256 * dpr;
        canvas.height = 32 * dpr;

        var _ctx = canvas.getContext('2d');

        _ctx.font = '20px monospace';

        _ctx.scale(dpr, dpr);
      }

      var ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      var color = this.layer.options['debugOutline'];
      Canvas.fillText(ctx, debugInfo, DEBUG_POINT, color);
      this.loadTexture(canvas);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      w = 256;
      h = 32;
      var x1 = x;
      var x2 = x + w;
      var y1 = y;
      var y2 = y - h;
      gl.bufferData(gl.ARRAY_BUFFER, this.set8(x1, y1, x1, y2, x2, y1, x2, y2), gl.DYNAMIC_DRAW);
      gl.uniform1f(this.program['u_debug_line'], 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };

    _proto.bufferTileData = function bufferTileData(x, y, w, h, buffer) {
      var x1 = x;
      var x2 = x + w;
      var y1 = y;
      var y2 = y - h;
      var data;

      if (isInteger(x1) && isInteger(x2) && isInteger(y1) && isInteger(y2)) {
        data = this.set8Int(x1, y1, x1, y2, x2, y1, x2, y2);
      } else {
        data = this.set8(x1, y1, x1, y2, x2, y1, x2, y2);
      }

      var glBuffer = this.loadImageBuffer(data, buffer);
      glBuffer.width = w;
      glBuffer.height = h;
      glBuffer.type = data instanceof Int16Array ? 'SHORT' : 'FLOAT';
      return glBuffer;
    };

    _proto.drawTinImage = function drawTinImage(image, vertices, texCoords, indices, opacity) {
      var gl = this.gl;
      this.loadTexture(image);
      gl.uniformMatrix4fv(this.program['u_matrix'], false, this.getMap().projViewMatrix);
      gl.uniform1f(this.program['u_opacity'], opacity);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
      this.enableVertexAttrib(['a_position', 3]);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
      this.enableVertexAttrib(['a_texCoord', 2]);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.DYNAMIC_DRAW);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.DYNAMIC_DRAW);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    };

    _proto.createCanvas2 = function createCanvas2() {
      this.canvas2 = Canvas.createCanvas(this.canvas.width, this.canvas.height);
    };

    _proto.createGLContext = function createGLContext$$1() {
      if (this.canvas.gl && this.canvas.gl.wrap) {
        this.gl = this.canvas.gl.wrap();
      } else {
        this.gl = createGLContext(this.canvas2 || this.canvas, this.layer.options['glOptions']);
      }

      var gl = this.gl;
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.STENCIL_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      this.program = this.createProgram(shaders['vertexShader'], this.layer.options['fragmentShader'] || shaders['fragmentShader'], ['u_matrix', 'u_image', 'u_opacity', 'u_debug_line']);
      this._debugBuffer = this.createBuffer();
      this.useProgram(this.program);
      this.texBuffer = this.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
      this.enableVertexAttrib(['a_texCoord', 2, 'UNSIGNED_BYTE']);
      gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array([0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
      this.enableSampler('u_image');
      gl.activeTexture(gl['TEXTURE0']);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    };

    _proto.resizeGLCanvas = function resizeGLCanvas() {
      if (this.gl) {
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      }

      if (!this.canvas2) {
        return;
      }

      if (this.canvas2.width !== this.canvas.width || this.canvas2.height !== this.canvas.height) {
        this.canvas2.width = this.canvas.width;
        this.canvas2.height = this.canvas.height;
      }
    };

    _proto.clearGLCanvas = function clearGLCanvas() {
      if (this.gl) {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT);
      }
    };

    _proto.disposeImage = function disposeImage(image) {
      if (!image) {
        return;
      }

      if (image.texture) {
        this.saveTexture(image.texture);
      }

      if (image.glBuffer) {
        this.saveImageBuffer(image.glBuffer);
      }

      delete image.texture;
      delete image.glBuffer;
    };

    _proto._createTexture = function _createTexture(image) {
      var gl = this.gl;
      var texture = this.getTexture() || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

      if (isInteger(log2(image.width)) && isInteger(log2(image.width))) {
        gl.generateMipmap(gl.TEXTURE_2D);
      }

      return texture;
    };

    _proto.getTexture = function getTexture() {
      if (!this._textures) {
        this._textures = [];
      }

      var textures = this._textures;
      return textures && textures.length > 0 ? textures.pop() : null;
    };

    _proto.saveTexture = function saveTexture(texture) {
      this._textures.push(texture);
    };

    _proto.loadTexture = function loadTexture(image) {
      var gl = this.gl;
      var texture = image.texture;

      if (!texture) {
        texture = this._createTexture(image);
        image.texture = texture;
      }

      gl.bindTexture(gl.TEXTURE_2D, texture);
      return texture;
    };

    _proto.getImageBuffer = function getImageBuffer() {
      if (!this._imageBuffers) {
        this._imageBuffers = [];
      }

      var imageBuffers = this._imageBuffers;
      return imageBuffers && imageBuffers.length > 0 ? imageBuffers.pop() : null;
    };

    _proto.saveImageBuffer = function saveImageBuffer(buffer) {
      this._imageBuffers.push(buffer);
    };

    _proto.loadImageBuffer = function loadImageBuffer(data, glBuffer) {
      var gl = this.gl;
      var buffer = glBuffer || this.createImageBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
      return buffer;
    };

    _proto.createImageBuffer = function createImageBuffer() {
      return this.getImageBuffer() || this.createBuffer();
    };

    _proto.removeGLCanvas = function removeGLCanvas() {
      var gl = this.gl;

      if (!gl) {
        return;
      }

      if (this._debugBuffer) {
        gl.deleteBuffer(this._debugBuffer);
        delete this._debugBuffer;
      }

      if (this._buffers) {
        this._buffers.forEach(function (b) {
          gl.deleteBuffer(b);
        });

        delete this._buffers;
      }

      if (this._textures) {
        this._textures.forEach(function (t) {
          return gl.deleteTexture(t);
        });

        delete this._textures;
      }

      if (this._debugInfoCanvas) {
        var texture = this._debugInfoCanvas.texture;

        if (texture) {
          gl.deleteTexture(texture);
        }

        delete this._debugInfoCanvas.texture;
        delete this._debugInfoCanvas;
      }

      var program = gl.program;
      gl.deleteShader(program.fragmentShader);
      gl.deleteShader(program.vertexShader);
      gl.deleteProgram(program);
      delete this.gl;
      delete this.canvas2;
    };

    _proto.createBuffer = function createBuffer() {
      var gl = this.gl;
      var buffer = gl.createBuffer();

      if (!buffer) {
        throw new Error('Failed to create the buffer object');
      }

      if (!this._buffers) {
        this._buffers = [];
      }

      this._buffers.push(buffer);

      return buffer;
    };

    _proto.enableVertexAttrib = function enableVertexAttrib$$1(attributes) {
      enableVertexAttrib(this.gl, this.gl.program, attributes);
    };

    _proto.createProgram = function createProgram$$1(vert, frag, uniforms) {
      var gl = this.gl;

      var _createProgram2 = createProgram(gl, vert, frag),
          program = _createProgram2.program,
          vertexShader = _createProgram2.vertexShader,
          fragmentShader = _createProgram2.fragmentShader;

      program.vertexShader = vertexShader;
      program.fragmentShader = fragmentShader;

      this._initUniforms(program, uniforms);

      return program;
    };

    _proto.useProgram = function useProgram(program) {
      var gl = this.gl;
      gl.useProgram(program);
      gl.program = program;
      return this;
    };

    _proto.enableSampler = function enableSampler(sampler, texIdx) {
      var gl = this.gl;

      var uSampler = this._getUniform(gl.program, sampler);

      if (!texIdx) {
        texIdx = 0;
      }

      gl.uniform1i(uSampler, texIdx);
      return uSampler;
    };

    _proto._initUniforms = function _initUniforms(program, uniforms) {
      for (var i = 0; i < uniforms.length; i++) {
        var name = uniforms[i];
        var uniform = uniforms[i];
        var b = name.indexOf('[');

        if (b >= 0) {
          name = name.substring(0, b);

          if (!IS_NODE) {
            uniform = uniform.substring(0, b);
          }
        }

        program[name] = this._getUniform(program, uniform);
      }
    };

    _proto._getUniform = function _getUniform(program, uniformName) {
      var gl = this.gl;
      var uniform = gl.getUniformLocation(program, uniformName);

      if (!uniform) {
        throw new Error('Failed to get the storage location of ' + uniformName);
      }

      return uniform;
    };

    return renderable;
  }(Base);

  extend(renderable.prototype, {
    set8: function () {
      var out = Browser$1.ie9 ? null : new Float32Array(8);
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        out[0] = a0;
        out[1] = a1;
        out[2] = a2;
        out[3] = a3;
        out[4] = a4;
        out[5] = a5;
        out[6] = a6;
        out[7] = a7;
        return out;
      };
    }(),
    set8Int: function () {
      var out = Browser$1.ie9 ? null : new Int16Array(8);
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        out[0] = a0;
        out[1] = a1;
        out[2] = a2;
        out[3] = a3;
        out[4] = a4;
        out[5] = a5;
        out[6] = a6;
        out[7] = a7;
        return out;
      };
    }()
  });
  return renderable;
};

var options$w = {
  renderer: Browser$1.webgl ? 'gl' : 'canvas',
  crossOrigin: null
};
var TEMP_POINT$1 = new Point(0, 0);

var ImageLayer = function (_Layer) {
  _inheritsLoose(ImageLayer, _Layer);

  function ImageLayer(id, images, options) {
    var _this;

    if (images && !Array.isArray(images) && !images.url) {
      options = images;
      images = null;
    }

    _this = _Layer.call(this, id, options) || this;
    _this._images = images;
    return _this;
  }

  var _proto = ImageLayer.prototype;

  _proto.onAdd = function onAdd() {
    this._prepareImages(this._images);
  };

  _proto.setImages = function setImages(images) {
    this._images = images;

    this._prepareImages(images);

    return this;
  };

  _proto.getImages = function getImages() {
    return this._images;
  };

  _proto._prepareImages = function _prepareImages(images) {
    images = images || [];

    if (!Array.isArray(images)) {
      images = [images];
    }

    var map = this.getMap();
    this._imageData = images.map(function (img) {
      var extent = new Extent(img.extent);
      return extend({}, img, {
        extent: extent,
        extent2d: extent.convertTo(function (c) {
          return map.coordToPoint(c, map.getGLZoom());
        })
      });
    });
    this._images = images;
    var renderer = this.getRenderer();

    if (renderer) {
      renderer.refreshImages();
    }
  };

  return ImageLayer;
}(Layer);

ImageLayer.mergeOptions(options$w);
var EMPTY_ARRAY = [];
var ImageLayerCanvasRenderer = function (_CanvasRenderer) {
  _inheritsLoose(ImageLayerCanvasRenderer, _CanvasRenderer);

  function ImageLayerCanvasRenderer() {
    return _CanvasRenderer.apply(this, arguments) || this;
  }

  var _proto2 = ImageLayerCanvasRenderer.prototype;

  _proto2.isDrawable = function isDrawable() {
    if (this.getMap().getPitch()) {
      if (console) {
        console.warn('ImageLayer with canvas renderer can\'t be pitched, use gl renderer (\'renderer\' : \'gl\') instead.');
      }

      return false;
    }

    return true;
  };

  _proto2.checkResources = function checkResources() {
    var _this2 = this;

    if (this._imageLoaded) {
      return EMPTY_ARRAY;
    }

    var layer = this.layer;

    var urls = layer._imageData.map(function (img) {
      return [img.url, null, null];
    });

    if (this.resources) {
      var unloaded = [];
      var resources = new ResourceCache();
      urls.forEach(function (url) {
        if (_this2.resources.isResourceLoaded(url)) {
          var img = _this2.resources.getImage(url);

          resources.addResource(url, img);
        } else {
          unloaded.push(url);
        }
      });
      this.resources.forEach(function (url, res) {
        if (!resources.isResourceLoaded(url)) {
          _this2.retireImage(res.image);
        }
      });
      this.resources = resources;
      urls = unloaded;
    }

    this._imageLoaded = true;
    return urls;
  };

  _proto2.retireImage = function retireImage() {};

  _proto2.refreshImages = function refreshImages() {
    this._imageLoaded = false;
    this.setToRedraw();
  };

  _proto2.needToRedraw = function needToRedraw() {
    var map = this.getMap();

    if (map.isZooming() && !map.getPitch()) {
      return false;
    }

    return _CanvasRenderer.prototype.needToRedraw.call(this);
  };

  _proto2.draw = function draw() {
    if (!this.isDrawable()) {
      return;
    }

    this.prepareCanvas();
    this._painted = false;

    this._drawImages();

    this.completeRender();
  };

  _proto2._drawImages = function _drawImages() {
    var imgData = this.layer._imageData;
    var map = this.getMap();

    var mapExtent = map._get2DExtent(map.getGLZoom());

    if (imgData && imgData.length) {
      for (var i = 0; i < imgData.length; i++) {
        var extent = imgData[i].extent2d;
        var image = this.resources && this.resources.getImage(imgData[i].url);

        if (image && mapExtent.intersects(extent)) {
          this._painted = true;

          this._drawImage(image, extent, imgData[i].opacity || 1);
        }
      }
    }
  };

  _proto2._drawImage = function _drawImage(image, extent, opacity) {
    var globalAlpha = 0;
    var ctx = this.context;

    if (opacity < 1) {
      globalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = opacity;
    }

    var map = this.getMap();
    var nw = TEMP_POINT$1.set(extent.xmin, extent.ymax);

    var point = map._pointToContainerPoint(nw, map.getGLZoom());

    var x = point.x,
        y = point.y;
    var bearing = map.getBearing();

    if (bearing) {
      ctx.save();
      ctx.translate(x, y);

      if (bearing) {
        ctx.rotate(-bearing * Math.PI / 180);
      }

      x = y = 0;
    }

    var scale = map.getGLScale();
    ctx.drawImage(image, x, y, extent.getWidth() / scale, extent.getHeight() / scale);

    if (bearing) {
      ctx.restore();
    }

    if (globalAlpha) {
      ctx.globalAlpha = globalAlpha;
    }
  };

  _proto2.drawOnInteracting = function drawOnInteracting() {
    this.draw();
  };

  return ImageLayerCanvasRenderer;
}(CanvasRenderer);
var ImageLayerGLRenderer = function (_ImageGLRenderable) {
  _inheritsLoose(ImageLayerGLRenderer, _ImageGLRenderable);

  function ImageLayerGLRenderer() {
    return _ImageGLRenderable.apply(this, arguments) || this;
  }

  var _proto3 = ImageLayerGLRenderer.prototype;

  _proto3.isDrawable = function isDrawable() {
    return true;
  };

  _proto3._drawImage = function _drawImage(image, extent, opacity) {
    this.drawGLImage(image, extent.xmin, extent.ymax, extent.getWidth(), extent.getHeight(), 1, opacity);
  };

  _proto3.createContext = function createContext() {
    this.createGLContext();
  };

  _proto3.resizeCanvas = function resizeCanvas(canvasSize) {
    if (!this.canvas) {
      return;
    }

    _ImageGLRenderable.prototype.resizeCanvas.call(this, canvasSize);

    this.resizeGLCanvas();
  };

  _proto3.clearCanvas = function clearCanvas() {
    if (!this.canvas) {
      return;
    }

    _ImageGLRenderable.prototype.clearCanvas.call(this);

    this.clearGLCanvas();
  };

  _proto3.retireImage = function retireImage(image) {
    this.disposeImage(image);
  };

  _proto3.onRemove = function onRemove() {
    this.removeGLCanvas();

    _ImageGLRenderable.prototype.onRemove.call(this);
  };

  return ImageLayerGLRenderer;
}(ImageGLRenderable(ImageLayerCanvasRenderer));
ImageLayer.registerRenderer('canvas', ImageLayerCanvasRenderer);
ImageLayer.registerRenderer('gl', ImageLayerGLRenderer);

var CanvasLayerRenderer = function (_CanvasRenderer) {
  _inheritsLoose(CanvasLayerRenderer, _CanvasRenderer);

  function CanvasLayerRenderer() {
    return _CanvasRenderer.apply(this, arguments) || this;
  }

  var _proto = CanvasLayerRenderer.prototype;

  _proto.getPrepareParams = function getPrepareParams() {
    return [];
  };

  _proto.getDrawParams = function getDrawParams() {
    return [];
  };

  _proto.onCanvasCreate = function onCanvasCreate() {
    if (this.canvas && this.layer.options['doubleBuffer']) {
      this.buffer = Canvas.createCanvas(this.canvas.width, this.canvas.height, this.getMap().CanvasClass);
    }
  };

  _proto.needToRedraw = function needToRedraw() {
    if (this.layer.options['animation']) {
      return true;
    }

    var map = this.getMap();

    if (map.isInteracting() && !this.layer.drawOnInteracting) {
      return false;
    }

    return _CanvasRenderer.prototype.needToRedraw.call(this);
  };

  _proto.draw = function draw() {
    this.prepareCanvas();
    this.prepareDrawContext();

    this._drawLayer();
  };

  _proto.drawOnInteracting = function drawOnInteracting() {
    this._drawLayerOnInteracting();
  };

  _proto.getCanvasImage = function getCanvasImage() {
    var canvasImg = _CanvasRenderer.prototype.getCanvasImage.call(this);

    if (canvasImg && canvasImg.image && this.layer.options['doubleBuffer']) {
      var canvas = canvasImg.image;

      if (this.buffer.width !== canvas.width || this.buffer.height !== canvas.height) {
        this.buffer.width = canvas.width;
        this.buffer.height = canvas.height;
      }

      var bufferContext = this.buffer.getContext('2d');
      var prevent = this.layer.doubleBuffer(bufferContext, this.context);

      if (prevent === undefined || prevent) {
        Canvas.image(bufferContext, canvas, 0, 0);
        canvasImg.image = this.buffer;
      }
    }

    return canvasImg;
  };

  _proto.remove = function remove() {
    delete this._drawContext;
    return _CanvasRenderer.prototype.remove.call(this);
  };

  _proto.onZoomStart = function onZoomStart(param) {
    this.layer.onZoomStart(param);

    _CanvasRenderer.prototype.onZoomStart.call(this, param);
  };

  _proto.onZooming = function onZooming(param) {
    this.layer.onZooming(param);

    _CanvasRenderer.prototype.onZooming.call(this, param);
  };

  _proto.onZoomEnd = function onZoomEnd(param) {
    this.layer.onZoomEnd(param);

    _CanvasRenderer.prototype.onZoomEnd.call(this, param);
  };

  _proto.onMoveStart = function onMoveStart(param) {
    this.layer.onMoveStart(param);

    _CanvasRenderer.prototype.onMoveStart.call(this, param);
  };

  _proto.onMoving = function onMoving(param) {
    this.layer.onMoving(param);

    _CanvasRenderer.prototype.onMoving.call(this, param);
  };

  _proto.onMoveEnd = function onMoveEnd(param) {
    this.layer.onMoveEnd(param);

    _CanvasRenderer.prototype.onMoveEnd.call(this, param);
  };

  _proto.onResize = function onResize(param) {
    this.layer.onResize(param);

    _CanvasRenderer.prototype.onResize.call(this, param);
  };

  _proto.prepareDrawContext = function prepareDrawContext() {
    if (!this._predrawed) {
      var params = ensureParams(this.getPrepareParams());
      this._drawContext = this.layer.prepareToDraw.apply(this.layer, [this.context].concat(params));

      if (!this._drawContext) {
        this._drawContext = [];
      }

      if (!Array.isArray(this._drawContext)) {
        this._drawContext = [this._drawContext];
      }

      this._predrawed = true;
    }
  };

  _proto._prepareDrawParams = function _prepareDrawParams() {
    if (!this.getMap()) {
      return null;
    }

    var view = this.getViewExtent();

    if (view['maskExtent'] && !view['extent'].intersects(view['maskExtent'])) {
      this.completeRender();
      return null;
    }

    var args = [this.context, view];
    var params = ensureParams(this.getDrawParams());
    args.push.apply(args, params);
    args.push.apply(args, this._drawContext);
    return args;
  };

  _proto._drawLayer = function _drawLayer() {
    var args = this._prepareDrawParams();

    if (!args) {
      return;
    }

    this.layer.draw.apply(this.layer, args);
    this.completeRender();
  };

  _proto._drawLayerOnInteracting = function _drawLayerOnInteracting() {
    if (!this.layer.drawOnInteracting) {
      return;
    }

    var args = this._prepareDrawParams();

    if (!args) {
      return;
    }

    this.layer.drawOnInteracting.apply(this.layer, args);
    this.completeRender();
  };

  return CanvasLayerRenderer;
}(CanvasRenderer);

function ensureParams(params) {
  if (!params) {
    params = [];
  }

  if (!Array.isArray(params)) {
    params = [params];
  }

  return params;
}

var options$x = {
  'doubleBuffer': false,
  'animation': false
};

var CanvasLayer = function (_Layer) {
  _inheritsLoose(CanvasLayer, _Layer);

  function CanvasLayer() {
    return _Layer.apply(this, arguments) || this;
  }

  var _proto = CanvasLayer.prototype;

  _proto.isCanvasRender = function isCanvasRender() {
    return true;
  };

  _proto.prepareToDraw = function prepareToDraw() {};

  _proto.draw = function draw() {};

  _proto.redraw = function redraw() {
    if (this._getRenderer()) {
      this._getRenderer().setToRedraw();
    }

    return this;
  };

  _proto.play = function play() {
    this.config('animation', true);
    return this;
  };

  _proto.pause = function pause() {
    this.config('animation', false);
    return this;
  };

  _proto.isPlaying = function isPlaying() {
    return this.options['animation'];
  };

  _proto.clearCanvas = function clearCanvas() {
    if (this._getRenderer()) {
      this._getRenderer().clearCanvas();
    }

    return this;
  };

  _proto.requestMapToRender = function requestMapToRender() {
    if (this._getRenderer()) {
      this._getRenderer().requestMapToRender();
    }

    return this;
  };

  _proto.completeRender = function completeRender() {
    if (this._getRenderer()) {
      this._getRenderer().completeRender();
    }

    return this;
  };

  _proto.onCanvasCreate = function onCanvasCreate() {
    return this;
  };

  _proto.onZoomStart = function onZoomStart() {};

  _proto.onZooming = function onZooming() {};

  _proto.onZoomEnd = function onZoomEnd() {};

  _proto.onMoveStart = function onMoveStart() {};

  _proto.onMoving = function onMoving() {};

  _proto.onMoveEnd = function onMoveEnd() {};

  _proto.onResize = function onResize() {};

  _proto.doubleBuffer = function doubleBuffer(bufferContext) {
    bufferContext.clearRect(0, 0, bufferContext.canvas.width, bufferContext.canvas.height);
    return this;
  };

  return CanvasLayer;
}(Layer);

CanvasLayer.mergeOptions(options$x);
CanvasLayer.registerRenderer('canvas', CanvasLayerRenderer);

var TEMP_POINT$2 = new Point(0, 0);
var options$y = {
  'animation': true
};

var ParticleLayer = function (_CanvasLayer) {
  _inheritsLoose(ParticleLayer, _CanvasLayer);

  function ParticleLayer() {
    return _CanvasLayer.apply(this, arguments) || this;
  }

  var _proto = ParticleLayer.prototype;

  _proto.getParticles = function getParticles() {};

  _proto.draw = function draw(context, view) {
    var points = this.getParticles(now());

    if (!points || points.length === 0) {
      var renderer = this._getRenderer();

      if (renderer) {
        this._getRenderer()._shouldClear = true;
      }

      return;
    }

    var map = this.getMap();
    var extent = view.extent;

    if (view.maskExtent) {
      extent = view.extent.intersection(view.maskExtent);
    }

    extent = extent.convertTo(function (c) {
      return map._pointToContainerPoint(c, undefined, 0, TEMP_POINT$2);
    });
    var e = 2 * Math.PI;

    for (var i = 0, l = points.length; i < l; i++) {
      var pos = points[i].point;

      if (extent.contains(pos)) {
        var color = points[i].color || this.options['lineColor'] || '#fff',
            r = points[i].r;

        if (context.fillStyle !== color) {
          context.fillStyle = color;
        }

        if (r <= 2) {
          context.fillRect(pos.x - r / 2, pos.y - r / 2, r, r);
        } else {
          context.beginPath();
          context.arc(pos.x, pos.y, r / 2, 0, e);
          context.fill();
        }
      }
    }

    this._fillCanvas(context);
  };

  _proto._fillCanvas = function _fillCanvas(context) {
    var g = context.globalCompositeOperation;
    context.globalCompositeOperation = 'destination-out';
    var trail = this.options['trail'] || 30;
    context.fillStyle = 'rgba(0, 0, 0, ' + 1 / trail + ')';
    context.fillRect(0, 0, context.canvas.width, context.canvas.height);
    context.globalCompositeOperation = g;
  };

  return ParticleLayer;
}(CanvasLayer);

ParticleLayer.mergeOptions(options$y);
ParticleLayer.registerRenderer('canvas', function (_CanvasLayerRenderer) {
  _inheritsLoose(_class, _CanvasLayerRenderer);

  function _class() {
    return _CanvasLayerRenderer.apply(this, arguments) || this;
  }

  var _proto2 = _class.prototype;

  _proto2.draw = function draw() {
    if (!this.canvas || !this.layer.options['animation'] || this._shouldClear) {
      this.prepareCanvas();
      this._shouldClear = false;
    }

    this.prepareDrawContext();

    this._drawLayer();
  };

  _proto2.drawOnInteracting = function drawOnInteracting() {
    this.draw();
    this._shouldClear = false;
  };

  _proto2.onSkipDrawOnInteracting = function onSkipDrawOnInteracting() {
    this._shouldClear = true;
  };

  return _class;
}(CanvasLayerRenderer));

var EDIT_STAGE_LAYER_PREFIX = INTERNAL_LAYER_PREFIX + '_edit_stage_';

function createHandleSymbol(markerType, opacity) {
  return {
    'markerType': markerType,
    'markerFill': '#fff',
    'markerLineColor': '#000',
    'markerLineWidth': 2,
    'markerWidth': 10,
    'markerHeight': 10,
    'opacity': opacity
  };
}

var options$z = {
  'fixAspectRatio': false,
  'symbol': null,
  'removeVertexOn': 'contextmenu',
  'centerHandleSymbol': createHandleSymbol('ellipse', 1),
  'vertexHandleSymbol': createHandleSymbol('square', 1),
  'newVertexHandleSymbol': createHandleSymbol('square', 0.4)
};

var GeometryEditor = function (_Eventable) {
  _inheritsLoose(GeometryEditor, _Eventable);

  function GeometryEditor(geometry, opts) {
    var _this;

    _this = _Eventable.call(this, opts) || this;
    _this._geometry = geometry;

    if (!_this._geometry) {
      return _assertThisInitialized(_this);
    }

    return _this;
  }

  var _proto = GeometryEditor.prototype;

  _proto.getMap = function getMap() {
    return this._geometry.getMap();
  };

  _proto.prepare = function prepare() {
    var map = this.getMap();

    if (!map) {
      return;
    }

    if (this.options['symbol']) {
      this._originalSymbol = this._geometry.getSymbol();

      this._geometry.setSymbol(this.options['symbol']);
    }

    this._prepareEditStageLayer();
  };

  _proto._prepareEditStageLayer = function _prepareEditStageLayer() {
    var map = this.getMap();
    var uid = UID();
    var stageId = EDIT_STAGE_LAYER_PREFIX + uid,
        shadowId = EDIT_STAGE_LAYER_PREFIX + uid + '_shadow';
    this._editStageLayer = map.getLayer(stageId);
    this._shadowLayer = map.getLayer(shadowId);

    if (!this._editStageLayer) {
      this._editStageLayer = new VectorLayer(stageId);
      map.addLayer(this._editStageLayer);
    }

    if (!this._shadowLayer) {
      this._shadowLayer = new VectorLayer(shadowId);
      map.addLayer(this._shadowLayer);
    }
  };

  _proto.start = function start() {
    var _this2 = this;

    if (!this._geometry || !this._geometry.getMap() || this._geometry.editing) {
      return;
    }

    var map = this.getMap();
    this.editing = true;
    var geometry = this._geometry;
    this._geometryDraggble = geometry.options['draggable'];
    geometry.config('draggable', false);
    this.prepare();
    var shadow = geometry.copy();
    shadow.setSymbol(geometry._getInternalSymbol());
    shadow.copyEventListeners(geometry);

    if (geometry._getParent()) {
      shadow.copyEventListeners(geometry._getParent());
    }

    shadow._setEventTarget(geometry);

    shadow.setId(null).config({
      'draggable': false
    });
    this._shadow = shadow;

    this._switchGeometryEvents('on');

    geometry.hide();

    if (geometry instanceof Marker || geometry instanceof Circle || geometry instanceof Rectangle || geometry instanceof Ellipse) {
      this._createOrRefreshOutline();
    }

    this._shadowLayer.bringToFront().addGeometry(shadow);

    this._editStageLayer.bringToFront();

    this._addListener([map, 'zoomstart', function () {
      _this2._editStageLayer.hide();
    }]);

    this._addListener([map, 'zoomend', function () {
      _this2._editStageLayer.show();
    }]);

    if (!(geometry instanceof Marker)) {
      this._createCenterHandle();
    } else {
      shadow.config('draggable', true);
      shadow.on('dragend', this._onMarkerDragEnd, this);
    }

    if (geometry instanceof Marker) {
      this.createMarkerEditor();
    } else if (geometry instanceof Circle) {
      this.createCircleEditor();
    } else if (geometry instanceof Rectangle) {
      this.createEllipseOrRectEditor();
    } else if (geometry instanceof Ellipse) {
      this.createEllipseOrRectEditor();
    } else if (geometry instanceof Sector) ; else if (geometry instanceof Polygon || geometry instanceof LineString) {
      this.createPolygonEditor();
    }
  };

  _proto.stop = function stop() {
    delete this._history;
    delete this._historyPointer;
    delete this._editOutline;

    this._switchGeometryEvents('off');

    var map = this.getMap();

    if (!map) {
      return;
    }

    delete this._shadow;

    this._geometry.config('draggable', this._geometryDraggble);

    delete this._geometryDraggble;

    this._geometry.show();

    this._editStageLayer.remove();

    this._shadowLayer.remove();

    this._clearAllListeners();

    this._refreshHooks = [];

    if (this.options['symbol']) {
      this._geometry.setSymbol(this._originalSymbol);

      delete this._originalSymbol;
    }

    this.editing = false;
  };

  _proto.isEditing = function isEditing() {
    if (isNil(this.editing)) {
      return false;
    }

    return this.editing;
  };

  _proto._getGeometryEvents = function _getGeometryEvents() {
    return {
      'symbolchange': this._onGeoSymbolChange,
      'positionchange shapechange': this._exeAndReset
    };
  };

  _proto._switchGeometryEvents = function _switchGeometryEvents(oper) {
    if (this._geometry) {
      var events = this._getGeometryEvents();

      for (var p in events) {
        this._geometry[oper](p, events[p], this);
      }
    }
  };

  _proto._onGeoSymbolChange = function _onGeoSymbolChange(param) {
    if (this._shadow) {
      this._shadow.setSymbol(param.target._getInternalSymbol());
    }
  };

  _proto._onMarkerDragEnd = function _onMarkerDragEnd() {
    this._update('setCoordinates', this._shadow.getCoordinates().toArray());

    this._refresh();
  };

  _proto._createOrRefreshOutline = function _createOrRefreshOutline() {
    var geometry = this._geometry;
    var outline = this._editOutline;

    if (!outline) {
      outline = geometry.getOutline();

      this._editStageLayer.addGeometry(outline);

      this._editOutline = outline;

      this._addRefreshHook(this._createOrRefreshOutline);
    } else {
      outline.remove();
      this._editOutline = outline = geometry.getOutline();

      this._editStageLayer.addGeometry(outline);
    }

    return outline;
  };

  _proto._createCenterHandle = function _createCenterHandle() {
    var _this3 = this;

    var center = this._shadow.getCenter();

    var symbol = this.options['centerHandleSymbol'];
    var shadow;
    var handle = this.createHandle(center, {
      'symbol': symbol,
      'cursor': 'move',
      onDown: function onDown() {
        shadow = _this3._shadow.copy();
        var symbol = lowerSymbolOpacity(shadow._getInternalSymbol(), 0.5);
        shadow.setSymbol(symbol).addTo(_this3._editStageLayer);
      },
      onMove: function onMove(v, param) {
        var offset = param['coordOffset'];
        shadow.translate(offset);
      },
      onUp: function onUp() {
        _this3._update('setCoordinates', Coordinate.toNumberArrays(shadow.getCoordinates()));

        shadow.remove();

        _this3._refresh();
      }
    });

    this._addRefreshHook(function () {
      var center = _this3._shadow.getCenter();

      handle.setCoordinates(center);
    });
  };

  _proto._createHandleInstance = function _createHandleInstance(coordinate, opts) {
    var symbol = opts['symbol'];
    var handle = new Marker(coordinate, {
      'draggable': true,
      'dragShadow': false,
      'dragOnAxis': opts['axis'],
      'cursor': opts['cursor'],
      'symbol': symbol
    });
    return handle;
  };

  _proto.createHandle = function createHandle(coordinate, opts) {
    if (!opts) {
      opts = {};
    }

    var map = this.getMap();

    var handle = this._createHandleInstance(coordinate, opts);

    var me = this;

    function onHandleDragstart(param) {
      if (opts.onDown) {
        this._geometry.fire('handledragstart');

        opts.onDown.call(me, param['viewPoint'], param);
      }

      return false;
    }

    function onHandleDragging(param) {
      me._hideContext();

      var viewPoint = map._prjToViewPoint(handle._getPrjCoordinates());

      if (opts.onMove) {
        this._geometry.fire('handledragging');

        opts.onMove.call(me, viewPoint, param);
      }

      return false;
    }

    function onHandleDragEnd(ev) {
      if (opts.onUp) {
        this._geometry.fire('handledragend');

        opts.onUp.call(me, ev);
      }

      return false;
    }

    function onHandleRemove() {
      handle.config('draggable', false);
      handle.off('dragstart', onHandleDragstart, me);
      handle.off('dragging', onHandleDragging, me);
      handle.off('dragend', onHandleDragEnd, me);
      handle.off('removestart', onHandleRemove, me);
      delete handle['maptalks--editor-refresh-fn'];
    }

    handle.on('dragstart', onHandleDragstart, this);
    handle.on('dragging', onHandleDragging, this);
    handle.on('dragend', onHandleDragEnd, this);
    handle.on('removestart', onHandleRemove, this);

    if (opts.onRefresh) {
      handle['maptalks--editor-refresh-fn'] = opts.onRefresh;
    }

    this._editStageLayer.addGeometry(handle);

    return handle;
  };

  _proto._createResizeHandles = function _createResizeHandles(blackList, onHandleMove, onHandleUp) {
    var _this4 = this;

    var cursors = ['nw-resize', 'n-resize', 'ne-resize', 'w-resize', 'e-resize', 'sw-resize', 's-resize', 'se-resize'];
    var axis = [null, 'y', null, 'x', 'x', null, 'y', null];
    var geometry = this._geometry;

    function getResizeAnchors(ext) {
      return [new Point(ext['xmin'], ext['ymax']), new Point((ext['xmax'] + ext['xmin']) / 2, ext['ymax']), new Point(ext['xmax'], ext['ymax']), new Point(ext['xmin'], (ext['ymax'] + ext['ymin']) / 2), new Point(ext['xmax'], (ext['ymax'] + ext['ymin']) / 2), new Point(ext['xmin'], ext['ymin']), new Point((ext['xmax'] + ext['xmin']) / 2, ext['ymin']), new Point(ext['xmax'], ext['ymin'])];
    }

    if (!blackList) {
      blackList = [];
    }

    var me = this;
    var resizeHandles = [],
        anchorIndexes = {},
        map = this.getMap(),
        handleSymbol = this.options['vertexHandleSymbol'];

    var fnLocateHandles = function fnLocateHandles() {
      var pExt = geometry._getPainter().get2DExtent(),
          anchors = getResizeAnchors(pExt);

      var _loop = function _loop(i) {
        if (Array.isArray(blackList)) {
          var isBlack = blackList.some(function (ele) {
            return ele === i;
          });

          if (isBlack) {
            return "continue";
          }
        }

        var anchor = anchors[i],
            coordinate = map.pointToCoordinate(anchor);

        if (resizeHandles.length < anchors.length - blackList.length) {
          var handle = _this4.createHandle(coordinate, {
            'symbol': handleSymbol,
            'cursor': cursors[i],
            'axis': axis[i],
            onMove: function (_index) {
              return function (handleViewPoint) {
                me._updating = true;
                onHandleMove(handleViewPoint, _index);
                geometry.fire('resizing');
              };
            }(i),
            onUp: function onUp() {
              me._updating = false;
              onHandleUp();

              _this4._refresh();
            }
          });

          handle.setId(i);
          anchorIndexes[i] = resizeHandles.length;
          resizeHandles.push(handle);
        } else {
          resizeHandles[anchorIndexes[i]].setCoordinates(coordinate);
        }
      };

      for (var i = 0; i < anchors.length; i++) {
        var _ret = _loop(i);

        if (_ret === "continue") continue;
      }
    };

    fnLocateHandles();

    this._addRefreshHook(fnLocateHandles);

    return resizeHandles;
  };

  _proto.createMarkerEditor = function createMarkerEditor() {
    var _this5 = this;

    var geometryToEdit = this._geometry,
        shadow = this._shadow,
        map = this.getMap();

    if (!shadow._canEdit()) {
      if (console) {
        console.warn('A marker can\'t be resized with symbol:', shadow.getSymbol());
      }

      return;
    }

    if (!this._history) {
      this._recordHistory(getUpdates());
    }

    var symbol = shadow._getInternalSymbol();

    var dxdy = new Point(0, 0);

    if (isNumber(symbol['markerDx'])) {
      dxdy.x = symbol['markerDx'];
    }

    if (isNumber(symbol['markerDy'])) {
      dxdy.y = symbol['markerDy'];
    }

    var blackList = null;

    if (VectorMarkerSymbolizer.test(symbol)) {
      if (symbol['markerType'] === 'pin' || symbol['markerType'] === 'pie' || symbol['markerType'] === 'bar') {
        blackList = [5, 6, 7];
      }
    } else if (ImageMarkerSymbolizer.test(symbol) || VectorPathMarkerSymbolizer.test(symbol)) {
      blackList = [5, 6, 7];
    }

    var resizeAbilities = [2, 1, 2, 0, 0, 2, 1, 2];
    var aspectRatio;

    if (this.options['fixAspectRatio']) {
      var size = shadow.getSize();
      aspectRatio = size.width / size.height;
    }

    var resizeHandles = this._createResizeHandles(null, function (handleViewPoint, i) {
      if (blackList && blackList.indexOf(i) >= 0) {
        var newCoordinates = map.viewPointToCoordinate(handleViewPoint.sub(dxdy));
        var coordinates = shadow.getCoordinates();
        newCoordinates.x = coordinates.x;
        shadow.setCoordinates(newCoordinates);

        _this5._updateCoordFromShadow(true);

        var mirrorHandle = resizeHandles[resizeHandles.length - 1 - i];
        var mirrorViewPoint = map.coordToViewPoint(mirrorHandle.getCoordinates());
        handleViewPoint = mirrorViewPoint;
      }

      var viewCenter = map._pointToViewPoint(shadow._getCenter2DPoint()).add(dxdy),
          symbol = shadow._getInternalSymbol();

      var wh = handleViewPoint.sub(viewCenter);

      if (blackList && handleViewPoint.y > viewCenter.y) {
        wh.y = 0;
      }

      var r = blackList ? 1 : 2;
      var width = Math.abs(wh.x) * 2,
          height = Math.abs(wh.y) * r;

      if (aspectRatio) {
        width = Math.max(width, height * aspectRatio);
        height = width / aspectRatio;
      }

      var ability = resizeAbilities[i];

      if (!(shadow instanceof TextBox)) {
        if (aspectRatio || ability === 0 || ability === 2) {
          symbol['markerWidth'] = width;
        }

        if (aspectRatio || ability === 1 || ability === 2) {
          symbol['markerHeight'] = height;
        }

        shadow.setSymbol(symbol);
        geometryToEdit.setSymbol(symbol);
      } else {
        if (aspectRatio || ability === 0 || ability === 2) {
          shadow.setWidth(width);
          geometryToEdit.setWidth(width);
        }

        if (aspectRatio || ability === 1 || ability === 2) {
          shadow.setHeight(height);
          geometryToEdit.setHeight(height);
        }
      }
    }, function () {
      _this5._update(getUpdates());
    });

    function getUpdates() {
      var updates = [['setCoordinates', shadow.getCoordinates().toArray()]];

      if (shadow instanceof TextBox) {
        updates.push(['setWidth', shadow.getWidth()]);
        updates.push(['setHeight', shadow.getHeight()]);
      } else {
        updates.push(['setSymbol', shadow.getSymbol()]);
      }

      return updates;
    }

    function onZoomEnd() {
      this._refresh();
    }

    this._addListener([map, 'zoomend', onZoomEnd]);
  };

  _proto.createCircleEditor = function createCircleEditor() {
    var _this6 = this;

    var circle = this._geometry,
        shadow = this._shadow;
    var map = this.getMap();

    if (!this._history) {
      this._recordHistory([['setCoordinates', shadow.getCoordinates().toArray()], ['setRadius', shadow.getRadius()]]);
    }

    this._createResizeHandles(null, function (handleViewPoint) {
      var center = circle.getCenter();
      var mouseCoordinate = map.viewPointToCoordinate(handleViewPoint);
      var wline = new LineString([[center.x, center.y], [mouseCoordinate.x, center.y]]);
      var hline = new LineString([[center.x, center.y], [center.x, mouseCoordinate.y]]);
      var r = Math.max(map.computeGeometryLength(wline), map.computeGeometryLength(hline));
      shadow.setRadius(r);
      circle.setRadius(r);
    }, function () {
      _this6._update('setRadius', shadow.getRadius());
    });
  };

  _proto.createEllipseOrRectEditor = function createEllipseOrRectEditor() {
    var _this7 = this;

    var resizeAbilities = [2, 1, 2, 0, 0, 2, 1, 2];
    var geometryToEdit = this._geometry,
        shadow = this._shadow;

    if (!this._history) {
      this._recordHistory(getUpdates());
    }

    var map = this.getMap();
    var isRect = this._geometry instanceof Rectangle;
    var aspectRatio;

    if (this.options['fixAspectRatio']) {
      aspectRatio = geometryToEdit.getWidth() / geometryToEdit.getHeight();
    }

    var resizeHandles = this._createResizeHandles(null, function (mouseViewPoint, i) {
      var r = isRect ? 1 : 2;
      var pointSub, w, h;
      var targetPoint = mouseViewPoint;
      var ability = resizeAbilities[i];

      if (isRect) {
        var mirror = resizeHandles[7 - i];
        var mirrorViewPoint = map.coordToViewPoint(mirror.getCoordinates());
        pointSub = targetPoint.sub(mirrorViewPoint);
        var absSub = pointSub.abs();
        w = map.pixelToDistance(absSub.x, 0);
        h = map.pixelToDistance(0, absSub.y);
        var size = geometryToEdit.getSize();
        var firstMirrorCoordinate = resizeHandles[0].getCoordinates();
        var mouseCoordinate = map.viewPointToCoordinate(mouseViewPoint);
        var mirrorCoordinate = mirror.getCoordinates();
        var wline = new LineString([[mirrorCoordinate.x, mirrorCoordinate.y], [mouseCoordinate.x, mirrorCoordinate.y]]);
        var hline = new LineString([[mirrorCoordinate.x, mirrorCoordinate.y], [mirrorCoordinate.x, mouseCoordinate.y]]);
        w = map.computeGeometryLength(wline);
        h = map.computeGeometryLength(hline);

        if (ability === 0) {
          if (aspectRatio) {
            absSub.y = absSub.x / aspectRatio;
            size.height = Math.abs(absSub.y);
            h = w / aspectRatio;
          }

          targetPoint.y = mirrorViewPoint.y - size.height / 2;
          mouseCoordinate.y = firstMirrorCoordinate.y;

          if (i === 4) {
            mouseCoordinate.x = Math.min(mouseCoordinate.x, firstMirrorCoordinate.x);
          } else {
            mouseCoordinate.x = Math.min(mouseCoordinate.x, mirrorCoordinate.x);
          }
        } else if (ability === 1) {
          if (aspectRatio) {
            absSub.x = absSub.y * aspectRatio;
            size.width = Math.abs(absSub.x);
            w = h * aspectRatio;
          }

          targetPoint.x = mirrorViewPoint.x - size.width / 2;
          mouseCoordinate.x = firstMirrorCoordinate.x;
          mouseCoordinate.y = Math.max(mouseCoordinate.y, mirrorCoordinate.y);
        } else {
          if (aspectRatio) {
            if (w > h * aspectRatio) {
              h = w / aspectRatio;
              targetPoint.y = mirrorViewPoint.y + absSub.x * sign(pointSub.y) / aspectRatio;
            } else {
              w = h * aspectRatio;
              targetPoint.x = mirrorViewPoint.x + absSub.y * sign(pointSub.x) * aspectRatio;
            }
          }

          mouseCoordinate.x = Math.min(mouseCoordinate.x, mirrorCoordinate.x);
          mouseCoordinate.y = Math.max(mouseCoordinate.y, mirrorCoordinate.y);
        }

        shadow.setCoordinates(mouseCoordinate);

        _this7._updateCoordFromShadow(true);
      } else {
        var center = geometryToEdit.getCenter();

        var _mouseCoordinate = map.viewPointToCoordinate(targetPoint);

        var _wline = new LineString([[center.x, center.y], [_mouseCoordinate.x, center.y]]);

        var _hline = new LineString([[center.x, center.y], [center.x, _mouseCoordinate.y]]);

        w = map.computeGeometryLength(_wline);
        h = map.computeGeometryLength(_hline);

        if (aspectRatio) {
          w = Math.max(w, h * aspectRatio);
          h = w / aspectRatio;
        }
      }

      if (aspectRatio || ability === 0 || ability === 2) {
        shadow.setWidth(w * r);
        geometryToEdit.setWidth(w * r);
      }

      if (aspectRatio || ability === 1 || ability === 2) {
        shadow.setHeight(h * r);
        geometryToEdit.setHeight(h * r);
      }
    }, function () {
      _this7._update(getUpdates());
    });

    function getUpdates() {
      return [['setCoordinates', shadow.getCoordinates().toArray()], ['setWidth', shadow.getWidth()], ['setHeight', shadow.getHeight()]];
    }
  };

  _proto.createPolygonEditor = function createPolygonEditor() {
    var map = this.getMap(),
        shadow = this._shadow,
        me = this,
        projection = map.getProjection();

    if (!this._history) {
      this._recordHistory('setCoordinates', Coordinate.toNumberArrays(shadow.getCoordinates()));
    }

    var verticeLimit = shadow instanceof Polygon ? 3 : 2;
    var propertyOfVertexRefreshFn = 'maptalks--editor-refresh-fn',
        propertyOfVertexIndex = 'maptalks--editor-vertex-index';
    var vertexHandles = {
      0: []
    },
        newVertexHandles = {
      0: []
    };

    function getVertexCoordinates(ringIndex) {
      if (ringIndex === void 0) {
        ringIndex = 0;
      }

      if (shadow instanceof Polygon) {
        var coordinates = shadow.getCoordinates()[ringIndex] || [];
        return coordinates.slice(0, coordinates.length - 1);
      } else {
        return shadow.getCoordinates();
      }
    }

    function getVertexPrjCoordinates(ringIndex) {
      if (ringIndex === void 0) {
        ringIndex = 0;
      }

      if (ringIndex === 0) {
        return shadow._getPrjCoordinates();
      }

      return shadow._getPrjHoles()[ringIndex - 1];
    }

    function onVertexAddOrRemove() {
      for (var ringIndex in vertexHandles) {
        for (var i = vertexHandles[ringIndex].length - 1; i >= 0; i--) {
          vertexHandles[ringIndex][i][propertyOfVertexIndex] = i;
        }

        for (var _i = newVertexHandles[ringIndex].length - 1; _i >= 0; _i--) {
          newVertexHandles[ringIndex][_i][propertyOfVertexIndex] = _i;
        }
      }

      me._updateCoordFromShadow();
    }

    function removeVertex(param) {
      var handle = param['target'],
          index = handle[propertyOfVertexIndex];
      var ringIndex = isNumber(handle._ringIndex) ? handle._ringIndex : 0;
      var prjCoordinates = getVertexPrjCoordinates(ringIndex);

      if (prjCoordinates.length <= verticeLimit) {
        return;
      }

      prjCoordinates.splice(index, 1);

      if (ringIndex > 0) {
        shadow._prjHoles[ringIndex - 1] = prjCoordinates;
      } else {
        shadow._setPrjCoordinates(prjCoordinates);
      }

      shadow._updateCache();

      vertexHandles[ringIndex].splice(index, 1)[0].remove();

      if (index < newVertexHandles[ringIndex].length) {
        newVertexHandles[ringIndex].splice(index, 1)[0].remove();
      }

      var nextIndex;

      if (index === 0) {
        nextIndex = newVertexHandles[ringIndex].length - 1;
      } else {
        nextIndex = index - 1;
      }

      newVertexHandles[ringIndex].splice(nextIndex, 1)[0].remove();
      newVertexHandles[ringIndex].splice(nextIndex, 0, createNewVertexHandle.call(me, nextIndex, ringIndex));
      onVertexAddOrRemove();

      me._refresh();
    }

    function moveVertexHandle(handleViewPoint, index, ringIndex) {
      if (ringIndex === void 0) {
        ringIndex = 0;
      }

      var vertice = getVertexPrjCoordinates(ringIndex);

      var nVertex = map._viewPointToPrj(handleViewPoint);

      var pVertex = vertice[index];
      pVertex.x = nVertex.x;
      pVertex.y = nVertex.y;

      shadow._updateCache();

      shadow.onShapeChanged();

      me._updateCoordFromShadow(true);

      var nextIndex;

      if (index === 0) {
        nextIndex = newVertexHandles[ringIndex].length - 1;
      } else {
        nextIndex = index - 1;
      }

      if (newVertexHandles[ringIndex][index]) {
        newVertexHandles[ringIndex][index][propertyOfVertexRefreshFn]();
      }

      if (newVertexHandles[ringIndex][nextIndex]) {
        newVertexHandles[ringIndex][nextIndex][propertyOfVertexRefreshFn]();
      }
    }

    function createVertexHandle(index, ringIndex) {
      if (ringIndex === void 0) {
        ringIndex = 0;
      }

      var vertex = getVertexCoordinates(ringIndex)[index];
      var handle = me.createHandle(vertex, {
        'symbol': me.options['vertexHandleSymbol'],
        'cursor': 'pointer',
        'axis': null,
        onMove: function onMove(handleViewPoint) {
          moveVertexHandle(handleViewPoint, handle[propertyOfVertexIndex], ringIndex);
        },
        onRefresh: function onRefresh() {
          vertex = getVertexCoordinates(ringIndex)[handle[propertyOfVertexIndex]];
          handle.setCoordinates(vertex);
        },
        onUp: function onUp() {
          me._refresh();

          me._updateCoordFromShadow();
        },
        onDown: function onDown(param, e) {
          if (e && e.domEvent && e.domEvent.button === 2) {
            return;
          }
        }
      });
      handle[propertyOfVertexIndex] = index;
      handle._ringIndex = ringIndex;
      handle.on(me.options['removeVertexOn'], removeVertex);
      return handle;
    }

    function createNewVertexHandle(index, ringIndex) {
      if (ringIndex === void 0) {
        ringIndex = 0;
      }

      var vertexCoordinates = getVertexCoordinates(ringIndex);
      var nextVertex;

      if (index + 1 >= vertexCoordinates.length) {
        nextVertex = vertexCoordinates[0];
      } else {
        nextVertex = vertexCoordinates[index + 1];
      }

      var vertex = vertexCoordinates[index].add(nextVertex).multi(1 / 2);
      var handle = me.createHandle(vertex, {
        'symbol': me.options['newVertexHandleSymbol'],
        'cursor': 'pointer',
        'axis': null,
        onDown: function onDown(param, e) {
          if (e && e.domEvent && e.domEvent.button === 2) {
            return;
          }

          var prjCoordinates = getVertexPrjCoordinates(ringIndex);
          var vertexIndex = handle[propertyOfVertexIndex];
          var pVertex = projection.project(handle.getCoordinates());
          prjCoordinates.splice(vertexIndex + 1, 0, pVertex);

          if (ringIndex > 0) {
            shadow._prjHoles[ringIndex - 1] = prjCoordinates;
          } else {
            shadow._setPrjCoordinates(prjCoordinates);
          }

          shadow._updateCache();

          var symbol = handle.getSymbol();
          delete symbol['opacity'];
          handle.setSymbol(symbol);
          newVertexHandles[ringIndex].splice(vertexIndex, 0, createNewVertexHandle.call(me, vertexIndex, ringIndex), createNewVertexHandle.call(me, vertexIndex + 1, ringIndex));
        },
        onMove: function onMove(handleViewPoint) {
          moveVertexHandle(handleViewPoint, handle[propertyOfVertexIndex] + 1, ringIndex);
        },
        onUp: function onUp(e) {
          if (e && e.domEvent && e.domEvent.button === 2) {
            return;
          }

          var vertexIndex = handle[propertyOfVertexIndex];
          removeFromArray(handle, newVertexHandles[ringIndex]);
          handle.remove();
          vertexHandles[ringIndex].splice(vertexIndex + 1, 0, createVertexHandle.call(me, vertexIndex + 1, ringIndex));
          onVertexAddOrRemove();

          me._updateCoordFromShadow();

          me._refresh();
        },
        onRefresh: function onRefresh() {
          vertexCoordinates = getVertexCoordinates(ringIndex);
          var vertexIndex = handle[propertyOfVertexIndex];
          var nextIndex;

          if (vertexIndex === vertexCoordinates.length - 1) {
            nextIndex = 0;
          } else {
            nextIndex = vertexIndex + 1;
          }

          var refreshVertex = vertexCoordinates[vertexIndex].add(vertexCoordinates[nextIndex]).multi(1 / 2);
          handle.setCoordinates(refreshVertex);
        }
      });
      handle[propertyOfVertexIndex] = index;
      return handle;
    }

    if (shadow instanceof Polygon) {
      var rings = shadow.getHoles().length + 1;

      for (var ringIndex = 0; ringIndex < rings; ringIndex++) {
        vertexHandles[ringIndex] = [];
        newVertexHandles[ringIndex] = [];
        var vertexCoordinates = getVertexCoordinates(ringIndex);

        for (var i = 0, len = vertexCoordinates.length; i < len; i++) {
          vertexHandles[ringIndex].push(createVertexHandle.call(this, i, ringIndex));

          if (i < len - 1) {
            newVertexHandles[ringIndex].push(createNewVertexHandle.call(this, i, ringIndex));
          }
        }

        newVertexHandles[ringIndex].push(createNewVertexHandle.call(this, vertexCoordinates.length - 1, ringIndex));
      }
    } else {
      var _ringIndex = 0;

      var _vertexCoordinates = getVertexCoordinates(_ringIndex);

      for (var _i2 = 0, _len = _vertexCoordinates.length; _i2 < _len; _i2++) {
        vertexHandles[_ringIndex].push(createVertexHandle.call(this, _i2, _ringIndex));

        if (_i2 < _len - 1) {
          newVertexHandles[_ringIndex].push(createNewVertexHandle.call(this, _i2, _ringIndex));
        }
      }
    }

    this._addRefreshHook(function () {
      for (var _ringIndex2 in newVertexHandles) {
        for (var _i3 = newVertexHandles[_ringIndex2].length - 1; _i3 >= 0; _i3--) {
          newVertexHandles[_ringIndex2][_i3][propertyOfVertexRefreshFn](_ringIndex2);
        }
      }

      for (var _ringIndex3 in vertexHandles) {
        for (var _i4 = vertexHandles[_ringIndex3].length - 1; _i4 >= 0; _i4--) {
          vertexHandles[_ringIndex3][_i4][propertyOfVertexRefreshFn](_ringIndex3);
        }
      }
    });
  };

  _proto._refresh = function _refresh() {
    if (this._refreshHooks) {
      for (var i = this._refreshHooks.length - 1; i >= 0; i--) {
        this._refreshHooks[i].call(this);
      }
    }
  };

  _proto._hideContext = function _hideContext() {
    if (this._geometry) {
      this._geometry.closeMenu();

      this._geometry.closeInfoWindow();
    }
  };

  _proto._addListener = function _addListener(listener) {
    if (!this._eventListeners) {
      this._eventListeners = [];
    }

    this._eventListeners.push(listener);

    listener[0].on(listener[1], listener[2], this);
  };

  _proto._clearAllListeners = function _clearAllListeners() {
    if (this._eventListeners && this._eventListeners.length > 0) {
      for (var i = this._eventListeners.length - 1; i >= 0; i--) {
        var listener = this._eventListeners[i];
        listener[0].off(listener[1], listener[2], this);
      }

      this._eventListeners = [];
    }
  };

  _proto._addRefreshHook = function _addRefreshHook(fn) {
    if (!fn) {
      return;
    }

    if (!this._refreshHooks) {
      this._refreshHooks = [];
    }

    this._refreshHooks.push(fn);
  };

  _proto._update = function _update(method) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key = 1; _key < _len2; _key++) {
      args[_key - 1] = arguments[_key];
    }

    this._exeHistory([method, args]);

    this._recordHistory.apply(this, [method].concat(args));
  };

  _proto._updateCoordFromShadow = function _updateCoordFromShadow(ignoreRecord) {
    if (!this._shadow) {
      return;
    }

    var coords = this._shadow.getCoordinates();

    var geo = this._geometry;
    var updating = this._updating;
    this._updating = true;
    geo.setCoordinates(coords);

    if (!ignoreRecord) {
      this._recordHistory('setCoordinates', Coordinate.toNumberArrays(geo.getCoordinates()));
    }

    this._updating = updating;
  };

  _proto._recordHistory = function _recordHistory(method) {
    if (!this._history) {
      this._history = [];
      this._historyPointer = 0;
    }

    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key2 = 1; _key2 < _len3; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (this._history.length) {
      var lastOperation = this._history[this._history.length - 1];

      if (lastOperation[0] === method && JSON.stringify(lastOperation[1]) === JSON.stringify(args)) {
        return;
      }
    }

    if (this._historyPointer < this._history.length - 1) {
      this._history.splice(this._historyPointer + 1);
    }

    this._history.push([method, args]);

    this._historyPointer = this._history.length - 1;

    this._geometry.fire('editrecord');
  };

  _proto.cancel = function cancel() {
    if (!this._history || this._historyPointer === 0) {
      return this;
    }

    this._historyPointer = 0;
    var record = this._history[0];

    this._exeAndReset(record);

    return this;
  };

  _proto.undo = function undo() {
    if (!this._history || this._historyPointer === 0) {
      return this;
    }

    var record = this._history[--this._historyPointer];

    this._exeAndReset(record);

    return this;
  };

  _proto.redo = function redo() {
    if (!this._history || this._historyPointer === this._history.length - 1) {
      return this;
    }

    var record = this._history[++this._historyPointer];

    this._exeAndReset(record);

    return this;
  };

  _proto._exeAndReset = function _exeAndReset(record) {
    if (this._updating) {
      return;
    }

    this._exeHistory(record);

    var history = this._history,
        pointer = this._historyPointer;
    this.stop();
    this._history = history;
    this._historyPointer = pointer;
    this.start();
  };

  _proto._exeHistory = function _exeHistory(record) {
    var _this8 = this;

    if (!Array.isArray(record)) {
      return;
    }

    var updating = this._updating;
    this._updating = true;
    var geo = this._geometry;

    if (Array.isArray(record[0])) {
      record[0].forEach(function (o) {
        var m = o[0],
            args = o.slice(1);

        _this8._shadow[m].apply(_this8._shadow, args);

        geo[m].apply(geo, args);
      });
    } else {
      this._shadow[record[0]].apply(this._shadow, record[1]);

      geo[record[0]].apply(geo, record[1]);
    }

    this._updating = updating;
  };

  return GeometryEditor;
}(Eventable(Class));

GeometryEditor.mergeOptions(options$z);

var TextEditable = {
  startEditText: function startEditText() {
    if (!this.getMap()) {
      return this;
    }

    this.hide();
    this.endEditText();

    this._prepareEditor();

    this._fireEvent('edittextstart');

    return this;
  },
  endEditText: function endEditText() {
    if (this._textEditor) {
      var html = this._textEditor.innerHTML;
      html = html.replace(/<p>/ig, '').replace(/<\/p>/ig, '<br/>');
      this._textEditor.innerHTML = html;

      var content = this._textEditor.innerText.replace(/[\r\n]+$/gi, '');

      this.setContent(content);
      off(this._textEditor, 'mousedown dblclick', stopPropagation);
      this.getMap().off('mousedown', this.endEditText, this);

      this._editUIMarker.remove();

      delete this._editUIMarker;
      this._textEditor.onkeyup = null;
      delete this._textEditor;
      this.show();

      this._fireEvent('edittextend');
    }

    return this;
  },
  isEditingText: function isEditingText() {
    if (this._textEditor) {
      return true;
    }

    return false;
  },
  getTextEditor: function getTextEditor() {
    return this._editUIMarker;
  },
  _prepareEditor: function _prepareEditor() {
    var map = this.getMap();

    var editContainer = this._createEditor();

    this._textEditor = editContainer;
    map.on('mousedown', this.endEditText, this);

    var offset = this._getEditorOffset();

    this._editUIMarker = new UIMarker(this.getCoordinates(), {
      'animation': null,
      'content': editContainer,
      'dx': offset.dx,
      'dy': offset.dy
    }).addTo(map);

    this._setCursorToLast(this._textEditor);
  },
  _getEditorOffset: function _getEditorOffset() {
    var symbol = this._getInternalSymbol() || {};
    var dx = 0,
        dy = 0;
    var textAlign = symbol['textHorizontalAlignment'];

    if (textAlign === 'middle' || isNil(textAlign)) {
      dx = (symbol['textDx'] || 0) - 2;
      dy = (symbol['textDy'] || 0) - 2;
    } else {
      dx = (symbol['markerDx'] || 0) - 2;
      dy = (symbol['markerDy'] || 0) - 2;
    }

    return {
      'dx': dx,
      'dy': dy
    };
  },
  _createEditor: function _createEditor() {
    var content = this.getContent();
    var labelSize = this.getSize(),
        symbol = this._getInternalSymbol() || {},
        width = labelSize.width,
        textColor = symbol['textFill'] || '#000000',
        textSize = symbol['textSize'] || 12,
        height = labelSize.height,
        lineColor = symbol['markerLineColor'] || '#000',
        fill = symbol['markerFill'] || '#3398CC',
        spacing = symbol['textLineSpacing'] || 0;
    var editor = createEl('div');
    editor.contentEditable = true;
    editor.style.cssText = "background:" + fill + "; border:1px solid " + lineColor + ";\n            color:" + textColor + ";font-size:" + textSize + "px;width:" + (width - 2) + "px;height:" + (height - 2) + "px;margin: auto;\n            line-height:" + (textSize + spacing) + "px;outline: 0; padding:0; margin:0;word-wrap: break-word;\n            overflow: hidden;-webkit-user-modify: read-write-plaintext-only;";
    editor.innerText = content;
    on(editor, 'mousedown dblclick', stopPropagation);

    editor.onkeyup = function (event) {
      var h = editor.style.height || 0;

      if (event.keyCode === 13) {
        editor.style.height = parseInt(h) + textSize / 2 + 'px';
      }
    };

    return editor;
  },
  _setCursorToLast: function _setCursorToLast(obj) {
    var range;

    if (window.getSelection) {
      obj.focus();
      range = window.getSelection();
      range.selectAllChildren(obj);
      range.collapseToEnd();
    } else if (document.selection) {
      range = document.selection.createRange();
      range.moveToElementText(obj);
      range.collapse(false);
      range.select();
    }
  }
};
TextMarker.include(TextEditable);

Geometry.include({
  animate: function animate(styles, options, step) {
    var _this = this;

    if (this._animPlayer) {
      this._animPlayer.finish();
    }

    if (isFunction(options)) {
      step = options;
    }

    if (!options) {
      options = {};
    }

    var map = this.getMap(),
        projection = this._getProjection(),
        symbol = this.getSymbol() || {},
        stylesToAnimate = this._prepareAnimationStyles(styles);

    var preTranslate;
    var isFocusing = options['focus'];
    delete this._animationStarted;

    if (map) {
      var renderer = map._getRenderer();

      var framer = function framer(fn) {
        renderer.callInNextFrame(fn);
      };

      options['framer'] = framer;
    }

    var player = Animation.animate(stylesToAnimate, options, function (frame) {
      if (map && map.isRemoved()) {
        player.finish();
        return;
      }

      if (map && !_this._animationStarted && isFocusing) {
        map.onMoveStart();
      }

      var styles = frame.styles;

      for (var p in styles) {
        if (p !== 'symbol' && p !== 'translate' && styles.hasOwnProperty(p)) {
          var fnName = 'set' + p[0].toUpperCase() + p.slice(1);

          _this[fnName](styles[p]);
        }
      }

      var translate = styles['translate'];

      if (translate) {
        var toTranslate = translate;

        if (preTranslate) {
          toTranslate = translate.sub(preTranslate);
        }

        preTranslate = translate;

        _this.translate(toTranslate);
      }

      var dSymbol = styles['symbol'];

      if (dSymbol) {
        _this.setSymbol(extendSymbol(symbol, dSymbol));
      }

      if (map && isFocusing) {
        var pcenter = projection.project(_this.getCenter());

        map._setPrjCenter(pcenter);

        var e = map._parseEventFromCoord(projection.unproject(pcenter));

        if (player.playState !== 'running') {
          map.onMoveEnd(e);
        } else {
          map.onMoving(e);
        }
      }

      _this._fireAnimateEvent(player.playState);

      if (step) {
        step(frame);
      }
    }, this);
    this._animPlayer = player;
    return this._animPlayer.play();
  },
  _prepareAnimationStyles: function _prepareAnimationStyles(styles) {
    var symbol = this._getInternalSymbol();

    var stylesToAnimate = {};

    for (var p in styles) {
      if (styles.hasOwnProperty(p)) {
        var v = styles[p];

        if (p !== 'translate' && p !== 'symbol') {
          var fnName = 'get' + p[0].toUpperCase() + p.substring(1);
          var current = this[fnName]();
          stylesToAnimate[p] = [current, v];
        } else if (p === 'symbol') {
          var symbolToAnimate = void 0;

          if (Array.isArray(styles['symbol'])) {
            if (!Array.isArray(symbol)) {
              throw new Error('geometry\'symbol isn\'t a composite symbol, while the symbol in styles is.');
            }

            symbolToAnimate = [];
            var symbolInStyles = styles['symbol'];

            for (var i = 0; i < symbolInStyles.length; i++) {
              if (!symbolInStyles[i]) {
                symbolToAnimate.push(null);
                continue;
              }

              var a = {};

              for (var sp in symbolInStyles[i]) {
                if (symbolInStyles[i].hasOwnProperty(sp)) {
                  a[sp] = [symbol[i][sp], symbolInStyles[i][sp]];
                }
              }

              symbolToAnimate.push(a);
            }
          } else {
            if (Array.isArray(symbol)) {
              throw new Error('geometry\'symbol is a composite symbol, while the symbol in styles isn\'t.');
            }

            symbolToAnimate = {};

            for (var _sp in v) {
              if (v.hasOwnProperty(_sp)) {
                symbolToAnimate[_sp] = [symbol[_sp], v[_sp]];
              }
            }
          }

          stylesToAnimate['symbol'] = symbolToAnimate;
        } else if (p === 'translate') {
          stylesToAnimate['translate'] = new Coordinate(v);
        }
      }
    }

    return stylesToAnimate;
  },
  _fireAnimateEvent: function _fireAnimateEvent(playState) {
    if (playState === 'finished') {
      delete this._animationStarted;

      this._fireEvent('animateend');
    } else if (playState === 'running') {
      if (this._animationStarted) {
        this._fireEvent('animating');
      } else {
        this._fireEvent('animatestart');

        this._animationStarted = true;
      }
    }
  }
});

var DRAG_STAGE_LAYER_ID = INTERNAL_LAYER_PREFIX + '_drag_stage';
var EVENTS$2 = Browser$1.touch ? 'touchstart mousedown' : 'mousedown';

var GeometryDragHandler = function (_Handler) {
  _inheritsLoose(GeometryDragHandler, _Handler);

  function GeometryDragHandler(target) {
    return _Handler.call(this, target) || this;
  }

  var _proto = GeometryDragHandler.prototype;

  _proto.addHooks = function addHooks() {
    this.target.on(EVENTS$2, this._startDrag, this);
  };

  _proto.removeHooks = function removeHooks() {
    this._endDrag();

    this.target.off(EVENTS$2, this._startDrag, this);
    delete this.container;
  };

  _proto._prepareDragHandler = function _prepareDragHandler() {
    this._dragHandler = new DragHandler(this.container);

    this._dragHandler.on('dragging', this._dragging, this).on('mouseup', this._endDrag, this).enable();
  };

  _proto._prepareShadow = function _prepareShadow() {
    var _this = this;

    var target = this.target;

    this._prepareDragStageLayer();

    if (this._shadow) {
      this._shadow.remove();
    }

    var shadow = this._shadow = target.copy();

    if (shadow.getGeometries) {
      var shadows = shadow.getGeometries();
      var geos = target.getGeometries();
      shadows.forEach(function (g, i) {
        _this._updateShadowSymbol(g, geos[i]);
      });
    } else {
      this._updateShadowSymbol(shadow, target);
    }

    shadow.setId(null);

    this._prepareShadowConnectors();
  };

  _proto._updateShadowSymbol = function _updateShadowSymbol(shadow, target) {
    shadow.setSymbol(target._getInternalSymbol());

    if (target.options['dragShadow']) {
      var symbol = lowerSymbolOpacity(shadow._getInternalSymbol(), 0.5);
      shadow.setSymbol(symbol);
    }
  };

  _proto._prepareShadowConnectors = function _prepareShadowConnectors() {
    var target = this.target;
    var shadow = this._shadow;

    var resources = this._dragStageLayer._getRenderer().resources;

    var shadowConnectors = [];

    if (ConnectorLine._hasConnectors(target)) {
      var connectors = ConnectorLine._getConnectors(target);

      for (var i = 0, l = connectors.length; i < l; i++) {
        var targetConn = connectors[i];

        var connOptions = targetConn.config(),
            connSymbol = targetConn._getInternalSymbol();

        connOptions['symbol'] = lowerSymbolOpacity(connSymbol, 0.5);
        var conn = void 0;

        if (targetConn.getConnectSource() === target) {
          conn = new targetConn.constructor(shadow, targetConn.getConnectTarget(), connOptions);
        } else {
          conn = new targetConn.constructor(targetConn.getConnectSource(), shadow, connOptions);
        }

        shadowConnectors.push(conn);

        if (targetConn.getLayer() && targetConn.getLayer()._getRenderer()) {
          resources.merge(targetConn.getLayer()._getRenderer().resources);
        }
      }
    }

    this._shadowConnectors = shadowConnectors;
    shadowConnectors.push(shadow);

    this._dragStageLayer.bringToFront().addGeometry(shadowConnectors);
  };

  _proto._onTargetUpdated = function _onTargetUpdated() {
    if (this._shadow) {
      this._shadow.setSymbol(this.target._getSymbol());
    }
  };

  _proto._prepareDragStageLayer = function _prepareDragStageLayer() {
    var map = this.target.getMap(),
        layer = this.target.getLayer();
    this._dragStageLayer = map.getLayer(DRAG_STAGE_LAYER_ID);

    if (!this._dragStageLayer) {
      this._dragStageLayer = new VectorLayer(DRAG_STAGE_LAYER_ID, {
        enableAltitude: layer.options['enableAltitude'],
        altitudeProperty: layer.options['altitudeProperty']
      });
      map.addLayer(this._dragStageLayer);
    }

    var resources = new ResourceCache();
    resources.merge(layer._getRenderer().resources);
    this._dragStageLayer._getRenderer().resources = resources;
  };

  _proto._startDrag = function _startDrag(param) {
    var map = this.target.getMap();

    if (!map) {
      return;
    }

    var parent = this.target._getParent();

    if (parent) {
      return;
    }

    if (this.isDragging()) {
      return;
    }

    var domEvent = param['domEvent'];

    if (domEvent.touches && domEvent.touches.length > 1 || domEvent.button === 2) {
      return;
    }

    this.container = map._panels.mapWrapper || map._containerDOM;
    this.target.on('click', this._endDrag, this);
    this._lastCoord = this._correctCoord(param['coordinate']);
    this._lastPoint = param['containerPoint'];

    this._prepareDragHandler();

    this._dragHandler.onMouseDown(param['domEvent']);

    on(this.container, 'mouseleave', this._endDrag, this);
    this._startParam = param;
    this._moved = false;
    return;
  };

  _proto._dragging = function _dragging(param) {
    var target = this.target;

    var map = target.getMap(),
        e = map._parseEvent(param['domEvent']);

    var domEvent = e['domEvent'];

    if (domEvent.touches && domEvent.touches.length > 1) {
      return;
    }

    if (!this._moved) {
      this._moved = true;
      target.on('symbolchange', this._onTargetUpdated, this);
      this._isDragging = true;

      this._prepareShadow();

      if (!target.options['dragShadow']) {
        target.hide();
      }

      this._shadow._fireEvent('dragstart', e);

      this.target._fireEvent('dragstart', this._startParam || e);

      delete this._startParam;
      return;
    }

    if (!this._shadow) {
      return;
    }

    var axis = this._shadow.options['dragOnAxis'],
        coord = this._correctCoord(e['coordinate']),
        point = e['containerPoint'];

    this._lastPoint = this._lastPoint || point;
    this._lastCoord = this._lastCoord || coord;
    var pointOffset = point.sub(this._lastPoint);
    var coordOffset = coord.sub(this._lastCoord);

    if (axis === 'x') {
      pointOffset.y = coordOffset.y = 0;
    } else if (axis === 'y') {
      pointOffset.x = coordOffset.x = 0;
    }

    this._lastPoint = point;
    this._lastCoord = coord;

    this._shadow.translate(coordOffset);

    if (!target.options['dragShadow']) {
      target.translate(coordOffset);
    }

    e['coordOffset'] = coordOffset;
    e['pointOffset'] = pointOffset;

    this._shadow._fireEvent('dragging', e);

    target._fireEvent('dragging', e);
  };

  _proto._endDrag = function _endDrag(param) {
    if (this._dragHandler) {
      this._dragHandler.disable();

      delete this._dragHandler;
    }

    if (this.container) {
      off(this.container, 'mouseleave', this._endDrag, this);
    }

    if (!this.target) {
      return;
    }

    var target = this.target;
    target.off('click', this._endDrag, this);
    target.off('symbolchange', this._onTargetUpdated, this);
    delete this._lastCoord;
    delete this._lastPoint;
    this._isDragging = false;
    var map = target.getMap();

    if (this.enabled() && map) {
      var e = map._parseEvent(param ? param['domEvent'] : null);

      this._updateTargetAndRemoveShadow(e);

      if (this._moved) {
        target._fireEvent('dragend', e);
      }
    }
  };

  _proto.isDragging = function isDragging() {
    if (!this._isDragging) {
      return false;
    }

    return true;
  };

  _proto._updateTargetAndRemoveShadow = function _updateTargetAndRemoveShadow(eventParam) {
    var target = this.target,
        map = target.getMap();

    if (!target.options['dragShadow']) {
      target.show();
    }

    var shadow = this._shadow;

    if (shadow) {
      if (target.options['dragShadow']) {
        if (target.getGeometries) {
          var shadows = shadow.getGeometries();
          var geos = target.getGeometries();
          shadows.forEach(function (g, i) {
            geos[i].setCoordinates(shadows[i].getCoordinates());
          });
        } else {
          target.setCoordinates(shadow.getCoordinates());
        }
      }

      shadow._fireEvent('dragend', eventParam);

      shadow.remove();
      delete this._shadow;
    }

    if (this._shadowConnectors) {
      map.getLayer(DRAG_STAGE_LAYER_ID).removeGeometry(this._shadowConnectors);
      delete this._shadowConnectors;
    }

    if (this._dragStageLayer) {
      this._dragStageLayer.remove();
    }
  };

  _proto._correctCoord = function _correctCoord(coord) {
    var map = this.target.getMap();

    if (!map.getPitch()) {
      return coord;
    }

    var painter = this.target._getPainter();

    if (!painter.getMinAltitude()) {
      return coord;
    }

    var alt = (painter.getMinAltitude() + painter.getMaxAltitude()) / 2;
    return map.locateByPoint(coord, 0, -alt);
  };

  return GeometryDragHandler;
}(Handler$1);

Geometry.mergeOptions({
  'draggable': false,
  'dragShadow': true,
  'dragOnAxis': null
});
Geometry.addInitHook('addHandler', 'draggable', GeometryDragHandler);
Geometry.include({
  isDragging: function isDragging() {
    if (this._getParent()) {
      return this._getParent().isDragging();
    }

    if (this['draggable']) {
      return this['draggable'].isDragging();
    }

    return false;
  }
});

Geometry.include({
  startEdit: function startEdit(opts) {
    if (!this.getMap() || !this.options['editable']) {
      return this;
    }

    this.endEdit();
    this._editor = new GeometryEditor(this, opts);

    this._editor.start();

    this.fire('editstart');
    return this;
  },
  endEdit: function endEdit() {
    if (this._editor) {
      this._editor.stop();

      delete this._editor;
      this.fire('editend');
    }

    return this;
  },
  redoEdit: function redoEdit() {
    if (!this.isEditing()) {
      return this;
    }

    this._editor.redo();

    this.fire('redoedit');
    return this;
  },
  undoEdit: function undoEdit() {
    if (!this.isEditing()) {
      return this;
    }

    this._editor.undo();

    this.fire('undoedit');
    return this;
  },
  cancelEdit: function cancelEdit() {
    if (!this.isEditing()) {
      return this;
    }

    this._editor.cancel();

    this.fire('canceledit');
    return this;
  },
  isEditing: function isEditing() {
    if (this._editor) {
      return this._editor.isEditing();
    }

    return false;
  }
});

Geometry.include({
  _onEvent: function _onEvent(event, type) {
    if (!this.getMap()) {
      return;
    }

    var eventType = type || this._getEventTypeToFire(event);

    if (eventType === 'contextmenu' && this.listens('contextmenu')) {
      stopPropagation(event);
      preventDefault(event);
    }

    var params = this._getEventParams(event);

    this._fireEvent(eventType, params);
  },
  _getEventTypeToFire: function _getEventTypeToFire(domEvent) {
    return domEvent.type;
  },
  _getEventParams: function _getEventParams(e) {
    var map = this.getMap();
    var eventParam = {
      'domEvent': e
    };
    var actual = e.touches && e.touches.length > 0 ? e.touches[0] : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;

    if (actual) {
      var containerPoint = getEventContainerPoint(actual, map._containerDOM);
      eventParam['coordinate'] = map.containerPointToCoordinate(containerPoint);
      eventParam['containerPoint'] = containerPoint;
      eventParam['viewPoint'] = map.containerPointToViewPoint(containerPoint);
      eventParam['pont2d'] = map._containerPointToPoint(containerPoint);
    }

    return eventParam;
  }
});

Geometry.include({
  setInfoWindow: function setInfoWindow(options) {
    this.removeInfoWindow();

    if (options instanceof InfoWindow) {
      this._infoWindow = options;
      this._infoWinOptions = extend({}, this._infoWindow.options);

      this._infoWindow.addTo(this);

      return this;
    }

    this._infoWinOptions = extend({}, options);

    if (this._infoWindow) {
      this._infoWindow.setOptions(options);
    } else if (this.getMap()) {
      this._bindInfoWindow(this._infoWinOptions);
    }

    return this;
  },
  getInfoWindow: function getInfoWindow() {
    if (!this._infoWindow) {
      return null;
    }

    return this._infoWindow;
  },
  openInfoWindow: function openInfoWindow(coordinate) {
    if (!this.getMap()) {
      return this;
    }

    if (!coordinate) {
      coordinate = this.getCenter();
    }

    if (!this._infoWindow) {
      if (this._infoWinOptions && this.getMap()) {
        this._bindInfoWindow(this._infoWinOptions);

        this._infoWindow.show(coordinate);
      }
    } else {
      this._infoWindow.show(coordinate);
    }

    return this;
  },
  closeInfoWindow: function closeInfoWindow() {
    if (this._infoWindow) {
      this._infoWindow.hide();
    }

    return this;
  },
  removeInfoWindow: function removeInfoWindow() {
    this._unbindInfoWindow();

    delete this._infoWinOptions;
    delete this._infoWindow;
    return this;
  },
  _bindInfoWindow: function _bindInfoWindow(options) {
    this._infoWindow = new InfoWindow(options);

    this._infoWindow.addTo(this);

    return this;
  },
  _unbindInfoWindow: function _unbindInfoWindow() {
    if (this._infoWindow) {
      this.closeInfoWindow();

      this._infoWindow.remove();

      delete this._infoWindow;
    }

    return this;
  }
});

var LRUCache = function () {
  function LRUCache(max, onRemove) {
    this.max = max;
    this.onRemove = onRemove;
    this.reset();
  }

  var _proto = LRUCache.prototype;

  _proto.reset = function reset() {
    for (var key in this.data) {
      this.onRemove(this.data[key]);
    }

    this.data = {};
    this.order = [];
    return this;
  };

  _proto.clear = function clear() {
    this.reset();
    delete this.onRemove;
  };

  _proto.add = function add(key, data) {
    if (this.has(key)) {
      this.order.splice(this.order.indexOf(key), 1);
      this.data[key] = data;
      this.order.push(key);
    } else {
      this.data[key] = data;
      this.order.push(key);

      if (this.order.length > this.max) {
        var removedData = this.getAndRemove(this.order[0]);
        if (removedData) this.onRemove(removedData);
      }
    }

    return this;
  };

  _proto.has = function has(key) {
    return key in this.data;
  };

  _proto.keys = function keys() {
    return this.order;
  };

  _proto.getAndRemove = function getAndRemove(key) {
    if (!this.has(key)) {
      return null;
    }

    var data = this.data[key];
    delete this.data[key];
    this.order.splice(this.order.indexOf(key), 1);
    return data;
  };

  _proto.get = function get(key) {
    if (!this.has(key)) {
      return null;
    }

    var data = this.data[key];
    return data;
  };

  _proto.remove = function remove(key) {
    if (!this.has(key)) {
      return this;
    }

    var data = this.data[key];
    delete this.data[key];
    this.onRemove(data);
    this.order.splice(this.order.indexOf(key), 1);
    return this;
  };

  _proto.setMaxSize = function setMaxSize(max) {
    this.max = max;

    while (this.order.length > this.max) {
      var removedData = this.getAndRemove(this.order[0]);
      if (removedData) this.onRemove(removedData);
    }

    return this;
  };

  return LRUCache;
}();

var TEMP_POINT$3 = new Point(0, 0);
var TEMP_POINT1$2 = new Point(0, 0);
var TEMP_POINT2$1 = new Point(0, 0);

var TileLayerCanvasRenderer = function (_CanvasRenderer) {
  _inheritsLoose(TileLayerCanvasRenderer, _CanvasRenderer);

  function TileLayerCanvasRenderer(layer) {
    var _this;

    _this = _CanvasRenderer.call(this, layer) || this;
    _this.tilesInView = {};
    _this.tilesLoading = {};
    _this._parentTiles = [];
    _this._childTiles = [];
    _this.tileCache = new LRUCache(layer.options['maxCacheSize'], _this.deleteTile.bind(_assertThisInitialized(_assertThisInitialized(_this))));
    return _this;
  }

  var _proto = TileLayerCanvasRenderer.prototype;

  _proto.getCurrentTileZoom = function getCurrentTileZoom() {
    return this._tileZoom;
  };

  _proto.draw = function draw() {
    var map = this.getMap();

    if (!this.isDrawable()) {
      return;
    }

    var mask2DExtent = this.prepareCanvas();

    if (mask2DExtent) {
      if (!mask2DExtent.intersects(this.canvasExtent2D)) {
        this.completeRender();
        return;
      }
    }

    var layer = this.layer;
    var tileGrids = layer.getTiles().tileGrids;

    if (!tileGrids || !tileGrids.length) {
      this.completeRender();
      return;
    }

    var loadingCount = 0;
    var loading = false;
    var checkedTiles = {};
    var tiles = [],
        parentTiles = [],
        parentKeys = {},
        childTiles = [],
        childKeys = {},
        placeholders = [],
        placeholderKeys = {};
    var tileQueue = {};

    var preLoadingCount = this._markTiles(),
        loadingLimit = this._getLoadLimit();

    var l = tileGrids.length;
    this._tileZoom = tileGrids[0]['zoom'];
    this._tileOffset = tileGrids[0]['offset'];

    for (var i = 0; i < l; i++) {
      var tileGrid = tileGrids[i];
      var allTiles = tileGrid['tiles'];

      var placeholder = this._generatePlaceHolder(tileGrid.zoom);

      for (var _i = 0, _l = allTiles.length; _i < _l; _i++) {
        var tile = allTiles[_i],
            tileId = tile['id'];
        var tileLoading = false;

        if (this._isLoadingTile(tileId)) {
          tileLoading = loading = true;
          this.tilesLoading[tileId].current = true;
        } else {
          var cached = this._getCachedTile(tileId);

          if (cached) {
            if (cached.image && this.getTileOpacity(cached.image) < 1) {
              tileLoading = loading = true;
            }

            tiles.push(cached);
          } else {
            tileLoading = loading = true;
            var hitLimit = loadingLimit && loadingCount + preLoadingCount[0] > loadingLimit;

            if (!hitLimit && (!map.isInteracting() || map.isMoving() || map.isRotating())) {
              loadingCount++;
              tileQueue[tileId + '@' + tile['point'].toArray().join()] = tile;
            }
          }
        }

        if (!tileLoading) continue;

        if (checkedTiles[tileId]) {
          continue;
        }

        checkedTiles[tileId] = 1;

        if (placeholder && !placeholderKeys[tileId]) {
          tile.cache = false;
          placeholders.push({
            image: placeholder,
            info: tile
          });
          placeholderKeys[tileId] = 1;
        }

        var parentTile = this._findParentTile(tile);

        if (parentTile) {
          var parentId = parentTile.info.id;

          if (parentKeys[parentId] === undefined) {
            parentKeys[parentId] = parentTiles.length;
            parentTiles.push(parentTile);
          }
        } else if (!parentTiles.length) {
          var children = this._findChildTiles(tile);

          if (children.length) {
            children.forEach(function (c) {
              if (!childKeys[c.info.id]) {
                childTiles.push(c);
                childKeys[c.info.id] = 1;
              }
            });
          }
        }
      }
    }

    if (parentTiles.length) {
      childTiles.length = 0;
      this._childTiles.length = 0;
    }

    this._drawTiles(tiles, parentTiles, childTiles, placeholders);

    if (!loadingCount) {
      if (!loading) {
        if (!map.isAnimating() && (this._parentTiles.length || this._childTiles.length)) {
          this._parentTiles = [];
          this._childTiles = [];
          this.setToRedraw();
        }

        this.completeRender();
      }
    } else {
      this.loadTileQueue(tileQueue);
    }

    this._retireTiles();
  };

  _proto.isTileCachedOrLoading = function isTileCachedOrLoading(tileId) {
    return this.tilesLoading[tileId] || this.tilesInView[tileId] || this.tileCache.get(tileId);
  };

  _proto._drawTiles = function _drawTiles(tiles, parentTiles, childTiles, placeholders) {
    var _this2 = this;

    if (parentTiles.length) {
      parentTiles.sort(function (t1, t2) {
        return Math.abs(t2.info.z - _this2._tileZoom) - Math.abs(t1.info.z - _this2._tileZoom);
      });
      this._parentTiles = parentTiles;
    }

    if (childTiles.length) {
      this._childTiles = childTiles;
    }

    var context = {
      tiles: tiles,
      parentTiles: this._parentTiles,
      childTiles: this._childTiles
    };
    this.onDrawTileStart(context);

    this._parentTiles.forEach(function (t) {
      return _this2._drawTileAndCache(t);
    });

    this._childTiles.forEach(function (t) {
      return _this2._drawTileOffset(t.info, t.image);
    });

    placeholders.forEach(function (t) {
      return _this2._drawTileOffset(t.info, t.image);
    });
    var layer = this.layer,
        map = this.getMap();

    if (!layer.options['cascadeTiles'] || map.getPitch() <= map.options['cascadePitches'][0]) {
      tiles.forEach(function (t) {
        return _this2._drawTileAndCache(t);
      });
    } else {
      this.writeZoomStencil();
      var started = false;

      for (var i = 0, l = tiles.length; i < l; i++) {
        if (tiles[i].info.z !== this._tileZoom) {
          if (!started) {
            this.startZoomStencilTest();
            started = true;
          } else {
            this.resumeZoomStencilTest();
          }
        } else if (started) {
          this.pauseZoomStencilTest();
        }

        this._drawTileAndCache(tiles[i]);
      }

      this.endZoomStencilTest();
    }

    this.onDrawTileEnd(context);
  };

  _proto.writeZoomStencil = function writeZoomStencil() {};

  _proto.startZoomStencilTest = function startZoomStencilTest() {};

  _proto.endZoomStencilTest = function endZoomStencilTest() {};

  _proto.pauseZoomStencilTest = function pauseZoomStencilTest() {};

  _proto.resumeZoomStencilTest = function resumeZoomStencilTest() {};

  _proto.onDrawTileStart = function onDrawTileStart() {};

  _proto.onDrawTileEnd = function onDrawTileEnd() {};

  _proto._drawTileOffset = function _drawTileOffset(info, image) {
    if (!image) {
      return;
    }

    var offset = this._tileOffset;

    if (!offset[0] && !offset[1]) {
      this.drawTile(info, image);
      return;
    }

    var map = this.getMap();

    var scale = map._getResolution(this._tileZoom) / map._getResolution(info.z);

    offset[0] *= scale;
    offset[1] *= scale;

    info.point._sub(offset);

    info.extent2d._sub(offset);

    this.drawTile(info, image);

    info.point._add(offset);

    info.extent2d._add(offset);

    offset[0] /= scale;
    offset[1] /= scale;
  };

  _proto._drawTileAndCache = function _drawTileAndCache(tile) {
    tile.current = true;
    this.tilesInView[tile.info.id] = tile;

    this._drawTileOffset(tile.info, tile.image);

    this.tileCache.add(tile.info.id, tile);
  };

  _proto.drawOnInteracting = function drawOnInteracting() {
    this.draw();
  };

  _proto.needToRedraw = function needToRedraw() {
    var map = this.getMap();

    if (map.getPitch()) {
      return _CanvasRenderer.prototype.needToRedraw.call(this);
    }

    if (map.isRotating() || map.isZooming()) {
      return true;
    }

    if (map.isMoving()) {
      return !!this.layer.options['forceRenderOnMoving'];
    }

    return _CanvasRenderer.prototype.needToRedraw.call(this);
  };

  _proto.hitDetect = function hitDetect() {
    return false;
  };

  _proto._getLoadLimit = function _getLoadLimit() {
    if (this.getMap().isInteracting()) {
      return this.layer.options['loadingLimitOnInteracting'];
    }

    return 0;
  };

  _proto.isDrawable = function isDrawable() {
    if (this.getMap().getPitch()) {
      if (console) {
        console.warn('TileLayer with canvas renderer can\'t be pitched, use gl renderer (\'renderer\' : \'gl\') instead.');
      }

      this.clear();
      return false;
    }

    return true;
  };

  _proto.clear = function clear() {
    this._retireTiles(true);

    this.tileCache.reset();
    this.tilesInView = {};
    this.tilesLoading = {};
    this._parentTiles = [];
    this._childTiles = [];

    _CanvasRenderer.prototype.clear.call(this);
  };

  _proto._isLoadingTile = function _isLoadingTile(tileId) {
    return !!this.tilesLoading[tileId];
  };

  _proto.clipCanvas = function clipCanvas(context) {
    return _CanvasRenderer.prototype.clipCanvas.call(this, context);
  };

  _proto._clipByPitch = function _clipByPitch(ctx) {
    var map = this.getMap();

    if (map.getPitch() <= map.options['maxVisualPitch']) {
      return false;
    }

    if (!this.layer.options['clipByPitch']) {
      return false;
    }

    var clipExtent = map.getContainerExtent();
    var r = map.getDevicePixelRatio();
    ctx.save();
    ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
    ctx.beginPath();
    ctx.rect(0, Math.ceil(clipExtent.ymin) * r, Math.ceil(clipExtent.getWidth()) * r, Math.ceil(clipExtent.getHeight()) * r);
    ctx.stroke();
    ctx.clip();
    return true;
  };

  _proto.loadTileQueue = function loadTileQueue(tileQueue) {
    for (var p in tileQueue) {
      if (tileQueue.hasOwnProperty(p)) {
        var tile = tileQueue[p];
        var tileImage = this.loadTile(tile);

        if (tileImage.loadTime === undefined) {
          this.tilesLoading[tile['id']] = {
            image: tileImage,
            current: true,
            info: tile
          };
        }
      }
    }
  };

  _proto.loadTile = function loadTile(tile) {
    var tileSize = this.layer.getTileSize();
    var tileImage = new Image();
    tileImage.width = tileSize['width'];
    tileImage.height = tileSize['height'];
    tileImage.onload = this.onTileLoad.bind(this, tileImage, tile);
    tileImage.onerror = this.onTileError.bind(this, tileImage, tile);
    this.loadTileImage(tileImage, tile['url']);
    return tileImage;
  };

  _proto.loadTileImage = function loadTileImage(tileImage, url) {
    var crossOrigin = this.layer.options['crossOrigin'];

    if (!isNil(crossOrigin)) {
      tileImage.crossOrigin = crossOrigin;
    }

    return loadImage(tileImage, [url]);
  };

  _proto.abortTileLoading = function abortTileLoading(tileImage) {
    if (!tileImage) return;
    tileImage.onload = falseFn;
    tileImage.onerror = falseFn;
    tileImage.src = emptyImageUrl;
  };

  _proto.onTileLoad = function onTileLoad(tileImage, tileInfo) {
    if (!this.layer) {
      return;
    }

    var id = tileInfo['id'];

    if (!this.tilesInView) {
      return;
    }

    var e = {
      tile: tileInfo,
      tileImage: tileImage
    };
    this.layer.fire('tileload', e);
    tileImage = e.tileImage;
    tileImage.loadTime = now();
    delete this.tilesLoading[id];

    this._addTileToCache(tileInfo, tileImage);

    this.setToRedraw();
  };

  _proto.onTileError = function onTileError(tileImage, tileInfo) {
    if (!this.layer) {
      return;
    }

    tileImage.onerrorTick = tileImage.onerrorTick || 0;
    var tileRetryCount = this.layer.options['tileRetryCount'];

    if (tileRetryCount > tileImage.onerrorTick) {
      tileImage.onerrorTick++;
      tileImage.src = tileInfo.url;
      return;
    }

    if (tileImage instanceof Image) {
      this.abortTileLoading(tileImage, tileInfo);
    }

    tileImage.loadTime = 0;
    delete this.tilesLoading[tileInfo['id']];

    this._addTileToCache(tileInfo, tileImage);

    this.setToRedraw();
    this.layer.fire('tileerror', {
      tile: tileInfo
    });
  };

  _proto.drawTile = function drawTile(tileInfo, tileImage) {
    if (!tileImage || !this.getMap()) {
      return;
    }

    var point = tileInfo.point,
        tileZoom = tileInfo.z,
        tileId = tileInfo.id;

    var map = this.getMap(),
        tileSize = tileInfo.size,
        zoom = map.getZoom(),
        ctx = this.context,
        cp = map._pointToContainerPoint(point, tileZoom, 0, TEMP_POINT$3),
        bearing = map.getBearing(),
        transformed = bearing || zoom !== tileZoom;

    var opacity = this.getTileOpacity(tileImage);
    var alpha = ctx.globalAlpha;

    if (opacity < 1) {
      ctx.globalAlpha = opacity;
      this.setToRedraw();
    }

    if (!transformed) {
      cp._round();
    }

    var x = cp.x,
        y = cp.y;
    var w = tileSize[0],
        h = tileSize[1];

    if (transformed) {
      ctx.save();
      ctx.translate(x, y);

      if (bearing) {
        ctx.rotate(-bearing * Math.PI / 180);
        w += 0.1;
        h += 0.1;
      }

      if (zoom !== tileZoom) {
        var scale = map._getResolution(tileZoom) / map._getResolution();

        ctx.scale(scale, scale);
      }

      x = y = 0;
    }

    Canvas.image(ctx, tileImage, x, y, w, h);

    if (this.layer.options['debug']) {
      var color = this.layer.options['debugOutline'];
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.strokeWidth = 10;
      ctx.font = '20px monospace';

      var _point = new Point(x, y);

      Canvas.rectangle(ctx, _point, {
        width: w,
        height: h
      }, 1, 0);
      Canvas.fillText(ctx, this.getDebugInfo(tileId), _point._add(10, 20), color);
      Canvas.drawCross(ctx, x + w / 2, y + h / 2, 2, color);
      ctx.restore();
    }

    if (transformed) {
      ctx.restore();
    }

    if (ctx.globalAlpha !== alpha) {
      ctx.globalAlpha = alpha;
    }

    this.setCanvasUpdated();
  };

  _proto.getDebugInfo = function getDebugInfo(tileId) {
    var xyz = tileId.split('_');
    var length = xyz.length;
    return 'x:' + xyz[length - 2] + ', y:' + xyz[length - 3] + ', z:' + xyz[length - 1];
  };

  _proto._findChildTiles = function _findChildTiles(info) {
    var layer = this._getLayerOfTile(info.layer);

    if (!layer.options['background']) {
      return [];
    }

    var map = this.getMap();
    var children = [];

    var min = info.extent2d.getMin(),
        max = info.extent2d.getMax(),
        pmin = layer._project(map._pointToPrj(min, info.z, TEMP_POINT1$2), TEMP_POINT1$2),
        pmax = layer._project(map._pointToPrj(max, info.z, TEMP_POINT2$1), TEMP_POINT2$1);

    var zoomDiff = 2;

    for (var i = 1; i < zoomDiff; i++) {
      this._findChildTilesAt(children, pmin, pmax, layer, info.z + i);
    }

    return children;
  };

  _proto._findChildTilesAt = function _findChildTilesAt(children, pmin, pmax, layer, childZoom) {
    var zoomOffset = layer.options['zoomOffset'];
    var layerId = layer.getId(),
        res = layer.getSpatialReference().getResolution(childZoom + zoomOffset);

    if (!res) {
      return;
    }

    var dmin = layer._getTileConfig().getTileIndex(pmin, res),
        dmax = layer._getTileConfig().getTileIndex(pmax, res);

    var sx = Math.min(dmin.idx, dmax.idx),
        ex = Math.max(dmin.idx, dmax.idx);
    var sy = Math.min(dmin.idy, dmax.idy),
        ey = Math.max(dmin.idy, dmax.idy);
    var id, tile;

    for (var i = sx; i < ex; i++) {
      for (var ii = sy; ii < ey; ii++) {
        id = layer._getTileId(i, ii, childZoom + zoomOffset, layerId);

        if (this.tileCache.has(id)) {
          tile = this.tileCache.getAndRemove(id);
          children.push(tile);
          this.tileCache.add(id, tile);
        }
      }
    }
  };

  _proto._findParentTile = function _findParentTile(info) {
    var map = this.getMap(),
        layer = this._getLayerOfTile(info.layer);

    if (!layer.options['background']) {
      return null;
    }

    var sr = layer.getSpatialReference();
    var d = sr.getZoomDirection(),
        zoomOffset = layer.options['zoomOffset'],
        zoomDiff = layer.options['backgroundZoomDiff'];

    var center = info.extent2d.getCenter(),
        prj = layer._project(map._pointToPrj(center, info.z));

    for (var diff = 1; diff <= zoomDiff; diff++) {
      var z = info.z - d * diff;
      var res = sr.getResolution(z + zoomOffset);
      if (!res) continue;

      var tileIndex = layer._getTileConfig().getTileIndex(prj, res);

      var id = layer._getTileId(tileIndex.x, tileIndex.y, z + zoomOffset, info.layer);

      if (this.tileCache.has(id)) {
        var tile = this.tileCache.getAndRemove(id);
        this.tileCache.add(id, tile);
        return tile;
      }
    }

    return null;
  };

  _proto._getLayerOfTile = function _getLayerOfTile(layerId) {
    return this.layer.getChildLayer ? this.layer.getChildLayer(layerId) : this.layer;
  };

  _proto._getCachedTile = function _getCachedTile(tileId) {
    var tilesInView = this.tilesInView;
    var cached = this.tileCache.getAndRemove(tileId);

    if (cached) {
      tilesInView[tileId] = cached;
      var tilesLoading = this.tilesLoading;

      if (tilesLoading && tilesLoading[tileId]) {
        tilesLoading[tileId].current = false;
        var _tilesLoading$tileId = tilesLoading[tileId],
            image = _tilesLoading$tileId.image,
            info = _tilesLoading$tileId.info;
        this.abortTileLoading(image, info);
        console.log('_getCachedTile');
        delete tilesLoading[tileId];
      }
    } else {
      cached = tilesInView[tileId];
    }

    return cached;
  };

  _proto._addTileToCache = function _addTileToCache(tileInfo, tileImage) {
    this.tilesInView[tileInfo.id] = {
      image: tileImage,
      current: true,
      info: tileInfo
    };
  };

  _proto.getTileOpacity = function getTileOpacity(tileImage) {
    if (!this.layer.options['fadeAnimation'] || !tileImage.loadTime) {
      return 1;
    }

    return Math.min(1, (now() - tileImage.loadTime) / (1000 / 60 * 10));
  };

  _proto.onRemove = function onRemove() {
    this.clear();
    delete this.tileCache;
    delete this._tilePlaceHolder;

    _CanvasRenderer.prototype.onRemove.call(this);
  };

  _proto._markTiles = function _markTiles() {
    var a = 0,
        b = 0;

    if (this.tilesLoading) {
      for (var p in this.tilesLoading) {
        this.tilesLoading[p].current = false;
        a++;
      }
    }

    if (this.tilesInView) {
      for (var _p in this.tilesInView) {
        this.tilesInView[_p].current = false;
        b++;
      }
    }

    return [a, b];
  };

  _proto._retireTiles = function _retireTiles(force) {
    for (var i in this.tilesLoading) {
      var tile = this.tilesLoading[i];

      if (force || !tile.current) {
        if (tile.image) {
          this.abortTileLoading(tile.image, tile.info);
        }

        this.deleteTile(tile);
        delete this.tilesLoading[i];
      }
    }

    for (var _i2 in this.tilesInView) {
      var _tile = this.tilesInView[_i2];

      if (!_tile.current) {
        delete this.tilesInView[_i2];

        if (!this.tileCache.has(_i2)) {
          this.deleteTile(_tile);
        }
      }
    }
  };

  _proto.deleteTile = function deleteTile(tile) {
    if (!tile || !tile.image) {
      return;
    }

    tile.image.onload = null;
    tile.image.onerror = null;
  };

  _proto._generatePlaceHolder = function _generatePlaceHolder(z) {
    var map = this.getMap();
    var placeholder = this.layer.options['placeholder'];

    if (!placeholder || map.getPitch()) {
      return null;
    }

    var tileSize = this.layer.getTileSize(),
        scale = map._getResolution(z) / map._getResolution(),
        canvas = this._tilePlaceHolder = this._tilePlaceHolder || Canvas.createCanvas(1, 1);

    canvas.width = tileSize.width * scale;
    canvas.height = tileSize.height * scale;

    if (isFunction(placeholder)) {
      placeholder(canvas);
    } else {
      defaultPlaceholder(canvas);
    }

    return canvas;
  };

  return TileLayerCanvasRenderer;
}(CanvasRenderer);

TileLayer.registerRenderer('canvas', TileLayerCanvasRenderer);

function falseFn() {
  return false;
}

function defaultPlaceholder(canvas) {
  var ctx = canvas.getContext('2d'),
      cw = canvas.width,
      ch = canvas.height,
      w = cw / 16,
      h = ch / 16;
  ctx.beginPath();

  for (var i = 0; i < 16; i++) {
    ctx.moveTo(0, i * h);
    ctx.lineTo(cw, i * h);
    ctx.moveTo(i * w, 0);
    ctx.lineTo(i * w, ch);
  }

  ctx.strokeStyle = 'rgba(180, 180, 180, 0.1)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.beginPath();
  var path = [[0, 0], [cw, 0], [0, ch], [cw, ch], [0, 0], [0, ch], [cw, 0], [cw, ch], [0, ch / 2], [cw, ch / 2], [cw / 2, 0], [cw / 2, ch]];

  for (var _i3 = 1; _i3 < path.length; _i3 += 2) {
    ctx.moveTo(path[_i3 - 1][0], path[_i3 - 1][1]);
    ctx.lineTo(path[_i3][0], path[_i3][1]);
  }

  ctx.lineWidth = 1 * 4;
  ctx.stroke();
}

var TileLayerGLRenderer = function (_ImageGLRenderable) {
  _inheritsLoose(TileLayerGLRenderer, _ImageGLRenderable);

  function TileLayerGLRenderer() {
    return _ImageGLRenderable.apply(this, arguments) || this;
  }

  var _proto = TileLayerGLRenderer.prototype;

  _proto.isDrawable = function isDrawable() {
    return true;
  };

  _proto.needToRedraw = function needToRedraw() {
    var map = this.getMap();

    if (this._gl() && !map.getPitch() && map.isZooming() && !map.isMoving() && !map.isRotating()) {
      return true;
    }

    return _ImageGLRenderable.prototype.needToRedraw.call(this);
  };

  _proto.drawTile = function drawTile(tileInfo, tileImage) {
    var map = this.getMap();

    if (!tileInfo || !map || !tileImage) {
      return;
    }

    var scale = tileInfo._glScale = tileInfo._glScale || map.getGLScale(tileInfo.z),
        w = tileInfo.size[0],
        h = tileInfo.size[1];

    if (tileInfo.cache !== false) {
      this._bindGLBuffer(tileImage, w, h);
    }

    if (!this._gl()) {
      _ImageGLRenderable.prototype.drawTile.call(this, tileInfo, tileImage);

      return;
    }

    var point = tileInfo.point;
    var x = point.x * scale,
        y = point.y * scale;
    var opacity = this.getTileOpacity(tileImage);
    var debugInfo = null;

    if (this.layer.options['debug']) {
      debugInfo = this.getDebugInfo(tileInfo.id);
    }

    this.drawGLImage(tileImage, x, y, w, h, scale, opacity, debugInfo);

    if (opacity < 1) {
      this.setToRedraw();
    } else {
      this.setCanvasUpdated();
    }
  };

  _proto.writeZoomStencil = function writeZoomStencil() {
    var gl = this.gl;
    gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
  };

  _proto.startZoomStencilTest = function startZoomStencilTest() {
    var gl = this.gl;
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilFunc(gl.EQUAL, 0, 0xFF);
  };

  _proto.endZoomStencilTest = function endZoomStencilTest() {
    this.pauseZoomStencilTest();
  };

  _proto.pauseZoomStencilTest = function pauseZoomStencilTest() {
    var gl = this.gl;
    gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
  };

  _proto.resumeZoomStencilTest = function resumeZoomStencilTest() {
    var gl = this.gl;
    gl.stencilFunc(gl.EQUAL, 0, 0xFF);
  };

  _proto._bindGLBuffer = function _bindGLBuffer(image, w, h) {
    if (!image.glBuffer) {
      image.glBuffer = this.bufferTileData(0, 0, w, h);
    }
  };

  _proto.loadTileImage = function loadTileImage(tileImage, url) {
    var crossOrigin = this.layer.options['crossOrigin'];
    tileImage.crossOrigin = crossOrigin !== null ? crossOrigin : '';
    tileImage.src = url;
    return;
  };

  _proto.onCanvasCreate = function onCanvasCreate() {
    if (!this.canvas.gl || !this.canvas.gl.wrap) {
      this.createCanvas2();
    }
  };

  _proto.createContext = function createContext() {
    _ImageGLRenderable.prototype.createContext.call(this);

    this.createGLContext();
  };

  _proto.resizeCanvas = function resizeCanvas(canvasSize) {
    if (!this.canvas) {
      return;
    }

    _ImageGLRenderable.prototype.resizeCanvas.call(this, canvasSize);

    this.resizeGLCanvas();
  };

  _proto.clearCanvas = function clearCanvas() {
    if (!this.canvas) {
      return;
    }

    _ImageGLRenderable.prototype.clearCanvas.call(this);

    this.clearGLCanvas();
  };

  _proto.getCanvasImage = function getCanvasImage() {
    if (!this._gl() || !this.canvas2) {
      return _ImageGLRenderable.prototype.getCanvasImage.call(this);
    }

    var img = _ImageGLRenderable.prototype.getCanvasImage.call(this);

    if (img) {
      img.image = this.canvas2;
    }

    return img;
  };

  _proto._gl = function _gl() {
    if (this.canvas.gl && this.canvas.gl.wrap) {
      return true;
    }

    var map = this.getMap();
    return map && (map.getPitch() || map.getBearing()) || this.layer && !!this.layer.options['fragmentShader'];
  };

  _proto.deleteTile = function deleteTile(tile) {
    _ImageGLRenderable.prototype.deleteTile.call(this, tile);

    if (tile && tile.image) {
      this.disposeImage(tile.image);
    }

    delete tile.image;
  };

  _proto.onRemove = function onRemove() {
    _ImageGLRenderable.prototype.onRemove.call(this);

    this.removeGLCanvas();
  };

  return TileLayerGLRenderer;
}(ImageGLRenderable(TileLayerCanvasRenderer));

TileLayer.registerRenderer('gl', TileLayerGLRenderer);

function _loadTile(tile) {
  var tileSize = this.layer.getTileSize(),
      canvasClass = this.canvas.constructor,
      map = this.getMap();
  var r = map.getDevicePixelRatio();
  var tileCanvas = Canvas.createCanvas(tileSize['width'] * r, tileSize['height'] * r, canvasClass);
  tileCanvas['layer'] = this.layer;
  var me = this;
  var extent = new Extent(map.pointToCoordinate(tile['point']), map.pointToCoordinate(tile['point'].add(tileSize.toPoint())), map.getProjection());
  this.layer.drawTile(tileCanvas, {
    'url': tile['url'],
    'point': tile['point'],
    'center': map.pointToCoordinate(tile['point'].add(tileSize['width'] / 2, tileSize['height'] / 2)),
    'extent': extent,
    'z': tile['z'],
    'x': tile['x'],
    'y': tile['y']
  }, function (error) {
    if (error) {
      me.onTileError(tileCanvas, tile);
      return;
    }

    me.onTileLoad(tileCanvas, tile);
  });
  return tileCanvas;
}

var CanvasRenderer$1 = function (_TileLayerCanvasRende) {
  _inheritsLoose(CanvasRenderer, _TileLayerCanvasRende);

  function CanvasRenderer() {
    return _TileLayerCanvasRende.apply(this, arguments) || this;
  }

  var _proto = CanvasRenderer.prototype;

  _proto.loadTile = function loadTile() {
    return _loadTile.apply(this, arguments);
  };

  return CanvasRenderer;
}(TileLayerCanvasRenderer);

var GLRenderer = function (_TileLayerGLRenderer) {
  _inheritsLoose(GLRenderer, _TileLayerGLRenderer);

  function GLRenderer() {
    return _TileLayerGLRenderer.apply(this, arguments) || this;
  }

  var _proto2 = GLRenderer.prototype;

  _proto2.loadTile = function loadTile() {
    return _loadTile.apply(this, arguments);
  };

  return GLRenderer;
}(TileLayerGLRenderer);

CanvasTileLayer.registerRenderer('canvas', CanvasRenderer$1);
CanvasTileLayer.registerRenderer('gl', GLRenderer);

var OverlayLayerRenderer = function (_CanvasRenderer) {
  _inheritsLoose(OverlayLayerRenderer, _CanvasRenderer);

  function OverlayLayerRenderer() {
    return _CanvasRenderer.apply(this, arguments) || this;
  }

  var _proto = OverlayLayerRenderer.prototype;

  _proto.checkResources = function checkResources() {
    var geometries = this._geosToCheck;

    if (!this._resourceChecked && !geometries) {
      geometries = this.layer._geoList;
    }

    if (!isArrayHasData(geometries)) {
      return [];
    }

    var resources = [];
    var cache = {};

    for (var i = geometries.length - 1; i >= 0; i--) {
      var geo = geometries[i];

      var res = geo._getExternalResources();

      if (!res.length) {
        continue;
      }

      if (!this.resources) {
        resources.push.apply(resources, res);
      } else {
        for (var _i = 0; _i < res.length; _i++) {
          var url = res[_i][0];

          if (!this.resources.isResourceLoaded(res[_i]) && !cache[url]) {
            resources.push(res[_i]);
            cache[url] = 1;
          }
        }
      }
    }

    this._resourceChecked = true;
    delete this._geosToCheck;
    return resources;
  };

  _proto.render = function render() {
    this.layer._sortGeometries();

    return _CanvasRenderer.prototype.render.apply(this, arguments);
  };

  _proto._addGeoToCheckRes = function _addGeoToCheckRes(res) {
    if (!res) {
      return;
    }

    if (!Array.isArray(res)) {
      res = [res];
    }

    if (!this._geosToCheck) {
      this._geosToCheck = [];
    }

    pushIn(this._geosToCheck, res);
  };

  _proto.onGeometryAdd = function onGeometryAdd(geometries) {
    this._addGeoToCheckRes(geometries);

    redraw(this);
  };

  _proto.onGeometryRemove = function onGeometryRemove() {
    redraw(this);
  };

  _proto.onGeometrySymbolChange = function onGeometrySymbolChange(e) {
    this._addGeoToCheckRes(e.target);

    redraw(this);
  };

  _proto.onGeometryShapeChange = function onGeometryShapeChange() {
    redraw(this);
  };

  _proto.onGeometryPositionChange = function onGeometryPositionChange() {
    redraw(this);
  };

  _proto.onGeometryZIndexChange = function onGeometryZIndexChange() {
    redraw(this);
  };

  _proto.onGeometryShow = function onGeometryShow() {
    redraw(this);
  };

  _proto.onGeometryHide = function onGeometryHide() {
    redraw(this);
  };

  _proto.onGeometryPropertiesChange = function onGeometryPropertiesChange() {
    redraw(this);
  };

  return OverlayLayerRenderer;
}(CanvasRenderer);

function redraw(renderer) {
  if (renderer.layer.options['drawImmediate']) {
    renderer.render();
  }

  renderer.setToRedraw();
}

var TEMP_EXTENT$4 = new PointExtent();

var VectorLayerRenderer = function (_OverlayLayerCanvasRe) {
  _inheritsLoose(VectorLayerRenderer, _OverlayLayerCanvasRe);

  function VectorLayerRenderer() {
    return _OverlayLayerCanvasRe.apply(this, arguments) || this;
  }

  var _proto = VectorLayerRenderer.prototype;

  _proto.checkResources = function checkResources() {
    var _this = this;

    var resources = _OverlayLayerCanvasRe.prototype.checkResources.apply(this, arguments);

    var style = this.layer.getStyle();

    if (style) {
      if (!Array.isArray(style)) {
        style = [style];
      }

      style.forEach(function (s) {
        var res = getExternalResources(s['symbol'], true);

        for (var i = 0, l = res.length; i < l; i++) {
          if (!_this.resources.isResourceLoaded(res[i])) {
            resources.push(res[i]);
          }
        }
      });
    }

    return resources;
  };

  _proto.needToRedraw = function needToRedraw() {
    var map = this.getMap();

    if (map.isInteracting() && this.layer.options['enableAltitude']) {
      return true;
    }

    if (map.isZooming() && !map.isRotating() && !map.getPitch() && !this._hasPoint && this.layer.constructor === VectorLayer) {
      return false;
    }

    return _OverlayLayerCanvasRe.prototype.needToRedraw.call(this);
  };

  _proto.draw = function draw() {
    if (!this.getMap()) {
      return;
    }

    if (!this.layer.isVisible() || this.layer.isEmpty()) {
      this.clearCanvas();
      this.completeRender();
      return;
    }

    this.prepareCanvas();
    this.drawGeos();
    this.completeRender();
  };

  _proto.isBlank = function isBlank() {
    if (!this.context) {
      return false;
    }

    return !this.context.canvas._drawn;
  };

  _proto.drawOnInteracting = function drawOnInteracting() {
    if (!this._geosToDraw) {
      return;
    }

    this._updateDisplayExtent();

    var map = this.getMap();
    var count = this.layer.getCount();
    var res = this.getMap().getResolution();

    if (map.isZooming() && map.options['seamlessZoom'] && this._drawnRes !== undefined && res > this._drawnRes * 1.5 && this._geosToDraw.length < count || map.isMoving() || map.isInteracting()) {
      this.prepareToDraw();
      this.forEachGeo(this.checkGeo, this);
      this._drawnRes = res;
    }

    for (var i = 0, l = this._geosToDraw.length; i < l; i++) {
      var geo = this._geosToDraw[i];

      if (!geo.isVisible()) {
        continue;
      }

      geo._paint(this._displayExtent);
    }
  };

  _proto.show = function show() {
    this.layer.forEach(function (geo) {
      geo._repaint();
    });

    _OverlayLayerCanvasRe.prototype.show.apply(this, arguments);
  };

  _proto.forEachGeo = function forEachGeo(fn, context) {
    this.layer.forEach(fn, context);
  };

  _proto.drawGeos = function drawGeos() {
    this._drawnRes = this.getMap().getResolution();

    this._updateDisplayExtent();

    this.prepareToDraw();
    this.forEachGeo(this.checkGeo, this);

    for (var i = 0, len = this._geosToDraw.length; i < len; i++) {
      this._geosToDraw[i]._paint();
    }
  };

  _proto.prepareToDraw = function prepareToDraw() {
    this._hasPoint = false;
    this._geosToDraw = [];
  };

  _proto.checkGeo = function checkGeo(geo) {
    if (!geo || !geo.isVisible() || !geo.getMap() || !geo.getLayer() || !geo.getLayer().isCanvasRender()) {
      return;
    }

    var painter = geo._getPainter();

    var extent2D = painter.get2DExtent(this.resources, TEMP_EXTENT$4);

    if (!extent2D || !extent2D.intersects(this._displayExtent)) {
      return;
    }

    if (painter.hasPoint()) {
      this._hasPoint = true;
    }

    this._geosToDraw.push(geo);
  };

  _proto.onZoomEnd = function onZoomEnd() {
    delete this.canvasExtent2D;

    _OverlayLayerCanvasRe.prototype.onZoomEnd.apply(this, arguments);
  };

  _proto.onRemove = function onRemove() {
    this.forEachGeo(function (g) {
      g.onHide();
    });
    delete this._geosToDraw;
  };

  _proto.onGeometryPropertiesChange = function onGeometryPropertiesChange(param) {
    if (param) {
      this.layer._styleGeometry(param['target']);
    }

    _OverlayLayerCanvasRe.prototype.onGeometryPropertiesChange.call(this, param);
  };

  _proto._updateDisplayExtent = function _updateDisplayExtent() {
    var extent2D = this.canvasExtent2D;

    if (this._maskExtent) {
      if (!this._maskExtent.intersects(extent2D)) {
        this.completeRender();
        return;
      }

      extent2D = extent2D.intersection(this._maskExtent);
    }

    this._displayExtent = extent2D;
  };

  _proto.identify = function identify(coordinate, options) {
    if (options === void 0) {
      options = {};
    }

    var geometries = this._geosToDraw;

    if (!geometries) {
      return [];
    }

    return this.layer._hitGeos(geometries, coordinate, options);
  };

  return VectorLayerRenderer;
}(OverlayLayerRenderer);

VectorLayer.registerRenderer('canvas', VectorLayerRenderer);

var MapRenderer = function (_Class) {
  _inheritsLoose(MapRenderer, _Class);

  function MapRenderer(map) {
    var _this;

    _this = _Class.call(this) || this;
    _this.map = map;
    _this._handlerQueue = {};
    return _this;
  }

  var _proto = MapRenderer.prototype;

  _proto.callInNextFrame = function callInNextFrame(fn) {
    this._handlerQueue.push(fn);
  };

  _proto.executeFrameCallbacks = function executeFrameCallbacks() {
    var running = this._handlerQueue;
    this._handlerQueue = [];

    for (var i = 0, l = running.length; i < l; i++) {
      running[i]();
    }
  };

  _proto.offsetPlatform = function offsetPlatform(offset, force) {
    if (!this.map._panels.front) {
      return this;
    }

    if (!force && offset.x === 0 && offset.y === 0) {
      return this;
    }

    var panels = this.map._panels;
    var hasFront = this._frontCount = panels.back.layerDOM.childElementCount;
    var hasBack = this._backCount = panels.front.layerDOM.childElementCount;
    var hasUI = this._uiCount = panels.front.uiDOM.childElementCount;

    if (hasFront || hasBack || hasUI) {
      var pos = this.map.offsetPlatform();

      if (offset) {
        pos = pos.add(offset)._round();
      } else {
        pos = pos.round();
      }

      if (hasBack) {
        offsetDom(panels.back, pos);
      }

      if (hasFront || hasUI) {
        offsetDom(panels.front, pos);
      }
    }

    return this;
  };

  _proto.domChanged = function domChanged() {
    var panels = this.map._panels;

    if (!panels.front) {
      return false;
    }

    var frontCount = panels.back.layerDOM.childElementCount;

    if (this._frontCount === undefined || this._frontCount !== frontCount) {
      return true;
    }

    var backCount = panels.front.layerDOM.childElementCount;

    if (this._backCount === undefined || this._backCount !== backCount) {
      return true;
    }

    var uiCount = panels.front.uiDOM.childElementCount;

    if (this._uiCount === undefined || this._uiCount !== uiCount) {
      return true;
    }

    return false;
  };

  _proto.resetContainer = function resetContainer() {
    if (!this.map) {
      return;
    }

    this.map._resetMapViewPoint();

    if (this.map._panels.front) {
      var pos = new Point(0, 0);
      offsetDom(this.map._panels.back, pos);
      offsetDom(this.map._panels.front, pos);
    }
  };

  _proto.onZoomEnd = function onZoomEnd() {
    this.resetContainer();
  };

  _proto.onLoad = function onLoad() {
    this._frameLoop();
  };

  return MapRenderer;
}(Class);

var MapCanvasRenderer = function (_MapRenderer) {
  _inheritsLoose(MapCanvasRenderer, _MapRenderer);

  function MapCanvasRenderer(map) {
    var _this;

    _this = _MapRenderer.call(this, map) || this;
    _this._containerIsCanvas = !!map._containerDOM.getContext;
    _this._thisVisibilitychange = _this._onVisibilitychange.bind(_assertThisInitialized(_assertThisInitialized(_this)));

    _this._registerEvents();

    _this._loopTime = 0;
    return _this;
  }

  var _proto = MapCanvasRenderer.prototype;

  _proto.load = function load() {
    this.initContainer();
  };

  _proto.renderFrame = function renderFrame(framestamp) {
    if (!this.map) {
      return false;
    }

    delete this._isViewChanged;
    var map = this.map;

    map._fireEvent('framestart');

    this.updateMapDOM();

    var layers = this._getAllLayerToRender();

    this.drawLayers(layers, framestamp);
    var updated = this.drawLayerCanvas(layers);

    if (updated) {
      this._drawCenterCross();
    }

    map._fireEvent('frameend');

    this._recordView();

    this._mapview = this._getMapView();
    delete this._spatialRefChanged;

    this._fireLayerLoadEvents();

    this.executeFrameCallbacks();
    this._canvasUpdated = false;
    return true;
  };

  _proto.updateMapDOM = function updateMapDOM() {
    var map = this.map;

    if (map.isZooming()) {
      return;
    }

    var offset = map._getViewPointFrameOffset();

    if (offset) {
      map.offsetPlatform(offset);
    } else if (this.domChanged()) {
      this.offsetPlatform(null, true);
    }
  };

  _proto.drawLayers = function drawLayers(layers, framestamp) {
    var map = this.map,
        isInteracting = map.isInteracting(),
        canvasIds = [],
        updatedIds = [],
        fps = map.options['fpsOnInteracting'] || 0,
        timeLimit = fps === 0 ? 0 : 1000 / fps,
        layerLimit = this.map.options['layerCanvasLimitOnInteracting'],
        l = layers.length;
    var baseLayer = map.getBaseLayer();
    var t = 0;

    for (var i = 0; i < l; i++) {
      var layer = layers[i];

      if (!layer.isVisible()) {
        continue;
      }

      var isCanvas = layer.isCanvasRender();

      if (isCanvas) {
        canvasIds.push(layer.getId());
      }

      var renderer = layer._getRenderer();

      if (!renderer) {
        continue;
      }

      var needsRedraw = this._checkLayerRedraw(layer);

      if (isCanvas && renderer.isCanvasUpdated()) {
        if (!needsRedraw) {
          updatedIds.push(layer.getId());
        }

        this.setLayerCanvasUpdated();
      }

      var transformMatrix = renderer.__zoomTransformMatrix;
      delete renderer.__zoomTransformMatrix;

      if (!needsRedraw) {
        if (isCanvas && isInteracting) {
          if (map.isZooming() && !map.getPitch()) {
            renderer.prepareRender();
            renderer.__zoomTransformMatrix = this._zoomMatrix;
          } else if (map.getPitch() || map.isRotating()) {
            renderer.clearCanvas();
          }
        }

        continue;
      }

      if (isInteracting && isCanvas) {
        if (layerLimit > 0 && l - 1 - i > layerLimit && layer !== baseLayer) {
          layer._getRenderer().clearCanvas();

          continue;
        }

        t += this._drawCanvasLayerOnInteracting(layer, t, timeLimit, framestamp);
      } else if (isInteracting && renderer.drawOnInteracting) {
        if (renderer.prepareRender) {
          renderer.prepareRender();
        }

        if (renderer.checkAndDraw) {
          renderer.checkAndDraw(renderer.drawOnInteracting, this._eventParam, framestamp);
        } else {
          renderer.drawOnInteracting(this._eventParam, framestamp);
        }
      } else {
        renderer.render(framestamp);

        if (isCanvas && transformMatrix && renderer.isLoadingResource()) {
          renderer.__zoomTransformMatrix = transformMatrix;
        }
      }

      if (isCanvas) {
        updatedIds.push(layer.getId());
        this.setLayerCanvasUpdated();
      }
    }

    var preCanvasIds = this._canvasIds || [];
    var preUpdatedIds = this._updatedIds || [];
    this._canvasIds = canvasIds;
    this._updatedIds = updatedIds;

    if (!this.isLayerCanvasUpdated()) {
      var sep = '---';

      if (preCanvasIds.join(sep) !== canvasIds.join(sep) || preUpdatedIds.join(sep) !== updatedIds.join(sep)) {
        this.setLayerCanvasUpdated();
      }
    }
  };

  _proto._checkLayerRedraw = function _checkLayerRedraw(layer) {
    if (this.isSpatialReferenceChanged()) {
      return true;
    }

    var map = this.map;

    var renderer = layer._getRenderer();

    if (layer.isCanvasRender()) {
      return renderer.testIfNeedRedraw();
    } else {
      if (renderer.needToRedraw && renderer.needToRedraw()) {
        return true;
      }

      return map.isInteracting() || this.isViewChanged();
    }
  };

  _proto._drawCanvasLayerOnInteracting = function _drawCanvasLayerOnInteracting(layer, t, timeLimit, framestamp) {
    var map = this.map,
        renderer = layer._getRenderer(),
        drawTime = renderer.getDrawTime(),
        inTime = timeLimit === 0 || timeLimit > 0 && t + drawTime <= timeLimit;

    if (renderer.mustRenderOnInteracting && renderer.mustRenderOnInteracting()) {
      renderer.render(framestamp);
    } else if (renderer.drawOnInteracting && (layer === map.getBaseLayer() || inTime || map.isZooming() && layer.options['forceRenderOnZooming'] || map.isMoving() && layer.options['forceRenderOnMoving'] || map.isRotating() && layer.options['forceRenderOnRotating'])) {
      renderer.prepareRender();
      renderer.prepareCanvas();

      if (renderer.checkAndDraw) {
        renderer.checkAndDraw(renderer.drawOnInteracting, this._eventParam, framestamp);
      } else {
        renderer.drawOnInteracting(this._eventParam, framestamp);
      }

      return drawTime;
    } else if (map.isZooming() && !map.getPitch() && !map.isRotating()) {
      renderer.prepareRender();
      renderer.__zoomTransformMatrix = this._zoomMatrix;
    } else if (map.getPitch() || map.isRotating()) {
      renderer.clearCanvas();
    }

    if (renderer.drawOnInteracting && !inTime) {
      renderer.onSkipDrawOnInteracting(this._eventParam, framestamp);
    }

    return 0;
  };

  _proto._fireLayerLoadEvents = function _fireLayerLoadEvents() {
    if (this._updatedIds && this._updatedIds.length > 0) {
      var map = this.map;

      this._updatedIds.reverse().forEach(function (id) {
        var layer = map.getLayer(id);

        if (!layer) {
          return;
        }

        var renderer = layer._getRenderer();

        if (!renderer || !renderer.isRenderComplete()) {
          return;
        }

        layer.fire('layerload');
      });
    }
  };

  _proto.isLayerCanvasUpdated = function isLayerCanvasUpdated() {
    return this._canvasUpdated;
  };

  _proto.setLayerCanvasUpdated = function setLayerCanvasUpdated() {
    this._canvasUpdated = true;
  };

  _proto.drawLayerCanvas = function drawLayerCanvas(layers) {
    var map = this.map;

    if (!map) {
      return false;
    }

    if (!this.isLayerCanvasUpdated() && !this.isViewChanged()) {
      return false;
    }

    if (!this.canvas) {
      this.createCanvas();
    }

    map._fireEvent('renderstart', {
      'context': this.context
    });

    if (!this._updateCanvasSize()) {
      this.clearCanvas();
    }

    var interacting = map.isInteracting(),
        limit = map.options['layerCanvasLimitOnInteracting'];
    var len = layers.length;
    var baseLayerImage;
    var images = [];

    for (var i = 0; i < len; i++) {
      if (!layers[i].isVisible() || !layers[i].isCanvasRender()) {
        continue;
      }

      var renderer = layers[i]._getRenderer();

      if (!renderer) {
        continue;
      }

      var layerImage = this._getLayerImage(layers[i]);

      if (layerImage && layerImage['image']) {
        if (layers[i] === map.getBaseLayer()) {
          baseLayerImage = [layers[i], layerImage];
        } else {
          images.push([layers[i], layerImage]);
        }
      }
    }

    if (baseLayerImage) {
      this._drawLayerCanvasImage(baseLayerImage[0], baseLayerImage[1]);

      this._drawFog();
    }

    len = images.length;
    var start = interacting && limit >= 0 && len > limit ? len - limit : 0;

    for (var _i = start; _i < len; _i++) {
      this._drawLayerCanvasImage(images[_i][0], images[_i][1]);
    }

    map._fireEvent('renderend', {
      'context': this.context
    });

    return true;
  };

  _proto.setToRedraw = function setToRedraw() {
    var layers = this._getAllLayerToRender();

    for (var i = 0, l = layers.length; i < l; i++) {
      var renderer = layers[i].getRenderer();

      if (renderer && renderer.canvas && renderer.setToRedraw) {
        renderer.setToRedraw();
      }
    }
  };

  _proto.updateMapSize = function updateMapSize(size) {
    if (!size || this._containerIsCanvas) {
      return;
    }

    var width = size['width'] + 'px',
        height = size['height'] + 'px';
    var panels = this.map._panels;
    panels.mapWrapper.style.width = width;
    panels.mapWrapper.style.height = height;

    this._updateCanvasSize();
  };

  _proto.getMainPanel = function getMainPanel() {
    if (!this.map) {
      return null;
    }

    if (this._containerIsCanvas) {
      return this.map._containerDOM;
    }

    if (this.map._panels) {
      return this.map._panels.mapWrapper;
    }

    return null;
  };

  _proto.toDataURL = function toDataURL(mimeType) {
    if (!this.canvas) {
      return null;
    }

    return this.canvas.toDataURL(mimeType);
  };

  _proto.remove = function remove() {
    if (Browser$1.webgl && typeof document !== 'undefined') {
      removeDomEvent(document, 'visibilitychange', this._thisVisibilitychange, this);
    }

    if (this._resizeInterval) {
      clearInterval(this._resizeInterval);
    }

    delete this.context;
    delete this.canvas;
    delete this.map;
    delete this._spatialRefChanged;

    this._cancelFrameLoop();
  };

  _proto.hitDetect = function hitDetect(point) {
    var map = this.map;

    if (!map || !map.options['hitDetect'] || map.isInteracting()) {
      return;
    }

    var layers = map._getLayers();

    var cursor = 'default';
    var limit = map.options['hitDetectLimit'] || 0;
    var counter = 0;

    for (var i = layers.length - 1; i >= 0; i--) {
      var layer = layers[i];

      if (!layer.options['hitDetect'] || layer.isEmpty && layer.isEmpty()) {
        continue;
      }

      var renderer = layer._getRenderer();

      if (!renderer || !renderer.hitDetect) {
        continue;
      }

      if (renderer.isBlank && renderer.isBlank()) {
        continue;
      }

      if (layer.options['cursor'] !== 'default' && renderer.hitDetect(point)) {
        cursor = layer.options['cursor'] || 'pointer';
        break;
      }

      counter++;

      if (limit > 0 && counter > limit) {
        break;
      }
    }

    map._trySetCursor(cursor);
  };

  _proto._getLayerImage = function _getLayerImage(layer) {
    var renderer = layer._getRenderer();

    if (renderer.getCanvasImage) {
      return renderer.getCanvasImage();
    }

    return null;
  };

  _proto.initContainer = function initContainer() {
    var panels = this.map._panels;

    function createContainer(name, className, cssText, enableSelect) {
      var c = createEl('div', className);

      if (cssText) {
        c.style.cssText = cssText;
      }

      panels[name] = c;

      if (!enableSelect) {
        preventSelection(c);
      }

      return c;
    }

    var containerDOM = this.map._containerDOM;

    if (this._containerIsCanvas) {
      return;
    }

    containerDOM.innerHTML = '';
    var POSITION0 = 'position:absolute;top:0px;left:0px;';
    var mapWrapper = createContainer('mapWrapper', 'maptalks-wrapper', 'position:absolute;overflow:hidden;', true),
        mapAllLayers = createContainer('allLayers', 'maptalks-all-layers', POSITION0 + 'padding:0px;margin:0px;z-index:0;overflow:visible;', true),
        backStatic = createContainer('backStatic', 'maptalks-back-static', POSITION0 + 'z-index:0;', true),
        back = createContainer('back', 'maptalks-back', POSITION0 + 'z-index:1;'),
        backLayer = createContainer('backLayer', 'maptalks-back-layer', POSITION0),
        canvasContainer = createContainer('canvasContainer', 'maptalks-canvas-layer', POSITION0 + 'border:none;z-index:2;'),
        frontStatic = createContainer('frontStatic', 'maptalks-front-static', POSITION0 + 'z-index:3;', true),
        front = createContainer('front', 'maptalks-front', POSITION0 + 'z-index:4;', true),
        frontLayer = createContainer('frontLayer', 'maptalks-front-layer', POSITION0 + 'z-index:0;'),
        ui = createContainer('ui', 'maptalks-ui', POSITION0 + 'border:none;z-index:1;', true),
        control = createContainer('control', 'maptalks-control', 'z-index:1', true);
    containerDOM.appendChild(mapWrapper);
    mapAllLayers.appendChild(backStatic);
    back.appendChild(backLayer);
    back.layerDOM = backLayer;
    mapAllLayers.appendChild(back);
    mapAllLayers.appendChild(canvasContainer);
    front.appendChild(frontLayer);
    front.layerDOM = frontLayer;
    front.uiDOM = ui;
    mapAllLayers.appendChild(frontStatic);
    mapAllLayers.appendChild(front);
    front.appendChild(ui);
    mapWrapper.appendChild(mapAllLayers);
    mapWrapper.appendChild(control);
    this.createCanvas();
    this.resetContainer();

    var mapSize = this.map._getContainerDomSize();

    this.updateMapSize(mapSize);
  };

  _proto.isViewChanged = function isViewChanged() {
    if (this._isViewChanged !== undefined) {
      return this._isViewChanged;
    }

    var previous = this._mapview;

    var view = this._getMapView();

    this._isViewChanged = !previous || !equalMapView(previous, view);
    return this._isViewChanged;
  };

  _proto._recordView = function _recordView() {
    var map = this.map;

    if (!map._onViewChange || map.isInteracting() || map.isAnimating()) {
      return;
    }

    if (!equalMapView(map.getView(), map._getCurrentView())) {
      map._onViewChange(map.getView());
    }
  };

  _proto.isSpatialReferenceChanged = function isSpatialReferenceChanged() {
    return this._spatialRefChanged;
  };

  _proto._getMapView = function _getMapView() {
    var map = this.map;

    var center = map._getPrjCenter();

    return {
      x: center.x,
      y: center.y,
      zoom: map.getZoom(),
      pitch: map.getPitch(),
      bearing: map.getBearing(),
      width: map.width,
      height: map.height
    };
  };

  _proto._frameLoop = function _frameLoop(framestamp) {
    var _this2 = this;

    if (!this.map) {
      this._cancelFrameLoop();

      return;
    }

    this.renderFrame(framestamp);
    this._animationFrame = requestAnimFrame(function (framestamp) {
      _this2._frameLoop(framestamp);
    });
  };

  _proto._cancelFrameLoop = function _cancelFrameLoop() {
    if (this._animationFrame) {
      cancelAnimFrame(this._animationFrame);
    }
  };

  _proto._drawLayerCanvasImage = function _drawLayerCanvasImage(layer, layerImage) {
    var ctx = this.context;
    var point = layerImage['point'].round();
    var dpr = this.map.getDevicePixelRatio();

    if (dpr !== 1) {
      point._multi(dpr);
    }

    var canvasImage = layerImage['image'];
    var width = canvasImage.width,
        height = canvasImage.height;

    if (point.x + width <= 0 || point.y + height <= 0) {
      return;
    }

    var op = layer.options['opacity'];

    if (!isNumber(op)) {
      op = 1;
    }

    if (op <= 0) {
      return;
    }

    var imgOp = layerImage['opacity'];

    if (!isNumber(imgOp)) {
      imgOp = 1;
    }

    if (imgOp <= 0) {
      return;
    }

    var alpha = ctx.globalAlpha;

    if (op < 1) {
      ctx.globalAlpha *= op;
    }

    if (imgOp < 1) {
      ctx.globalAlpha *= imgOp;
    }

    if (layer.options['cssFilter']) {
      ctx.filter = layer.options['cssFilter'];
    }

    var renderer = layer.getRenderer();
    var matrix = renderer.__zoomTransformMatrix;
    var clipped = renderer.clipCanvas(this.context);

    if (matrix) {
      ctx.save();
      ctx.setTransform.apply(ctx, matrix);
    }

    ctx.drawImage(canvasImage, 0, 0, width, height, point.x, point.y, width, height);

    if (matrix) {
      ctx.restore();
    }

    if (clipped) {
      ctx.restore();
    }

    if (ctx.filter !== 'none') {
      ctx.filter = 'none';
    }

    ctx.globalAlpha = alpha;
  };

  _proto._drawCenterCross = function _drawCenterCross() {
    var cross = this.map.options['centerCross'];

    if (cross) {
      var ctx = this.context;
      var p = new Point(this.canvas.width / 2, this.canvas.height / 2);

      if (isFunction(cross)) {
        cross(ctx, p);
      } else {
        Canvas.drawCross(this.context, p.x, p.y, 2, '#f00');
      }
    }
  };

  _proto._drawContainerExtent = function _drawContainerExtent() {
    var cascadePitches = this.map.options.cascadePitches;

    var h30 = this.map.height - this.map._getVisualHeight(cascadePitches[0]);

    var h60 = this.map.height - this.map._getVisualHeight(cascadePitches[1]);

    var extent = this.map.getContainerExtent();
    var ctx = this.context;
    ctx.beginPath();
    ctx.moveTo(0, extent.ymin);
    ctx.lineTo(extent.xmax, extent.ymin);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, h30);
    ctx.lineTo(extent.xmax, h30);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, h60);
    ctx.lineTo(extent.xmax, h60);
    ctx.stroke();
  };

  _proto._drawFog = function _drawFog() {
    var map = this.map;

    if (map.getPitch() <= map.options['maxVisualPitch'] || !map.options['fog']) {
      return;
    }

    var fogThickness = 30;
    var r = map.getDevicePixelRatio();
    var ctx = this.context,
        clipExtent = map.getContainerExtent();
    var top = (map.height - map._getVisualHeight(75)) * r;
    if (top < 0) top = 0;
    var bottom = clipExtent.ymin * r,
        h = Math.ceil(bottom - top),
        color = map.options['fogColor'].join();
    var gradient = ctx.createLinearGradient(0, top, 0, bottom + fogThickness);
    var landscape = 1 - fogThickness / (h + fogThickness);
    gradient.addColorStop(0, "rgba(" + color + ", 0)");
    gradient.addColorStop(0.3, "rgba(" + color + ", 0.3)");
    gradient.addColorStop(landscape, "rgba(" + color + ", 1)");
    gradient.addColorStop(1, "rgba(" + color + ", 0)");
    ctx.beginPath();
    ctx.fillStyle = gradient;
    ctx.fillRect(0, top, Math.ceil(clipExtent.getWidth()) * r, Math.ceil(h + fogThickness));
  };

  _proto._getAllLayerToRender = function _getAllLayerToRender() {
    return this.map._getLayers();
  };

  _proto.clearCanvas = function clearCanvas() {
    if (!this.canvas) {
      return;
    }

    Canvas.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height);
  };

  _proto._updateCanvasSize = function _updateCanvasSize() {
    if (!this.canvas || this._containerIsCanvas) {
      return false;
    }

    var map = this.map,
        mapSize = map.getSize(),
        canvas = this.canvas,
        r = map.getDevicePixelRatio();

    if (mapSize['width'] * r === canvas.width && mapSize['height'] * r === canvas.height) {
      return false;
    }

    canvas.height = r * mapSize['height'];
    canvas.width = r * mapSize['width'];

    if (canvas.style) {
      canvas.style.width = mapSize['width'] + 'px';
      canvas.style.height = mapSize['height'] + 'px';
    }

    return true;
  };

  _proto.createCanvas = function createCanvas() {
    if (this._containerIsCanvas) {
      this.canvas = this.map._containerDOM;
    } else {
      this.canvas = createEl('canvas');

      this._updateCanvasSize();

      this.map._panels.canvasContainer.appendChild(this.canvas);
    }

    this.context = this.canvas.getContext('2d');
  };

  _proto._checkSize = function _checkSize() {
    if (!this.map || this.map.isInteracting()) {
      return;
    }

    computeDomPosition(this.map._containerDOM);
    this.map.checkSize();
  };

  _proto._setCheckSizeInterval = function _setCheckSizeInterval(interval) {
    var _this3 = this;

    clearInterval(this._resizeInterval);
    this._checkSizeInterval = interval;
    this._resizeInterval = setInterval(function () {
      if (!_this3.map || _this3.map.isRemoved()) {
        clearInterval(_this3._resizeInterval);
      } else {
        _this3._checkSize();
      }
    }, this._checkSizeInterval);
  };

  _proto._registerEvents = function _registerEvents() {
    var _this4 = this;

    var map = this.map;

    if (map.options['checkSize'] && !IS_NODE && typeof window !== 'undefined') {
      this._setCheckSizeInterval(map.options['checkSizeInterval']);
    }

    if (!Browser$1.mobile) {
      map.on('_mousemove', this._onMapMouseMove, this);
    }

    map.on('_dragrotatestart _dragrotating _dragrotateend _movestart _moving _moveend _zoomstart', function (param) {
      _this4._eventParam = param;
    });
    map.on('_zooming', function (param) {
      if (!map.getPitch()) {
        _this4._zoomMatrix = param['matrix']['container'];
      }

      _this4._eventParam = param;
    });
    map.on('_zoomend', function (param) {
      _this4._eventParam = param;
      delete _this4._zoomMatrix;
    });
    map.on('_spatialreferencechange', function () {
      _this4._spatialRefChanged = true;
    });

    if (Browser$1.webgl && typeof document !== 'undefined') {
      addDomEvent(document, 'visibilitychange', this._thisVisibilitychange, this);
    }
  };

  _proto._onMapMouseMove = function _onMapMouseMove(param) {
    var _this5 = this;

    var map = this.map;

    if (map.isInteracting() || !map.options['hitDetect']) {
      return;
    }

    if (this._hitDetectFrame) {
      cancelAnimFrame(this._hitDetectFrame);
    }

    this._hitDetectFrame = requestAnimFrame(function () {
      _this5.hitDetect(param['containerPoint']);
    });
  };

  _proto._getCanvasLayers = function _getCanvasLayers() {
    return this.map._getLayers(function (layer) {
      return layer.isCanvasRender();
    });
  };

  _proto._onVisibilitychange = function _onVisibilitychange() {
    if (document.visibilityState !== 'visible') {
      return;
    }

    this.setToRedraw();
  };

  return MapCanvasRenderer;
}(MapRenderer);

Map$1.registerRenderer('canvas', MapCanvasRenderer);
Map$1.mergeOptions({
  'fog': false,
  'fogColor': [233, 233, 233]
});



var index$6 = /*#__PURE__*/Object.freeze({
  ResourceCache: ResourceCache,
  CanvasRenderer: CanvasRenderer,
  ImageGLRenderable: ImageGLRenderable,
  MapRenderer: MapRenderer,
  MapCanvasRenderer: MapCanvasRenderer,
  Renderable: Renderable,
  ImageLayerCanvasRenderer: ImageLayerCanvasRenderer,
  ImageLayerGLRenderer: ImageLayerGLRenderer,
  TileLayerCanvasRenderer: TileLayerCanvasRenderer,
  TileLayerGLRenderer: TileLayerGLRenderer,
  CanvasTileLayerCanvasRenderer: CanvasRenderer$1,
  CanvasTileLayerGLRenderer: GLRenderer,
  OverlayLayerCanvasRenderer: OverlayLayerRenderer,
  VectorLayerCanvasRenderer: VectorLayerRenderer,
  CanvasLayerRenderer: CanvasLayerRenderer
});

var CenterPointRenderer = {
  _getRenderPoints: function _getRenderPoints() {
    return [[this._getCenter2DPoint(this.getMap().getGLZoom())], null];
  }
};
Marker.include(CenterPointRenderer);
Ellipse.include(CenterPointRenderer);
Circle.include(CenterPointRenderer);
Sector.include(CenterPointRenderer);
Rectangle.include({
  _getRenderPoints: function _getRenderPoints(placement) {
    var map = this.getMap();

    if (placement === 'vertex') {
      var shell = this._trimRing(this.getShell());

      var points = [];

      for (var i = 0, len = shell.length; i < len; i++) {
        points.push(map.coordToPoint(shell[i], map.getGLZoom()));
      }

      return [points, null];
    } else {
      var c = map.coordToPoint(this.getCenter(), map.getGLZoom());
      return [[c], null];
    }
  }
});
var PolyRenderer = {
  _getRenderPoints: function _getRenderPoints(placement) {
    var map = this.getMap();
    var glZoom = map.getGLZoom();
    var points,
        rotations = null;

    if (placement === 'point') {
      points = this._getPath2DPoints(this._getPrjCoordinates(), false, glZoom);

      if (points && points.length > 0 && Array.isArray(points[0])) {
        points = points[0].concat(points[1]);
      }
    } else if (placement === 'vertex') {
      points = this._getPath2DPoints(this._getPrjCoordinates(), false, glZoom);
      rotations = [];

      if (points && points.length > 0 && Array.isArray(points[0])) {
        for (var i = 0, l = points.length; i < l; i++) {
          for (var ii = 0, ll = points[i].length; ii < ll; ii++) {
            if (ii === 0) {
              rotations.push([points[i][ii], points[i][ii + 1]]);
            } else {
              rotations.push([points[i][ii - 1], points[i][ii]]);
            }
          }
        }

        points = points[0].concat(points[1]);
      } else {
        for (var _i = 0, _l = points.length; _i < _l; _i++) {
          if (_i === 0) {
            rotations.push([points[_i], points[_i + 1]]);
          } else {
            rotations.push([points[_i - 1], points[_i]]);
          }
        }
      }
    } else if (placement === 'line') {
      points = [];
      rotations = [];

      var vertice = this._getPath2DPoints(this._getPrjCoordinates(), false, glZoom),
          isSplitted = vertice.length > 0 && Array.isArray(vertice[0]);

      if (isSplitted) {
        var ring;

        for (var _i2 = 1, _l2 = vertice.length; _i2 < _l2; _i2++) {
          ring = vertice[_i2];

          if (this instanceof Polygon && ring.length > 0 && !ring[0].equals(ring[ring.length - 1])) {
            ring.push(ring[0]);
          }

          for (var _ii = 1, _ll = ring.length; _ii < _ll; _ii++) {
            points.push(ring[_ii].add(ring[_ii - 1])._multi(0.5));
            rotations.push([ring[_ii - 1], ring[_ii]]);
          }
        }
      } else {
        if (this instanceof Polygon && vertice.length > 0 && !vertice[0].equals(vertice[vertice.length - 1])) {
          vertice.push(vertice[0]);
        }

        for (var _i3 = 1, _l3 = vertice.length; _i3 < _l3; _i3++) {
          points.push(vertice[_i3].add(vertice[_i3 - 1])._multi(0.5));
          rotations.push([vertice[_i3 - 1], vertice[_i3]]);
        }
      }
    } else if (placement === 'vertex-first') {
      var coords = this._getPrjCoordinates();

      points = coords.length ? [map._prjToPoint(coords[0], glZoom)] : [];
      rotations = coords.length ? [[map._prjToPoint(coords[0], glZoom), map._prjToPoint(coords[1], glZoom)]] : [];
    } else if (placement === 'vertex-last') {
      var _coords = this._getPrjCoordinates();

      var _l4 = _coords.length;
      points = _l4 ? [map._prjToPoint(_coords[_l4 - 1], glZoom)] : [];
      var current = _l4 - 1,
          previous = _l4 > 1 ? _l4 - 2 : _l4 - 1;
      rotations = _l4 ? [[map._prjToPoint(_coords[previous], glZoom), map._prjToPoint(_coords[current], glZoom)]] : [];
    } else {
      var pcenter = this._getProjection().project(this.getCenter());

      points = [map._prjToPoint(pcenter, glZoom)];
    }

    return [points, rotations];
  }
};
LineString.include(PolyRenderer);
Polygon.include(PolyRenderer);

Geometry.include({
  _redrawWhenPitch: function _redrawWhenPitch() {
    return false;
  },
  _redrawWhenRotate: function _redrawWhenRotate() {
    return false;
  }
});
var el = {
  _redrawWhenPitch: function _redrawWhenPitch() {
    return true;
  },
  _redrawWhenRotate: function _redrawWhenRotate() {
    return this instanceof Ellipse || this instanceof Sector;
  },
  _paintAsPath: function _paintAsPath() {
    var map = this.getMap();
    var altitude = this.getAltitude();
    return altitude > 0 || map.getPitch() || this instanceof Ellipse && map.getBearing();
  },
  _getPaintParams: function _getPaintParams() {
    var map = this.getMap();

    if (this._paintAsPath()) {
      return Polygon.prototype._getPaintParams.call(this, true);
    }

    var pcenter = this._getPrjCoordinates();

    var pt = map._prjToPoint(pcenter, map.getGLZoom());

    var size = this._getRenderSize(pt);

    return [pt].concat(size);
  },
  _paintOn: function _paintOn() {
    if (this._paintAsPath()) {
      return Canvas.polygon.apply(Canvas, arguments);
    } else {
      return Canvas.ellipse.apply(Canvas, arguments);
    }
  },
  _getRenderSize: function _getRenderSize(pt) {
    var map = this.getMap(),
        z = map.getGLZoom();

    var prjExtent = this._getPrjExtent();

    var pmin = map._prjToPoint(prjExtent.getMin(), z),
        pmax = map._prjToPoint(prjExtent.getMax(), z);

    return [Math.abs(pmax.x - pmin.x) / 2, Math.abs(pmax.y - pt.y), Math.abs(pt.y - pmin.y)];
  }
};
Ellipse.include(el);
Circle.include(el);
Rectangle.include({
  _getPaintParams: function _getPaintParams() {
    var map = this.getMap();
    var pointZoom = map.getGLZoom();

    var shell = this._getPrjShell();

    var points = this._getPath2DPoints(shell, false, pointZoom);

    return [points];
  },
  _paintOn: Canvas.polygon
});
Sector.include(el, {
  _redrawWhenPitch: function _redrawWhenPitch() {
    return true;
  },
  _getPaintParams: function _getPaintParams() {
    if (this._paintAsPath()) {
      return Polygon.prototype._getPaintParams.call(this, true);
    }

    var map = this.getMap();

    var pt = map._prjToPoint(this._getPrjCoordinates(), map.getGLZoom());

    var size = this._getRenderSize(pt);

    return [pt, size[0], [this.getStartAngle(), this.getEndAngle()]];
  },
  _paintOn: function _paintOn() {
    if (this._paintAsPath()) {
      return Canvas.polygon.apply(Canvas, arguments);
    } else {
      var r = this.getMap().getBearing();
      var args = arguments;

      if (r) {
        args[3] = args[3].slice(0);
        args[3][0] += r;
        args[3][1] += r;
      }

      return Canvas.sector.apply(Canvas, args);
    }
  }
});
Path.include({
  _paintAsPath: function _paintAsPath() {
    return true;
  }
});
LineString.include({
  arrowStyles: {
    'classic': [3, 4]
  },
  _getArrowShape: function _getArrowShape(prePoint, point, lineWidth, arrowStyle, tolerance) {
    if (!prePoint || !point || prePoint.equals(point)) {
      return null;
    }

    if (!tolerance) {
      tolerance = 0;
    }

    var width = lineWidth * arrowStyle[0],
        height = lineWidth * arrowStyle[1] + tolerance,
        hw = width / 2 + tolerance;
    var normal;

    if (point.nextCtrlPoint || point.prevCtrlPoint) {
      if (point.prevCtrlPoint) {
        normal = point.sub(new Point(point.prevCtrlPoint));
      } else {
        normal = point.sub(new Point(point.nextCtrlPoint));
      }
    } else {
      normal = point.sub(prePoint);
    }

    normal._unit();

    var p1 = point.sub(normal.multi(height));

    normal._perp();

    var p0 = p1.add(normal.multi(hw));

    normal._multi(-1);

    var p2 = p1.add(normal.multi(hw));
    return [p0, point, p2, p0];
  },
  _getPaintParams: function _getPaintParams() {
    var prjVertexes = this._getPrjCoordinates();

    var points = this._getPath2DPoints(prjVertexes, false, this.getMap().getGLZoom());

    return [points];
  },
  _paintOn: function _paintOn(ctx, points, lineOpacity, fillOpacity, dasharray) {
    if (this.options['smoothness']) {
      Canvas.paintSmoothLine(ctx, points, lineOpacity, this.options['smoothness'], false, this._animIdx, this._animTailRatio);
    } else {
      Canvas.path(ctx, points, lineOpacity, null, dasharray);
    }

    this._paintArrow(ctx, points, lineOpacity);
  },
  _getArrowPlacement: function _getArrowPlacement() {
    return this.options['arrowPlacement'];
  },
  _getArrowStyle: function _getArrowStyle() {
    var arrowStyle = this.options['arrowStyle'];

    if (arrowStyle) {
      return Array.isArray(arrowStyle) ? arrowStyle : this.arrowStyles[arrowStyle];
    }

    return null;
  },
  _getArrows: function _getArrows(points, lineWidth, tolerance) {
    var arrowStyle = this._getArrowStyle();

    if (!arrowStyle || points.length < 2) {
      return [];
    }

    var isSplitted = points.length > 0 && Array.isArray(points[0]);
    var segments = isSplitted ? points : [points];

    var placement = this._getArrowPlacement();

    var arrows = [];
    var map = this.getMap(),
        first = map.coordToContainerPoint(this.getFirstCoordinate()),
        last = map.coordToContainerPoint(this.getLastCoordinate());

    for (var i = segments.length - 1; i >= 0; i--) {
      if (placement === 'vertex-first' || placement === 'vertex-firstlast' && segments[i][0].closeTo(first, 0.01)) {
        var arrow = this._getArrowShape(segments[i][1], segments[i][0], lineWidth, arrowStyle, tolerance);

        if (arrow) {
          arrows.push(arrow);
        }
      }

      if (placement === 'vertex-last' || placement === 'vertex-firstlast' && segments[i][segments[i].length - 1].closeTo(last, 0.01)) {
        var _arrow = this._getArrowShape(segments[i][segments[i].length - 2], segments[i][segments[i].length - 1], lineWidth, arrowStyle, tolerance);

        if (_arrow) {
          arrows.push(_arrow);
        }
      } else if (placement === 'point') {
        this._getArrowPoints(arrows, segments[i], lineWidth, arrowStyle, tolerance);
      }
    }

    return arrows;
  },
  _getArrowPoints: function _getArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance) {
    for (var ii = 0, ll = segments.length - 1; ii < ll; ii++) {
      var arrow = this._getArrowShape(segments[ii], segments[ii + 1], lineWidth, arrowStyle, tolerance);

      if (arrow) {
        arrows.push(arrow);
      }
    }
  },
  _paintArrow: function _paintArrow(ctx, points, lineOpacity) {
    var lineWidth = this._getInternalSymbol()['lineWidth'];

    if (!isNumber(lineWidth) || lineWidth < 3) {
      lineWidth = 3;
    }

    var arrows = this._getArrows(points, lineWidth);

    if (!arrows.length) {
      return;
    }

    if (ctx.setLineDash) {
      ctx.setLineDash([]);
    }

    for (var i = arrows.length - 1; i >= 0; i--) {
      ctx.fillStyle = ctx.strokeStyle;
      Canvas.polygon(ctx, arrows[i], lineOpacity, lineOpacity);
    }
  }
});
Polygon.include({
  _getPaintParams: function _getPaintParams(disableSimplify) {
    var maxZoom = this.getMap().getGLZoom();

    var prjVertexes = this._getPrjShell();

    var points = this._getPath2DPoints(prjVertexes, disableSimplify, maxZoom);

    var isSplitted = points.length > 0 && Array.isArray(points[0]);

    if (isSplitted) {
      points = [[points[0]], [points[1]]];
    }

    var prjHoles = this._getPrjHoles();

    var holePoints = [];

    if (prjHoles && prjHoles.length > 0) {
      var simplified = this._simplified;

      for (var i = 0; i < prjHoles.length; i++) {
        var hole = this._getPath2DPoints(prjHoles[i], disableSimplify, maxZoom);

        if (Array.isArray(hole) && isSplitted) {
          if (Array.isArray(hole[0])) {
            points[0].push(hole[0]);
            points[1].push(hole[1]);
          } else {
            points[0].push(hole);
          }
        } else {
          holePoints.push(hole);
        }
      }

      if (simplified) {
        this._simplified = simplified;
      }
    }

    if (!isSplitted) {
      points = [points];
      pushIn(points, holePoints);
    }

    return [points];
  },
  _paintOn: function _paintOn(ctx, points, lineOpacity, fillOpacity, dasharray) {
    Canvas.polygon(ctx, points, lineOpacity, fillOpacity, dasharray, this.options['smoothness']);
  }
});

Map$1.VERSION = version;



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "../node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "../node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "../node_modules/nanoid/index.browser.js":
/*!***********************************************!*\
  !*** ../node_modules/nanoid/index.browser.js ***!
  \***********************************************/
/*! exports provided: nanoid, customAlphabet, customRandom, urlAlphabet, random */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nanoid", function() { return nanoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customAlphabet", function() { return customAlphabet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customRandom", function() { return customRandom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "../node_modules/nanoid/url-alphabet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "urlAlphabet", function() { return _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__["urlAlphabet"]; });

// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.



if (true) {
  // All bundlers will remove this block in the production bundle.
  if (
    typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative' &&
    typeof crypto === 'undefined'
  ) {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +
        'For secure IDs, import `react-native-get-random-values` ' +
        'before Nano ID. If you use Expo, install `expo-random` ' +
        'and use `nanoid/async`.'
    )
  }
  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {
    throw new Error(
      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +
        ' before importing Nano ID to fix IE 11 support'
    )
  }
  if (typeof crypto === 'undefined') {
    throw new Error(
      'Your browser does not have secure random generator. ' +
        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))

let customRandom = (alphabet, size, getRandom) => {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  // `Math.clz32` is not used, because it is not available in browsers.
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.

  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.

  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).

  // `-~f => Math.ceil(f)` if f is a float
  // `-~i => i + 1` if i is an integer
  let step = -~((1.6 * mask * size) / alphabet.length)

  return () => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      // A compact alternative for `for (var i = 0; i < step; i++)`.
      let j = step
      while (j--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}

let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)

let nanoid = (size = 21) => {
  let id = ''
  let bytes = crypto.getRandomValues(new Uint8Array(size))

  // A compact alternative for `for (var i = 0; i < step; i++)`.
  while (size--) {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    let byte = bytes[size] & 63
    if (byte < 36) {
      // `0-9a-z`
      id += byte.toString(36)
    } else if (byte < 62) {
      // `A-Z`
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte < 63) {
      id += '_'
    } else {
      id += '-'
    }
  }
  return id
}




/***/ }),

/***/ "../node_modules/nanoid/url-alphabet/index.js":
/*!****************************************************!*\
  !*** ../node_modules/nanoid/url-alphabet/index.js ***!
  \****************************************************/
/*! exports provided: urlAlphabet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlAlphabet", function() { return urlAlphabet; });
// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped
// optimize the gzip compression for this alphabet.
let urlAlphabet =
  'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW'




/***/ }),

/***/ "../node_modules/object-assign/index.js":
/*!**********************************************!*\
  !*** ../node_modules/object-assign/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/prop-types/checkPropTypes.js":
/*!****************************************************!*\
  !*** ../node_modules/prop-types/checkPropTypes.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "../node_modules/prop-types/factoryWithTypeCheckers.js":
/*!*************************************************************!*\
  !*** ../node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "../node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "../node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "../node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../node_modules/prop-types/index.js":
/*!*******************************************!*\
  !*** ../node_modules/prop-types/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "../node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "../node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!**************************************************************!*\
  !*** ../node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../node_modules/react-dropzone/dist/es/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/react-dropzone/dist/es/index.js ***!
  \*******************************************************/
/*! exports provided: default, useDropzone */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDropzone", function() { return useDropzone; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "../node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var file_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-selector */ "../node_modules/file-selector/dist/es5/index.js");
/* harmony import */ var _utils_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/index */ "../node_modules/react-dropzone/dist/es/utils/index.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/* eslint prefer-template: 0 */




/**
 * Convenience wrapper component for the `useDropzone` hook
 *
 * ```jsx
 * <Dropzone>
 *   {({getRootProps, getInputProps}) => (
 *     <div {...getRootProps()}>
 *       <input {...getInputProps()} />
 *       <p>Drag 'n' drop some files here, or click to select files</p>
 *     </div>
 *   )}
 * </Dropzone>
 * ```
 */

var Dropzone = /*#__PURE__*/Object(react__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(function (_ref, ref) {
  var children = _ref.children,
      params = _objectWithoutProperties(_ref, ["children"]);

  var _useDropzone = useDropzone(params),
      open = _useDropzone.open,
      props = _objectWithoutProperties(_useDropzone, ["open"]);

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"])(ref, function () {
    return {
      open: open
    };
  }, [open]); // TODO: Figure out why react-styleguidist cannot create docs if we don't return a jsx element

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0__["Fragment"], null, children(_objectSpread(_objectSpread({}, props), {}, {
    open: open
  })));
});
Dropzone.displayName = 'Dropzone'; // Add default props for react-docgen

var defaultProps = {
  disabled: false,
  getFilesFromEvent: file_selector__WEBPACK_IMPORTED_MODULE_2__["fromEvent"],
  maxSize: Infinity,
  minSize: 0,
  multiple: true,
  maxFiles: 0,
  preventDropOnDocument: true,
  noClick: false,
  noKeyboard: false,
  noDrag: false,
  noDragEventsBubbling: false
};
Dropzone.defaultProps = defaultProps;
Dropzone.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.draggedFiles Files in active drag
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Set accepted file types.
   * See https://github.com/okonet/attr-accept for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all.
   * See: https://github.com/react-dropzone/react-dropzone/issues/276
   */
  accept: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string)]),

  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * If true, disables drag 'n' drop
   */
  noDrag: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * Minimum file size (in bytes)
   */
  minSize: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,

  /**
   * Maximum file size (in bytes)
   */
  maxSize: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,

  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,

  /**
   * Enable/disable the dropzone
   */
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func
};
/* harmony default export */ __webpack_exports__["default"] = (Dropzone);
/**
 * A function that is invoked for the `dragenter`,
 * `dragover` and `dragleave` events.
 * It is not invoked if the items are not files (such as link, text, etc.).
 *
 * @callback dragCb
 * @param {DragEvent} event
 */

/**
 * A function that is invoked for the `drop` or input change event.
 * It is not invoked if the items are not files (such as link, text, etc.).
 *
 * @callback dropCb
 * @param {File[]} acceptedFiles List of accepted files
 * @param {FileRejection[]} fileRejections List of rejected files and why they were rejected
 * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
 */

/**
 * A function that is invoked for the `drop` or input change event.
 * It is not invoked if the items are files (such as link, text, etc.).
 *
 * @callback dropAcceptedCb
 * @param {File[]} files List of accepted files that meet the given criteria
 * (`accept`, `multiple`, `minSize`, `maxSize`)
 * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
 */

/**
 * A function that is invoked for the `drop` or input change event.
 *
 * @callback dropRejectedCb
 * @param {File[]} files List of rejected files that do not meet the given criteria
 * (`accept`, `multiple`, `minSize`, `maxSize`)
 * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
 */

/**
 * A function that is used aggregate files,
 * in a asynchronous fashion, from drag or input change events.
 *
 * @callback getFilesFromEvent
 * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
 * @returns {(File[]|Promise<File[]>)}
 */

/**
 * An object with the current dropzone state and some helper functions.
 *
 * @typedef {object} DropzoneState
 * @property {Function} getRootProps Returns the props you should apply to the root drop container you render
 * @property {Function} getInputProps Returns the props you should apply to hidden file input you render
 * @property {Function} open Open the native file selection dialog
 * @property {boolean} isFocused Dropzone area is in focus
 * @property {boolean} isFileDialogActive File dialog is opened
 * @property {boolean} isDragActive Active drag is in progress
 * @property {boolean} isDragAccept Dragged files are accepted
 * @property {boolean} isDragReject Some dragged files are rejected
 * @property {File[]} draggedFiles Files in active drag
 * @property {File[]} acceptedFiles Accepted files
 * @property {FileRejection[]} fileRejections Rejected files and why they were rejected
 */

var initialState = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  draggedFiles: [],
  acceptedFiles: [],
  fileRejections: []
};
/**
 * A React hook that creates a drag 'n' drop area.
 *
 * ```jsx
 * function MyDropzone(props) {
 *   const {getRootProps, getInputProps} = useDropzone({
 *     onDrop: acceptedFiles => {
 *       // do something with the File objects, e.g. upload to some server
 *     }
 *   });
 *   return (
 *     <div {...getRootProps()}>
 *       <input {...getInputProps()} />
 *       <p>Drag and drop some files here, or click to select files</p>
 *     </div>
 *   )
 * }
 * ```
 *
 * @function useDropzone
 *
 * @param {object} props
 * @param {string|string[]} [props.accept] Set accepted file types.
 * See https://github.com/okonet/attr-accept for more information.
 * Keep in mind that mime type determination is not reliable across platforms. CSV files,
 * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
 * Windows. In some cases there might not be a mime type set at all.
 * See: https://github.com/react-dropzone/react-dropzone/issues/276
 * @param {boolean} [props.multiple=true] Allow drag 'n' drop (or selection from the file dialog) of multiple files
 * @param {boolean} [props.preventDropOnDocument=true] If false, allow dropped items to take over the current browser window
 * @param {boolean} [props.noClick=false] If true, disables click to open the native file selection dialog
 * @param {boolean} [props.noKeyboard=false] If true, disables SPACE/ENTER to open the native file selection dialog.
 * Note that it also stops tracking the focus state.
 * @param {boolean} [props.noDrag=false] If true, disables drag 'n' drop
 * @param {boolean} [props.noDragEventsBubbling=false] If true, stops drag event propagation to parents
 * @param {number} [props.minSize=0] Minimum file size (in bytes)
 * @param {number} [props.maxSize=Infinity] Maximum file size (in bytes)
 * @param {boolean} [props.disabled=false] Enable/disable the dropzone
 * @param {getFilesFromEvent} [props.getFilesFromEvent] Use this to provide a custom file aggregator
 * @param {Function} [props.onFileDialogCancel] Cb for when closing the file dialog with no selection
 * @param {dragCb} [props.onDragEnter] Cb for when the `dragenter` event occurs.
 * @param {dragCb} [props.onDragLeave] Cb for when the `dragleave` event occurs
 * @param {dragCb} [props.onDragOver] Cb for when the `dragover` event occurs
 * @param {dropCb} [props.onDrop] Cb for when the `drop` event occurs.
 * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
 *
 * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
 * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
 * If `multiple` is set to false and additional files are dropped,
 * all files besides the first will be rejected.
 * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
 *
 * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
 * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
 *
 * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
 * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
 *
 * ```js
 * function onDrop(acceptedFiles) {
 *   const req = request.post('/upload')
 *   acceptedFiles.forEach(file => {
 *     req.attach(file.name, file)
 *   })
 *   req.end(callback)
 * }
 * ```
 * @param {dropAcceptedCb} [props.onDropAccepted]
 * @param {dropRejectedCb} [props.onDropRejected]
 *
 * @returns {DropzoneState}
 */

function useDropzone() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _defaultProps$options = _objectSpread(_objectSpread({}, defaultProps), options),
      accept = _defaultProps$options.accept,
      disabled = _defaultProps$options.disabled,
      getFilesFromEvent = _defaultProps$options.getFilesFromEvent,
      maxSize = _defaultProps$options.maxSize,
      minSize = _defaultProps$options.minSize,
      multiple = _defaultProps$options.multiple,
      maxFiles = _defaultProps$options.maxFiles,
      onDragEnter = _defaultProps$options.onDragEnter,
      onDragLeave = _defaultProps$options.onDragLeave,
      onDragOver = _defaultProps$options.onDragOver,
      onDrop = _defaultProps$options.onDrop,
      onDropAccepted = _defaultProps$options.onDropAccepted,
      onDropRejected = _defaultProps$options.onDropRejected,
      onFileDialogCancel = _defaultProps$options.onFileDialogCancel,
      preventDropOnDocument = _defaultProps$options.preventDropOnDocument,
      noClick = _defaultProps$options.noClick,
      noKeyboard = _defaultProps$options.noKeyboard,
      noDrag = _defaultProps$options.noDrag,
      noDragEventsBubbling = _defaultProps$options.noDragEventsBubbling;

  var rootRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var inputRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);

  var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"])(reducer, initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  var isFocused = state.isFocused,
      isFileDialogActive = state.isFileDialogActive,
      draggedFiles = state.draggedFiles; // Fn for opening the file dialog programmatically

  var openFileDialog = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function () {
    if (inputRef.current) {
      dispatch({
        type: 'openDialog'
      });
      inputRef.current.value = null;
      inputRef.current.click();
    }
  }, [dispatch]); // Update file dialog active state when the window is focused on

  var onWindowFocus = function onWindowFocus() {
    // Execute the timeout only if the file dialog is opened in the browser
    if (isFileDialogActive) {
      setTimeout(function () {
        if (inputRef.current) {
          var files = inputRef.current.files;

          if (!files.length) {
            dispatch({
              type: 'closeDialog'
            });

            if (typeof onFileDialogCancel === 'function') {
              onFileDialogCancel();
            }
          }
        }
      }, 300);
    }
  };

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    window.addEventListener('focus', onWindowFocus, false);
    return function () {
      window.removeEventListener('focus', onWindowFocus, false);
    };
  }, [inputRef, isFileDialogActive, onFileDialogCancel]); // Cb to open the file dialog when SPACE/ENTER occurs on the dropzone

  var onKeyDownCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (event) {
    // Ignore keyboard events bubbling up the DOM tree
    if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {
      return;
    }

    if (event.keyCode === 32 || event.keyCode === 13) {
      event.preventDefault();
      openFileDialog();
    }
  }, [rootRef, inputRef]); // Update focus state for the dropzone

  var onFocusCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function () {
    dispatch({
      type: 'focus'
    });
  }, []);
  var onBlurCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function () {
    dispatch({
      type: 'blur'
    });
  }, []); // Cb to open the file dialog when click occurs on the dropzone

  var onClickCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function () {
    if (noClick) {
      return;
    } // In IE11/Edge the file-browser dialog is blocking, therefore, use setTimeout()
    // to ensure React can handle state changes
    // See: https://github.com/react-dropzone/react-dropzone/issues/450


    if (Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["isIeOrEdge"])()) {
      setTimeout(openFileDialog, 0);
    } else {
      openFileDialog();
    }
  }, [inputRef, noClick]);
  var dragTargetsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])([]);

  var onDocumentDrop = function onDocumentDrop(event) {
    if (rootRef.current && rootRef.current.contains(event.target)) {
      // If we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
      return;
    }

    event.preventDefault();
    dragTargetsRef.current = [];
  };

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    if (preventDropOnDocument) {
      document.addEventListener('dragover', _utils_index__WEBPACK_IMPORTED_MODULE_3__["onDocumentDragOver"], false);
      document.addEventListener('drop', onDocumentDrop, false);
    }

    return function () {
      if (preventDropOnDocument) {
        document.removeEventListener('dragover', _utils_index__WEBPACK_IMPORTED_MODULE_3__["onDocumentDragOver"]);
        document.removeEventListener('drop', onDocumentDrop);
      }
    };
  }, [rootRef, preventDropOnDocument]);
  var onDragEnterCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (event) {
    event.preventDefault(); // Persist here because we need the event later after getFilesFromEvent() is done

    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [].concat(_toConsumableArray(dragTargetsRef.current), [event.target]);

    if (Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["isEvtWithFiles"])(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function (draggedFiles) {
        if (Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["isPropagationStopped"])(event) && !noDragEventsBubbling) {
          return;
        }

        dispatch({
          draggedFiles: draggedFiles,
          isDragActive: true,
          type: 'setDraggedFiles'
        });

        if (onDragEnter) {
          onDragEnter(event);
        }
      });
    }
  }, [getFilesFromEvent, onDragEnter, noDragEventsBubbling]);
  var onDragOverCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);

    if (event.dataTransfer) {
      try {
        event.dataTransfer.dropEffect = 'copy';
      } catch (_unused) {}
      /* eslint-disable-line no-empty */

    }

    if (Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["isEvtWithFiles"])(event) && onDragOver) {
      onDragOver(event);
    }

    return false;
  }, [onDragOver, noDragEventsBubbling]);
  var onDragLeaveCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event); // Only deactivate once the dropzone and all children have been left

    var targets = dragTargetsRef.current.filter(function (target) {
      return rootRef.current && rootRef.current.contains(target);
    }); // Make sure to remove a target present multiple times only once
    // (Firefox may fire dragenter/dragleave multiple times on the same element)

    var targetIdx = targets.indexOf(event.target);

    if (targetIdx !== -1) {
      targets.splice(targetIdx, 1);
    }

    dragTargetsRef.current = targets;

    if (targets.length > 0) {
      return;
    }

    dispatch({
      isDragActive: false,
      type: 'setDraggedFiles',
      draggedFiles: []
    });

    if (Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["isEvtWithFiles"])(event) && onDragLeave) {
      onDragLeave(event);
    }
  }, [rootRef, onDragLeave, noDragEventsBubbling]);
  var onDropCb = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (event) {
    event.preventDefault(); // Persist here because we need the event later after getFilesFromEvent() is done

    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [];

    if (Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["isEvtWithFiles"])(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function (files) {
        if (Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["isPropagationStopped"])(event) && !noDragEventsBubbling) {
          return;
        }

        var acceptedFiles = [];
        var fileRejections = [];
        files.forEach(function (file) {
          var _fileAccepted = Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["fileAccepted"])(file, accept),
              _fileAccepted2 = _slicedToArray(_fileAccepted, 2),
              accepted = _fileAccepted2[0],
              acceptError = _fileAccepted2[1];

          var _fileMatchSize = Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["fileMatchSize"])(file, minSize, maxSize),
              _fileMatchSize2 = _slicedToArray(_fileMatchSize, 2),
              sizeMatch = _fileMatchSize2[0],
              sizeError = _fileMatchSize2[1];

          if (accepted && sizeMatch) {
            acceptedFiles.push(file);
          } else {
            var errors = [acceptError, sizeError].filter(function (e) {
              return e;
            });
            fileRejections.push({
              file: file,
              errors: errors
            });
          }
        });

        if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {
          // Reject everything and empty accepted files
          acceptedFiles.forEach(function (file) {
            fileRejections.push({
              file: file,
              errors: [_utils_index__WEBPACK_IMPORTED_MODULE_3__["TOO_MANY_FILES_REJECTION"]]
            });
          });
          acceptedFiles.splice(0);
        }

        dispatch({
          acceptedFiles: acceptedFiles,
          fileRejections: fileRejections,
          type: 'setFiles'
        });

        if (onDrop) {
          onDrop(acceptedFiles, fileRejections, event);
        }

        if (fileRejections.length > 0 && onDropRejected) {
          onDropRejected(fileRejections, event);
        }

        if (acceptedFiles.length > 0 && onDropAccepted) {
          onDropAccepted(acceptedFiles, event);
        }
      });
    }

    dispatch({
      type: 'reset'
    });
  }, [multiple, accept, minSize, maxSize, maxFiles, getFilesFromEvent, onDrop, onDropAccepted, onDropRejected, noDragEventsBubbling]);

  var composeHandler = function composeHandler(fn) {
    return disabled ? null : fn;
  };

  var composeKeyboardHandler = function composeKeyboardHandler(fn) {
    return noKeyboard ? null : composeHandler(fn);
  };

  var composeDragHandler = function composeDragHandler(fn) {
    return noDrag ? null : composeHandler(fn);
  };

  var stopPropagation = function stopPropagation(event) {
    if (noDragEventsBubbling) {
      event.stopPropagation();
    }
  };

  var getRootProps = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return function () {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$refKey = _ref2.refKey,
          refKey = _ref2$refKey === void 0 ? 'ref' : _ref2$refKey,
          onKeyDown = _ref2.onKeyDown,
          onFocus = _ref2.onFocus,
          onBlur = _ref2.onBlur,
          onClick = _ref2.onClick,
          onDragEnter = _ref2.onDragEnter,
          onDragOver = _ref2.onDragOver,
          onDragLeave = _ref2.onDragLeave,
          onDrop = _ref2.onDrop,
          rest = _objectWithoutProperties(_ref2, ["refKey", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"]);

      return _objectSpread(_objectSpread(_defineProperty({
        onKeyDown: composeKeyboardHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onKeyDown, onKeyDownCb)),
        onFocus: composeKeyboardHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onFocus, onFocusCb)),
        onBlur: composeKeyboardHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onBlur, onBlurCb)),
        onClick: composeHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onClick, onClickCb)),
        onDragEnter: composeDragHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onDragEnter, onDragEnterCb)),
        onDragOver: composeDragHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onDragOver, onDragOverCb)),
        onDragLeave: composeDragHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onDragLeave, onDragLeaveCb)),
        onDrop: composeDragHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onDrop, onDropCb))
      }, refKey, rootRef), !disabled && !noKeyboard ? {
        tabIndex: 0
      } : {}), rest);
    };
  }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled]);
  var onInputElementClick = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (event) {
    event.stopPropagation();
  }, []);
  var getInputProps = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$refKey = _ref3.refKey,
          refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
          onChange = _ref3.onChange,
          onClick = _ref3.onClick,
          rest = _objectWithoutProperties(_ref3, ["refKey", "onChange", "onClick"]);

      var inputProps = _defineProperty({
        accept: accept,
        multiple: multiple,
        type: 'file',
        style: {
          display: 'none'
        },
        onChange: composeHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onChange, onDropCb)),
        onClick: composeHandler(Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["composeEventHandlers"])(onClick, onInputElementClick)),
        autoComplete: 'off',
        tabIndex: -1
      }, refKey, inputRef);

      return _objectSpread(_objectSpread({}, inputProps), rest);
    };
  }, [inputRef, accept, multiple, onDropCb, disabled]);
  var fileCount = draggedFiles.length;
  var isDragAccept = fileCount > 0 && Object(_utils_index__WEBPACK_IMPORTED_MODULE_3__["allFilesAccepted"])({
    files: draggedFiles,
    accept: accept,
    minSize: minSize,
    maxSize: maxSize,
    multiple: multiple,
    maxFiles: maxFiles
  });
  var isDragReject = fileCount > 0 && !isDragAccept;
  return _objectSpread(_objectSpread({}, state), {}, {
    isDragAccept: isDragAccept,
    isDragReject: isDragReject,
    isFocused: isFocused && !disabled,
    getRootProps: getRootProps,
    getInputProps: getInputProps,
    rootRef: rootRef,
    inputRef: inputRef,
    open: composeHandler(openFileDialog)
  });
}

function reducer(state, action) {
  /* istanbul ignore next */
  switch (action.type) {
    case 'focus':
      return _objectSpread(_objectSpread({}, state), {}, {
        isFocused: true
      });

    case 'blur':
      return _objectSpread(_objectSpread({}, state), {}, {
        isFocused: false
      });

    case 'openDialog':
      return _objectSpread(_objectSpread({}, state), {}, {
        isFileDialogActive: true
      });

    case 'closeDialog':
      return _objectSpread(_objectSpread({}, state), {}, {
        isFileDialogActive: false
      });

    case 'setDraggedFiles':
      /* eslint no-case-declarations: 0 */
      var isDragActive = action.isDragActive,
          draggedFiles = action.draggedFiles;
      return _objectSpread(_objectSpread({}, state), {}, {
        draggedFiles: draggedFiles,
        isDragActive: isDragActive
      });

    case 'setFiles':
      return _objectSpread(_objectSpread({}, state), {}, {
        acceptedFiles: action.acceptedFiles,
        fileRejections: action.fileRejections
      });

    case 'reset':
      return _objectSpread(_objectSpread({}, state), {}, {
        isFileDialogActive: false,
        isDragActive: false,
        draggedFiles: [],
        acceptedFiles: [],
        fileRejections: []
      });

    default:
      return state;
  }
}

/***/ }),

/***/ "../node_modules/react-dropzone/dist/es/utils/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/react-dropzone/dist/es/utils/index.js ***!
  \*************************************************************/
/*! exports provided: FILE_INVALID_TYPE, FILE_TOO_LARGE, FILE_TOO_SMALL, TOO_MANY_FILES, getInvalidTypeRejectionErr, getTooLargeRejectionErr, getTooSmallRejectionErr, TOO_MANY_FILES_REJECTION, fileAccepted, fileMatchSize, allFilesAccepted, isPropagationStopped, isEvtWithFiles, isKindFile, onDocumentDragOver, isIeOrEdge, composeEventHandlers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILE_INVALID_TYPE", function() { return FILE_INVALID_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILE_TOO_LARGE", function() { return FILE_TOO_LARGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILE_TOO_SMALL", function() { return FILE_TOO_SMALL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOO_MANY_FILES", function() { return TOO_MANY_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInvalidTypeRejectionErr", function() { return getInvalidTypeRejectionErr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTooLargeRejectionErr", function() { return getTooLargeRejectionErr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTooSmallRejectionErr", function() { return getTooSmallRejectionErr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOO_MANY_FILES_REJECTION", function() { return TOO_MANY_FILES_REJECTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fileAccepted", function() { return fileAccepted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fileMatchSize", function() { return fileMatchSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFilesAccepted", function() { return allFilesAccepted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPropagationStopped", function() { return isPropagationStopped; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEvtWithFiles", function() { return isEvtWithFiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isKindFile", function() { return isKindFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onDocumentDragOver", function() { return onDocumentDragOver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIeOrEdge", function() { return isIeOrEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composeEventHandlers", function() { return composeEventHandlers; });
/* harmony import */ var attr_accept__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! attr-accept */ "../node_modules/attr-accept/dist/es/index.js");
/* harmony import */ var attr_accept__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(attr_accept__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

 // Error codes

var FILE_INVALID_TYPE = 'file-invalid-type';
var FILE_TOO_LARGE = 'file-too-large';
var FILE_TOO_SMALL = 'file-too-small';
var TOO_MANY_FILES = 'too-many-files'; // File Errors

var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr(accept) {
  accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
  var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(', ')) : accept;
  return {
    code: FILE_INVALID_TYPE,
    message: "File type must be ".concat(messageSuffix)
  };
};
var getTooLargeRejectionErr = function getTooLargeRejectionErr(maxSize) {
  return {
    code: FILE_TOO_LARGE,
    message: "File is larger than ".concat(maxSize, " bytes")
  };
};
var getTooSmallRejectionErr = function getTooSmallRejectionErr(minSize) {
  return {
    code: FILE_TOO_SMALL,
    message: "File is smaller than ".concat(minSize, " bytes")
  };
};
var TOO_MANY_FILES_REJECTION = {
  code: TOO_MANY_FILES,
  message: 'Too many files'
}; // Firefox versions prior to 53 return a bogus MIME type for every file drag, so dragovers with
// that MIME type will always be accepted

function fileAccepted(file, accept) {
  var isAcceptable = file.type === 'application/x-moz-file' || attr_accept__WEBPACK_IMPORTED_MODULE_0___default()(file, accept);
  return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
}
function fileMatchSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, getTooLargeRejectionErr(maxSize)];
      if (file.size < minSize) return [false, getTooSmallRejectionErr(minSize)];
    } else if (isDefined(minSize) && file.size < minSize) return [false, getTooSmallRejectionErr(minSize)];else if (isDefined(maxSize) && file.size > maxSize) return [false, getTooLargeRejectionErr(maxSize)];
  }

  return [true, null];
}

function isDefined(value) {
  return value !== undefined && value !== null;
}

function allFilesAccepted(_ref) {
  var files = _ref.files,
      accept = _ref.accept,
      minSize = _ref.minSize,
      maxSize = _ref.maxSize,
      multiple = _ref.multiple,
      maxFiles = _ref.maxFiles;

  if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {
    return false;
  }

  return files.every(function (file) {
    var _fileAccepted = fileAccepted(file, accept),
        _fileAccepted2 = _slicedToArray(_fileAccepted, 1),
        accepted = _fileAccepted2[0];

    var _fileMatchSize = fileMatchSize(file, minSize, maxSize),
        _fileMatchSize2 = _slicedToArray(_fileMatchSize, 1),
        sizeMatch = _fileMatchSize2[0];

    return accepted && sizeMatch;
  });
} // React's synthetic events has event.isPropagationStopped,
// but to remain compatibility with other libs (Preact) fall back
// to check event.cancelBubble

function isPropagationStopped(event) {
  if (typeof event.isPropagationStopped === 'function') {
    return event.isPropagationStopped();
  } else if (typeof event.cancelBubble !== 'undefined') {
    return event.cancelBubble;
  }

  return false;
}
function isEvtWithFiles(event) {
  if (!event.dataTransfer) {
    return !!event.target && !!event.target.files;
  } // https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/types
  // https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types#file


  return Array.prototype.some.call(event.dataTransfer.types, function (type) {
    return type === 'Files' || type === 'application/x-moz-file';
  });
}
function isKindFile(item) {
  return _typeof(item) === 'object' && item !== null && item.kind === 'file';
} // allow the entire document to be a drag target

function onDocumentDragOver(event) {
  event.preventDefault();
}

function isIe(userAgent) {
  return userAgent.indexOf('MSIE') !== -1 || userAgent.indexOf('Trident/') !== -1;
}

function isEdge(userAgent) {
  return userAgent.indexOf('Edge/') !== -1;
}

function isIeOrEdge() {
  var userAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.navigator.userAgent;
  return isIe(userAgent) || isEdge(userAgent);
}
/**
 * This is intended to be used to compose event handlers
 * They are executed in order until one of them calls `event.isPropagationStopped()`.
 * Note that the check is done on the first invoke too,
 * meaning that if propagation was stopped before invoking the fns,
 * no handlers will be executed.
 *
 * @param {Function} fns the event hanlder functions
 * @return {Function} the event handler to add to an element
 */

function composeEventHandlers() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return fns.some(function (fn) {
      if (!isPropagationStopped(event) && fn) {
        fn.apply(void 0, [event].concat(args));
      }

      return isPropagationStopped(event);
    });
  };
}

/***/ }),

/***/ "../node_modules/react-is/cjs/react-is.development.js":
/*!************************************************************!*\
  !*** ../node_modules/react-is/cjs/react-is.development.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../node_modules/react-is/index.js":
/*!*****************************************!*\
  !*** ../node_modules/react-is/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../node_modules/setimmediate/setImmediate.js":
/*!****************************************************!*\
  !*** ../node_modules/setimmediate/setImmediate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../node_modules/process/browser.js")))

/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "../node_modules/three/build/three.module.js":
/*!***************************************************!*\
  !*** ../node_modules/three/build/three.module.js ***!
  \***************************************************/
/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float16BufferAttribute, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGL1Renderer, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveAnimationBlendMode", function() { return AdditiveAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLightProbe", function() { return AmbientLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomToneMapping", function() { return CustomToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function() { return DataTexture2DArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return DataTexture3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataUtils", function() { return DataUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face3", function() { return Face3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face4", function() { return Face4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16BufferAttribute", function() { return Float16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLBufferAttribute", function() { return GLBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL1", function() { return GLSL1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL3", function() { return GLSL3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() { return GeometryUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightProbe", function() { return HemisphereLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return InstancedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return LightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalAnimationBlendMode", function() { return NormalAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return PMREMGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return RGBAIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function() { return RGBA_BPTC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return RGBA_ETC2_EAC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function() { return RGBIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return RGB_ETC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return RGFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return RGIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return RedIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return SphericalHarmonics3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spline", function() { return Spline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() { return SplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return TextBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGL1Renderer", function() { return WebGL1Renderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return WebGLCubeRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return WebGLMultisampleRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
// threejs.org/license
const REVISION = '123';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = "100";
const GLSL3 = "300 es";

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;

const MathUtils = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	// Deterministic pseudo-random float in the interval [ 0, 1 ]

	seededRandom: function ( s ) {

		if ( s !== undefined ) _seed = s % 2147483647;

		// Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;

		return ( _seed - 1 ) / 2147483646;

	},

	degToRad: function ( degrees ) {

		return degrees * MathUtils.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * MathUtils.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	},

	setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos;
		const sin = Math.sin;

		const c2 = cos( b / 2 );
		const s2 = sin( b / 2 );

		const c13 = cos( ( a + c ) / 2 );
		const s13 = sin( ( a + c ) / 2 );

		const c1_3 = cos( ( a - c ) / 2 );
		const s1_3 = sin( ( a - c ) / 2 );

		const c3_1 = cos( ( c - a ) / 2 );
		const s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

			default:
				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

		}

	}

};

class Vector2 {

	constructor( x = 0, y = 0 ) {

		Object.defineProperty( this, 'isVector2', { value: true } );

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

}

class Matrix3 {

	constructor() {

		Object.defineProperty( this, 'isMatrix3', { value: true } );

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).copy( this ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

}

let _canvas;

const ImageUtils = {

	getDataURL: function ( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

};

let textureId = 0;

function Texture( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';

	this.image = image;
	this.mipmaps = [];

	this.mapping = mapping;

	this.wrapS = wrapS;
	this.wrapT = wrapT;

	this.magFilter = magFilter;
	this.minFilter = minFilter;

	this.anisotropy = anisotropy;

	this.format = format;
	this.internalFormat = null;
	this.type = type;

	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );
	this.center = new Vector2( 0, 0 );
	this.rotation = 0;

	this.matrixAutoUpdate = true;
	this.matrix = new Matrix3();

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding;

	this.version = 0;
	this.onUpdate = null;

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Texture,

	isTexture: true,

	updateMatrix: function () {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			const image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = MathUtils.generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				let url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( let i = 0, l = image.length; i < l; i ++ ) {

						// check cube texture with data textures

						if ( image[ i ].isDataTexture ) {

							url.push( serializeImage( image[ i ].image ) );

						} else {

							url.push( serializeImage( image[ i ] ) );

						}

					}

				} else {

					// process single image

					url = serializeImage( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

} );

Object.defineProperty( Texture.prototype, "needsUpdate", {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.prototype.slice.call( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		Object.defineProperty( this, 'isVector4', { value: true } );

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget( width, height, options ) {

	this.width = width;
	this.height = height;

	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new Vector4( 0, 0, width, height );

	options = options || {};

	this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.texture.image = {};
	this.texture.image.width = width;
	this.texture.image.height = height;

	this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
	this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

}

WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: WebGLRenderTarget,

	isWebGLRenderTarget: true,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.texture.image.width = width;
			this.texture.image.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

function WebGLMultisampleRenderTarget( width, height, options ) {

	WebGLRenderTarget.call( this, width, height, options );

	this.samples = 4;

}

WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

	constructor: WebGLMultisampleRenderTarget,

	isWebGLMultisampleRenderTarget: true,

	copy: function ( source ) {

		WebGLRenderTarget.prototype.copy.call( this, source );

		this.samples = source.samples;

		return this;

	}

} );

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		Object.defineProperty( this, 'isQuaternion', { value: true } );

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		const EPS = 0.000001;

		let r = vFrom.dot( vTo ) + 1;

		if ( r < EPS ) {

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		Object.defineProperty( this, 'isVector3', { value: true } );

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min, max ) {

		Object.defineProperty( this, 'isBox3', { value: true } );

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box.copy( geometry.boundingBox );
			_box.applyMatrix4( object.matrixWorld );

			this.union( _box );

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new Vector3();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$1 );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0.subVectors( triangle.a, _center );
		_v1.subVectors( triangle.b, _center );
		_v2.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1, _v0 );
		_f1.subVectors( _v2, _v1 );
		_f2.subVectors( _v0, _v2 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0, _v1, _v2, _extents );

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		if ( target === undefined ) {

			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
			//target = new Sphere(); // removed to avoid cyclic dependency

		}

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$1 ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the seperating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the seperating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is seperating and we can exit
			return false;

		}

	}

	return true;

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$1 = /*@__PURE__*/ new Vector3();

const _box = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0 = /*@__PURE__*/ new Vector3();
const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

const _box$1 = /*@__PURE__*/ new Box3();

class Sphere {

	constructor( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : - 1;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$1.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new Vector3();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new Box3();

		}

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$2 ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$2.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$2.subVectors( sphere.center, this.origin );
		const tca = _vector$2.dot( this.direction );
		const d2 = _vector$2.dot( _vector$2 ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$2 ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

}

class Matrix4 {

	constructor() {

		Object.defineProperty( this, 'isMatrix4', { value: true } );

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$1.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$1.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$1 = /*@__PURE__*/ new Vector3();
const _m1 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		Object.defineProperty( this, 'isEuler', { value: true } );

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order, update ) {

		const clamp = MathUtils.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	}

	setFromVector3( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$1.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$1, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

const _matrix = /*@__PURE__*/ new Matrix4();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = 1 << channel | 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

}

let _object3DId = 0;

const _v1$2 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();

const _position = new Vector3();
const _scale = new Vector3();
const _quaternion$2 = new Quaternion();

const _xAxis = new Vector3( 1, 0, 0 );
const _yAxis = new Vector3( 0, 1, 0 );
const _zAxis = new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	const position = new Vector3();
	const rotation = new Euler();
	const quaternion = new Quaternion();
	const scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.animations = [];

	this.userData = {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix4: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$2.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$2.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	clear: function () {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new Quaternion();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, _quaternion$2, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal, constant ) {

		Object.defineProperty( this, 'isPlane', { value: true } );

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
			target = new Vector3();

		}

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return undefined;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return undefined;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

}

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	static getNormal( a, b, c, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
			target = new Vector3();

		}

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$1.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$1 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$1 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
			target = new Vector3();

		}

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3 );

		return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3.x );
		target.addScaledVector( uv2, _v3.y );
		target.addScaledVector( uv3, _v3.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new Plane();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

class Color {

	constructor( r, g, b ) {

		Object.defineProperty( this, 'isColor', { value: true } );

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	}

	setRGB( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	}

	setHSL( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = MathUtils.euclideanModulo( h, 1 );
		s = MathUtils.clamp( s, 0, 1 );
		l = MathUtils.clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	}

	setStyle( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	}

	setColorName( style ) {

		// color keywords
		const hex = _colorKeywords[ style ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copyGammaToLinear( color, gammaFactor = 2.0 ) {

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	}

	copyLinearToGamma( color, gammaFactor = 2.0 ) {

		const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	}

	convertGammaToLinear( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	}

	convertLinearToGamma( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex() {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	}

	getHexString() {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	}

	getHSL( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		const r = this.r, g = this.g, b = this.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getStyle() {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
		const s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
		const l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

}

Color.NAMES = _colorKeywords;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;

class Face3 {

	constructor( a, b, c, normal, color, materialIndex = 0 ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( let i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( let i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

}

let materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.flatShading = false;
	this.vertexColors = false;

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.stencilWriteMask = 0xff;
	this.stencilFunc = AlwaysStencilFunc;
	this.stencilRef = 0;
	this.stencilFuncMask = 0xff;
	this.stencilFail = KeepStencilOp;
	this.stencilZFail = KeepStencilOp;
	this.stencilZPass = KeepStencilOp;
	this.stencilWrite = false;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.toneMapped = true;

	this.userData = {};

	this.version = 0;

}

Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function ( /* shaderobject, renderer */ ) {},

	customProgramCacheKey: function () {

		return this.onBeforeCompile.toString();

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap
			data.refractionRatio = this.refractionRatio;

			if ( this.combine !== undefined ) data.combine = this.combine;
			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.flatShading === true ) data.flatShading = this.flatShading;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.morphTargets === true ) data.morphTargets = true;
		if ( this.morphNormals === true ) data.morphNormals = true;
		if ( this.skinning === true ) data.skinning = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.flatShading = source.flatShading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

Object.defineProperty( Material.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

const _vector$3 = new Vector3();
const _vector2$1 = new Vector2();

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	applyMatrix3: function ( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.fromBufferAttribute( this, i );
				_vector$3.applyMatrix3( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyMatrix4( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyNormalMatrix( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.transformDirection( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	},

	toJSON: function () {

		return {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

	}

} );

//

function Int8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

function Float32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

class DirectGeometry {

	constructor() {

		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	computeGroups( geometry ) {

		const groups = [];

		let group, i;
		let materialIndex = undefined;

		const faces = geometry.faces;

		for ( i = 0; i < faces.length; i ++ ) {

			const face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	}

	fromGeometry( geometry ) {

		const faces = geometry.faces;
		const vertices = geometry.vertices;
		const faceVertexUvs = geometry.faceVertexUvs;

		const hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		const hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		const morphTargets = geometry.morphTargets;
		const morphTargetsLength = morphTargets.length;

		let morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( let i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = {
					name: morphTargets[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		const morphNormals = geometry.morphNormals;
		const morphNormalsLength = morphNormals.length;

		let morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( let i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = {
					name: morphNormals[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		const skinIndices = geometry.skinIndices;
		const skinWeights = geometry.skinWeights;

		const hasSkinIndices = skinIndices.length === vertices.length;
		const hasSkinWeights = skinWeights.length === vertices.length;

		//

		if ( vertices.length > 0 && faces.length === 0 ) {

			console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

		}

		for ( let i = 0; i < faces.length; i ++ ) {

			const face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			const vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				const normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			const vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				const color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				const vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				const vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			// morphs

			for ( let j = 0; j < morphTargetsLength; j ++ ) {

				const morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( let j = 0; j < morphNormalsLength; j ++ ) {

				const morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	}

}

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	let max = array[ 0 ];

	for ( let i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	// Workaround for IE11 pre KB2929437. See #11440
	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

let _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

const _m1$2 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box$2 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$4 = new Vector3();

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};
	this.morphTargetsRelative = false;

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

	this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	setAttribute: function ( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	},

	deleteAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	hasAttribute: function ( name ) {

		return this.attributes[ name ] !== undefined;

	},

	addGroup: function ( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix4: function ( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1$2.makeRotationX( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1$2.makeRotationY( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1$2.makeRotationZ( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1$2.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1$2.makeScale( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		const geometry = object.geometry;

		if ( object.isPoints || object.isLine ) {

			const positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			const colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

			this.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				const lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

				this.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object.isMesh ) {

			if ( geometry && geometry.isGeometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	setFromPoints: function ( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	},

	updateFromObject: function ( object ) {

		let geometry = object.geometry;

		if ( object.isMesh ) {

			let direct = geometry.__directGeometry;

			if ( geometry.elementsNeedUpdate === true ) {

				direct = undefined;
				geometry.elementsNeedUpdate = false;

			}

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		if ( geometry.verticesNeedUpdate === true ) {

			const attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			const attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			const attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			const attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			const attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		const positions = new Float32Array( geometry.vertices.length * 3 );
		this.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			const normals = new Float32Array( geometry.normals.length * 3 );
			this.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			const colors = new Float32Array( geometry.colors.length * 3 );
			this.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			const uvs = new Float32Array( geometry.uvs.length * 2 );
			this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			const uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( const name in geometry.morphTargets ) {

			const array = [];
			const morphTargets = geometry.morphTargets[ name ];

			for ( let i = 0, l = morphTargets.length; i < l; i ++ ) {

				const morphTarget = morphTargets[ i ];

				const attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
				attribute.name = morphTarget.name;

				array.push( attribute.copyVector3sArray( morphTarget.data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			const skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			const skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$4 );

						_vector$4.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$4 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$4 );

						_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$4 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$4.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$4.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$4.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	},

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$4.fromBufferAttribute( normals, i );

			_vector$4.normalize();

			normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

		}

	},

	toNonIndexed: function () {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const attributeData = attribute.toJSON( data.data );

			if ( attribute.name !== '' ) attributeData.name = attribute.name;

			data.data.attributes[ key ] = attributeData;

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				const attributeData = attribute.toJSON( data.data );

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				array.push( attributeData );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();

const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();

const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();

const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();

const _uvA = new Vector2();
const _uvB = new Vector2();
const _uvC = new Vector2();

const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();

function Mesh( geometry, material ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial();

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			const isMultiMaterial = Array.isArray( material );

			const vertices = geometry.vertices;
			const faces = geometry.faces;
			let uvs;

			const faceVertexUvs = geometry.faceVertexUvs[ 0 ];
			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

			for ( let f = 0, fl = faces.length; f < fl; f ++ ) {

				const face = faces[ f ];
				const faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

				if ( faceMaterial === undefined ) continue;

				const fvA = vertices[ face.a ];
				const fvB = vertices[ face.b ];
				const fvC = vertices[ face.c ];

				intersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );

				if ( intersection ) {

					if ( uvs && uvs[ f ] ) {

						const uvs_f = uvs[ f ];
						_uvA.copy( uvs_f[ 0 ] );
						_uvB.copy( uvs_f[ 1 ] );
						_uvC.copy( uvs_f[ 2 ] );

						intersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );

					}

					intersection.face = face;
					intersection.faceIndex = f;
					intersects.push( intersection );

				}

			}

		}

	}

} );

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA.fromBufferAttribute( position, a );
	_vB.fromBufferAttribute( position, b );
	_vC.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( material.morphTargets && morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC ), influence );

			}

		}

		_vA.add( _morphA );
		_vB.add( _morphB );
		_vC.add( _morphC );

	}

	if ( object.isSkinnedMesh ) {

		object.boneTransform( a, _vA );
		object.boneTransform( b, _vB );
		object.boneTransform( c, _vC );

	}

	const intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA.fromBufferAttribute( uv, a );
			_uvB.fromBufferAttribute( uv, b );
			_uvC.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

		}

		if ( uv2 ) {

			_uvA.fromBufferAttribute( uv2, a );
			_uvB.fromBufferAttribute( uv2, b );
			_uvC.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

		}

		const face = new Face3( a, b, c );
		Triangle.getNormal( _vA, _vB, _vC, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxBufferGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = default_vertex;
	this.fragmentShader = default_fragment;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	this.glslVersion = null;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = cloneUniforms( source.uniforms );

	this.defines = Object.assign( {}, source.defines );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = Object.assign( {}, source.extensions );

	this.glslVersion = source.glslVersion;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	const data = Material.prototype.toJSON.call( this, meta );

	data.glslVersion = this.glslVersion;
	data.uniforms = {};

	for ( const name in this.uniforms ) {

		const uniform = this.uniforms[ name ];
		const value = uniform.value;

		if ( value && value.isTexture ) {

			data.uniforms[ name ] = {
				type: 't',
				value: value.toJSON( meta ).uuid
			};

		} else if ( value && value.isColor ) {

			data.uniforms[ name ] = {
				type: 'c',
				value: value.getHex()
			};

		} else if ( value && value.isVector2 ) {

			data.uniforms[ name ] = {
				type: 'v2',
				value: value.toArray()
			};

		} else if ( value && value.isVector3 ) {

			data.uniforms[ name ] = {
				type: 'v3',
				value: value.toArray()
			};

		} else if ( value && value.isVector4 ) {

			data.uniforms[ name ] = {
				type: 'v4',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix3 ) {

			data.uniforms[ name ] = {
				type: 'm3',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix4 ) {

			data.uniforms[ name ] = {
				type: 'm4',
				value: value.toArray()
			};

		} else {

			data.uniforms[ name ] = {
				value: value
			};

			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

		}

	}

	if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	const extensions = {};

	for ( const key in this.extensions ) {

		if ( this.extensions[ key ] === true ) extensions[ key ] = true;

	}

	if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

	return data;

};

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();

	this.projectionMatrix = new Matrix4();
	this.projectionMatrixInverse = new Matrix4();

}

Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Camera,

	isCamera: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

function PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov;
	this.zoom = 1;

	this.near = near;
	this.far = far;
	this.focus = 10;

	this.aspect = aspect;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		const vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return MathUtils.RAD2DEG * 2 * Math.atan(
			Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		const near = this.near;
		let top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	},

	toJSON: function ( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

const fov = 90, aspect = 1;

function CubeCamera( near, far, renderTarget ) {

	Object3D.call( this );

	this.type = 'CubeCamera';

	if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

		console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
		return;

	}

	this.renderTarget = renderTarget;

	const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
	cameraPX.layers = this.layers;
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
	cameraNX.layers = this.layers;
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
	cameraPY.layers = this.layers;
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
	cameraNY.layers = this.layers;
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.layers = this.layers;
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.layers = this.layers;
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.update = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const currentXrEnabled = renderer.xr.enabled;
		const currentRenderTarget = renderer.getRenderTarget();

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.xr.enabled = currentXrEnabled;

	};

}

CubeCamera.prototype = Object.create( Object3D.prototype );
CubeCamera.prototype.constructor = CubeCamera;

function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	format = format !== undefined ? format : RGBFormat;

	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

	// Why CubeTexture._needsFlipEnvMap is necessary:
	//
	// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
	// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
	// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

	// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
	// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
	// when using WebGLCubeRenderTarget.texture as a cube texture.

	this._needsFlipEnvMap = true;

}

CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty( CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

function WebGLCubeRenderTarget( size, options, dummy ) {

	if ( Number.isInteger( options ) ) {

		console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

		options = dummy;

	}

	WebGLRenderTarget.call( this, size, size, options );

	options = options || {};

	this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.texture._needsFlipEnvMap = false;

}

WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {

	this.texture.type = texture.type;
	this.texture.format = RGBAFormat; // see #18859
	this.texture.encoding = texture.encoding;

	this.texture.generateMipmaps = texture.generateMipmaps;
	this.texture.minFilter = texture.minFilter;
	this.texture.magFilter = texture.magFilter;

	const shader = {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: /* glsl */`

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,

		fragmentShader: /* glsl */`

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
	};

	const geometry = new BoxBufferGeometry( 5, 5, 5 );

	const material = new ShaderMaterial( {

		name: 'CubemapFromEquirect',

		uniforms: cloneUniforms( shader.uniforms ),
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader,
		side: BackSide,
		blending: NoBlending

	} );

	material.uniforms.tEquirect.value = texture;

	const mesh = new Mesh( geometry, material );

	const currentMinFilter = texture.minFilter;

	// Avoid blurred poles
	if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

	const camera = new CubeCamera( 1, 10, this );
	camera.update( renderer, mesh );

	texture.minFilter = currentMinFilter;

	mesh.geometry.dispose();
	mesh.material.dispose();

	return this;

};

WebGLCubeRenderTarget.prototype.clear = function ( renderer, color, depth, stencil ) {

	const currentRenderTarget = renderer.getRenderTarget();

	for ( let i = 0; i < 6; i ++ ) {

		renderer.setRenderTarget( this, i );

		renderer.clear( color, depth, stencil );

	}

	renderer.setRenderTarget( currentRenderTarget );

};

function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data || null, width: width || 1, height: height || 1 };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.generateMipmaps = false;
	this.flipY = false;
	this.unpackAlignment = 1;

	this.needsUpdate = true;

}

DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;

const _sphere$1 = /*@__PURE__*/ new Sphere();
const _vector$5 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	}

	intersectsSprite( sprite ) {

		_sphere$1.center.set( 0, 0, 0 );
		_sphere$1.radius = 0.7071067811865476;
		_sphere$1.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$5 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type = 5126;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = 5131;

				} else {

					console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = 5123;

			}

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneBufferGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();
		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";

var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmissionmap_fragment: transmissionmap_fragment,
	transmissionmap_pars_fragment: transmissionmap_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_frag: background_frag,
	background_vert: background_vert,
	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshmatcap_frag: meshmatcap_frag,
	meshmatcap_vert: meshmatcap_vert,
	meshtoon_frag: meshtoon_frag,
	meshtoon_vert: meshtoon_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert,
	sprite_frag: sprite_frag,
	sprite_vert: sprite_vert
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: new Color( 0x000000 ) },
			transmission: { value: 0 },
			transmissionMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = 0;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene, camera, forceClear ) {

		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			background = cubemaps.get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxBufferGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			if ( background.isWebGLCubeRenderTarget ) {

				// TODO Deprecate

				background = background.texture;

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneBufferGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( 34921 );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( geometry, index );

			if ( updateBuffers ) saveCache( geometry, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( object.isInstancedMesh === true ) {

			updateBuffers = true;

		}

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( 34963, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( geometry, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		for ( const key in geometryAttributes ) {

			const cachedAttribute = cachedAttributes[ key ];
			const geometryAttribute = geometryAttributes[ key ];

			if ( cachedAttribute === undefined ) return true;

			if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			attributesNum ++;

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( geometry, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const data = {};
			data.attribute = attribute;

			if ( attribute.data ) {

				data.data = attribute.data;

			}

			cache[ key ] = data;

			attributesNum ++;

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				const geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( 34962, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( 34962, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					}

				} else if ( name === 'instanceMatrix' ) {

					const attribute = attributes.get( object.instanceMatrix );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute + 0, 1 );
					enableAttributeAndDivisor( programAttribute + 1, 1 );
					enableAttributeAndDivisor( programAttribute + 2, 1 );
					enableAttributeAndDivisor( programAttribute + 3, 1 );

					gl.bindBuffer( 34962, buffer );

					gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				} else if ( name === 'instanceColor' ) {

					const attribute = attributes.get( object.instanceColor );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute, 1 );

					gl.bindBuffer( 34962, buffer );

					gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatilibity

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	/* eslint-disable no-undef */
	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	/* eslint-enable no-undef */

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( 34930 );
	const maxVertexTextures = gl.getParameter( 35660 );
	const maxTextureSize = gl.getParameter( 3379 );
	const maxCubemapSize = gl.getParameter( 34076 );

	const maxAttributes = gl.getParameter( 34921 );
	const maxVertexUniforms = gl.getParameter( 36347 );
	const maxVaryings = gl.getParameter( 36348 );
	const maxFragmentUniforms = gl.getParameter( 36349 );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const currentRenderList = renderer.getRenderList();
						const currentRenderTarget = renderer.getRenderTarget();
						const currentRenderState = renderer.getRenderState();

						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						renderer.setRenderTarget( currentRenderTarget );
						renderer.setRenderList( currentRenderList );
						renderer.setRenderState( currentRenderState );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	return {

		has: function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ] !== null;

			}

			let extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension !== null;

		},

		get: function ( name ) {

			if ( ! this.has( name ) ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extensions[ name ];

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = new WeakMap();
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;
		const buffergeometry = geometries.get( geometry );

		if ( buffergeometry.index !== null ) {

			attributes.remove( buffergeometry.index );

		}

		for ( const name in buffergeometry.attributes ) {

			attributes.remove( buffergeometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		geometries.delete( geometry );

		const attribute = wireframeAttributes.get( buffergeometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( buffergeometry );

		}

		bindingStates.releaseStatesOfGeometry( buffergeometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		let buffergeometry = geometries.get( geometry );

		if ( buffergeometry ) return buffergeometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		if ( geometry.isBufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry.isGeometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries.set( geometry, buffergeometry );

		info.memory.geometries ++;

		return buffergeometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		let influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( let i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		// Collect influences

		for ( let i = 0; i < length; i ++ ) {

			const influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		for ( let i = 0; i < 8; i ++ ) {

			if ( i < length && influences[ i ][ 1 ] ) {

				workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
				workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

			} else {

				workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
				workInfluences[ i ][ 1 ] = 0;

			}

		}

		workInfluences.sort( numericalSort );

		const morphTargets = material.morphTargets && geometry.morphAttributes.position;
		const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < 8; i ++ ) {

			const influence = workInfluences[ i ];
			const index = influence[ 0 ];
			const value = influence[ 1 ];

			if ( index !== Number.MAX_SAFE_INTEGER && value ) {

				if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

					geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

				}

				if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

					geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

				}

				morphInfluences[ i ] = value;
				morphInfluencesSum += value;

			} else {

				if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

					geometry.deleteAttribute( 'morphTarget' + i );

				}

				if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

					geometry.deleteAttribute( 'morphNormal' + i );

				}

				morphInfluences[ i ] = 0;

			}

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			if ( geometry.isGeometry ) {

				buffergeometry.updateFromObject( object );

			}

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			attributes.update( object.instanceMatrix, 34962 );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, 34962 );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	return {

		update: update,
		dispose: dispose

	};

}

function DataTexture2DArray( data = null, width = 1, height = 1, depth = 1 ) {

	Texture.call( this, null );

	this.image = { data, width, height, depth };

	this.magFilter = NearestFilter;
	this.minFilter = NearestFilter;

	this.wrapR = ClampToEdgeWrapping;

	this.generateMipmaps = false;
	this.flipY = false;

	this.needsUpdate = true;

}

DataTexture2DArray.prototype = Object.create( Texture.prototype );
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;

function DataTexture3D( data = null, width = 1, height = 1, depth = 1 ) {

	// We're going to add .setXXX() methods for setting properties later.
	// Users can still set in DataTexture3D directly.
	//
	//	const texture = new THREE.DataTexture3D( data, width, height, depth );
	// 	texture.anisotropy = 16;
	//
	// See #14839

	Texture.call( this, null );

	this.image = { data, width, height, depth };

	this.magFilter = NearestFilter;
	this.minFilter = NearestFilter;

	this.wrapR = ClampToEdgeWrapping;

	this.generateMipmaps = false;
	this.flipY = false;

	this.needsUpdate = true;


}

DataTexture3D.prototype = Object.create( Texture.prototype );
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTexture2D( v || emptyTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// uint

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}

// Array of scalars
function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}


// Array of vectors (flat or from THREE classes)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (flat or from THREE clases)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of textures (2D / Cube)

function setValueT1Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	const cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	const seq = this.seq;

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	const n = gl.getProgramParameter( program, 35718 );

	for ( let i = 0; i < n; ++ i ) {

		const info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	const u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	const v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	const r = [];

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

let programIdCount = 0;

function addLineNumbers( string ) {

	const lines = string.split( '\n' );

	for ( let i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		case LogLuvEncoding:
			return [ 'LogLuv', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, 35713 );
	const log = gl.getShaderInfoLog( shader ).trim();

	if ( status && log === '' ) return '';

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	const source = gl.getShaderSource( shader );

	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

}

function getTexelDecodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, 35721 );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

	if ( parameters.precision === "highp" ) {

		precisionstring += "\n#define HIGH_PRECISION";

	} else if ( parameters.precision === "mediump" ) {

		precisionstring += "\n#define MEDIUM_PRECISION";

	} else if ( parameters.precision === "lowp" ) {

		precisionstring += "\n#define LOW_PRECISION";

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:
			case CubeUVRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + "\n" : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const floatVertexTextures = capabilities.floatVertexTextures;
	const maxVertexUniforms = capabilities.maxVertexUniforms;
	const vertexTextures = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	const parameterNames = [
		"precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor",
		"map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",
		"lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",
		"sheen", "transmissionMap"
	];

	function getMaxBones( object ) {

		const skeleton = object.skeleton;
		const bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			const nVertexUniforms = maxVertexUniforms;
			const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			const maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map ) {

		let encoding;

		if ( ! map ) {

			encoding = LinearEncoding;

		} else if ( map.isTexture ) {

			encoding = map.encoding;

		} else if ( map.isWebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		return encoding;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = cubemaps.get( material.envMap || environment );

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		let vertexShader, fragmentShader;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( envMap ),
			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			clearcoatMap: !! material.clearcoatMap,
			clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: !! material.clearcoatNormalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			sheen: !! material.sheen,

			transmissionMap: !! material.transmissionMap,

			combine: material.combine,

			vertexTangents: ( material.normalMap && material.vertexTangents ),
			vertexColors: material.vertexColors,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.fragmentShader );
			array.push( parameters.vertexShader );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			for ( let i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( renderer.outputEncoding );
			array.push( renderer.gammaFactor );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList( properties ) {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transparent = [];

	const defaultProgram = { id: - 1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];
		const materialProperties = properties.get( material );

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: materialProperties.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = materialProperties.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).push( renderItem );

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.program = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists( properties ) {

	let lists = new WeakMap();

	function get( scene, camera ) {

		const cameras = lists.get( scene );
		let list;

		if ( cameras === undefined ) {

			list = new WebGLRenderList( properties );
			lists.set( scene, new WeakMap() );
			lists.get( scene ).set( camera, list );

		} else {

			list = cameras.get( camera );
			if ( list === undefined ) {

				list = new WebGLRenderList( properties );
				cameras.set( camera, list );

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights, shadows, camera ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;

		const viewMatrix = camera.matrixWorldInverse;

		lights.sort( shadowCastingLightsFirst );

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				// TODO (abelnation): RectAreaLight distance?
				// uniforms.distance = distance;

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	return {
		setup: setup,
		state: state
	};

}

function WebGLRenderState( extensions, capabilities ) {

	const lights = new WebGLLights( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( camera ) {

		lights.setup( lightsArray, shadowsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, camera ) {

		let renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, new WeakMap() );
			renderStates.get( scene ).set( camera, renderState );

		} else {

			if ( renderStates.get( scene ).has( camera ) === false ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.get( scene ).set( camera, renderState );

			} else {

				renderState = renderStates.get( scene ).get( camera );

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;

	this.setValues( parameters );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

function MeshDistanceMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDistanceMaterial';

	this.referencePosition = new Vector3();
	this.nearDistance = 1;
	this.farDistance = 1000;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.fog = false;

	this.setValues( parameters );

}

MeshDistanceMaterial.prototype = Object.create( Material.prototype );
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.referencePosition.copy( source.referencePosition );
	this.nearDistance = source.nearDistance;
	this.farDistance = source.farDistance;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	return this;

};

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterials = [],
		_distanceMaterials = [],

		_materialCache = {};

	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {

		defines: {
			SAMPLE_RATE: 2.0 / 8.0,
			HALF_SAMPLE_RATE: 1.0 / 8.0
		},

		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vsm_vert,

		fragmentShader: vsm_frag

	} );

	const shadowMaterialHorizonal = shadowMaterialVertical.clone();
	shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		"position",
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {

				if ( _shadowMapSize.x > maxTextureSize ) {

					_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > maxTextureSize ) {

					_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizonal pass

		shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );

	}

	function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _depthMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ index ] = material;

		}

		return material;

	}

	function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _distanceMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ index ] = material;

		}

		return material;

	}

	function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		let getMaterialVariant = getDepthMaterialVariant;
		let customMaterial = object.customDepthMaterial;

		if ( light.isPointLight === true ) {

			getMaterialVariant = getDistanceMaterialVariant;
			customMaterial = object.customDistanceMaterial;

		}

		if ( customMaterial === undefined ) {

			let useMorphing = false;

			if ( material.morphTargets === true ) {

				useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			}

			let useSkinning = false;

			if ( object.isSkinnedMesh === true ) {

				if ( material.skinning === true ) {

					useSkinning = true;

				} else {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

			}

			const useInstancing = object.isInstancedMesh === true;

			result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	let enabledCapabilities = {};

	let currentProgram = null;

	let currentBlendingEnabled = null;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( 35661 );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const currentScissor = new Vector4();
	const currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( ! currentBlendingEnabled ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 0, 769, 771 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFunc( 0, 769 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		let boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentProgram = null;

		currentBlendingEnabled = null;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;

	const _videoTextures = new WeakMap();
	let _canvas;

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			&& ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			new OffscreenCanvas( width, height ) :
			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target, texture, width, height ) {

		_gl.generateMipmap( target );

		const textureProperties = properties.get( texture );

		// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
		textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

	}

	function getInternalFormat( internalFormatName, glFormat, glType ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 6407 ) {

			if ( glType === 5126 ) internalFormat = 34837;
			if ( glType === 5131 ) internalFormat = 34843;
			if ( glType === 5121 ) internalFormat = 32849;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = 32856;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		properties.remove( renderTarget.texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	const filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = 3553;

		if ( texture.isDataTexture2DArray ) textureType = 35866;
		if ( texture.isDataTexture3D ) textureType = 32879;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );

		const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
		const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		const supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format );

		let glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( textureType, texture, supportsMips );

		let mipmap;
		const mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = 6402;

			if ( isWebGL2 ) {

				if ( texture.type === FloatType ) {

					glInternalFormat = 36012;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = 33190;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = 35056;

				} else {

					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				}

			} else {

				if ( texture.type === FloatType ) {

					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				}

			}

			// validation checks for WebGL 1

			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );

				}

			}

			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				glInternalFormat = 34041;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );

				}

			}

			//

			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( glFormat !== null ) {

						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture2DArray ) {

			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( textureType, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );

		const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
		const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

		const cubeImage = [];

		for ( let i = 0; i < 6; i ++ ) {

			if ( ! isCompressed && ! isDataTexture ) {

				cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

			} else {

				cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

			}

		}

		const image = cubeImage[ 0 ],
			supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( 34067, texture, supportsMips );

		let mipmaps;

		if ( isCompressed ) {

			for ( let i = 0; i < 6; i ++ ) {

				mipmaps = cubeImage[ i ].mipmaps;

				for ( let j = 0; j < mipmaps.length; j ++ ) {

					const mipmap = mipmaps[ j ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

						}

					} else {

						state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else {

			mipmaps = texture.mipmaps;

			for ( let i = 0; i < 6; i ++ ) {

				if ( isDataTexture ) {

					state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];
						const mipmapImage = mipmap.image[ i ].image;

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

					}

				} else {

					state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length;

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			// We assume images for cube map have the same size.
			generateMipmap( 34067, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		const glFormat = utils.convert( renderTarget.texture.format );
		const glType = utils.convert( renderTarget.texture.type );
		const glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
		state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( 36160, framebuffer );
		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( 36160, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = 33189;

			if ( isMultisample ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			const glFormat = utils.convert( renderTarget.texture.format );
			const glType = utils.convert( renderTarget.texture.type );
			const glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		_gl.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		_gl.bindFramebuffer( 36160, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		info.memory.textures ++;

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		// Handles WebGL2 RGBFormat fallback - #18858

		if ( isWebGL2 && renderTarget.texture.format === RGBFormat && ( renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType ) ) {

			renderTarget.texture.format = RGBAFormat;

			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultisample ) {

				if ( isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					const glFormat = utils.convert( renderTarget.texture.format );
					const glType = utils.convert( renderTarget.texture.type );
					const glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					_gl.bindFramebuffer( 36160, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, renderTarget.texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 34067, null );

		} else {

			state.bindTexture( 3553, textureProperties.__webglTexture );
			setTextureParameters( 3553, renderTarget.texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 3553, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const texture = renderTarget.texture;
		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
			const webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
			state.bindTexture( target, null );

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( isWebGL2 ) {

				const renderTargetProperties = properties.get( renderTarget );

				_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = 16384;

				if ( renderTarget.depthBuffer ) mask |= 256;
				if ( renderTarget.stencilBuffer ) mask |= 1024;

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	// backwards compatibility

	let warnedTexture2D = false;
	let warnedTextureCube = false;

	function safeSetTexture2D( texture, slot ) {

		if ( texture && texture.isWebGLRenderTarget ) {

			if ( warnedTexture2D === false ) {

				console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
				warnedTexture2D = true;

			}

			texture = texture.texture;

		}

		setTexture2D( texture, slot );

	}

	function safeSetTextureCube( texture, slot ) {

		if ( texture && texture.isWebGLCubeRenderTarget ) {

			if ( warnedTextureCube === false ) {

				console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
				warnedTextureCube = true;

			}

			texture = texture.texture;

		}


		setTextureCube( texture, slot );

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;

}

function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p ) {

		let extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;
		if ( p === UnsignedShort565Type ) return 33635;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBFormat ) return 6407;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBIntegerFormat ) return 36248;
		if ( p === RGBAIntegerFormat ) return 36249;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			} else {

				return null;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			}

		}

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
			p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
			p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
			p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
			p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
			p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}

function ArrayCamera( array = [] ) {

	PerspectiveCamera.call( this );

	this.cameras = array;

}

ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

	constructor: ArrayCamera,

	isArrayCamera: true

} );

function Group() {

	Object3D.call( this );

	this.type = 'Group';

}

Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Group,

	isGroup: true

} );

function WebXRController() {

	this._targetRay = null;
	this._grip = null;
	this._hand = null;

}

Object.assign( WebXRController.prototype, {

	constructor: WebXRController,

	getHandSpace: function () {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = [];
			this._hand.inputState = { pinching: false };

			if ( window.XRHand ) {

				for ( let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i ++ ) {

					// The transform of this joint will be updated with the joint pose on each frame
					const joint = new Group();
					joint.matrixAutoUpdate = false;
					joint.visible = false;
					this._hand.joints.push( joint );
					// ??
					this._hand.add( joint );

				}

			}

		}

		return this._hand;

	},

	getTargetRaySpace: function () {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;

		}

		return this._targetRay;

	},

	getGripSpace: function () {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;

		}

		return this._grip;

	},

	dispatchEvent: function ( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	},

	disconnect: function ( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	},

	update: function ( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i ++ ) {

					if ( inputSource.hand[ i ] ) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose( inputSource.hand[ i ], referenceSpace );
						const joint = hand.joints[ i ];

						if ( jointPose !== null ) {

							joint.matrix.fromArray( jointPose.transform.matrix );
							joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
							joint.jointRadius = jointPose.radius;

						}

						joint.visible = jointPose !== null;

						// Custom events

						// Check pinch
						const indexTip = hand.joints[ window.XRHand.INDEX_PHALANX_TIP ];
						const thumbTip = hand.joints[ window.XRHand.THUMB_PHALANX_TIP ];
						const distance = indexTip.position.distanceTo( thumbTip.position );

						const distanceToPinch = 0.02;
						const threshold = 0.005;

						if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

							hand.inputState.pinching = false;
							this.dispatchEvent( {
								type: "pinchend",
								handedness: inputSource.handedness,
								target: this
							} );

						} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

							hand.inputState.pinching = true;
							this.dispatchEvent( {
								type: "pinchstart",
								handedness: inputSource.handedness,
								target: this
							} );

						}

					}

				}

			} else {

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					}

				}

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

					}

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

} );

function WebXRManager( renderer, gl ) {

	const scope = this;

	let session = null;

	let framebufferScaleFactor = 1.0;

	let referenceSpace = null;
	let referenceSpaceType = 'local-floor';

	let pose = null;

	const controllers = [];
	const inputSourcesMap = new Map();

	//

	const cameraL = new PerspectiveCamera();
	cameraL.layers.enable( 1 );
	cameraL.viewport = new Vector4();

	const cameraR = new PerspectiveCamera();
	cameraR.layers.enable( 2 );
	cameraR.viewport = new Vector4();

	const cameras = [ cameraL, cameraR ];

	const cameraVR = new ArrayCamera();
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	let _currentDepthNear = null;
	let _currentDepthFar = null;

	//

	this.enabled = false;

	this.isPresenting = false;

	this.getController = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getTargetRaySpace();

	};

	this.getControllerGrip = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getGripSpace();

	};

	this.getHand = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getHandSpace();

	};

	//

	function onSessionEvent( event ) {

		const controller = inputSourcesMap.get( event.inputSource );

		if ( controller ) {

			controller.dispatchEvent( { type: event.type, data: event.inputSource } );

		}

	}

	function onSessionEnd() {

		inputSourcesMap.forEach( function ( controller, inputSource ) {

			controller.disconnect( inputSource );

		} );

		inputSourcesMap.clear();

		//

		renderer.setFramebuffer( null );
		renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
		animation.stop();

		scope.isPresenting = false;

		scope.dispatchEvent( { type: 'sessionend' } );

	}

	function onRequestReferenceSpace( value ) {

		referenceSpace = value;

		animation.setContext( session );
		animation.start();

		scope.isPresenting = true;

		scope.dispatchEvent( { type: 'sessionstart' } );

	}

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

		}

	};

	this.setReferenceSpaceType = function ( value ) {

		referenceSpaceType = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

		}

	};

	this.getReferenceSpace = function () {

		return referenceSpace;

	};

	this.getSession = function () {

		return session;

	};

	this.setSession = function ( value ) {

		session = value;

		if ( session !== null ) {

			session.addEventListener( 'select', onSessionEvent );
			session.addEventListener( 'selectstart', onSessionEvent );
			session.addEventListener( 'selectend', onSessionEvent );
			session.addEventListener( 'squeeze', onSessionEvent );
			session.addEventListener( 'squeezestart', onSessionEvent );
			session.addEventListener( 'squeezeend', onSessionEvent );
			session.addEventListener( 'end', onSessionEnd );

			const attributes = gl.getContextAttributes();

			if ( attributes.xrCompatible !== true ) {

				gl.makeXRCompatible();

			}

			const layerInit = {
				antialias: attributes.antialias,
				alpha: attributes.alpha,
				depth: attributes.depth,
				stencil: attributes.stencil,
				framebufferScaleFactor: framebufferScaleFactor
			};

			// eslint-disable-next-line no-undef
			const baseLayer = new XRWebGLLayer( session, gl, layerInit );

			session.updateRenderState( { baseLayer: baseLayer } );

			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

			//

			session.addEventListener( 'inputsourceschange', updateInputSources );

		}

	};

	function updateInputSources( event ) {

		const inputSources = session.inputSources;

		// Assign inputSources to available controllers

		for ( let i = 0; i < controllers.length; i ++ ) {

			inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

		}

		// Notify disconnected

		for ( let i = 0; i < event.removed.length; i ++ ) {

			const inputSource = event.removed[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
				inputSourcesMap.delete( inputSource );

			}

		}

		// Notify connected

		for ( let i = 0; i < event.added.length; i ++ ) {

			const inputSource = event.added[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'connected', data: inputSource } );

			}

		}

	}

	//

	const cameraLPos = new Vector3();
	const cameraRPos = new Vector3();

	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		const ipd = cameraLPos.distanceTo( cameraRPos );

		const projL = cameraL.projectionMatrix.elements;
		const projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		const left = near * leftFov;
		const right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		const zOffset = ipd / ( - leftFov + rightFov );
		const xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		const near2 = near + zOffset;
		const far2 = far + zOffset;
		const left2 = left - xOffset;
		const right2 = right + ( ipd - xOffset );
		const top2 = topFov * far / far2 * near2;
		const bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	function updateCamera( camera, parent ) {

		if ( parent === null ) {

			camera.matrixWorld.copy( camera.matrix );

		} else {

			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

		}

		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

	}

	this.getCamera = function ( camera ) {

		cameraVR.near = cameraR.near = cameraL.near = camera.near;
		cameraVR.far = cameraR.far = cameraL.far = camera.far;

		if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

			// Note that the new renderState won't apply until the next frame. See #18320

			session.updateRenderState( {
				depthNear: cameraVR.near,
				depthFar: cameraVR.far
			} );

			_currentDepthNear = cameraVR.near;
			_currentDepthFar = cameraVR.far;

		}

		const parent = camera.parent;
		const cameras = cameraVR.cameras;

		updateCamera( cameraVR, parent );

		for ( let i = 0; i < cameras.length; i ++ ) {

			updateCamera( cameras[ i ], parent );

		}

		// update camera and its children

		camera.matrixWorld.copy( cameraVR.matrixWorld );

		const children = camera.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( true );

		}

		// update projection matrix for proper view frustum culling

		if ( cameras.length === 2 ) {

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

		} else {

			// assume single camera setup (AR)

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

		}

		return cameraVR;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time, frame ) {

		pose = frame.getViewerPose( referenceSpace );

		if ( pose !== null ) {

			const views = pose.views;
			const baseLayer = session.renderState.baseLayer;

			renderer.setFramebuffer( baseLayer.framebuffer );

			let cameraVRNeedsUpdate = false;

			// check if it's necessary to rebuild cameraVR's camera list

			if ( views.length !== cameraVR.cameras.length ) {

				cameraVR.cameras.length = 0;
				cameraVRNeedsUpdate = true;

			}

			for ( let i = 0; i < views.length; i ++ ) {

				const view = views[ i ];
				const viewport = baseLayer.getViewport( view );

				const camera = cameras[ i ];
				camera.matrix.fromArray( view.transform.matrix );
				camera.projectionMatrix.fromArray( view.projectionMatrix );
				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

				if ( i === 0 ) {

					cameraVR.matrix.copy( camera.matrix );

				}

				if ( cameraVRNeedsUpdate === true ) {

					cameraVR.cameras.push( camera );

				}

			}

		}

		//

		const inputSources = session.inputSources;

		for ( let i = 0; i < controllers.length; i ++ ) {

			const controller = controllers[ i ];
			const inputSource = inputSources[ i ];

			controller.update( inputSource, frame, referenceSpace );

		}

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;

	};

	this.dispose = function () {};

}

Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

function WebGLMaterials( properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsLambert( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material );

			} else {

				refreshUniformsStandard( uniforms, material );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDepth( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsNormal( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			const maxMipLevel = properties.get( envMap ).__maxMipLevel;

			if ( maxMipLevel !== undefined ) {

				uniforms.maxMipLevel.value = maxMipLevel;

			}

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		refreshUniformsStandard( uniforms, material );

		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		uniforms.clearcoat.value = material.clearcoat;
		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		if ( material.clearcoatMap ) {

			uniforms.clearcoatMap.value = material.clearcoatMap;

		}

		if ( material.clearcoatRoughnessMap ) {

			uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		}

		if ( material.clearcoatNormalMap ) {

			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			if ( material.side === BackSide ) {

				uniforms.clearcoatNormalScale.value.negate();

			}

		}

		uniforms.transmission.value = material.transmission;

		if ( material.transmissionMap ) {

			uniforms.transmissionMap.value = material.transmissionMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function createCanvasElement() {

	const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters ) {

	parameters = parameters || {};

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let currentRenderList = null;
	let currentRenderState = null;

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _framebuffer = null;

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentFramebuffer = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;
	let _currentArrayCamera = null;

	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new Vector4( 0, 0, _width, _height );
	const _scissor = new Vector4( 0, 0, _width, _height );
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();

	const _vector3 = new Vector3();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		if ( capabilities.isWebGL2 === false ) {

			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'OES_element_index_uint' );
			extensions.get( 'OES_vertex_array_object' );
			extensions.get( 'ANGLE_instanced_arrays' );

		}

		extensions.get( 'OES_texture_float_linear' );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new WebGLCubeMaps( _this );
		attributes = new WebGLAttributes( _gl, capabilities );
		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl );
		clipping = new WebGLClipping( properties );
		programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
		materials = new WebGLMaterials( properties );
		renderLists = new WebGLRenderLists( properties );
		renderStates = new WebGLRenderStates( extensions, capabilities );
		background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// shadow map

	const shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

	this.shadowMap = shadowMap;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

			target = new Vector4();

		}

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function () {

		return background.getClearColor();

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		let bits = 0;

		if ( color === undefined || color ) bits |= 16384;
		if ( depth === undefined || depth ) bits |= 256;
		if ( stencil === undefined || stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		objects.dispose();
		bindingStates.dispose();

		xr.dispose();

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		initGLContext();

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReference( material ) {

		const programInfo = properties.get( material ).program;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program );

		} );

	}

	this.renderBufferImmediate = function ( object, program ) {

		bindingStates.initAttributes();

		const buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		const programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( 34962, buffers.position );
			_gl.bufferData( 34962, object.positionArray, 35048 );

			bindingStates.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( 34962, buffers.normal );
			_gl.bufferData( 34962, object.normalArray, 35048 );

			bindingStates.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

		}

		if ( object.hasUvs ) {

			_gl.bindBuffer( 34962, buffers.uv );
			_gl.bufferData( 34962, object.uvArray, 35048 );

			bindingStates.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

		}

		if ( object.hasColors ) {

			_gl.bindBuffer( 34962, buffers.color );
			_gl.bufferData( 34962, object.colorArray, 35048 );

			bindingStates.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

		}

		bindingStates.disableUnusedAttributes();

		_gl.drawArrays( 4, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		if ( material.morphTargets || material.morphNormals ) {

			morphtargets.update( object, geometry, material, program );

		}

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		const dataCount = ( index !== null ) ? index.count : position.count;

		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;

		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		const drawStart = Math.max( rangeStart, groupStart );
		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( camera );

		const compiled = new WeakMap();

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						if ( compiled.has( material2 ) === false ) {

							initMaterial( material2, scene, object );
							compiled.set( material2 );

						}

					}

				} else if ( compiled.has( material ) === false ) {

					initMaterial( material, scene, object );
					compiled.set( material );

				}

			}

		} );

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( xr.isPresenting ) return;
		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) animation.setContext( window );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	// Rendering

	this.render = function ( scene, camera ) {

		let renderTarget, forceClear;

		if ( arguments[ 2 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
			renderTarget = arguments[ 2 ];

		}

		if ( arguments[ 3 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
			forceClear = arguments[ 3 ];

		}

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// reset caching for this frame

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			camera = xr.getCamera( camera );

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, camera );
		currentRenderList.init();

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		currentRenderState.setupLights( camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		if ( renderTarget !== undefined ) {

			this.setRenderTarget( renderTarget );

		}

		//

		background.render( currentRenderList, scene, camera, forceClear );

		// render scene

		const opaqueObjects = currentRenderList.opaque;
		const transparentObjects = currentRenderList.transparent;

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		//

		if ( _currentRenderTarget !== null ) {

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		// _gl.finish();

		currentRenderList = null;
		currentRenderState = null;

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( camera.isArrayCamera ) {

				_currentArrayCamera = camera;

				const cameras = camera.cameras;

				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					const camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						state.viewport( _currentViewport.copy( camera2.viewport ) );

						currentRenderState.setupLights( camera2 );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				_currentArrayCamera = null;

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		if ( object.isImmediateRenderObject ) {

			const program = setProgram( camera, scene, material, object );

			state.setMaterial( material );

			bindingStates.reset();

			renderObjectImmediate( object, program );

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

	}

	function initMaterial( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let program = materialProperties.program;
		let programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.cacheKey !== programCacheKey ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

			programChange = false;

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list, envMap still needs the update here to avoid a frame-late effect

			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.envMap = cubemaps.get( material.envMap || environment );

			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );

			materialProperties.program = program;
			materialProperties.uniforms = parameters.uniforms;
			materialProperties.outputEncoding = parameters.outputEncoding;

		}

		const uniforms = materialProperties.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = clipping.numPlanes;
			materialProperties.numIntersection = clipping.numIntersection;
			uniforms.clippingPlanes = clipping.uniform;

		}

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = materialProperties.program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setProgram( camera, scene, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
		const envMap = cubemaps.get( material.envMap || environment );

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		if ( material.version === materialProperties.__version ) {

			if ( material.fog && materialProperties.fog !== fog ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.environment !== environment ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.outputEncoding !== encoding ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.envMap !== envMap ) {

				initMaterial( material, scene, object );

			}

		} else {

			initMaterial( material, scene, object );
			materialProperties.__version = material.version;

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// otherwise textures used for skinning can take over texture units reserved for other material textures

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				const bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						let size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = MathUtils.ceilPowerOfTwo( size );
						size = Math.max( size, 4 );

						const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	//
	this.setFramebuffer = function ( value ) {

		if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );

		_framebuffer = value;

	};

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderList = function () {

		return currentRenderList;

	};

	this.setRenderList = function ( renderList ) {

		currentRenderList = renderList;

	};

	this.getRenderState = function () {

		return currentRenderState;

	};

	this.setRenderState = function ( renderState ) {

		currentRenderState = renderState;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		let framebuffer = _framebuffer;
		let isCube = false;

		if ( renderTarget ) {

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( 36160, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			let restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( 36160, framebuffer );

				restore = true;

			}

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( 36160, _currentFramebuffer );

				}

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );
		const glFormat = utils.convert( texture.format );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

function WebGL1Renderer( parameters ) {

	WebGLRenderer.call( this, parameters );

}

WebGL1Renderer.prototype = Object.assign( Object.create( WebGLRenderer.prototype ), {

	constructor: WebGL1Renderer,

	isWebGL1Renderer: true

} );

class FogExp2 {

	constructor( color, density ) {

		Object.defineProperty( this, 'isFogExp2', { value: true } );

		this.name = '';

		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

}

class Fog {

	constructor( color, near, far ) {

		Object.defineProperty( this, 'isFog', { value: true } );

		this.name = '';

		this.color = new Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

class Scene extends Object3D {

	constructor() {

		super();

		Object.defineProperty( this, 'isScene', { value: true } );

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

}

function InterleavedBuffer( array, stride ) {

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

	this.uuid = MathUtils.generateUUID();

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( InterleavedBuffer.prototype, {

	isInterleavedBuffer: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	clone: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = MathUtils.generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new InterleavedBuffer( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	toJSON: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = MathUtils.generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

} );

const _vector$6 = new Vector3();

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.name = '';

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}

Object.defineProperties( InterleavedBufferAttribute.prototype, {

	count: {

		get: function () {

			return this.data.count;

		}

	},

	array: {

		get: function () {

			return this.data.array;

		}

	},

	needsUpdate: {

		set: function ( value ) {

			this.data.needsUpdate = value;

		}

	}

} );

Object.assign( InterleavedBufferAttribute.prototype, {

	isInterleavedBufferAttribute: true,

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	},

	clone: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	},

	toJSON: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interlaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

} );

/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial( parameters ) {

	Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.alphaMap = null;

	this.rotation = 0;

	this.sizeAttenuation = true;

	this.transparent = true;

	this.setValues( parameters );

}

SpriteMaterial.prototype = Object.create( Material.prototype );
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.rotation = source.rotation;

	this.sizeAttenuation = source.sizeAttenuation;

	return this;

};

let _geometry;

const _intersectPoint = new Vector3();
const _worldScale = new Vector3();
const _mvPosition = new Vector3();

const _alignedPosition = new Vector2();
const _rotatedPosition = new Vector2();
const _viewWorldMatrix = new Matrix4();

const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();

const _uvA$1 = new Vector2();
const _uvB$1 = new Vector2();
const _uvC$1 = new Vector2();

function Sprite( material ) {

	Object3D.call( this );

	this.type = 'Sprite';

	if ( _geometry === undefined ) {

		_geometry = new BufferGeometry();

		const float32Array = new Float32Array( [
			- 0.5, - 0.5, 0, 0, 0,
			0.5, - 0.5, 0, 1, 0,
			0.5, 0.5, 0, 1, 1,
			- 0.5, 0.5, 0, 0, 1
		] );

		const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

		_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
		_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
		_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

	}

	this.geometry = _geometry;
	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

	this.center = new Vector2( 0.5, 0.5 );

}

Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Sprite,

	isSprite: true,

	raycast: function ( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA$1.set( 0, 0 );
		_uvB$1.set( 1, 0 );
		_uvC$1.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB$1.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),
			face: null,
			object: this

		} );

	},

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

} );

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$4 = new Vector3();
const _v2$2 = new Vector3();

function LOD() {

	Object3D.call( this );

	this._currentLevel = 0;

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

	this.autoUpdate = true;

}

LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LOD,

	isLOD: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	},

	addLevel: function ( object, distance = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	},

	getCurrentLevel: function () {

		return this._currentLevel;

	},

	getObjectForDistance: function ( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	},

	raycast: function ( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$4.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$4 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	},

	update: function ( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$4.setFromMatrixPosition( camera.matrixWorld );
			_v2$2.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	},

	toJSON: function ( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

} );

function SkinnedMesh( geometry, material ) {

	if ( geometry && geometry.isGeometry ) {

		console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

	}

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	copy: function ( source ) {

		Mesh.prototype.copy.call( this, source );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	},

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	},

	updateMatrixWorld: function ( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	boneTransform: ( function () {

		const basePosition = new Vector3();

		const skinIndex = new Vector4();
		const skinWeight = new Vector4();

		const vector = new Vector3();
		const matrix = new Matrix4();

		return function ( index, target ) {

			const skeleton = this.skeleton;
			const geometry = this.geometry;

			skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
			skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

			basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

			target.set( 0, 0, 0 );

			for ( let i = 0; i < 4; i ++ ) {

				const weight = skinWeight.getComponent( i );

				if ( weight !== 0 ) {

					const boneIndex = skinIndex.getComponent( i );

					matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

					target.addScaledVector( vector.copy( basePosition ).applyMatrix4( matrix ), weight );

				}

			}

			return target.applyMatrix4( this.bindMatrixInverse );

		};

	}() )

} );

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();

function Skeleton( bones = [], boneInverses = [] ) {

	this.uuid = MathUtils.generateUUID();

	this.bones = bones.slice( 0 );
	this.boneInverses = boneInverses;
	this.boneMatrices = null;

	this.boneTexture = null;
	this.boneTextureSize = 0;

	this.frame = - 1;

	this.init();

}

Object.assign( Skeleton.prototype, {

	init: function () {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	},

	calculateInverses: function () {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: function () {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	},

	clone: function () {

		return new Skeleton( this.bones, this.boneInverses );

	},

	getBoneByName: function ( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	},

	dispose: function ( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	},

	fromJSON: function ( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

} );

const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();

const _instanceIntersects = [];

const _mesh = new Mesh();

function InstancedMesh( geometry, material, count ) {

	Mesh.call( this, geometry, material );

	this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
	this.instanceColor = null;

	this.count = count;

	this.frustumCulled = false;

}

InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: InstancedMesh,

	isInstancedMesh: true,

	copy: function ( source ) {

		Mesh.prototype.copy.call( this, source );

		this.instanceMatrix.copy( source.instanceMatrix );
		this.count = source.count;

		return this;

	},

	getColorAt: function ( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	},

	getMatrixAt: function ( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	},

	raycast: function ( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	},

	setColorAt: function ( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	},

	setMatrixAt: function ( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	},

	updateMorphTargets: function () {

	}

} );

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.morphTargets = false;

	this.setValues( parameters );

}

LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	this.morphTargets = source.morphTargets;

	return this;

};

const _start = new Vector3();
const _end = new Vector3();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$2 = new Sphere();

function Line( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

	}

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial();

	this.updateMorphTargets();

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start.fromBufferAttribute( positionAttribute, i - 1 );
					_end.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			const vertices = geometry.vertices;
			const lineDistances = geometry.lineDistances;

			lineDistances[ 0 ] = 0;

			for ( let i = 1, l = vertices.length; i < l; i ++ ) {

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

			}

		}

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere );
		_sphere$2.applyMatrix4( matrixWorld );
		_sphere$2.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const indices = index.array;

				for ( let i = 0, l = indices.length - 1; i < l; i += step ) {

					const a = indices[ i ];
					const b = indices[ i + 1 ];

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				for ( let i = 0, l = positionAttribute.count - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			const vertices = geometry.vertices;
			const nbVertices = vertices.length;

			for ( let i = 0; i < nbVertices - 1; i += step ) {

				const distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );

const _start$1 = new Vector3();
const _end$1 = new Vector3();

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true,

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start$1.fromBufferAttribute( positionAttribute, i );
					_end$1.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			const vertices = geometry.vertices;
			const lineDistances = geometry.lineDistances;

			for ( let i = 0, l = vertices.length; i < l; i += 2 ) {

				_start$1.copy( vertices[ i ] );
				_end$1.copy( vertices[ i + 1 ] );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

			}

		}

		return this;

	}

} );

function LineLoop( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineLoop';

}

LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineLoop,

	isLineLoop: true,

} );

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial( parameters ) {

	Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.alphaMap = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.morphTargets = false;

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.morphTargets = source.morphTargets;

	return this;

};

const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere();
const _position$1 = new Vector3();

function Points( geometry, material ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial();

	this.updateMorphTargets();

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );
		_sphere$3.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const indices = index.array;

				for ( let i = 0, il = indices.length; i < il; i ++ ) {

					const a = indices[ i ];

					_position$1.fromBufferAttribute( positionAttribute, a );

					testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

					_position$1.fromBufferAttribute( positionAttribute, i );

					testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			const vertices = geometry.vertices;

			for ( let i = 0, l = vertices.length; i < l; i ++ ) {

				testPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray$2.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray$2.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.format = format !== undefined ? format : RGBFormat;

	this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

	this.generateMipmaps = false;

	const scope = this;

	function updateVideo() {

		scope.needsUpdate = true;
		video.requestVideoFrameCallback( updateVideo );

	}

	if ( 'requestVideoFrameCallback' in video ) {

		video.requestVideoFrameCallback( updateVideo );

	}

}

VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

	constructor: VideoTexture,

	clone: function () {

		return new this.constructor( this.image ).copy( this );

	},

	isVideoTexture: true,

	update: function () {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

} );

function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

}

CompressedTexture.prototype = Object.create( Texture.prototype );
CompressedTexture.prototype.constructor = CompressedTexture;

CompressedTexture.prototype.isCompressedTexture = true;

function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

}

CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;

function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

	format = format !== undefined ? format : DepthFormat;

	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

	}

	if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
	if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.flipY = false;
	this.generateMipmaps = false;

}

DepthTexture.prototype = Object.create( Texture.prototype );
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

let _geometryId = 0; // Geometry uses even numbers as Id
const _m1$3 = new Matrix4();
const _obj$1 = new Object3D();
const _offset$1 = new Vector3();

function Geometry() {

	Object.defineProperty( this, 'id', { value: _geometryId += 2 } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Geometry,

	isGeometry: true,

	applyMatrix4: function ( matrix ) {

		const normalMatrix = new Matrix3().getNormalMatrix( matrix );

		for ( let i = 0, il = this.vertices.length; i < il; i ++ ) {

			const vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( let i = 0, il = this.faces.length; i < il; i ++ ) {

			const face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( let j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1$3.makeRotationX( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1$3.makeRotationY( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1$3.makeRotationZ( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1$3.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1$3.makeScale( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj$1.lookAt( vector );

		_obj$1.updateMatrix();

		this.applyMatrix4( _obj$1.matrix );

		return this;

	},

	fromBufferGeometry: function ( geometry ) {

		const scope = this;

		const index = geometry.index !== null ? geometry.index : undefined;
		const attributes = geometry.attributes;

		if ( attributes.position === undefined ) {

			console.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );
			return this;

		}

		const position = attributes.position;
		const normal = attributes.normal;
		const color = attributes.color;
		const uv = attributes.uv;
		const uv2 = attributes.uv2;

		if ( uv2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		for ( let i = 0; i < position.count; i ++ ) {

			scope.vertices.push( new Vector3().fromBufferAttribute( position, i ) );

			if ( color !== undefined ) {

				scope.colors.push( new Color().fromBufferAttribute( color, i ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			const vertexColors = ( color === undefined ) ? [] : [
				scope.colors[ a ].clone(),
				scope.colors[ b ].clone(),
				scope.colors[ c ].clone()
			];

			const vertexNormals = ( normal === undefined ) ? [] : [
				new Vector3().fromBufferAttribute( normal, a ),
				new Vector3().fromBufferAttribute( normal, b ),
				new Vector3().fromBufferAttribute( normal, c )
			];

			const face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uv !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [
					new Vector2().fromBufferAttribute( uv, a ),
					new Vector2().fromBufferAttribute( uv, b ),
					new Vector2().fromBufferAttribute( uv, c )
				] );

			}

			if ( uv2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [
					new Vector2().fromBufferAttribute( uv2, a ),
					new Vector2().fromBufferAttribute( uv2, b ),
					new Vector2().fromBufferAttribute( uv2, c )
				] );

			}

		}

		const groups = geometry.groups;

		if ( groups.length > 0 ) {

			for ( let i = 0; i < groups.length; i ++ ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					if ( index !== undefined ) {

						addFace( index.getX( j ), index.getX( j + 1 ), index.getX( j + 2 ), group.materialIndex );

					} else {

						addFace( j, j + 1, j + 2, group.materialIndex );

					}

				}

			}

		} else {

			if ( index !== undefined ) {

				for ( let i = 0; i < index.count; i += 3 ) {

					addFace( index.getX( i ), index.getX( i + 1 ), index.getX( i + 2 ) );

				}

			} else {

				for ( let i = 0; i < position.count; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset$1 ).negate();

		this.translate( _offset$1.x, _offset$1.y, _offset$1.z );

		return this;

	},

	normalize: function () {

		this.computeBoundingSphere();

		const center = this.boundingSphere.center;
		const radius = this.boundingSphere.radius;

		const s = radius === 0 ? 1 : 1.0 / radius;

		const matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix4( matrix );

		return this;

	},

	computeFaceNormals: function () {

		const cb = new Vector3(), ab = new Vector3();

		for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

			const face = this.faces[ f ];

			const vA = this.vertices[ face.a ];
			const vB = this.vertices[ face.b ];
			const vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted = true ) {

		const vertices = new Array( this.vertices.length );

		for ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			const cb = new Vector3(), ab = new Vector3();

			for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

				const face = this.faces[ f ];

				const vA = this.vertices[ face.a ];
				const vB = this.vertices[ face.b ];
				const vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			this.computeFaceNormals();

			for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

				const face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

			const face = this.faces[ f ];

			const vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeFlatVertexNormals: function () {

		this.computeFaceNormals();

		for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

			const face = this.faces[ f ];

			const vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );

			} else {

				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

			const face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( let i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		const tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;

		for ( let i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				const dstNormalsFace = this.morphNormals[ i ].faceNormals;
				const dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

					const faceNormal = new Vector3();
					const vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			const morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

				const face = this.faces[ f ];

				const faceNormal = morphNormals.faceNormals[ f ];
				const vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {

			const face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset = 0 ) {

		if ( ! ( geometry && geometry.isGeometry ) ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		let normalMatrix;
		const vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			colors1 = this.colors,
			colors2 = geometry.colors;

		if ( matrix !== undefined ) {

			normalMatrix = new Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( let i = 0, il = vertices2.length; i < il; i ++ ) {

			const vertex = vertices2[ i ];

			const vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// colors

		for ( let i = 0, il = colors2.length; i < il; i ++ ) {

			colors1.push( colors2[ i ].clone() );

		}

		// faces

		for ( let i = 0, il = faces2.length; i < il; i ++ ) {

			const face = faces2[ i ];
			let normal, color;
			const faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

			const faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( let j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( let j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( let i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			const faceVertexUvs2 = geometry.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];

			for ( let j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {

				const uvs2 = faceVertexUvs2[ j ], uvsCopy = [];

				for ( let k = 0, kl = uvs2.length; k < kl; k ++ ) {

					uvsCopy.push( uvs2[ k ].clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

	},

	mergeMesh: function ( mesh ) {

		if ( ! ( mesh && mesh.isMesh ) ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function ( precisionPoints = 4 ) {

		const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		const unique = [], changes = [];

		const precision = Math.pow( 10, precisionPoints );

		for ( let i = 0, il = this.vertices.length; i < il; i ++ ) {

			const v = this.vertices[ i ];
			const key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		const faceIndicesToRemove = [];

		for ( let i = 0, il = this.faces.length; i < il; i ++ ) {

			const face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			const indices = [ face.a, face.b, face.c ];

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( let n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( let i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			const idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( let j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		const diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	setFromPoints: function ( points ) {

		this.vertices = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return this;

	},

	sortFacesByMaterialIndex: function () {

		const faces = this.faces;
		const length = faces.length;

		// tag faces

		for ( let i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		const uvs1 = this.faceVertexUvs[ 0 ];
		const uvs2 = this.faceVertexUvs[ 1 ];

		let newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( let i = 0; i < length; i ++ ) {

			const id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		const vertices = [];

		for ( let i = 0; i < this.vertices.length; i ++ ) {

			const vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		const faces = [];
		const normals = [];
		const normalsHash = {};
		const colors = [];
		const colorsHash = {};
		const uvs = [];
		const uvsHash = {};

		for ( let i = 0; i < this.faces.length; i ++ ) {

			const face = this.faces[ i ];

			const hasMaterial = true;
			const hasFaceUv = false; // deprecated
			const hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			const hasFaceNormal = face.normal.length() > 0;
			const hasFaceVertexNormal = face.vertexNormals.length > 0;
			const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			const hasFaceVertexColor = face.vertexColors.length > 0;

			let faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				const faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				const vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				const vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			const hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			const hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new Geometry().copy( this );

	},

	copy: function ( source ) {

		// reset

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// vertices

		const vertices = source.vertices;

		for ( let i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		// colors

		const colors = source.colors;

		for ( let i = 0, il = colors.length; i < il; i ++ ) {

			this.colors.push( colors[ i ].clone() );

		}

		// faces

		const faces = source.faces;

		for ( let i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		// face vertex uvs

		for ( let i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			const faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( let j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				const uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( let k = 0, kl = uvs.length; k < kl; k ++ ) {

					const uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		// morph targets

		const morphTargets = source.morphTargets;

		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = {};
			morphTarget.name = morphTargets[ i ].name;

			// vertices

			if ( morphTargets[ i ].vertices !== undefined ) {

				morphTarget.vertices = [];

				for ( let j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

				}

			}

			// normals

			if ( morphTargets[ i ].normals !== undefined ) {

				morphTarget.normals = [];

				for ( let j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

				}

			}

			this.morphTargets.push( morphTarget );

		}

		// morph normals

		const morphNormals = source.morphNormals;

		for ( let i = 0, il = morphNormals.length; i < il; i ++ ) {

			const morphNormal = {};

			// vertex normals

			if ( morphNormals[ i ].vertexNormals !== undefined ) {

				morphNormal.vertexNormals = [];

				for ( let j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

					const srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
					const destVertexNormal = {};

					destVertexNormal.a = srcVertexNormal.a.clone();
					destVertexNormal.b = srcVertexNormal.b.clone();
					destVertexNormal.c = srcVertexNormal.c.clone();

					morphNormal.vertexNormals.push( destVertexNormal );

				}

			}

			// face normals

			if ( morphNormals[ i ].faceNormals !== undefined ) {

				morphNormal.faceNormals = [];

				for ( let j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

				}

			}

			this.morphNormals.push( morphNormal );

		}

		// skin weights

		const skinWeights = source.skinWeights;

		for ( let i = 0, il = skinWeights.length; i < il; i ++ ) {

			this.skinWeights.push( skinWeights[ i ].clone() );

		}

		// skin indices

		const skinIndices = source.skinIndices;

		for ( let i = 0, il = skinIndices.length; i < il; i ++ ) {

			this.skinIndices.push( skinIndices[ i ].clone() );

		}

		// line distances

		const lineDistances = source.lineDistances;

		for ( let i = 0, il = lineDistances.length; i < il; i ++ ) {

			this.lineDistances.push( lineDistances[ i ] );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// update flags

		this.elementsNeedUpdate = source.elementsNeedUpdate;
		this.verticesNeedUpdate = source.verticesNeedUpdate;
		this.uvsNeedUpdate = source.uvsNeedUpdate;
		this.normalsNeedUpdate = source.normalsNeedUpdate;
		this.colorsNeedUpdate = source.colorsNeedUpdate;
		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
		this.groupsNeedUpdate = source.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

class BoxGeometry extends Geometry {

	constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

}

class CircleBufferGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class CircleGeometry extends Geometry {

	constructor( radius, segments, thetaStart, thetaLength ) {

		super();
		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

}

class CylinderBufferGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();
		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

}

class CylinderGeometry extends Geometry {

	constructor( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		super();
		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

}

class ConeBufferGeometry extends CylinderBufferGeometry {

	constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

}

class PolyhedronBufferGeometry extends BufferGeometry {

	constructor( vertices, indices, radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

}

class DodecahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

class DodecahedronGeometry extends Geometry {

	constructor( radius, detail ) {

		super();
		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

}

const _v0$2 = new Vector3();
const _v1$5 = new Vector3();
const _normal$1 = new Vector3();
const _triangle = new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry, thresholdAngle ) {

		super();

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		if ( geometry.isGeometry ) {

			geometry = new BufferGeometry().fromGeometry( geometry );

		}

		const precisionPoints = 4;
		const precision = Math.pow( 10, precisionPoints );
		const thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );

		const indexAttr = geometry.getIndex();
		const positionAttr = geometry.getAttribute( 'position' );
		const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

		const indexArr = [ 0, 0, 0 ];
		const vertKeys = [ 'a', 'b', 'c' ];
		const hashes = new Array( 3 );

		const edgeData = {};
		const vertices = [];
		for ( let i = 0; i < indexCount; i += 3 ) {

			if ( indexAttr ) {

				indexArr[ 0 ] = indexAttr.getX( i );
				indexArr[ 1 ] = indexAttr.getX( i + 1 );
				indexArr[ 2 ] = indexAttr.getX( i + 2 );

			} else {

				indexArr[ 0 ] = i;
				indexArr[ 1 ] = i + 1;
				indexArr[ 2 ] = i + 2;

			}

			const { a, b, c } = _triangle;
			a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
			b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
			c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
			_triangle.getNormal( _normal$1 );

			// create hashes for the edge from the vertices
			hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
			hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
			hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

			// skip degenerate triangles
			if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

				continue;

			}

			// iterate over every edge
			for ( let j = 0; j < 3; j ++ ) {

				// get the first and next vertex making up the edge
				const jNext = ( j + 1 ) % 3;
				const vecHash0 = hashes[ j ];
				const vecHash1 = hashes[ jNext ];
				const v0 = _triangle[ vertKeys[ j ] ];
				const v1 = _triangle[ vertKeys[ jNext ] ];

				const hash = `${ vecHash0 }_${ vecHash1 }`;
				const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

				if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

					// if we found a sibling edge add it into the vertex array if
					// it meets the angle threshold and delete the edge from the map.
					if ( _normal$1.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

						vertices.push( v0.x, v0.y, v0.z );
						vertices.push( v1.x, v1.y, v1.z );

					}

					edgeData[ reverseHash ] = null;

				} else if ( ! ( hash in edgeData ) ) {

					// if we've already got an edge here then skip adding a new one
					edgeData[ hash ] = {

						index0: indexArr[ j ],
						index1: indexArr[ jNext ],
						normal: _normal$1.clone(),

					};

				}

			}

		}

		// iterate over all remaining, unmatched edges and add them to the vertex array
		for ( const key in edgeData ) {

			if ( edgeData[ key ] ) {

				const { index0, index1 } = edgeData[ key ];
				_v0$2.fromBufferAttribute( positionAttr, index0 );
				_v1$5.fromBufferAttribute( positionAttr, index1 );

				vertices.push( _v0$2.x, _v0$2.y, _v0$2.z );
				vertices.push( _v1$5.x, _v1$5.y, _v1$5.z );

			}

		}

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim ) {

		dim = dim || 2;

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	let p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		const b = splitPolygon( outerNode, hole );

		// filter collinear points around the cuts
		filterPoints( outerNode, outerNode.next );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode;
	const hx = hole.x;
	const hy = hole.y;
	let qx = - Infinity, m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

const ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	},

	triangulateShape: function ( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

};

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeBufferGeometry extends BufferGeometry {

	constructor( shapes, options ) {

		super();

		this.type = 'ExtrudeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			let depth = options.depth !== undefined ? options.depth : 100;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON( shapes, options, data );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < 0.01 ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeGeometry extends Geometry {

	constructor( shapes, options ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

}

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

class IcosahedronGeometry extends Geometry {

	constructor( radius, detail ) {

		super();

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

}

class LatheBufferGeometry extends BufferGeometry {

	constructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices and uvs

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			const normals = this.attributes.normal.array;
			const n1 = new Vector3();
			const n2 = new Vector3();
			const n = new Vector3();

			// this is the buffer offset for the last line of vertices

			const base = segments * points.length * 3;

			for ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

}

class LatheGeometry extends Geometry {

	constructor( points, segments, phiStart, phiLength ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();

	}

}

class OctahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

class OctahedronGeometry extends Geometry {

	constructor( radius, detail ) {

		super();

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

}

/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

function ParametricBufferGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricBufferGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	const indices = [];
	const vertices = [];
	const normals = [];
	const uvs = [];

	const EPS = 0.00001;

	const normal = new Vector3();

	const p0 = new Vector3(), p1 = new Vector3();
	const pu = new Vector3(), pv = new Vector3();

	if ( func.length < 3 ) {

		console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

	}

	// generate vertices, normals and uvs

	const sliceCount = slices + 1;

	for ( let i = 0; i <= stacks; i ++ ) {

		const v = i / stacks;

		for ( let j = 0; j <= slices; j ++ ) {

			const u = j / slices;

			// vertex

			func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );

			// normal

			// approximate tangent vectors via finite differences

			if ( u - EPS >= 0 ) {

				func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );

			} else {

				func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );

			}

			if ( v - EPS >= 0 ) {

				func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );

			} else {

				func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );

			}

			// cross product of tangent vectors returns surface normal

			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( let i = 0; i < stacks; i ++ ) {

		for ( let j = 0; j < slices; j ++ ) {

			const a = i * sliceCount + j;
			const b = i * sliceCount + j + 1;
			const c = ( i + 1 ) * sliceCount + j + 1;
			const d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

function ParametricGeometry( func, slices, stacks ) {

	Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
	this.mergeVertices();

}

ParametricGeometry.prototype = Object.create( Geometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

class PlaneGeometry extends Geometry {

	constructor( width, height, widthSegments, heightSegments ) {

		super();

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();

	}

}

class PolyhedronGeometry extends Geometry {

	constructor( vertices, indices, radius, detail ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();

	}

}

class RingBufferGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class RingGeometry extends Geometry {

	constructor( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

}

class ShapeBufferGeometry extends BufferGeometry {

	constructor( shapes, curveSegments = 12 ) {

		super();
		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;

		return toJSON$2( shapes, data );

	}

}

function toJSON$2( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class ShapeGeometry extends Geometry {

	constructor( shapes, curveSegments ) {

		super();
		this.type = 'ShapeGeometry';

		if ( typeof curveSegments === 'object' ) {

			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

			curveSegments = curveSegments.curveSegments;

		}

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();

	}

	toJSON() {

		const data = Geometry.prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;

		return toJSON$3( shapes, data );

	}

}

function toJSON$3( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereBufferGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();
		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class SphereGeometry extends Geometry {

	constructor( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		super();
		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

}

class TetrahedronBufferGeometry extends PolyhedronBufferGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

class TetrahedronGeometry extends Geometry {

	constructor( radius, detail ) {

		super();
		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

}

/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */

class TextBufferGeometry extends ExtrudeBufferGeometry {

	constructor( text, parameters = {} ) {

		const font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new BufferGeometry();

		}

		const shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		super( shapes, parameters );

		this.type = 'TextBufferGeometry';

	}

}

/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */

class TextGeometry extends Geometry {

	constructor( text, parameters ) {

		super();
		this.type = 'TextGeometry';

		this.parameters = {
			text: text,
			parameters: parameters
		};

		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();

	}

}

class TorusBufferGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

		super();
		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class TorusGeometry extends Geometry {

	constructor( radius, tube, radialSegments, tubularSegments, arc ) {

		super();
		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();

	}

}

class TorusKnotBufferGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();
		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

}

class TorusKnotGeometry extends Geometry {

	constructor( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

		super();
		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();

	}

}

class TubeBufferGeometry extends BufferGeometry {

	constructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();
		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}
	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		data.path = this.parameters.path.toJSON();

		return data;

	}

}

class TubeGeometry extends Geometry {

	constructor( path, tubularSegments, radius, radialSegments, closed, taper ) {

		super();
		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

		const bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry ) {

		super();
		this.type = 'WireframeGeometry';

		// buffer

		const vertices = [];

		// helper variables

		const edge = [ 0, 0 ], edges = {};
		const keys = [ 'a', 'b', 'c' ];

		// different logic for Geometry and BufferGeometry

		if ( geometry && geometry.isGeometry ) {

			// create a data structure that contains all edges without duplicates

			const faces = geometry.faces;

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				for ( let j = 0; j < 3; j ++ ) {

					const edge1 = face[ keys[ j ] ];
					const edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );

					const key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

					}

				}

			}

			// generate vertices

			for ( const key in edges ) {

				const e = edges[ key ];

				let vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else if ( geometry && geometry.isBufferGeometry ) {

			const vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const start = group.start;
					const count = group.count;

					for ( let i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const edge1 = indices.getX( i + j );
							const edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							const key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( const key in edges ) {

					const e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						const index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxBufferGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeBufferGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	TextGeometry: TextGeometry,
	TextBufferGeometry: TextBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	WireframeGeometry: WireframeGeometry
});

/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShadowMaterial';

	this.color = new Color( 0x000000 );
	this.transparent = true;

	this.setValues( parameters );

}

ShadowMaterial.prototype = Object.create( Material.prototype );
ShadowMaterial.prototype.constructor = ShadowMaterial;

ShadowMaterial.prototype.isShadowMaterial = true;

ShadowMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	return this;

};

function RawShaderMaterial( parameters ) {

	ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

}

RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
RawShaderMaterial.prototype.constructor = RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.roughness = 1.0;
	this.metalness = 0.0;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.vertexTangents = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.vertexTangents = source.vertexTangents;

	return this;

};

/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.type = 'MeshPhysicalMaterial';

	this.clearcoat = 0.0;
	this.clearcoatMap = null;
	this.clearcoatRoughness = 0.0;
	this.clearcoatRoughnessMap = null;
	this.clearcoatNormalScale = new Vector2( 1, 1 );
	this.clearcoatNormalMap = null;

	this.reflectivity = 0.5; // maps to F0 = 0.04

	Object.defineProperty( this, 'ior', {
		get: function () {

			return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

		},
		set: function ( ior ) {

			this.reflectivity = MathUtils.clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

		}
	} );

	this.sheen = null; // null will disable sheen bsdf

	this.transmission = 0.0;
	this.transmissionMap = null;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.clearcoat = source.clearcoat;
	this.clearcoatMap = source.clearcoatMap;
	this.clearcoatRoughness = source.clearcoatRoughness;
	this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
	this.clearcoatNormalMap = source.clearcoatNormalMap;
	this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

	this.reflectivity = source.reflectivity;

	if ( source.sheen ) {

		this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

	} else {

		this.sheen = null;

	}

	this.transmission = source.transmission;
	this.transmissionMap = source.transmissionMap;

	return this;

};

/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshPhongMaterial.prototype = Object.create( Material.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshToonMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'TOON': '' };

	this.type = 'MeshToonMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;
	this.gradientMap = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.alphaMap = null;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshToonMaterial.prototype = Object.create( Material.prototype );
MeshToonMaterial.prototype.constructor = MeshToonMaterial;

MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;
	this.gradientMap = source.gradientMap;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.alphaMap = source.alphaMap;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshNormalMaterial';

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshNormalMaterial.prototype = Object.create( Material.prototype );
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshLambertMaterial.prototype = Object.create( Material.prototype );
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshMatcapMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'MATCAP': '' };

	this.type = 'MeshMatcapMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.matcap = null;

	this.map = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.alphaMap = null;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshMatcapMaterial.prototype = Object.create( Material.prototype );
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

MeshMatcapMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'MATCAP': '' };

	this.color.copy( source.color );

	this.matcap = source.matcap;

	this.map = source.map;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.alphaMap = source.alphaMap;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial( parameters ) {

	LineBasicMaterial.call( this );

	this.type = 'LineDashedMaterial';

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.setValues( parameters );

}

LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
LineDashedMaterial.prototype.constructor = LineDashedMaterial;

LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function ( source ) {

	LineBasicMaterial.prototype.copy.call( this, source );

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	return this;

};

var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshDistanceMaterial: MeshDistanceMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	MeshMatcapMaterial: MeshMatcapMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
		resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

	evaluate: function ( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function () {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function ( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function ( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function ( /* i1, t0, t1 */ ) {

		// empty

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( Interpolant.prototype, {

	//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_: Interpolant.prototype.copySampleValue_,

	//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_: Interpolant.prototype.copySampleValue_,

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;

}

CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding

	},

	intervalChanged_: function ( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function ( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

function KeyframeTrack( name, times, values, interpolation ) {

	if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
	if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

	this.name = name;

	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

}

// Static methods

Object.assign( KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	toJSON: function ( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

} );

Object.assign( KeyframeTrack.prototype, {

	constructor: KeyframeTrack,

	TimeBufferType: Float32Array,

	ValueBufferType: Float32Array,

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function ( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function ( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function ( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function ( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = "unsupported interpolation for " +
				this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	},

	getInterpolation: function () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	},

	getValueSize: function () {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function ( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function () {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function () {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	},

	clone: function () {

		const times = AnimationUtils.arraySlice( this.times, 0 );
		const values = AnimationUtils.arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

} );

/**
 * A Track of Boolean keyframe values.
 */

function BooleanKeyframeTrack( name, times, values ) {

	KeyframeTrack.call( this, name, times, values );

}

BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

/**
 * A Track of keyframe values that represent color.
 */

function ColorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

/**
 * A Track of numeric keyframe values.
 */

function NumberKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: NumberKeyframeTrack,

	ValueTypeName: 'number'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 * Spherical linear unit quaternion interpolant.
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 * A Track of quaternion keyframe values.
 */

function QuaternionKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodLinear: function ( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

/**
 * A Track that interpolates Strings
 */

function StringKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

/**
 * A Track of vectored keyframe values.
 */

function VectorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

function AnimationClip( name, duration, tracks, blendMode ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : - 1;
	this.blendMode = ( blendMode !== undefined ) ? blendMode : NormalAnimationBlendMode;

	this.uuid = MathUtils.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

Object.assign( AnimationClip, {

	parse: function ( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new AnimationClip( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	},

	toJSON: function ( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},

	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new AnimationClip( name, - 1, tracks );

	},

	findByName: function ( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function ( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new AnimationClip( clipName, duration, tracks, blendMode );

		return clip;

	}

} );

Object.assign( AnimationClip.prototype, {

	resetDuration: function () {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	},

	trim: function () {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	validate: function () {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	},

	optimize: function () {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	},

	clone: function () {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new AnimationClip( this.name, this.duration, tracks, this.blendMode );

	},

	toJSON: function () {

		return AnimationClip.toJSON( this );

	}

} );

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

function LoadingManager( onLoad, onProgress, onError ) {

	const scope = this;

	let isLoading = false;
	let itemsLoaded = 0;
	let itemsTotal = 0;
	let urlModifier = undefined;
	const handlers = [];

	// Refer to #5689 for the reason why we don't set .onStart
	// in the constructor

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

	this.resolveURL = function ( url ) {

		if ( urlModifier ) {

			return urlModifier( url );

		}

		return url;

	};

	this.setURLModifier = function ( transform ) {

		urlModifier = transform;

		return this;

	};

	this.addHandler = function ( regex, loader ) {

		handlers.push( regex, loader );

		return this;

	};

	this.removeHandler = function ( regex ) {

		const index = handlers.indexOf( regex );

		if ( index !== - 1 ) {

			handlers.splice( index, 2 );

		}

		return this;

	};

	this.getHandler = function ( file ) {

		for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

			const regex = handlers[ i ];
			const loader = handlers[ i + 1 ];

			if ( regex.global ) regex.lastIndex = 0; // see #17920

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	};

}

const DefaultLoadingManager = new LoadingManager();

function Loader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.crossOrigin = 'anonymous';
	this.withCredentials = false;
	this.path = '';
	this.resourcePath = '';
	this.requestHeader = {};

}

Object.assign( Loader.prototype, {

	load: function ( /* url, onLoad, onProgress, onError */ ) {},

	loadAsync: function ( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	},

	parse: function ( /* data */ ) {},

	setCrossOrigin: function ( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setPath: function ( path ) {

		this.path = path;
		return this;

	},

	setResourcePath: function ( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	},

	setRequestHeader: function ( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

} );

const loading = {};

function FileLoader( manager ) {

	Loader.call( this, manager );

}

FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: FileLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Check for data: URI
		const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		const dataUriRegexResult = url.match( dataUriRegex );
		let request;

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			const mimeType = dataUriRegexResult[ 1 ];
			const isBase64 = !! dataUriRegexResult[ 2 ];

			let data = dataUriRegexResult[ 3 ];
			data = decodeURIComponent( data );

			if ( isBase64 ) data = atob( data );

			try {

				let response;
				const responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

						const view = new Uint8Array( data.length );

						for ( let i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ view.buffer ], { type: mimeType } );

						} else {

							response = view.buffer;

						}

						break;

					case 'document':

						const parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, 0 );

			}

		} else {

			// Initialise array for duplicate requests

			loading[ url ] = [];

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			request = new XMLHttpRequest();

			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				const response = this.response;

				const callbacks = loading[ url ];

				delete loading[ url ];

				if ( this.status === 200 || this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, response );

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );

					}

					scope.manager.itemEnd( url );

				} else {

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}

			}, false );

			request.addEventListener( 'progress', function ( event ) {

				const callbacks = loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onProgress ) callback.onProgress( event );

				}

			}, false );

			request.addEventListener( 'error', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			request.addEventListener( 'abort', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			for ( const header in this.requestHeader ) {

				request.setRequestHeader( header, this.requestHeader[ header ] );

			}

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	}

} );

function AnimationLoader( manager ) {

	Loader.call( this, manager );

}

AnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: AnimationLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

} );

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader( manager ) {

	Loader.call( this, manager );

}

CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();
		texture.image = images;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

} );

function ImageLoader( manager ) {

	Loader.call( this, manager );

}

ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		function onImageLoad() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

} );

function CubeTextureLoader( manager ) {

	Loader.call( this, manager );

}

CubeTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: CubeTextureLoader,

	load: function ( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

} );

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader( manager ) {

	Loader.call( this, manager );

}

DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: DataTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			const texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

function TextureLoader( manager ) {

	Loader.call( this, manager );

}

TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

} );

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

function Curve() {

	this.type = 'Curve';

	this.arcLengthDivisions = 200;

}

Object.assign( Curve.prototype, {

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	},

	updateArcLengths: function () {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function ( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	},

	getTangentAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	},

	fromJSON: function ( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

} );

function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	Curve.call( this );

	this.type = 'EllipseCurve';

	this.aX = aX || 0;
	this.aY = aY || 0;

	this.xRadius = xRadius || 1;
	this.yRadius = yRadius || 1;

	this.aStartAngle = aStartAngle || 0;
	this.aEndAngle = aEndAngle || 2 * Math.PI;

	this.aClockwise = aClockwise || false;

	this.aRotation = aRotation || 0;

}

EllipseCurve.prototype = Object.create( Curve.prototype );
EllipseCurve.prototype.constructor = EllipseCurve;

EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

	const point = optionalTarget || new Vector2();

	const twoPi = Math.PI * 2;
	let deltaAngle = this.aEndAngle - this.aStartAngle;
	const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

	// ensures that deltaAngle is 0 .. 2 PI
	while ( deltaAngle < 0 ) deltaAngle += twoPi;
	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

	if ( deltaAngle < Number.EPSILON ) {

		if ( samePoints ) {

			deltaAngle = 0;

		} else {

			deltaAngle = twoPi;

		}

	}

	if ( this.aClockwise === true && ! samePoints ) {

		if ( deltaAngle === twoPi ) {

			deltaAngle = - twoPi;

		} else {

			deltaAngle = deltaAngle - twoPi;

		}

	}

	const angle = this.aStartAngle + t * deltaAngle;
	let x = this.aX + this.xRadius * Math.cos( angle );
	let y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		const cos = Math.cos( this.aRotation );
		const sin = Math.sin( this.aRotation );

		const tx = x - this.aX;
		const ty = y - this.aY;

		// Rotate the point about the center of the ellipse.
		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;

	}

	return point.set( x, y );

};

EllipseCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.aX = source.aX;
	this.aY = source.aY;

	this.xRadius = source.xRadius;
	this.yRadius = source.yRadius;

	this.aStartAngle = source.aStartAngle;
	this.aEndAngle = source.aEndAngle;

	this.aClockwise = source.aClockwise;

	this.aRotation = source.aRotation;

	return this;

};


EllipseCurve.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.aX = this.aX;
	data.aY = this.aY;

	data.xRadius = this.xRadius;
	data.yRadius = this.yRadius;

	data.aStartAngle = this.aStartAngle;
	data.aEndAngle = this.aEndAngle;

	data.aClockwise = this.aClockwise;

	data.aRotation = this.aRotation;

	return data;

};

EllipseCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.aX = json.aX;
	this.aY = json.aY;

	this.xRadius = json.xRadius;
	this.yRadius = json.yRadius;

	this.aStartAngle = json.aStartAngle;
	this.aEndAngle = json.aEndAngle;

	this.aClockwise = json.aClockwise;

	this.aRotation = json.aRotation;

	return this;

};

function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	this.type = 'ArcCurve';

}

ArcCurve.prototype = Object.create( EllipseCurve.prototype );
ArcCurve.prototype.constructor = ArcCurve;

ArcCurve.prototype.isArcCurve = true;

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

function CatmullRomCurve3( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

	Curve.call( this );

	this.type = 'CatmullRomCurve3';

	this.points = points;
	this.closed = closed;
	this.curveType = curveType;
	this.tension = tension;

}

CatmullRomCurve3.prototype = Object.create( Curve.prototype );
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget = new Vector3() ) {

	const point = optionalTarget;

	const points = this.points;
	const l = points.length;

	const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
	let intPoint = Math.floor( p );
	let weight = p - intPoint;

	if ( this.closed ) {

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

	} else if ( weight === 0 && intPoint === l - 1 ) {

		intPoint = l - 2;
		weight = 1;

	}

	let p0, p3; // 4 points (p1 & p2 defined below)

	if ( this.closed || intPoint > 0 ) {

		p0 = points[ ( intPoint - 1 ) % l ];

	} else {

		// extrapolate first point
		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
		p0 = tmp;

	}

	const p1 = points[ intPoint % l ];
	const p2 = points[ ( intPoint + 1 ) % l ];

	if ( this.closed || intPoint + 2 < l ) {

		p3 = points[ ( intPoint + 2 ) % l ];

	} else {

		// extrapolate last point
		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
		p3 = tmp;

	}

	if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

		// init Centripetal / Chordal Catmull-Rom
		const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
		let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
		let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
		let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

		// safety check for repeated points
		if ( dt1 < 1e-4 ) dt1 = 1.0;
		if ( dt0 < 1e-4 ) dt0 = dt1;
		if ( dt2 < 1e-4 ) dt2 = dt1;

		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

	} else if ( this.curveType === 'catmullrom' ) {

		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

	}

	point.set(
		px.calc( weight ),
		py.calc( weight ),
		pz.calc( weight )
	);

	return point;

};

CatmullRomCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.points = [];

	for ( let i = 0, l = source.points.length; i < l; i ++ ) {

		const point = source.points[ i ];

		this.points.push( point.clone() );

	}

	this.closed = source.closed;
	this.curveType = source.curveType;
	this.tension = source.tension;

	return this;

};

CatmullRomCurve3.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.points = [];

	for ( let i = 0, l = this.points.length; i < l; i ++ ) {

		const point = this.points[ i ];
		data.points.push( point.toArray() );

	}

	data.closed = this.closed;
	data.curveType = this.curveType;
	data.tension = this.tension;

	return data;

};

CatmullRomCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.points = [];

	for ( let i = 0, l = json.points.length; i < l; i ++ ) {

		const point = json.points[ i ];
		this.points.push( new Vector3().fromArray( point ) );

	}

	this.closed = json.closed;
	this.curveType = json.curveType;
	this.tension = json.tension;

	return this;

};

/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

function CubicBezierCurve( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

	Curve.call( this );

	this.type = 'CubicBezierCurve';

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

}

CubicBezierCurve.prototype = Object.create( Curve.prototype );
CubicBezierCurve.prototype.constructor = CubicBezierCurve;

CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget = new Vector2() ) {

	const point = optionalTarget;

	const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
	);

	return point;

};

CubicBezierCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );

	return this;

};

CubicBezierCurve.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;

};

CubicBezierCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );
	this.v3.fromArray( json.v3 );

	return this;

};

function CubicBezierCurve3( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

	Curve.call( this );

	this.type = 'CubicBezierCurve3';

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

}

CubicBezierCurve3.prototype = Object.create( Curve.prototype );
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget = new Vector3() ) {

	const point = optionalTarget;

	const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
	);

	return point;

};

CubicBezierCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );

	return this;

};

CubicBezierCurve3.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;

};

CubicBezierCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );
	this.v3.fromArray( json.v3 );

	return this;

};

function LineCurve( v1 = new Vector2(), v2 = new Vector2() ) {

	Curve.call( this );

	this.type = 'LineCurve';

	this.v1 = v1;
	this.v2 = v2;

}

LineCurve.prototype = Object.create( Curve.prototype );
LineCurve.prototype.constructor = LineCurve;

LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function ( t, optionalTarget = new Vector2() ) {

	const point = optionalTarget;

	if ( t === 1 ) {

		point.copy( this.v2 );

	} else {

		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

	}

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

	return this.getPoint( u, optionalTarget );

};

LineCurve.prototype.getTangent = function ( t, optionalTarget ) {

	const tangent = optionalTarget || new Vector2();

	tangent.copy( this.v2 ).sub( this.v1 ).normalize();

	return tangent;

};

LineCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

LineCurve.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

LineCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function LineCurve3( v1 = new Vector3(), v2 = new Vector3() ) {

	Curve.call( this );

	this.type = 'LineCurve3';

	this.v1 = v1;
	this.v2 = v2;

}

LineCurve3.prototype = Object.create( Curve.prototype );
LineCurve3.prototype.constructor = LineCurve3;

LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function ( t, optionalTarget = new Vector3() ) {

	const point = optionalTarget;

	if ( t === 1 ) {

		point.copy( this.v2 );

	} else {

		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

	}

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

	return this.getPoint( u, optionalTarget );

};

LineCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

LineCurve3.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

LineCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function QuadraticBezierCurve( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

	Curve.call( this );

	this.type = 'QuadraticBezierCurve';

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

}

QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget = new Vector2() ) {

	const point = optionalTarget;

	const v0 = this.v0, v1 = this.v1, v2 = this.v2;

	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y )
	);

	return point;

};

QuadraticBezierCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

QuadraticBezierCurve.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function QuadraticBezierCurve3( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

	Curve.call( this );

	this.type = 'QuadraticBezierCurve3';

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

}

QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget = new Vector3() ) {

	const point = optionalTarget;

	const v0 = this.v0, v1 = this.v1, v2 = this.v2;

	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y ),
		QuadraticBezier( t, v0.z, v1.z, v2.z )
	);

	return point;

};

QuadraticBezierCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

QuadraticBezierCurve3.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function SplineCurve( points = [] ) {

	Curve.call( this );

	this.type = 'SplineCurve';

	this.points = points;

}

SplineCurve.prototype = Object.create( Curve.prototype );
SplineCurve.prototype.constructor = SplineCurve;

SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function ( t, optionalTarget = new Vector2() ) {

	const point = optionalTarget;

	const points = this.points;
	const p = ( points.length - 1 ) * t;

	const intPoint = Math.floor( p );
	const weight = p - intPoint;

	const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	const p1 = points[ intPoint ];
	const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	point.set(
		CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
		CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
	);

	return point;

};

SplineCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.points = [];

	for ( let i = 0, l = source.points.length; i < l; i ++ ) {

		const point = source.points[ i ];

		this.points.push( point.clone() );

	}

	return this;

};

SplineCurve.prototype.toJSON = function () {

	const data = Curve.prototype.toJSON.call( this );

	data.points = [];

	for ( let i = 0, l = this.points.length; i < l; i ++ ) {

		const point = this.points[ i ];
		data.points.push( point.toArray() );

	}

	return data;

};

SplineCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.points = [];

	for ( let i = 0, l = json.points.length; i < l; i ++ ) {

		const point = json.points[ i ];
		this.points.push( new Vector2().fromArray( point ) );

	}

	return this;

};

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {

	Curve.call( this );

	this.type = 'CurvePath';

	this.curves = [];
	this.autoClose = false; // Automatically closes the path

}

CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

	constructor: CurvePath,

	add: function ( curve ) {

		this.curves.push( curve );

	},

	closePath: function () {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	},

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint: function ( t ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	},

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength: function () {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	},

	// cacheLengths must be recalculated.
	updateArcLengths: function () {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	},

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths: function () {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	},

	getSpacedPoints: function ( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	getPoints: function ( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	copy: function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	},

	toJSON: function () {

		const data = Curve.prototype.toJSON.call( this );

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	},

	fromJSON: function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

} );

function Path( points ) {

	CurvePath.call( this );

	this.type = 'Path';

	this.currentPoint = new Vector2();

	if ( points ) {

		this.setFromPoints( points );

	}

}

Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

	constructor: Path,

	setFromPoints: function ( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	},

	moveTo: function ( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	},

	lineTo: function ( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	},

	splineThru: function ( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	},

	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	},

	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	},

	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	},

	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	},

	copy: function ( source ) {

		CurvePath.prototype.copy.call( this, source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	},

	toJSON: function () {

		const data = CurvePath.prototype.toJSON.call( this );

		data.currentPoint = this.currentPoint.toArray();

		return data;

	},

	fromJSON: function ( json ) {

		CurvePath.prototype.fromJSON.call( this, json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

} );

function Shape( points ) {

	Path.call( this, points );

	this.uuid = MathUtils.generateUUID();

	this.type = 'Shape';

	this.holes = [];

}

Shape.prototype = Object.assign( Object.create( Path.prototype ), {

	constructor: Shape,

	getPointsHoles: function ( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	},

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints: function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	},

	copy: function ( source ) {

		Path.prototype.copy.call( this, source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	},

	toJSON: function () {

		const data = Path.prototype.toJSON.call( this );

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	},

	fromJSON: function ( json ) {

		Path.prototype.fromJSON.call( this, json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

} );

function Light( color, intensity = 1 ) {

	Object3D.call( this );

	this.type = 'Light';

	this.color = new Color( color );
	this.intensity = intensity;

}

Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Light,

	isLight: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

} );

function HemisphereLight( skyColor, groundColor, intensity ) {

	Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.groundColor = new Color( groundColor );

}

HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: HemisphereLight,

	isHemisphereLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

} );

function LightShadow( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.normalBias = 0;
	this.radius = 1;

	this.mapSize = new Vector2( 512, 512 );

	this.map = null;
	this.mapPass = null;
	this.matrix = new Matrix4();

	this.autoUpdate = true;
	this.needsUpdate = false;

	this._frustum = new Frustum();
	this._frameExtents = new Vector2( 1, 1 );

	this._viewportCount = 1;

	this._viewports = [

		new Vector4( 0, 0, 1, 1 )

	];

}

Object.assign( LightShadow.prototype, {

	_projScreenMatrix: new Matrix4(),

	_lightPositionWorld: new Vector3(),

	_lookTarget: new Vector3(),

	getViewportCount: function () {

		return this._viewportCount;

	},

	getFrustum: function () {

		return this._frustum;

	},

	updateMatrices: function ( light ) {

		const shadowCamera = this.camera,
			shadowMatrix = this.matrix,
			projScreenMatrix = this._projScreenMatrix,
			lookTarget = this._lookTarget,
			lightPositionWorld = this._lightPositionWorld;

		lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( lightPositionWorld );

		lookTarget.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( lookTarget );
		shadowCamera.updateMatrixWorld();

		projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( projScreenMatrix );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	},

	getViewport: function ( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	},

	getFrameExtents: function () {

		return this._frameExtents;

	},

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

} );

function SpotLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

	this.focus = 1;

}

SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: SpotLightShadow,

	isSpotLightShadow: true,

	updateMatrices: function ( light ) {

		const camera = this.camera;

		const fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		LightShadow.prototype.updateMatrices.call( this, light );

	}

} );

function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

	Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	Object.defineProperty( this, 'power', {
		get: function () {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;

		},
		set: function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;

		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new SpotLightShadow();

}

SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: SpotLight,

	isSpotLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

function PointLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	this._frameExtents = new Vector2( 4, 2 );

	this._viewportCount = 6;

	this._viewports = [
		// These viewports map a cube-map onto a 2D texture with the
		// following orientation:
		//
		//  xzXZ
		//   y Y
		//
		// X - Positive x direction
		// x - Negative x direction
		// Y - Positive y direction
		// y - Negative y direction
		// Z - Positive z direction
		// z - Negative z direction

		// positive X
		new Vector4( 2, 1, 1, 1 ),
		// negative X
		new Vector4( 0, 1, 1, 1 ),
		// positive Z
		new Vector4( 3, 1, 1, 1 ),
		// negative Z
		new Vector4( 1, 1, 1, 1 ),
		// positive Y
		new Vector4( 3, 0, 1, 1 ),
		// negative Y
		new Vector4( 1, 0, 1, 1 )
	];

	this._cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];

	this._cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];

}

PointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: PointLightShadow,

	isPointLightShadow: true,

	updateMatrices: function ( light, viewportIndex = 0 ) {

		const camera = this.camera,
			shadowMatrix = this.matrix,
			lightPositionWorld = this._lightPositionWorld,
			lookTarget = this._lookTarget,
			projScreenMatrix = this._projScreenMatrix;

		lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( lightPositionWorld );

		lookTarget.copy( camera.position );
		lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - lightPositionWorld.x, - lightPositionWorld.y, - lightPositionWorld.z );

		projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( projScreenMatrix );

	}

} );

function PointLight( color, intensity, distance, decay ) {

	Light.call( this, color, intensity );

	this.type = 'PointLight';

	Object.defineProperty( this, 'power', {
		get: function () {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;

		},
		set: function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / ( 4 * Math.PI );

		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new PointLightShadow();

}

PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: PointLight,

	isPointLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

} );

function OrthographicCamera( left, right, top, bottom, near, far ) {

	Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = ( left !== undefined ) ? left : - 1;
	this.right = ( right !== undefined ) ? right : 1;
	this.top = ( top !== undefined ) ? top : 1;
	this.bottom = ( bottom !== undefined ) ? bottom : - 1;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

}

OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: OrthographicCamera,

	isOrthographicCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	},

	toJSON: function ( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

} );

function DirectionalLightShadow() {

	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

}

DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: DirectionalLightShadow,

	isDirectionalLightShadow: true,

	updateMatrices: function ( light ) {

		LightShadow.prototype.updateMatrices.call( this, light );

	}

} );

function DirectionalLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	this.shadow = new DirectionalLightShadow();

}

DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: DirectionalLight,

	isDirectionalLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

function AmbientLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'AmbientLight';

}

AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: AmbientLight,

	isAmbientLight: true

} );

function RectAreaLight( color, intensity, width, height ) {

	Light.call( this, color, intensity );

	this.type = 'RectAreaLight';

	this.width = ( width !== undefined ) ? width : 10;
	this.height = ( height !== undefined ) ? height : 10;

}

RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: RectAreaLight,

	isRectAreaLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.width = source.width;
		this.height = source.height;

		return this;

	},

	toJSON: function ( meta ) {

		const data = Light.prototype.toJSON.call( this, meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

} );

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		Object.defineProperty( this, 'isSphericalHarmonics3', { value: true } );

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

function LightProbe( sh, intensity ) {

	Light.call( this, undefined, intensity );

	this.type = 'LightProbe';

	this.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();

}

LightProbe.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: LightProbe,

	isLightProbe: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.sh.copy( source.sh );

		return this;

	},

	fromJSON: function ( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	},

	toJSON: function ( meta ) {

		const data = Light.prototype.toJSON.call( this, meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

} );

function MaterialLoader( manager ) {

	Loader.call( this, manager );

	this.textures = {};

}

MaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );

		return material;

	},

	setTextures: function ( value ) {

		this.textures = value;
		return this;

	}

} );

const LoaderUtils = {

	decodeText: function ( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	},

	extractUrlBase: function ( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.substr( 0, index + 1 );

	}

};

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.instanceCount = Infinity;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function ( source ) {

		BufferGeometry.prototype.copy.call( this, source );

		this.instanceCount = source.instanceCount;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		const data = BufferGeometry.prototype.toJSON.call( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

} );

function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

	if ( typeof ( normalized ) === 'number' ) {

		meshPerAttribute = normalized;

		normalized = false;

		console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

	}

	BufferAttribute.call( this, array, itemSize, normalized );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	toJSON: function ()	{

		const data = BufferAttribute.prototype.toJSON.call( this );

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

} );

function BufferGeometryLoader( manager ) {

	Loader.call( this, manager );

}

BufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

} );

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ] instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};
		let geometryShapes;

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'TubeGeometry':
					case 'TubeBufferGeometry':

						// This only works for built-in curves (e.g. CatmullRomCurve3).
						// User defined curves or instances of CurvePath will not be deserialized.
						geometry = new Geometries[ data.type ](
							new Curves[ data.path.type ]().fromJSON( data.path ),
							data.tubularSegments,
							data.radius,
							data.radialSegments,
							data.closed
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.curveSegments
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						const extrudePath = data.options.extrudePath;

						if ( extrudePath !== undefined ) {

							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.options
						);

						break;

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					const array = [];

					for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				let texture;
				const image = images[ data.image ];

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture( image );

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture( image.data, image.width, image.height );

					} else {

						texture = new Texture( image );

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					}

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

function ImageBitmapLoader( manager ) {

	if ( typeof createImageBitmap === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

	}

	if ( typeof fetch === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

	}

	Loader.call( this, manager );

	this.options = { premultiplyAlpha: 'none' };

}

ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ImageBitmapLoader,

	isImageBitmapLoader: true,

	setOptions: function setOptions( options ) {

		this.options = options;

		return this;

	},

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, scope.options );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

} );

function ShapePath() {

	this.type = 'ShapePath';

	this.color = new Color();

	this.subPaths = [];
	this.currentPath = null;

}

Object.assign( ShapePath.prototype, {

	moveTo: function ( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	},

	lineTo: function ( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	},

	splineThru: function ( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	},

	toShapes: function ( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			const toChange = [];

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);

			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

} );

function Font( data ) {

	this.type = 'Font';

	this.data = data;

}

Object.assign( Font.prototype, {

	isFont: true,

	generateShapes: function ( text, size = 100 ) {

		const shapes = [];
		const paths = createPaths( text, size, this.data );

		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

} );

function createPaths( text, size, data ) {

	const chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988
	const scale = size / data.resolution;
	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	const paths = [];

	let offsetX = 0, offsetY = 0;

	for ( let i = 0; i < chars.length; i ++ ) {

		const char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			const ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	const path = new ShapePath();

	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( let i = 0, l = outline.length; i < l; ) {

			const action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}

function FontLoader( manager ) {

	Loader.call( this, manager );

}

FontLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: FontLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			let json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			const font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		return new Font( json );

	}

} );

let _context;

const AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};

function AudioLoader( manager ) {

	Loader.call( this, manager );

}

AudioLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: AudioLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

} );

function HemisphereLightProbe( skyColor, groundColor, intensity ) {

	LightProbe.call( this, undefined, intensity );

	const color1 = new Color().set( skyColor );
	const color2 = new Color().set( groundColor );

	const sky = new Vector3( color1.r, color1.g, color1.b );
	const ground = new Vector3( color2.r, color2.g, color2.b );

	// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
	const c0 = Math.sqrt( Math.PI );
	const c1 = c0 * Math.sqrt( 0.75 );

	this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
	this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

}

HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

	constructor: HemisphereLightProbe,

	isHemisphereLightProbe: true,

	copy: function ( source ) { // modifying colors not currently supported

		LightProbe.prototype.copy.call( this, source );

		return this;

	},

	toJSON: function ( meta ) {

		const data = LightProbe.prototype.toJSON.call( this, meta );

		// data.sh = this.sh.toArray(); // todo

		return data;

	}

} );

function AmbientLightProbe( color, intensity ) {

	LightProbe.call( this, undefined, intensity );

	const color1 = new Color().set( color );

	// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
	this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

}

AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

	constructor: AmbientLightProbe,

	isAmbientLightProbe: true,

	copy: function ( source ) { // modifying color not currently supported

		LightProbe.prototype.copy.call( this, source );

		return this;

	},

	toJSON: function ( meta ) {

		const data = LightProbe.prototype.toJSON.call( this, meta );

		// data.sh = this.sh.toArray(); // todo

		return data;

	}

} );

const _eyeRight = new Matrix4();
const _eyeLeft = new Matrix4();

function StereoCamera() {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.eyeSep = 0.064;

	this.cameraL = new PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

	this._cache = {
		focus: null,
		fov: null,
		aspect: null,
		near: null,
		far: null,
		zoom: null,
		eyeSep: null
	};

}

Object.assign( StereoCamera.prototype, {

	update: function ( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			const projectionMatrix = camera.projectionMatrix.clone();
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

} );

class Clock {

	constructor( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$2 = /*@__PURE__*/ new Vector3();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );

		_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$2.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$2.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$2.x, _position$2.y, _position$2.z );
			listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );

		}

	}

}

class Audio extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position$3 = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

class PositionalAudio extends Audio {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );

		_orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position$3.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position$3.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );

		} else {

			panner.setPosition( _position$3.x, _position$3.y, _position$3.z );
			panner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

function PropertyMixer( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	let mixFunction,
		mixFunctionAdditive,
		setIdentity;

	// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property
	//
	// 'add' is used for additive cumulative results
	//
	// 'work' is optional and is only present for quaternion types. It is used
	// to store intermediate quaternion multiplication results

	switch ( typeName ) {

		case 'quaternion':
			mixFunction = this._slerp;
			mixFunctionAdditive = this._slerpAdditive;
			setIdentity = this._setAdditiveIdentityQuaternion;

			this.buffer = new Float64Array( valueSize * 6 );
			this._workIndex = 5;
			break;

		case 'string':
		case 'bool':
			mixFunction = this._select;

			// Use the regular mix function and for additive on these types,
			// additive is not relevant for non-numeric types
			mixFunctionAdditive = this._select;

			setIdentity = this._setAdditiveIdentityOther;

			this.buffer = new Array( valueSize * 5 );
			break;

		default:
			mixFunction = this._lerp;
			mixFunctionAdditive = this._lerpAdditive;
			setIdentity = this._setAdditiveIdentityNumeric;

			this.buffer = new Float64Array( valueSize * 5 );

	}

	this._mixBufferRegion = mixFunction;
	this._mixBufferRegionAdditive = mixFunctionAdditive;
	this._setIdentity = setIdentity;
	this._origIndex = 3;
	this._addIndex = 4;

	this.cumulativeWeight = 0;
	this.cumulativeWeightAdditive = 0;

	this.useCount = 0;
	this.referenceCount = 0;

}

Object.assign( PropertyMixer.prototype, {

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function ( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive: function ( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function ( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function () {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function () {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},

	_setAdditiveIdentityNumeric: function () {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	},

	_setAdditiveIdentityQuaternion: function () {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	},

	_setAdditiveIdentityOther: function () {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	},


	// mix functions

	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	},

	_slerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	},

	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	},

	_lerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

} );

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

function Composite( targetGroup, path, optionalParsedPath ) {

	const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	},

	parseTrackName: function ( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	},

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			const source = this.resolvedProperty;

			for ( let i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

function AnimationObjectGroup() {

	this.uuid = MathUtils.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0; // threshold
	// note: read by PropertyBinding.Composite

	const indices = {};
	this._indicesByUUID = indices; // for bookkeeping

	for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = []; // inside: string
	this._parsedPaths = []; // inside: { we don't care, here }
	this._bindings = []; // inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; // inside: indices in these arrays

	const scope = this;

	this.stats = {

		objects: {
			get total() {

				return scope._objects.length;

			},
			get inUse() {

				return this.total - scope.nCachedObjects_;

			}
		},
		get bindingsPerObject() {

			return scope._bindings.length;

		}

	};

}

Object.assign( AnimationObjectGroup.prototype, {

	isAnimationObjectGroup: true,

	add: function () {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function () {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function () {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function ( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function ( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

} );

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

function AnimationMixer( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

}

AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: AnimationMixer,

	_bindAction: function ( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function ( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function ( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function () {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	},

	// Memory management for AnimationAction objects

	_isActiveAction: function ( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function ( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function ( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function ( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function ( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function ( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function ( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function ( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function () {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function ( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function ( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function ( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function () {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function ( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// Allows you to seek to a specific time in an animation.
	setTime: function ( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	},

	// return this mixer's root target object
	getRoot: function () {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function ( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function ( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function ( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

} );

class Uniform {

	constructor( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

	constructor: InstancedInterleavedBuffer,

	isInstancedInterleavedBuffer: true,

	copy: function ( source ) {

		InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	clone: function ( data ) {

		const ib = InterleavedBuffer.prototype.clone.call( this, data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	},

	toJSON: function ( data ) {

		const json = InterleavedBuffer.prototype.toJSON.call( this, data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

} );

function GLBufferAttribute( buffer, type, itemSize, elementSize, count ) {

	this.buffer = buffer;
	this.type = type;
	this.itemSize = itemSize;
	this.elementSize = elementSize;
	this.count = count;

	this.version = 0;

}

Object.defineProperty( GLBufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( GLBufferAttribute.prototype, {

	isGLBufferAttribute: true,

	setBuffer: function ( buffer ) {

		this.buffer = buffer;

		return this;

	},

	setType: function ( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	},

	setItemSize: function ( itemSize ) {

		this.itemSize = itemSize;

		return this;

	},

	setCount: function ( count ) {

		this.count = count;

		return this;

	},

} );

function Raycaster( origin, direction, near, far ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near || 0;
	this.far = far || Infinity;
	this.camera = null;
	this.layers = new Layers();

	this.params = {
		Mesh: {},
		Line: { threshold: 1 },
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {

				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;

			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( ( camera && camera.isPerspectiveCamera ) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( ( camera && camera.isOrthographicCamera ) ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	},

	intersectObject: function ( object, recursive, optionalTarget ) {

		const intersects = optionalTarget || [];

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive, optionalTarget ) {

		const intersects = optionalTarget || [];

		if ( Array.isArray( objects ) === false ) {

			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;

		}

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius, theta, y ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

}

const _vector$7 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min, max ) {

		Object.defineProperty( this, 'isBox2', { value: true } );

		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getCenter() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getSize() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getParameter() target is now required' );
			target = new Vector2();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .clampPoint() target is now required' );
			target = new Vector2();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start, end ) {

		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .delta() target is now required' );
			target = new Vector3();

		}

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .at() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = MathUtils.clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

}

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( /* renderCallback */ ) {};

	this.hasPositions = false;
	this.hasNormals = false;
	this.hasColors = false;
	this.hasUvs = false;

	this.positionArray = null;
	this.normalArray = null;
	this.colorArray = null;
	this.uvArray = null;

	this.count = 0;

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

const _vector$8 = /*@__PURE__*/ new Vector3();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateMatrixWorld();

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$8.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$8 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.type = 'SkeletonHelper';
		this.isSkeletonHelper = true;

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$9.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$9.x, _vector$9.y, _vector$9.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$9.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$9.x, _vector$9.y, _vector$9.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		mesh.lookAt( _vector$a.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the radials

		for ( let i = 0; i <= radials; i ++ ) {

			const v = ( i / radials ) * ( Math.PI * 2 );

			const x = Math.sin( v ) * radius;
			const z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			const color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( let i = 0; i <= circles; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / circles * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

}

const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		_v1$6.setFromMatrixPosition( this.light.matrixWorld );
		_v2$3.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3$1.subVectors( _v2$3, _v1$6 );

		this.lightPlane.lookAt( _v2$3 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2$3 );
		this.targetLine.scale.z = _v3$1.length();

	}

}

const _vector$b = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector$b.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector$b.x, _vector$b.y, _vector$b.z );

		}

	}

}

const _box$3 = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box$3.setFromObject( this.object );

		}

		if ( _box$3.isEmpty() ) return;

		const min = _box$3.min;
		const max = _box$3.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();


	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

}

class PlaneHelper extends Line {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		let scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		super.updateMatrixWorld( force );

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	constructor( dir, origin, length, color, headLength, headWidth ) {

		super();
		// dir is assumed to be normalized

		this.type = 'ArrowHelper';

		if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
		if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
		if ( length === undefined ) length = 1;
		if ( color === undefined ) color = 0xffff00;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

}

class AxesHelper extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

}

const _floatView = new Float32Array( 1 );
const _int32View = new Int32Array( _floatView.buffer );

const DataUtils = {

	// Converts float32 to float16 (stored as uint16 value).

	toHalfFloat: function ( val ) {

		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

		/* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */

		_floatView[ 0 ] = val;
		const x = _int32View[ 0 ];

		let bits = ( x >> 16 ) & 0x8000; /* Get the sign */
		let m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */
		const e = ( x >> 23 ) & 0xff; /* Using int is faster here */

		/* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */
		if ( e < 103 ) return bits;

		/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
		if ( e > 142 ) {

			bits |= 0x7c00;
			/* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */
			bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
			return bits;

		}

		/* If exponent underflows but not too much, return a denormal */
		if ( e < 113 ) {

			m |= 0x0800;
			/* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */
			bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
			return bits;

		}

		bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
		/* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */
		bits += m & 1;
		return bits;

	}

};

const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow( 2, LOD_MAX );

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const ENCODINGS = {
	[ LinearEncoding ]: 0,
	[ sRGBEncoding ]: 1,
	[ RGBEEncoding ]: 2,
	[ RGBM7Encoding ]: 3,
	[ RGBM16Encoding ]: 4,
	[ RGBDEncoding ]: 5,
	[ GammaEncoding ]: 6
};

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._blurMaterial = _getBlurShader( MAX_SAMPLES );
		this._equirectShader = null;
		this._cubemapShader = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets();

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular ) {

		return this._fromTexture( equirectangular );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap ) {

		return this._fromTexture( cubemap );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapShader === null ) {

			this._cubemapShader = _getCubemapShader();
			this._compileMaterial( this._cubemapShader );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectShader === null ) {

			this._equirectShader = _getEquirectShader();
			this._compileMaterial( this._equirectShader );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._blurMaterial.dispose();

		if ( this._cubemapShader !== null ) this._cubemapShader.dispose();
		if ( this._equirectShader !== null ) this._equirectShader.dispose();

		for ( let i = 0; i < _lodPlanes.length; i ++ ) {

			_lodPlanes[ i ].dispose();

		}

	}

	// private interface

	_cleanup( outputTarget ) {

		this._pingPongRenderTarget.dispose();
		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets( texture );
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets( texture ) { // warning: null texture is valid

		const params = {
			magFilter: NearestFilter,
			minFilter: NearestFilter,
			generateMipmaps: false,
			type: UnsignedByteType,
			format: RGBEFormat,
			encoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( params );
		cubeUVRenderTarget.depthBuffer = texture ? false : true;
		this._pingPongRenderTarget = _createRenderTarget( params );
		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( _lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const outputEncoding = renderer.outputEncoding;
		const toneMapping = renderer.toneMapping;
		const clearColor = renderer.getClearColor();
		const clearAlpha = renderer.getClearAlpha();

		renderer.toneMapping = NoToneMapping;
		renderer.outputEncoding = LinearEncoding;

		let background = scene.background;
		if ( background && background.isColor ) {

			background.convertSRGBToLinear();
			// Convert linear to RGBE
			const maxComponent = Math.max( background.r, background.g, background.b );
			const fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
			background = background.multiplyScalar( Math.pow( 2.0, - fExp ) );
			const alpha = ( fExp + 128.0 ) / 255.0;
			renderer.setClearColor( background, alpha );
			scene.background = null;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;
			if ( col == 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col == 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			_setViewport( cubeUVRenderTarget,
				col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.render( scene, cubeCamera );

		}

		renderer.toneMapping = toneMapping;
		renderer.outputEncoding = outputEncoding;
		renderer.setClearColor( clearColor, clearAlpha );

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		if ( texture.isCubeTexture ) {

			if ( this._cubemapShader == null ) {

				this._cubemapShader = _getCubemapShader();

			}

		} else {

			if ( this._equirectShader == null ) {

				this._equirectShader = _getEquirectShader();

			}

		}

		const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
		const mesh = new Mesh( _lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		if ( ! texture.isCubeTexture ) {

			uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

		}

		uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
		uniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < TOTAL_LODS; i ++ ) {

			const sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = _sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i == 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
		blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
		blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

		const outputSize = _sizeLods[ lodOut ];
		const x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
		const y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _isLDR( texture ) {

	if ( texture === undefined || texture.type !== UnsignedByteType ) return false;

	return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;

}

function _createPlanes() {

	const _lodPlanes = [];
	const _sizeLods = [];
	const _sigmas = [];

	let lod = LOD_MAX;

	for ( let i = 0; i < TOTAL_LODS; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		_sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > LOD_MAX - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

		} else if ( i == 0 ) {

			sigma = 0;

		}

		_sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 1 );
		const min = - texelSize / 2;
		const max = 1 + texelSize / 2;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		_lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { _lodPlanes, _sizeLods, _sigmas };

}

function _createRenderTarget( params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( maxSamples ) {

	const weights = new Float32Array( maxSamples );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: { 'n': maxSamples },

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${ _getEncodings() }

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectShader() {

	const texelSize = new Vector2( 1, 1 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'texelSize': { value: texelSize },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${ _getEncodings() }

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCubemapShader() {

	const shaderMaterial = new RawShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${ _getEncodings() }

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function _getEncodings() {

	return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;

}

function Face4( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new Face3( a, b, c, normal, color, materialIndex );

}

const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials = [] ) {

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};

	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
	return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

Object.assign( CurvePath.prototype, {

	createPointsGeometry: function ( divisions ) {

		console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		// generate geometry from path points (for Line or Points objects)

		const pts = this.getPoints( divisions );
		return this.createGeometry( pts );

	},

	createSpacedPointsGeometry: function ( divisions ) {

		console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		// generate geometry from equidistant sampling along the path

		const pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );

	},

	createGeometry: function ( points ) {

		console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		const geometry = new Geometry();

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	}

} );

//

Object.assign( Path.prototype, {

	fromPoints: function ( points ) {

		console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
		return this.setFromPoints( points );

	}

} );

//

function ClosedSplineCurve3( points ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

}

ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function SplineCurve3( points ) {

	console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function Spline( points ) {

	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

Spline.prototype = Object.create( CatmullRomCurve3.prototype );

Object.assign( Spline.prototype, {

	initFromArray: function ( /* a */ ) {

		console.error( 'THREE.Spline: .initFromArray() has been removed.' );

	},
	getControlPointsArray: function ( /* optionalTarget */ ) {

		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

	},
	reparametrizeByArcLength: function ( /* samplingCoef */ ) {

		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

	}

} );

//

function AxisHelper( size ) {

	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
	return new AxesHelper( size );

}

function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

Object.assign( Loader.prototype, {

	extractUrlBase: function ( url ) {

		console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
		return LoaderUtils.extractUrlBase( url );

	}

} );

Loader.Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

//

Object.assign( Box2.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Box3.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Sphere.prototype, {

	empty: function () {

		console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},

} );

Frustum.prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Object.assign( MathUtils, {

	random16: function () {

		console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
		return Math.random();

	},

	nearestPowerOfTwo: function ( value ) {

		console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
		return MathUtils.floorPowerOfTwo( value );

	},

	nextPowerOfTwo: function ( value ) {

		console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
		return MathUtils.ceilPowerOfTwo( value );

	}

} );

Object.assign( Matrix3.prototype, {

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},
	multiplyVector3Array: function ( /* a */ ) {

		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

	},
	applyToBufferAttribute: function ( attribute ) {

		console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
		return attribute.applyMatrix3( this );

	},
	applyToVector3Array: function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

	},
	getInverse: function ( matrix ) {

		console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
		return this.copy( matrix ).invert();

	}

} );

Object.assign( Matrix4.prototype, {

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},
	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	getPosition: function () {

		console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
		return new Vector3().setFromMatrixColumn( this, 3 );

	},
	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	},
	multiplyToArray: function () {

		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector3Array: function ( /* a */ ) {

		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

	},
	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	},
	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	translate: function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},
	rotateX: function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},
	rotateY: function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},
	rotateZ: function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},
	rotateByAxis: function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},
	applyToBufferAttribute: function ( attribute ) {

		console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
		return attribute.applyMatrix4( this );

	},
	applyToVector3Array: function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

	},
	makeFrustum: function ( left, right, bottom, top, near, far ) {

		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );

	},
	getInverse: function ( matrix ) {

		console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
		return this.copy( matrix ).invert();

	}

} );

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

Object.assign( Quaternion.prototype, {

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},
	inverse: function ( ) {

		console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
		return this.invert();

	}

} );

Object.assign( Ray.prototype, {

	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionPlane: function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	}

} );

Object.assign( Triangle.prototype, {

	area: function () {

		console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
		return this.getArea();

	},
	barycoordFromPoint: function ( point, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return this.getBarycoord( point, target );

	},
	midpoint: function ( target ) {

		console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
		return this.getMidpoint( target );

	},
	normal: function ( target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return this.getNormal( target );

	},
	plane: function ( target ) {

		console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
		return this.getPlane( target );

	}

} );

Object.assign( Triangle, {

	barycoordFromPoint: function ( point, a, b, c, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return Triangle.getBarycoord( point, a, b, c, target );

	},
	normal: function ( a, b, c, target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return Triangle.getNormal( a, b, c, target );

	}

} );

Object.assign( Shape.prototype, {

	extractAllPoints: function ( divisions ) {

		console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
		return this.extractPoints( divisions );

	},
	extrude: function ( options ) {

		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );

	},
	makeGeometry: function ( options ) {

		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );

	}

} );

Object.assign( Vector2.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	distanceToManhattan: function ( v ) {

		console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

Object.assign( Vector3.prototype, {

	setEulerFromRotationMatrix: function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},
	setEulerFromQuaternion: function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},
	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	},
	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	},
	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	},
	applyProjection: function ( m ) {

		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );

	},
	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	distanceToManhattan: function ( v ) {

		console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

Object.assign( Vector4.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

//

Object.assign( Geometry.prototype, {

	computeTangents: function () {

		console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

	},
	computeLineDistances: function () {

		console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.assign( Object3D.prototype, {

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},
	renderDepth: function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},
	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},
	getWorldRotation: function () {

		console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Object.assign( Mesh.prototype, {

	setDrawMode: function () {

		console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

	},

} );

Object.defineProperties( Mesh.prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return TrianglesDrawMode;

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

Object.defineProperties( LOD.prototype, {

	objects: {
		get: function () {

			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}

} );

Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

	get: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	},
	set: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	}

} );

SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

	get: function () {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;

	},
	set: function ( value ) {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;

	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( DynamicDrawUsage );

		}
	}

} );

Object.assign( BufferAttribute.prototype, {
	setDynamic: function ( value ) {

		console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	},
	copyIndicesArray: function ( /* indices */ ) {

		console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

	},
	setArray: function ( /* array */ ) {

		console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	}
} );

Object.assign( BufferGeometry.prototype, {

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},
	addAttribute: function ( name, attribute ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return this;

		}

		return this.setAttribute( name, attribute );

	},
	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}

		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},
	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},
	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},
	computeOffsets: function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	},
	removeAttribute: function ( name ) {

		console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

		return this.deleteAttribute( name );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

Object.defineProperties( InstancedBufferGeometry.prototype, {

	maxInstancedCount: {
		get: function () {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			return this.instanceCount;

		},
		set: function ( value ) {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			this.instanceCount = value;

		}
	}

} );

Object.defineProperties( Raycaster.prototype, {

	linePrecision: {
		get: function () {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			return this.params.Line.threshold;

		},
		set: function ( value ) {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			this.params.Line.threshold = value;

		}
	}

} );

Object.defineProperties( InterleavedBuffer.prototype, {

	dynamic: {
		get: function () {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( value ) {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			this.setUsage( value );

		}
	}

} );

Object.assign( InterleavedBuffer.prototype, {
	setDynamic: function ( value ) {

		console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	},
	setArray: function ( /* array */ ) {

		console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	}
} );

//

Object.assign( ExtrudeBufferGeometry.prototype, {

	getArrays: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

	},

	addShapeList: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

	},

	addShape: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

	}

} );

//

Object.assign( Scene.prototype, {

	dispose: function () {

		console.error( 'THREE.Scene: .dispose() has been removed.' );

	}

} );

//

Object.defineProperties( Uniform.prototype, {

	dynamic: {
		set: function () {

			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

		}
	},
	onUpdate: {
		value: function () {

			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;

		}
	}

} );

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	}

} );

Object.defineProperties( MeshPhongMaterial.prototype, {

	metal: {
		get: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

		}
	}

} );

Object.defineProperties( MeshPhysicalMaterial.prototype, {

	transparency: {
		get: function () {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			return this.transmission;

		},
		set: function ( value ) {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			this.transmission = value;

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

Object.assign( WebGLRenderer.prototype, {

	clearTarget: function ( renderTarget, color, depth, stencil ) {

		console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	},
	animate: function ( callback ) {

		console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
		this.setAnimationLoop( callback );

	},
	getCurrentRenderTarget: function () {

		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
		return this.getRenderTarget();

	},
	getMaxAnisotropy: function () {

		console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
		return this.capabilities.getMaxAnisotropy();

	},
	getPrecision: function () {

		console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
		return this.capabilities.precision;

	},
	resetGLState: function () {

		console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
		return this.state.reset();

	},
	supportsFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	},
	supportsHalfFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	},
	supportsStandardDerivatives: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	},
	supportsCompressedTextureS3TC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	},
	supportsCompressedTexturePVRTC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	},
	supportsBlendMinMax: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	},
	supportsVertexTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	},
	supportsInstancedArrays: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	},
	enableScissorTest: function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	},
	initMaterial: function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	},
	addPrePlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	},
	addPostPlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	},
	updateShadowMap: function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	},
	setFaceCulling: function () {

		console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

	},
	allocTextureUnit: function () {

		console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

	},
	setTexture: function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

	},
	setTexture2D: function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

	},
	setTextureCube: function () {

		console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

	},
	getActiveMipMapLevel: function () {

		console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
		return this.getActiveMipmapLevel();

	}

} );

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		}
	},
	toneMappingWhitePoint: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			return 1.0;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		}
	},

} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

function WebGLRenderTargetCube( width, height, options ) {

	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
	return new WebGLCubeRenderTarget( width, options );

}

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Object.defineProperties( Audio.prototype, {

	load: {
		value: function ( file ) {

			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			const scope = this;
			const audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {

				scope.setBuffer( buffer );

			} );
			return this;

		}
	},
	startTime: {
		set: function () {

			console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );

		}
	}

} );

AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

	console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	return this.renderTarget.clear( renderer, color, depth, stencil );

};

//

const GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
		let matrix;

		if ( geometry2.isMesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	const loader = new TextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	const loader = new CubeTextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

const SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );
	/* eslint-enable no-undef */

}




/***/ }),

/***/ "../node_modules/timers-browserify/main.js":
/*!*************************************************!*\
  !*** ../node_modules/timers-browserify/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "../node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tslib/tslib.es6.js":
/*!******************************************!*\
  !*** ../node_modules/tslib/tslib.es6.js ***!
  \******************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/harmony-module.js":
/*!*********************************************************!*\
  !*** ../node_modules/webpack/buildin/harmony-module.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./MainEditor.tsx":
/*!************************!*\
  !*** ./MainEditor.tsx ***!
  \************************/
/*! exports provided: MainEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainEditor", function() { return MainEditor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @grafana/ui */ "@grafana/ui");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_dropzone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dropzone */ "../node_modules/react-dropzone/dist/es/index.js");
/* harmony import */ var _img_DeleteIcon_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./img/DeleteIcon.svg */ "./img/DeleteIcon.svg");
/* harmony import */ var _img_DeleteIcon_svg__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_img_DeleteIcon_svg__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _img_CheckIcon_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./img/CheckIcon.svg */ "./img/CheckIcon.svg");
/* harmony import */ var _img_CheckIcon_svg__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_img_CheckIcon_svg__WEBPACK_IMPORTED_MODULE_5__);

 //@ts-ignore





var baseStyle = {
  flex: 1,
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  padding: '20px',
  borderWidth: 2,
  borderRadius: 2,
  borderColor: '#eeeeee',
  borderStyle: 'dashed',
  backgroundColor: '#fafafa',
  color: '#bdbdbd',
  outline: 'none',
  transition: 'border .24s ease-in-out'
};
var MainEditor = function MainEditor(_a) {
  var options = _a.options,
      onOptionsChange = _a.onOptionsChange;

  var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__read"])(Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])(options), 2),
      inputs = _b[0],
      setInputs = _b[1];

  var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__read"])(Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])([]), 2),
      myFiles = _c[0],
      setMyFiles = _c[1];

  var _d = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__read"])(Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])('geojson'), 2),
      optionFile = _d[0],
      setOption = _d[1];

  var handleChange = function handleChange(e) {
    var _a = e.target,
        name = _a.name,
        value = _a.value;
    setInputs(function (prevState) {
      var _a;

      return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, prevState), (_a = {}, _a[name] = value, _a));
    });
  };

  var handleSubmit = function handleSubmit() {
    onOptionsChange(inputs);
  };

  var onDrop = react__WEBPACK_IMPORTED_MODULE_1___default.a.useCallback(function (acceptedFiles) {
    setMyFiles(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spread"])(myFiles, acceptedFiles));
  }, [myFiles]);

  var _e = Object(react_dropzone__WEBPACK_IMPORTED_MODULE_3__["useDropzone"])({
    noKeyboard: true,
    maxSize: 20971520,
    multiple: true,
    onDrop: onDrop
  }),
      getRootProps = _e.getRootProps,
      getInputProps = _e.getInputProps,
      inputRef = _e.inputRef;

  var handleRemoveFile = function handleRemoveFile(fileName) {
    var dt = new DataTransfer();
    var leftOver = myFiles.filter(function (f) {
      return f.name !== fileName;
    });
    leftOver.map(function (f) {
      dt.items.add(f);
    });

    if (inputRef.current) {
      inputRef.current.files = dt.files;
    }

    setMyFiles(leftOver);
  };

  var storeFile = function storeFile(fileName) {
    var reader = new FileReader();
    var chosenFile = myFiles.find(function (f) {
      return f.name === fileName;
    });

    reader.onloadend = function () {
      var _a;

      var obj = JSON.parse(reader.result);
      onOptionsChange(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, options), (_a = {}, _a[optionFile] = obj, _a)));
    };

    reader.readAsText(chosenFile);
  };

  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__["PanelOptionsGroup"], null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "editor-row"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "section gf-form-group"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("h5", {
    className: "section-heading"
  }, "Map Visual Options"), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__["FormField"], {
    label: "Center Latitude",
    labelWidth: 10,
    inputWidth: 40,
    type: "number",
    name: "center_lat",
    value: inputs.center_lat,
    onChange: handleChange
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__["FormField"], {
    label: "Center Longitude",
    labelWidth: 10,
    inputWidth: 40,
    type: "number",
    name: "center_lon",
    value: inputs.center_lon,
    onChange: handleChange
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__["FormField"], {
    label: "Initial Zoom",
    labelWidth: 10,
    inputWidth: 40,
    type: "number",
    name: "zoom_level",
    value: inputs.zoom_level,
    onChange: handleChange
  })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    className: "section gf-form-group"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    style: {
      display: 'flex',
      flexDirection: 'row'
    }
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("h5", {
    className: "section-heading",
    style: {
      marginTop: 7
    }
  }, "Drop Polygon File")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("select", {
    value: optionFile,
    onChange: function onChange(e) {
      return setOption(e.target.value);
    },
    style: {
      width: 130
    }
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("option", {
    value: "geojson"
  }, "GeoJSON"), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("option", {
    value: "area_flat"
  }, "Area Flat")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("section", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, getRootProps({
    className: 'dropzone',
    style: baseStyle
  })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("input", Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, getInputProps())), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("p", null, "Drag 'n' drop Polygons File here, or click to select file")), myFiles.length > 0 ? react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("h4", null, "Files"), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", null, myFiles.map(function (file) {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("p", {
      key: file.name
    }, file.name, " (", file.size, " bytes)", react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
      onClick: function onClick() {
        return handleRemoveFile(file.name);
      }
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
      src: _img_DeleteIcon_svg__WEBPACK_IMPORTED_MODULE_4___default.a
    })), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
      onClick: function onClick() {
        return storeFile(file.name);
      }
    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("img", {
      src: _img_CheckIcon_svg__WEBPACK_IMPORTED_MODULE_5___default.a
    })));
  }))) : ''))), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
    className: "btn btn-primary",
    onClick: handleSubmit
  }, "Submit"));
};

/***/ }),

/***/ "./MainPanel.tsx":
/*!***********************!*\
  !*** ./MainPanel.tsx ***!
  \***********************/
/*! exports provided: MainPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainPanel", function() { return MainPanel; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var maptalks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maptalks */ "../node_modules/maptalks/dist/maptalks.es.js");
/* harmony import */ var _util_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/process */ "./util/process.ts");
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ "../node_modules/nanoid/index.browser.js");
/* harmony import */ var maptalks_dist_maptalks_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! maptalks/dist/maptalks.css */ "../node_modules/maptalks/dist/maptalks.css");
/* harmony import */ var maptalks_dist_maptalks_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(maptalks_dist_maptalks_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _style_main_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./style/main.css */ "./style/main.css");
/* harmony import */ var _style_main_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_style_main_css__WEBPACK_IMPORTED_MODULE_6__);

 //@ts-ignore







var MainPanel =
/** @class */
function (_super) {
  Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(MainPanel, _super);

  function MainPanel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.id = 'id' + Object(nanoid__WEBPACK_IMPORTED_MODULE_4__["nanoid"])();
    _this.state = {
      normalize: false
    };

    _this.switchMode = function () {
      _this.setState({
        normalize: !_this.state.normalize
      });
    };

    return _this;
  }

  MainPanel.prototype.componentDidMount = function () {
    var _a = this.props.options,
        center_lat = _a.center_lat,
        center_lon = _a.center_lon,
        zoom_level = _a.zoom_level;
    this.map = new maptalks__WEBPACK_IMPORTED_MODULE_2__["Map"](this.id, {
      center: [center_lon, center_lat],
      zoom: zoom_level,
      pitch: 56,
      bearing: 60,
      baseLayer: new maptalks__WEBPACK_IMPORTED_MODULE_2__["TileLayer"]('base', {
        urlTemplate: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        subdomains: ['a', 'b', 'c', 'd'],
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>'
      }),
      touchGesture: true,
      doubleClickZoom: false
    });
    if (!this.props.options.geojson || this.props.data.series.length == 0) return;
    this.threeLayer = Object(_util_process__WEBPACK_IMPORTED_MODULE_3__["createLayer"])(this.props.data.series, this.props.options.geojson);
    this.map.addLayer(this.threeLayer);
    if (!this.props.options.area_flat) return;
    this.normalizeLayer = Object(_util_process__WEBPACK_IMPORTED_MODULE_3__["createNormalizeLayer"])(this.props.data.series, this.props.options.geojson, this.props.options.area_flat);
  };

  MainPanel.prototype.componentDidUpdate = function (prevProps, prevState) {
    if (prevProps.data.series !== this.props.data.series) {
      this.map.removeLayer(this.threeLayer);
      this.map.removeLayer(this.normalizeLayer);
      if (!this.props.options.geojson || this.props.data.series.length == 0) return;
      this.threeLayer = Object(_util_process__WEBPACK_IMPORTED_MODULE_3__["createLayer"])(this.props.data.series, this.props.options.geojson);
      if (!this.state.normalize) this.map.addLayer(this.threeLayer);
      if (!this.props.options.area_flat) return;
      this.normalizeLayer = Object(_util_process__WEBPACK_IMPORTED_MODULE_3__["createNormalizeLayer"])(this.props.data.series, this.props.options.geojson, this.props.options.area_flat);
      if (this.state.normalize) this.map.addLayer(this.normalizeLayer);
    }

    if (prevState.normalize != this.state.normalize) {
      this.map.removeLayer(this.threeLayer);
      this.map.removeLayer(this.normalizeLayer);

      if (!this.state.normalize && this.props.options.geojson) {
        this.threeLayer = Object(_util_process__WEBPACK_IMPORTED_MODULE_3__["createLayer"])(this.props.data.series, this.props.options.geojson);
        this.map.addLayer(this.threeLayer);
      }

      if (this.state.normalize && this.props.options.geojson && this.props.options.area_flat) {
        this.normalizeLayer = Object(_util_process__WEBPACK_IMPORTED_MODULE_3__["createNormalizeLayer"])(this.props.data.series, this.props.options.geojson, this.props.options.area_flat);
        this.map.addLayer(this.normalizeLayer);
      }
    }
  };

  MainPanel.prototype.render = function () {
    var _a = this.props,
        width = _a.width,
        height = _a.height;
    var normalize = this.state.normalize;
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      id: this.id,
      style: {
        width: width,
        height: height
      }
    }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
      className: "pane",
      onClick: this.switchMode
    }, normalize ? 'Per/m2' : 'Per Store'));
  };

  return MainPanel;
}(react__WEBPACK_IMPORTED_MODULE_1__["PureComponent"]);



/***/ }),

/***/ "./img/CheckIcon.svg":
/*!***************************!*\
  !*** ./img/CheckIcon.svg ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iYmxhY2siIHdpZHRoPSIxOHB4IiBoZWlnaHQ9IjE4cHgiPjxwYXRoIGQ9Ik0wIDBoMjR2MjRIMFYwem0wIDBoMjR2MjRIMFYweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0xNi41OSA3LjU4TDEwIDE0LjE3bC0zLjU5LTMuNThMNSAxMmw1IDUgOC04ek0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDE4Yy00LjQyIDAtOC0zLjU4LTgtOHMzLjU4LTggOC04IDggMy41OCA4IDgtMy41OCA4LTggOHoiLz48L3N2Zz4="

/***/ }),

/***/ "./img/DeleteIcon.svg":
/*!****************************!*\
  !*** ./img/DeleteIcon.svg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iYmxhY2siIHdpZHRoPSIxOHB4IiBoZWlnaHQ9IjE4cHgiPjxwYXRoIGQ9Ik02IDE5YzAgMS4xLjkgMiAyIDJoOGMxLjEgMCAyLS45IDItMlY3SDZ2MTJ6TTE5IDRoLTMuNWwtMS0xaC01bC0xIDFINXYyaDE0VjR6Ii8+PHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg=="

/***/ }),

/***/ "./module.ts":
/*!*******************!*\
  !*** ./module.ts ***!
  \*******************/
/*! exports provided: plugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugin", function() { return plugin; });
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @grafana/ui */ "@grafana/ui");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./types.ts");
/* harmony import */ var _MainPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainPanel */ "./MainPanel.tsx");
/* harmony import */ var _MainEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MainEditor */ "./MainEditor.tsx");
// @ts-ignore




var plugin = new _grafana_ui__WEBPACK_IMPORTED_MODULE_0__["PanelPlugin"](_MainPanel__WEBPACK_IMPORTED_MODULE_2__["MainPanel"]).setDefaults(_types__WEBPACK_IMPORTED_MODULE_1__["defaults"]).setEditor(_MainEditor__WEBPACK_IMPORTED_MODULE_3__["MainEditor"]);

/***/ }),

/***/ "./style/main.css":
/*!************************!*\
  !*** ./style/main.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js??ref--8-1!../../node_modules/postcss-loader/src??ref--8-2!../../node_modules/sass-loader/dist/cjs.js!./main.css */ "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../node_modules/sass-loader/dist/cjs.js!./style/main.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),

/***/ "./types.ts":
/*!******************!*\
  !*** ./types.ts ***!
  \******************/
/*! exports provided: defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
var defaults = {
  center_lat: 48.1239,
  center_lon: 11.60857,
  zoom_level: 18,
  geojson: null,
  area_flat: null
};

/***/ }),

/***/ "./util/process.ts":
/*!*************************!*\
  !*** ./util/process.ts ***!
  \*************************/
/*! exports provided: createLayer, createNormalizeLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLayer", function() { return createLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNormalizeLayer", function() { return createNormalizeLayer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "../node_modules/three/build/three.module.js");
/* harmony import */ var maptalks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maptalks */ "../node_modules/maptalks/dist/maptalks.es.js");
/* harmony import */ var maptalks_three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! maptalks.three */ "../node_modules/maptalks.three/dist/maptalks.three.es.js");

 //@ts-ignore

 //@ts-ignore



var percentageToHsl = function percentageToHsl(percentage) {
  var hue = percentage * -120 + 120;
  return 'hsla(' + hue + ', 100%, 50%, 1)';
};

var createLayer = function createLayer(series, geojson) {
  var stores = [];
  var assignValueToStore = {};
  var assignValueToStoreLog = {};
  series.map(function (item) {
    var sumValue = item.fields[0].values.buffer.reduce(function (sum, elm) {
      return sum + elm;
    }, 0);

    if (item.name) {
      stores.push(item.name);
      assignValueToStore[item.name] = sumValue;
      assignValueToStoreLog[item.name] = Math.sqrt(sumValue);
    }
  });
  var heatValues = Object.values(assignValueToStoreLog);
  var max = Math.max.apply(Math, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spread"])(heatValues));
  var min = Math.min.apply(Math, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spread"])(heatValues));
  var range = max - min;
  var threeLayer = new maptalks_three__WEBPACK_IMPORTED_MODULE_3__["ThreeLayer"]('t', {
    forceRenderOnMoving: true,
    forceRenderOnRotating: true
  });
  var meshs = [];

  threeLayer.prepareToDraw = function (gl, scene, camera) {
    var light = new three__WEBPACK_IMPORTED_MODULE_1__["DirectionalLight"](0xffffff);
    light.position.set(0, -10, 10).normalize();
    scene.add(light);
    scene.add(new three__WEBPACK_IMPORTED_MODULE_1__["AmbientLight"](0xffffff));
    geojson.features.map(function (feature) {
      if (feature.properties && feature.properties.name && stores.includes(feature.properties.name)) {
        var percentage = (assignValueToStoreLog[feature.properties.name] - min) / range;
        var material = new three__WEBPACK_IMPORTED_MODULE_1__["MeshPhongMaterial"]({
          color: range != 0 ? percentageToHsl(percentage) : 'hsla(49, 100%, 50%, 0.5)',
          transparent: true
        });
        var polygon = maptalks__WEBPACK_IMPORTED_MODULE_2__["GeoJSON"].toGeometry(feature);
        var height = 3;

        if (percentage >= 0.1) {
          height = (Math.round(percentage * 10) + 1) * 3;
        }

        polygon.setProperties({
          height: height,
          num: assignValueToStore[feature.properties.name],
          name: feature.properties.name
        });
        var mesh = threeLayer.toExtrudePolygons(polygon, {
          topColor: '#fff'
        }, material);
        meshs.push(mesh);
        threeLayer.addMesh(meshs);
        mesh.setToolTip('tip', {
          showTimeout: 0,
          eventsPropagation: true,
          dx: 10
        });
        mesh.on('mouseover', function (e) {
          var select = e.selectMesh;
          var data;

          if (select) {
            data = select.data;
          }

          var num = data.getProperties().num;
          var name = data.getProperties().name; //@ts-ignore

          var tooltip = this.getToolTip();
          tooltip._content = name + " : " + num;
        });
      }
    });
    animation();
  };

  function animation() {
    threeLayer._needsUpdate = !threeLayer._needsUpdate;

    if (threeLayer._needsUpdate) {
      threeLayer.renderScene();
    }

    requestAnimationFrame(animation);
  }

  return threeLayer;
};
var createNormalizeLayer = function createNormalizeLayer(series, geojson, area_flat) {
  var stores = [];
  var assignValueToStore = {};
  var assignValueToStoreLog = {};
  series.map(function (item) {
    var sumValue = item.fields[0].values.buffer.reduce(function (sum, elm) {
      return sum + elm;
    }, 0);

    if (item.name && area_flat[item.name]) {
      var nomalizedValue = Math.round(sumValue / area_flat[item.name] * 100) / 100;
      stores.push(item.name);
      assignValueToStore[item.name] = nomalizedValue;
      assignValueToStoreLog[item.name] = Math.log2(nomalizedValue + 1);
    }
  });
  var heatValues = Object.values(assignValueToStoreLog);
  var max = Math.max.apply(Math, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spread"])(heatValues));
  var min = Math.min.apply(Math, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spread"])(heatValues));
  var range = max - min;
  var threeLayer = new maptalks_three__WEBPACK_IMPORTED_MODULE_3__["ThreeLayer"]('t', {
    forceRenderOnMoving: true,
    forceRenderOnRotating: true
  });
  var meshs = [];

  threeLayer.prepareToDraw = function (gl, scene, camera) {
    var light = new three__WEBPACK_IMPORTED_MODULE_1__["DirectionalLight"](0xffffff);
    light.position.set(0, -10, 10).normalize();
    scene.add(light);
    scene.add(new three__WEBPACK_IMPORTED_MODULE_1__["AmbientLight"](0xffffff));
    geojson.features.map(function (feature) {
      if (feature.properties && feature.properties.name && stores.includes(feature.properties.name)) {
        var percentage = (assignValueToStoreLog[feature.properties.name] - min) / range;
        var material = new three__WEBPACK_IMPORTED_MODULE_1__["MeshPhongMaterial"]({
          color: range != 0 ? percentageToHsl(percentage) : 'hsla(49, 100%, 50%, 0.5)',
          transparent: true
        });
        var polygon = maptalks__WEBPACK_IMPORTED_MODULE_2__["GeoJSON"].toGeometry(feature);
        var height = 3;

        if (percentage >= 0.1) {
          height = (Math.round(percentage * 10) + 1) * 3;
        }

        polygon.setProperties({
          height: height,
          num: assignValueToStore[feature.properties.name],
          name: feature.properties.name
        });
        var mesh = threeLayer.toExtrudePolygons(polygon, {
          topColor: '#fff'
        }, material);
        meshs.push(mesh);
        threeLayer.addMesh(meshs);
        mesh.setToolTip('tip', {
          showTimeout: 0,
          eventsPropagation: true,
          dx: 10
        });
        mesh.on('mouseover', function (e) {
          var select = e.selectMesh;
          var data;

          if (select) {
            data = select.data;
          }

          var num = data.getProperties().num;
          var name = data.getProperties().name; //@ts-ignore

          var tooltip = this.getToolTip();
          tooltip._content = name + " : " + num;
        });
      }
    });
    animation();
  };

  function animation() {
    threeLayer._needsUpdate = !threeLayer._needsUpdate;

    if (threeLayer._needsUpdate) {
      threeLayer.renderScene();
    }

    requestAnimationFrame(animation);
  }

  return threeLayer;
};

/***/ }),

/***/ "@grafana/ui":
/*!******************************!*\
  !*** external "@grafana/ui" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__grafana_ui__;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ })});;
//# sourceMappingURL=module.js.map